<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【置顶】博客导航</title>
    <link href="/gather-blog/"/>
    <url>/gather-blog/</url>
    
    <content type="html"><![CDATA[<p>欢迎来访，这是我的博客引导。</p><a id="more"></a><hr><p><a href="http://www.colourso.top/tags/SOP/">SOP</a>系列：一些流程的记录过程，包含各种软件或者环境的配置。</p><p><a href="http://www.colourso.top/tags/%E5%B0%8F%E7%99%BD%E6%96%87/">小白文</a>系列：一些技术或者工具的极简教程，仅作快速入门用。</p><p><a href="http://www.colourso.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/">文件下载</a>系列：包含我分享的一些资源的链接，或者是一些工程、项目文件。</p><hr><h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><h3 id="常识性知识"><a href="#常识性知识" class="headerlink" title="常识性知识"></a>常识性知识</h3><p><a href="http://www.colourso.top/C++%E5%8E%86%E5%8F%B2/">C++一些相关知识（慢慢补充）</a></p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p><a href="http://www.colourso.top/vs-use/">VS开发C++的一些问题——VS项目工程文件、Debug与Relase模式、字符集问题以及_T()宏</a></p><p><a href="http://www.colourso.top/qt5-use/">Windows下QT的安装</a></p><p><a href="http://www.colourso.top/qt5setupInLinux/">Ubuntu下安装QT5</a> </p><h3 id="基础学习"><a href="#基础学习" class="headerlink" title="基础学习"></a>基础学习</h3><p><a href="http://www.colourso.top/charAndStrign/">char* 、char[]、与string 的区别，以及求取字符串长度(未完成)</a></p><p><a href="http://www.colourso.top/C-memory-layout/">C语言内存四区模型详解(未完成)</a></p><p><a href="http://www.colourso.top/c-reference&point/">引用与指针(未完成)</a></p><p><a href="http://www.colourso.top/cpp-opp1/">C++类的基础知识</a></p><p><a href="http://www.colourso.top/cpp-opp1-prc1/">C++面向对象练习(一)函数执行顺序</a></p><p><a href="http://www.colourso.top/cpp-opp1-prc2/">C++面向对象练习(二)string的实现（一）</a></p><p><a href="http://www.colourso.top/cpp-opp2/">C++继承派生</a></p><p><a href="http://www.colourso.top/cpp-opp2-prc3/">C++面向对象练习(三)继承小练习</a></p><p>C++多态以及虚基类(未完成)</p><p>C++模板(未完成)</p><p><a href="http://www.colourso.top/operator/">C++操作符重载 operator</a></p><p>C++类型转换(未完成)</p><p><a href="http://www.colourso.top/cpp-file/">C++文件输入输出</a></p><p>C++多线程(未完成)</p><p>C++11新特性(未完成)</p><h3 id="STL库"><a href="#STL库" class="headerlink" title="STL库"></a>STL库</h3><p><a href="http://www.colourso.top/lanqiao-2/">STL专题-sort、reverse</a></p><p><a href="http://www.colourso.top/lanqiao-3/">STL专题-iterator和vector</a></p><p><a href="http://www.colourso.top/lanqiao-4/">STL专题-map 映射</a></p><p><a href="http://www.colourso.top/lanqiao-5/">STL专题-set 集合</a></p><p><a href="http://www.colourso.top/lanqiao-6/">STL专题-stack、queue 栈与队列</a></p><p>STL专题-list 链表(未完成)</p><h3 id="小设计"><a href="#小设计" class="headerlink" title="小设计"></a>小设计</h3><p><a href="http://www.colourso.top/c-snake-pro0/">C++基于EasyX制作贪吃蛇游戏（一）文档</a></p><p><a href="http://www.colourso.top/c-snake-pro1/">C++基于EasyX制作贪吃蛇游戏（二）第一版代码与程序</a></p><p><a href="http://www.colourso.top/c-snake-pro2/">C++基于EasyX制作贪吃蛇游戏（二）第一版代码与程序简单更新</a></p><p><a href="http://www.colourso.top/c-snake-pro3/">C++基于EasyX制作贪吃蛇游戏（三）第二版文档</a></p><p><a href="http://www.colourso.top/c-snake-pro4/">C++基于EasyX制作贪吃蛇游戏（四）第二版代码与程序</a></p><p><a href="http://www.colourso.top/c-snake-pro5/">C++基于EasyX制作贪吃蛇游戏（五）第三版文档</a></p><p><a href="http://www.colourso.top/c-snake-pro6/">C++基于EasyX制作贪吃蛇游戏（六）第三版代码与程序</a></p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><a href="http://www.colourso.top/ubuntu-set-up/">Linux–Ubuntu的安装|(win + linux)双系统</a></p><p><a href="http://www.colourso.top/linux-base/">Linux基础命令</a></p><p><a href="http://www.colourso.top/linux-vim/">vim编辑器的使用</a></p><p><a href="http://www.colourso.top/linux-qq/">Ubuntu安装腾讯QQ for Linux</a></p><p><a href="http://www.colourso.top/Linux-Tenet/">Linux-Telnet配置</a></p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><a href="http://www.colourso.top/Python/">Python入门</a></p><p><a href="http://www.colourso.top/python-sequence/">Python常用序列结构——列表、元组、字符串、字典和集合</a></p><p><a href="http://www.colourso.top/python-pollcode/">Python小项目 —— 企业编码生成系统</a></p><p><a href="http://www.colourso.top/python-grabnovel/">Python爬虫入门——简单的爬取小说</a></p><p><a href="http://www.colourso.top/ML01_numpy/">Numpy —— Python科学计算基础库</a></p><p><a href="http://www.colourso.top/ML02_pandas/">Pandas —— Python数据分析库</a></p><p><a href="http://www.colourso.top/ML03_matplotlib/">matplotlib —— Python图表绘图</a></p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p><a href="http://www.colourso.top/HTML/">HTML基本语法</a></p><p><a href="http://www.colourso.top/CSS-learn/">CSS语法总结</a></p><p><a href="http://www.colourso.top/Js-learn/">【转载】跟着9张思维导图学习Javascript</a></p><hr><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><a href="http://www.colourso.top/mysql-use/">Mysql基本语法</a></p><p><a href="http://www.colourso.top/mysql-instance/">Mysql数据库实例</a></p><p><a href="http://www.colourso.top/redis/">Redis的简单用法</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="http://www.colourso.top/JSON/">JSON的一些简单知识</a></p><p><a href="http://www.colourso.top/math-base/">数学基础知识、常用公式总结</a></p><p>Git的操作与使用(未完成)</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><a href="http://www.colourso.top/os-lab-1/">操作系统实验（一）—— 使用动态优先权的进程调度算法模拟</a></p><p><a href="http://www.colourso.top/os-lab-2/">操作系统实验（二）—— 使用动态分区分配方式的模拟</a></p><p><a href="http://www.colourso.top/os-lab-3/">操作系统实验（三）—— 请求调页存储管理方式的模拟</a></p><p><a href="http://www.colourso.top/os-lab-4/">操作系统课程设计 – 磁盘管理</a></p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p><a href="http://www.colourso.top/network-chapter-1/">计算机网络 —— 概述</a></p><p><a href="http://www.colourso.top/network-chapter-2/">计算机网络 —— 物理层</a></p><p><a href="http://www.colourso.top/network-chapter-3/">计算机网络 —— 数据链路层</a></p><p><a href="http://www.colourso.top/network-chapter-4/">计算机网络 —— 网络层</a></p><p><a href="http://www.colourso.top/network-chapter-5/">计算机网络 —— 运输层</a></p><p><a href="http://www.colourso.top/network-chapter-all/">计算机网络 —— 题目总结</a></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><a href="http://www.colourso.top/lanqiao-1/">蓝桥杯省赛备战–Fibonacci数列、iomanip控制输出精度、类型转换</a></p><p><a href="http://www.colourso.top/lanqiao-dfs/">蓝桥杯-DFS深度应用与模板</a></p><h2 id="课设"><a href="#课设" class="headerlink" title="课设"></a>课设</h2><p><a href="http://www.colourso.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AF%BE%E8%AE%BE%E2%80%94%E2%80%94%E2%80%94%E5%9B%9B%E7%BB%B4%E6%95%B0%E7%BB%84/">数据结构课课设 —— 四维数组</a></p><p><a href="http://www.colourso.top/os-lab-4/">操作系统课程设计 —— 磁盘管理</a></p><p><a href="http://www.colourso.top/e-design/">数电课设 —— 一位十进制加减法计算器(电路+连线)</a></p><p><a href="http://www.colourso.top/cpudesign/">计算机组成原理课程设计 —— MIPS32五级流水之addi指令的实现</a></p><p><a href="http://www.colourso.top/telnet-with-java/">计算机网络课程设计 —— Telnet协议的Java实现</a></p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【置顶】数学基础知识、常用公式总结</title>
    <link href="/math-base/"/>
    <url>/math-base/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>： 初高中数学常用内容：平方和差、等差数列、等比数列、常用三角函数变换等基础内容。 </p><a id="more"></a><p>部分Latex公式渲染可能出了问题，可移步博客园查看：<a href="https://www.cnblogs.com/colourso/p/12976891.html">数学基础知识、常用公式总结|Colourso</a></p><h2 id="特殊数字"><a href="#特殊数字" class="headerlink" title="特殊数字"></a>特殊数字</h2><p>自然常数 e = 2.71828183，是一个无限不循环小数。</p><p>圆周率 pi =  3.1415926</p><h2 id="充分与必要条件"><a href="#充分与必要条件" class="headerlink" title="充分与必要条件"></a>充分与必要条件</h2><p>假设A是条件，B是结论</p><p>（1）由A可以推出B，由B可以推出A，则A是B的充要条件(A=B)</p><p>（2）由A可以推出B，由B不可以推出A，则A是B的充分不必要条件(A⊆B)</p><p>（3）由A不可以推出B，由B可以推出A，则A是B的必要不充分条件(B⊆A)</p><p>（4）由A不可以推出B，由B不可以推出A，则A是B的既不充分也不必要条件(A￠B且B￠A)</p><h2 id="常用不等式"><a href="#常用不等式" class="headerlink" title="常用不等式"></a>常用不等式</h2><p>1.<strong>两数绝对值之差的绝对值小于等于两数之差的绝对值</strong><br>$$<br>||a| - |b| | \leq |a-b|<br>$$<br>2.<strong>一个正数加它的倒数恒大于等于2</strong><br>$$<br>a + \frac{1}{a} - 2 \<br>= \frac{a^2 + 1 -2a}{a} \<br>= \frac{(a-1)^2}{a} \<br>\geq 0 \<br>故 a + \frac{1}{a} \geq 2<br>$$<br>3.<strong>基本不等式：两个正实数的算术平均数大于或等于它们的几何平均数。</strong><br>$$<br>\frac{a+b}{2} \geq \sqrt{a+b}\<br>$$</p><p>$$<br>\sqrt{\frac{a^2 + b^2}{2}} \geq \frac{a+b}{2} \geq \sqrt{a+b} \geq \frac{2}{\frac{1}{a} + \frac{1}{b}} \<br>$$</p><p>$$<br>平方平均 \qquad 代数平均 \qquad  几何平均 \qquad 调和平均\<br>$$<br>(a-b)^2 = a^2 - 2ab + b^2</p><p>则 2ab &lt; a^2 + b^2，两个或者三个数相乘时就要想到他。</p><p>4.<strong>sin x与x与tan x之间的关系</strong></p><p>$$<br>sinx &lt; x &lt; tanx \qquad (0 &lt; x &lt; \frac{\pi}{2}) \<br>$$</p><p>$$<br>额外 \sin x \geq (\sin x)^2 = 1 - (cos x)^2 \geq 1 - cos x<br>$$</p><p>$$<br>即： sin x \geq 1 - cos x<br>$$</p><p>5.<strong>x与ln(1+x)之间的关系</strong><br>$$<br>\frac{x}{1+x} &lt; \ln{(1+x)} &lt; x \qquad (x &gt; 0) \<br>$$</p><p>$$<br>证： \quad \ln{(1+x)} = \ln{(1+x)} - \ln{1} \<br>$$</p><p>$$<br>由拉格朗日中值定理： \quad f(x) = \ln{x}。a = 1 , b = 1+x。 \<br>$$</p><p>$$<br>存在 a &lt; c &lt; b，使得 \quad \ln{(1+x)} = f^{‘}(c) (1+x - 1) \<br>$$</p><p>$$<br>即： \quad = \frac{x}{c} \<br>$$</p><p>$$<br>因： 1 &lt; c &lt; 1+x，故 \quad \frac{x}{1+x} &lt;  \frac{x}{c} &lt;  \frac{x}{1} \quad 即证<br>$$</p><h2 id="平方和-差-与立方和-差"><a href="#平方和-差-与立方和-差" class="headerlink" title="平方和(差)与立方和(差)"></a>平方和(差)与立方和(差)</h2><p>完全平方：<code>(a+b)^2 = a^2 + 2ab + b^2</code></p><p>平方和：<code>1^2 + 2^2 + 3^2 + …… + n^2 = n(n+1)(2n+1)/6</code></p><p>平方差：<code>a^2 - b^2 = (a+b)(a-b)</code></p><p>立方和：<code>a^3 + b^3 = (a+b)(a^2+ab+b^2)</code></p><p>立方差：<code>a^3 - b^3 = (a-b)(a^2+ab+b^2) </code></p><p>和的立方：$$ (a+b)^3 = a^3 + 3a^2b + 3ab^2 + b^3 $$</p><p>差的立方：$$ (a-b)^3 = a^3 - 3a^2b + 3ab^2 - b^3 $$</p><p>n次方之差：$$a^n - b^n = (a-b)(a^{n-1} + a^{n-2}b + a^{n-3}b^2 + 。。。 + ab^{n-2} + b^{n-1})$$</p><p>一个常用的变形：<br>$$<br>\frac{1}{x^2 - 1} = \frac{1}{(x-1)(x+1)}\<br>$$</p><p>$$<br>= \frac{1}{2}\times \frac{(x+1)-(x-1)}{(x-1)(x+1)}\<br>$$</p><p>$$<br>= \frac{1}{2}\times (\frac{1}{x-1} - \frac{1}{x+1})<br>$$</p><p>$$<br>推导：\frac{1}{x^2 - a^2} = \frac{1}{2a}\times(\frac{1}{x-a} - \frac{1}{x+a})<br>$$</p><p>另一个常用变形：<br>$$<br>\frac{1}{x(x+1)} = \frac{1}{x} - \frac{1}{x+1}<br>$$</p><p>除此之外做题碰到的一个<br>$$<br>\frac{1}{(1-x^2)\times(1+x)} = \frac{1}{(1-x)\times(1+x)^2} \<br>$$</p><p>$$<br>\frac{1}{(1-x^2)\times(1+x)} = \frac{1}{2} \times\frac{(1-x)+(1+x)}{(1-x^2)\times(1+x)} = \frac{1}{2} \times \lbrace \frac{1}{(1+x)^2} + \frac{1}{(1-x^2)} \rbrace<br>$$</p><h2 id="对数运算"><a href="#对数运算" class="headerlink" title="对数运算"></a>对数运算</h2><p>对数可以让乘除变加减</p><p>【定义】如果$N=a^x（a;0,a≠1）$，即a的x次方等于N（a&gt;0，且a≠1），那么数x叫做以a为底N的对数（logarithm），记作：$x=log_aN$<br>$$<br>N = a^x<br>$$</p><p>$$<br>则 x = \log_a N<br>$$<br>其中，a叫做对数的底数，N叫做真数，x叫做“以a为底N的对数”。</p><p><strong>对数的一些基本性质</strong>:<br>$$</p><ol><li>\quad a^{\log_ab} = b<br>$$</li></ol><p>$$<br>2. \quad \log_a{a^b} = b \<br>$$</p><p>$$<br>3. \quad \log_a{MN} = \log_aM + \log_aN \<br>$$</p><p>$$<br>4. \quad \log_a{(M/N)} = \log_aM - \log_aN \<br>$$</p><p>$$<br>5. \quad \log_a{M^n} = n \log_aM \<br>$$</p><p>$$<br>6. \quad \log_{a^n}M = \frac{1}{n\log_aM} \<br>$$</p><p>$$<br>7. \quad \log_aN = \frac{\log_bN}{\log_ba} \quad (换底公式) \<br>$$</p><p>$$<br>8. \quad \log_ab = \frac{1}{\log_ba}<br>$$</p><h2 id="等差数列"><a href="#等差数列" class="headerlink" title="等差数列"></a>等差数列</h2><img src="/math-base/equalsub.png" style="zoom:80%;"><h2 id="等比数列"><a href="#等比数列" class="headerlink" title="等比数列"></a>等比数列</h2><img src="/math-base/equalmul.png" style="zoom:80%;"><h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h2><p>排列，就是指从给定个数的元素中取出指定个数的元素进行排序。</p><p>组合则是指从给定个数的元素中仅仅取出指定个数的元素，不考虑排序。</p><p><img src="/math-base/pailiezuhe.png"></p><hr><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><p><img src="/math-base/triangle-1.png"></p><p><img src="/math-base/triangle-2.png"></p><hr><p>奇变偶不变，符号看象限。</p><p>任意角度均可表示为$\frac{k \pi}{2} + a \quad (k为整数) , |a|&lt; \frac{\pi}{4}$</p><p>当k为偶数时，得到a的同名函数值，即函数名不变.</p><p>当k为奇数的时候，得到a的异名函数值，即$\sin – \cos，\cos – \sin$等。</p><p>符号看象限是指<strong>通过公式左边的角度所落的象限决定公式右边是正还是是负</strong>，记得视a为锐角。</p><p>各种三角函数在四个象限内的符号判断：一全正；二正弦(余割)；三两切；四余弦(正割)。</p><p>第一象限内任何一个角的三角函数值都是“+”；</p><p>第二象限内只有正弦和余割是“+”，其余全部是“－”；</p><p>第三象限内只有正切和余切是“+”，其余函数是“－”；</p><p>第四象限内只有正割和余弦是“+”，其余全部是“－”。</p><hr><p><img src="/math-base/triangle-3.png"></p><p><img src="/math-base/triangle-4.png"></p><p><img src="/math-base/triangle-5.png"></p><p><img src="/math-base/triangle-6.png"></p><p><img src="/math-base/triangle-7.png"></p><p><img src="/math-base/angle.jpg"></p><p>$$<br>\sin{a} - \cos{a} = {\sqrt{2}} (\frac{\sqrt{2}}{2} \sin{a} - \frac{\sqrt{2}}{2}\cos{a}) = \sqrt{2} \sin{(a - \frac{\pi}{4})}<br>$$</p><p><code>sec x</code>是正割，$ \sec x = \frac{1}{\cos x} $</p><p><code>csc x</code>是余割，$\csc x = \frac{1}{\sin x}$</p><p><code>cot x</code>是余切，$\cot x = \frac{\cos x}{\sin x}$<br>$$<br>(\tan x)^{‘} = (\sec x)^2<br>$$</p><p>$$<br>(\cot x)^{‘} = -(\csc x)^2<br>$$</p><p>$$<br>(\sec x)^2  - 1 = (\tan x)^2 \<br>$$</p><h2 id="反三角函数"><a href="#反三角函数" class="headerlink" title="反三角函数"></a>反三角函数</h2><p>y=arcsin(x)，定义域[-1，1]，值域[-π/2,π/2]</p><p>y=arccos(x)，定义域[-1，1]，值域[0，π]</p><p>y=arctan(x)，定义域(-∞，+∞)，值域(-π/2，π/2)</p><p>y=arccot(x)，定义域(-∞，+∞)，值域(0，π)</p><p>sin(arcsinx)=x，定义域[-1，1]，值域[-1，1]arcsin(-x)=-arcsinx</p><h2 id="正余弦定理"><a href="#正余弦定理" class="headerlink" title="正余弦定理"></a>正余弦定理</h2><p><strong>正弦定理</strong>：  R为三角形外接圆的半径<br>$$<br>\frac{a}{sinA} = \frac{b}{sinB} = \frac{c}{sinC} = 2R<br>$$<br><strong>余弦定理</strong>：<br>$$<br>a^2 = b^2 + c^2 - 2bc*cosA<br>$$</p><h2 id="经典函数图像"><a href="#经典函数图像" class="headerlink" title="经典函数图像"></a>经典函数图像</h2><p>参考链接：<a href="https://wenku.baidu.com/view/d66747d176eeaeaad1f33099.html">https://wenku.baidu.com/view/d66747d176eeaeaad1f33099.html</a> </p><p><img src="/math-base/sanjiao.png"></p><p><img src="/math-base/fansanjiao.png"></p><p><img src="/math-base/acr.gif"></p><center>反三角系列函数图像</center><p><img src="/math-base/mi.png"></p><p><img src="/math-base/zhi.png"></p><p><img src="/math-base/dui.png"></p><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p><strong>空间直角坐标系</strong></p><blockquote><p>过空间定点O作三条互相垂直的数轴,它们都以O为原点,具有相同的单位长度.这三条数轴分别称为X轴(横轴).Y轴(纵轴).Z轴(竖轴),统称为坐标轴。</p><p>各轴之间的顺序要求符合右手法则,即以右手握住Z轴,让右手的四指从X轴的正向以90度的直角转向Y轴的正向,这时大拇指所指的方向就是Z轴的正向。这样的三个坐标轴构成的坐标系称为右手空间直角坐标系.与之相对应的是左手空间直角坐标系.一般在数学中更常用右手空间直角坐标系，在其他学科方面因应用方便而异。</p><p>三条坐标轴中的任意两条都可以确定一个平面,称为坐标面.它们是:由X轴及Y轴所确定的XOY平面;由Y轴及Z轴所确定的YOZ平面；由X轴及Z轴所确定的XOZ平面．这三个相互垂直的坐标面把空间分成八个部分，每一部分称为一个卦限．位于X，Y，Z轴的正半轴的卦限称为第一卦限，从第一卦限开始，在XOY平面上方的卦限，按逆时针方向依次称为第二，三，四卦限；第一，二，三，四卦限下方的卦限依次称为第五，六，七，八卦限。</p></blockquote><p><img src="/math-base/zuobiaoxi.jpg"></p><p><strong>右手坐标系</strong></p><blockquote><p>要标注X、Y和Z轴的正轴方向，就将右手背对着屏幕放置，拇指即指向X轴的正方向。伸出食指和中指，如下图所示，食指指向Y轴的正方向，中指所指示的方向即是Z轴的正方向。要确定轴的正旋转方向，如下图所示，用右手的大拇指指向轴的正方向，弯曲手指。那么手指所指示的方向即是轴的正旋转方向。</p></blockquote><p><img src="/math-base/youshouzuobiaoxi.jpg"></p><p><strong>极坐标系</strong></p><blockquote><p>极坐标系是一个二维坐标系，该坐标系统中任意位置可由一个夹角和一段相对原点——极点的距离来表示。</p><p>极坐标系是指在平面内由极点、极轴和极径组成的坐标系。在平面上取定一点O，称为极点。从O出发引一条射线Ox，称为极轴。再取定一个单位长度，通常规定角度取逆时针方向为正。这样，平面上任一点P的位置就可以用线段OP的长度ρ以及从Ox到OP的角度θ来确定，有序数对（ρ，θ）就称为P点的极坐标，记为P（ρ，θ）；ρ称为P点的极径，θ称为P点的极角。</p></blockquote><p><strong>常见的极坐标方程</strong></p><p><img src="/math-base/jizuobiao1.jpg"></p><p><img src="/math-base/jizuobiao2.jpg"></p><h2 id="常见圆锥曲线"><a href="#常见圆锥曲线" class="headerlink" title="常见圆锥曲线"></a>常见圆锥曲线</h2><p>圆锥曲线的统一定义：到定点的距离与到定直线的距离的商是常数e的点的轨迹。</p><p><strong>椭圆：</strong></p><blockquote><p>1、中心在原点，焦点在x轴上的椭圆标准方程：其中$\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$,其中a&gt;b&gt;0,c²=a²-b²</p><p>2、中心在原点，焦点在y轴上的椭圆标准方程：$\frac{y^2}{a^2}+\frac{x^2}{b^2}=1$,其中a&gt;b&gt;0,c²=a²-b²</p><p>参数方程：x=acosθ;y=bsinθ(θ为参数，0≤θ≤2π)</p><p> 椭圆面积公式：s=πab </p></blockquote><p><strong>双曲线：</strong></p><blockquote><p>1、中心在原点，焦点在x轴上的双曲线标准方程：$\frac{x^2}{a^2}-\frac{y^2}{b^2}=1$,其中a&gt;0，b&gt;0，c²=a²+b².</p><p>2、中心在原点，焦点在y轴上的双曲线标准方程：$\frac{y^2}{a^2}-\frac{x^2}{b^2}=1$,其中a&gt;0，b&gt;0，c²=a²+b².</p><p>参数方程：x=asecθ;y=btanθ(θ为参数)</p></blockquote><p><strong>抛物线：</strong></p><blockquote><p>参数方程:x=2pt²；y=2pt(t为参数)t=1/tanθ(tanθ为曲线上点与坐标原点确定直线的斜率)特别地，t可等于0</p><p>直角坐标:y=ax²+bx+c(开口方向为y轴，a≠0)x=ay²+by+c(开口方向为x轴，a≠0)</p></blockquote><p><img src="/math-base/yuanzhuiquxian.png"></p><h2 id="直线方程"><a href="#直线方程" class="headerlink" title="直线方程"></a>直线方程</h2><p>两条直线垂直，其斜率乘积为-1.</p><p>点斜式：$y - y_0 = k(x - x_0)$</p><p>斜截式：$y = kx + b$ ，与y轴交点为(0,b)</p><p>两点式：$\frac{y - y_1}{y - y_2} = \frac{x - x_1}{x - x_2}$ 。过两点。</p><p>截距式：$\frac{x}{a} + \frac{y}{b} = 1$ ，x截距为a，y截距为b。</p><p>一般式：$Ax + By + C = 0$</p><p>两点之间的距离公式：$d = \sqrt{(x_2-x_1)^2 + (y_2 - y_1)^2}$</p><p>点到直线的距离公式：$d = \frac{|Ax_0 + By_0 + C|}{\sqrt{A^2 + B^2}}$</p><p>两条平行直线的距离公式：$d = \frac{|C_1 - C_2|}{\sqrt{A^2 + B^2}}$</p><h2 id="圆的方程"><a href="#圆的方程" class="headerlink" title="圆的方程"></a>圆的方程</h2><p>圆的一般方程为$x²+y²+Dx+Ey+F=0(D²+E²-4F &gt; 0)$，或可以表示为$(X+D/2)²+(Y+E/2)²=(D²+E²-4F)/4$。</p><p>标准方程：$(x-a)^2 + (y-b)^2 = R^2$。圆心为(a,b)，半径为R。</p><h2 id="立体体积计算公式"><a href="#立体体积计算公式" class="headerlink" title="立体体积计算公式"></a>立体体积计算公式</h2><p>球：$V = \frac{4}{3}\pi R^3$.</p><p>圆锥：$V =\frac{1}{3}\pi R^2h$.</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>选择排序算法——简单选择排序、堆排序排序</title>
    <link href="/ds_03_SelectSort/"/>
    <url>/ds_03_SelectSort/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：简单选择排序、堆排序算法思想以及C++代码的实现。</p><a id="more"></a><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>算法思想</strong>：每一趟在待排序元素中选取关键字最小或者最大的元素加入到有序子序列中。</p><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>即选择排序最直接的实现方式。</p><p><img src="/ds_03_SelectSort/simplesort.png"></p><p>在这里中每次选择待排序序列中最小的那个元素，然后与已经有序的子序列的下一位交换位置。待排序序列缩短，循环往复，直到待排序序列还剩一个元素时终止。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">int</span> &amp;b)</span> </span>&#123;<span class="hljs-keyword">int</span> temp = a;a = b;b = temp;&#125;<span class="hljs-comment">//简单选择排序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-keyword">int</span> minpos;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; i++) &#123;<span class="hljs-comment">//一共进行n-1趟，最后一个元素不用再进行</span>minpos = i;<span class="hljs-comment">//假设当前元素是最小的，记录其下标</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; n; j++) &#123;<span class="hljs-keyword">if</span> (A[minpos] &gt; A[j]) &#123;<span class="hljs-comment">//若找到了更小的元素，更新下标</span>minpos = j;&#125;&#125;<span class="hljs-keyword">if</span>(minpos != i) swap(A[i], A[minpos]);<span class="hljs-comment">//交换位置</span>&#125;&#125;</code></pre><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li><p>空间复杂度：<code>O(1)</code>，著需要常量个辅助空间。</p></li><li><p>时间复杂度：该算法与序列内部状态无关，无论有序、乱序或者逆序排列都是<code>O(n^2)</code></p><ul><li>其比较次数是固定的$$(n-1)+(n-2)+…+1 = \frac{n(n-1)}{2}$$</li></ul></li><li><p>简单选择排序算法是<strong>不稳定</strong>的算法。eg：<code>3 3 1</code>，第一次排序之后两个3的相对次序发生了变化。</p></li><li><p>算法评价：简单、容易实现，适用于<strong>待排序序列比较小</strong>的情况。</p></li><li><p>算法适用：可用于顺序表、链表这样的数据结构。</p></li></ul><hr><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><strong>算法思想</strong>：堆排序是堆简单选择排序的改进，<strong>利用每趟比较后的结果，也就是在找出关键字值最小记录的同时，也找出关键字值较小的记录</strong>，则可减少后面的选择中所用的比较次数，从而提高整个排序过程的效率。</p><h3 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h3><p>把具有如下性质的**数组A[1……n]**表示的完全二叉树称为最大堆，也称大根堆、大顶堆：<code>A[i] &gt;= A[2i]并且A[i]&gt;=A[2i+1]</code>。(即父节点大于其两个孩子节点)。</p><p>把具有如下性质的**数组A[1……n]**表示的完全二叉树称为最小堆，也称小根堆、小顶堆：<code>A[i] &lt;= A[2i]并且A[i]&lt;=A[2i+1]</code>。</p><p>注意：</p><ul><li>二叉树的顺序存储来表示完全二叉树时，所用<strong>数组需要从1开始</strong>！</li><li>i的左孩子为<code>2*i</code>，i的右孩子为<code>2*i+1</code>，i的父节点为<code>i/2</code>向下取整，若i&gt;<code>i/2向下取整</code>时，当前节点为叶子节点，否则为分支节点。</li></ul><p><img src="/ds_03_SelectSort/bigheap.png"></p><p>如图所示：数组是其存储结构，下面的二叉树是其逻辑视图，表示一个大根堆。</p><h3 id="建立一个大根堆"><a href="#建立一个大根堆" class="headerlink" title="建立一个大根堆"></a>建立一个大根堆</h3><p>一个大根堆的基本要求就是每个逻辑上的父节点都大于其孩子节点，所以基本思路就是检查每一个非终端节点，看其是否满足大根堆的要求，不满足时进行调整。</p><p>从最后一个非终端节点开始往前检查，若不满足大根堆的要求时，将当前节点与其<strong>更大</strong>的一个孩子进行交换。当然调整过程中会发生下一层的子树不再满足的情况，则对下一层的子树也进行相应的调整。</p><p><img src="/ds_03_SelectSort/heapbuild.png"></p><p>当第五步调整完之后，根节点的右子树不再满足大根堆的要求，所以还需要再对其进行额外的调整。</p><p>最终调整结果如图所示：</p><p><img src="/ds_03_SelectSort/bigheap.png"></p><pre><code class="hljs c++"><span class="hljs-comment">//大根堆调整</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MaxHeadAdjust</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> len)</span> </span>&#123;A[<span class="hljs-number">0</span>] = A[k];<span class="hljs-comment">//暂存待调整子树的根节点</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>*k; i &lt;= len; i *= <span class="hljs-number">2</span>) &#123;<span class="hljs-comment">//沿着值较大的子节点向下筛选</span><span class="hljs-keyword">if</span> (i+<span class="hljs-number">1</span> &lt;= len &amp;&amp; A[i] &lt; A[i+<span class="hljs-number">1</span>])<span class="hljs-comment">//若有i+1这个元素</span>        i++;<span class="hljs-comment">//选择较大的孩子节点</span><span class="hljs-keyword">if</span> (A[<span class="hljs-number">0</span>] &gt;= A[i]) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//若原本就符合大根堆的要求，则结束</span><span class="hljs-keyword">else</span> &#123;A[k] = A[i];<span class="hljs-comment">//不符合时就进行替换</span>k = i;<span class="hljs-comment">//修改k值，以便于继续向下调整当前堆的子树</span>&#125;&#125;A[k] = A[<span class="hljs-number">0</span>];<span class="hljs-comment">//填入最终位置</span>&#125;<span class="hljs-comment">//建立大根堆</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BuildMaxHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> len)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len/<span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; i--)<span class="hljs-comment">//从最后一个非终端节点向前进行调整</span>MaxHeadAdjust(A, i, len);&#125;</code></pre><p>这段代码来自王道，不得不说代码写的非常精炼。选择两个孩子中较大的那段代码，非常巧妙的包含了所有情况，<code>i+1&lt;=len</code>，就包含了<code>当前节点只有一个孩子的情况，此时k=4,i=8,len=8,不会执行后续的语句，从而避免了A[i+1]导致数组越界的情况</code>。而若<code>A[i]&lt;A[i+1]</code>时，<code>i++</code>条件满足时<code>i</code>会指向值大的那个孩子节点。</p><h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p><strong>基本思想</strong>：将当前堆顶的元素与当前最大的叶子节点交换位置，然后将剩下的n-1个元素再次整理成为堆，重复执行上述过程，最后直到生意一个元素时停止。这是整个序列就是一个从小到大排序的序列。</p><p><img src="/ds_03_SelectSort/heapsort.png"></p><p>步骤如上如所示：<strong>整理成堆 —— 堆顶元素与堆底元素交换位置 —— 调整新的堆 —— 重复执行。</strong></p><p>最终执行结果：</p><p><img src="/ds_03_SelectSort/heapsortend.png"></p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">int</span> &amp;b)</span> </span>&#123;<span class="hljs-keyword">int</span> temp = a;a = b;b = temp;&#125;<span class="hljs-comment">//大顶堆排序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MaxHeapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;BuildMaxHeap(A, n);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n - <span class="hljs-number">1</span>; i++) &#123;<span class="hljs-comment">//一共进行n-1趟排序</span><span class="hljs-comment">//先调整成堆</span>MaxHeadAdjust(A,<span class="hljs-number">1</span>,n-i+<span class="hljs-number">1</span>);<span class="hljs-comment">//交换位置</span>swap(A[<span class="hljs-number">1</span>], A[n-i+<span class="hljs-number">1</span>]);<span class="hljs-comment">//堆顶元素和最后一个元素交换</span>&#125;&#125;</code></pre><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li><p>空间复杂度：<code>O(1)</code>，显然只需要常量个辅助空间。</p></li><li><p>时间复杂度：<code>O(n*log2_n)</code></p></li></ul><p>参考大根堆调整的代码，一个节点向下调整一层，最多需要对比2次，一个具有N个节点的数组，逻辑上树高为h，（$$h = \lfloor log_2{n}\rfloor + 1$$），若当前节点在第i层，则这个节点最多需要调整<code>h-i</code>层，从而关键字的对比次数不超过<code>2(h-i)</code>次。</p><p>第i层最多有$$2^{i-1}$$个节点，且只有第1层到第h-1层的节点才需要调整。</p><p>则将整个树调整成为大根堆，关键字的对比次数不超过4n，从而建立堆的时间复杂度为<code>O(n)</code>。</p><p><img src="/ds_03_SelectSort/heaptime.png"></p><p>而在实际代码中，每次调整堆都是从根节点向下调整，也就是说根节点至多调整<code>h-1</code>次，而每调整一次最多对比关键字2次，从而每一趟排序调整的时间复杂度不超过<code>O(h) = O(log2_n)</code>。一共会进行<code>n-1</code>趟，总的时间复杂度是<code>O(n*log2_n)</code>.</p><ul><li>堆排序算法是<strong>不稳定</strong>的算法，再大根堆调整的算法中，当两个孩子值相同时，优先与左孩子进行交换位置。eg：<code>1 2 2</code>，对其进行排序，调整成堆<code>2 1 2</code>，然后根节点与末尾节点互换位置，导致两个2的先后次序发生了变化。</li><li>算法适用：顺序表和<strong>单链表</strong>均可。</li></ul><h3 id="大根堆的链表代码实现"><a href="#大根堆的链表代码实现" class="headerlink" title="大根堆的链表代码实现"></a>大根堆的链表代码实现</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//链表定义</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span>&#123;</span><span class="hljs-keyword">int</span> data;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span>* <span class="hljs-title">next</span>;</span>&#125;LinkNode,*LinkList;<span class="hljs-comment">//获取当前链表的最后一个节点</span><span class="hljs-function">LinkNode* <span class="hljs-title">LastNode</span><span class="hljs-params">(LinkList L, <span class="hljs-keyword">int</span> len)</span> </span>&#123;LinkNode *p = L-&gt;next;<span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (index &lt; len) &#123;index++;p = p-&gt;next;&#125;<span class="hljs-keyword">return</span> p;&#125;<span class="hljs-comment">//交换两个链表元素的值</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(LinkNode &amp;a, LinkNode &amp;b)</span> </span>&#123;<span class="hljs-keyword">int</span> temp = a.data;a.data = b.data;b.data = temp;&#125;<span class="hljs-comment">//大根堆调整</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MaxHeadAdjust</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> len)</span> </span>&#123;<span class="hljs-keyword">int</span> i = k;<span class="hljs-keyword">while</span>(i &lt;= len/<span class="hljs-number">2</span>)&#123;LinkNode* pre = L-&gt;next;LinkNode* parent = <span class="hljs-literal">nullptr</span>;LinkNode* lchild = <span class="hljs-literal">nullptr</span>;LinkNode* rchild = <span class="hljs-literal">nullptr</span>;<span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (index &lt; i) &#123;pre = pre-&gt;next;<span class="hljs-comment">//找到了当前的节点</span>index++;&#125;parent = pre;<span class="hljs-comment">//父节点的位置</span><span class="hljs-comment">//寻找其左右孩子</span><span class="hljs-keyword">while</span> (index &lt; <span class="hljs-number">2</span>*i) &#123;pre = pre-&gt;next;index++;&#125;lchild = pre;<span class="hljs-comment">//一定有左孩子</span><span class="hljs-keyword">if</span> (<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= len) rchild = pre-&gt;next;<span class="hljs-comment">//若存在右孩子</span><span class="hljs-keyword">if</span> (rchild != <span class="hljs-literal">nullptr</span> &amp;&amp; lchild-&gt;data &lt; rchild-&gt;data) &#123;<span class="hljs-keyword">if</span> (parent-&gt;data &lt; rchild-&gt;data) &#123;swap(*parent, *rchild); <span class="hljs-comment">//与右孩子交换</span>i = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent-&gt;data &lt; lchild-&gt;data) &#123;swap(*parent, *lchild);<span class="hljs-comment">//与左孩子进行交换</span>i = <span class="hljs-number">2</span>*i;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>; <span class="hljs-comment">//满足条件，结束循环</span>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent-&gt;data &lt; lchild-&gt;data) &#123;swap(*parent, *lchild);<span class="hljs-comment">//与左孩子进行交换</span>i = <span class="hljs-number">2</span>*i;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<span class="hljs-comment">//满足条件，结束循环</span>&#125;&#125;<span class="hljs-comment">//建立大根堆</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BuildMaxHeap</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> len)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len/<span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<span class="hljs-comment">//从逻辑上的最后一个非终端节点向前建立</span>MaxHeadAdjust(L,i,len);&#125;&#125;<span class="hljs-comment">//大根堆排序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MaxHeapSort</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> len)</span> </span>&#123;BuildMaxHeap(L, len);<span class="hljs-comment">//初始建堆</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">//len个元素，共进行len-1趟排序</span>MaxHeadAdjust(L,<span class="hljs-number">1</span>,len-i);<span class="hljs-comment">//调整大根堆</span><span class="hljs-comment">//堆顶元素和最后一个元素交换位置</span>swap(*(L-&gt;next), *(LastNode(L,len-i)));&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;LinkList L = (LinkNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkNode));<span class="hljs-comment">//头节点</span>L-&gt;next = <span class="hljs-literal">nullptr</span>;LinkNode* pre = L;srand(time(<span class="hljs-number">0</span>));<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;LinkNode* q = (LinkNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkNode));<span class="hljs-keyword">int</span> randnum = rand() % <span class="hljs-number">100</span>; <span class="hljs-comment">//0 - 99之间的随机数</span>q-&gt;data = randnum;q-&gt;next = <span class="hljs-literal">nullptr</span>;pre-&gt;next = q;pre = pre-&gt;next;&#125;<span class="hljs-comment">//输出链表的元素</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;初始链表元素为：&quot;</span>;pre = L-&gt;next;<span class="hljs-keyword">while</span> (pre != <span class="hljs-literal">nullptr</span>) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; pre-&gt;data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;pre = pre-&gt;next;&#125;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//建立一个大根堆</span>BuildMaxHeap(L, <span class="hljs-number">8</span>);<span class="hljs-comment">//输出链表的元素</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;初始大根堆元素为：&quot;</span>;pre = L-&gt;next;<span class="hljs-keyword">while</span> (pre != <span class="hljs-literal">nullptr</span>) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; pre-&gt;data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;pre = pre-&gt;next;&#125;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//输出排序的元素</span>MaxHeapSort(L, <span class="hljs-number">8</span>);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;大根堆排序结果为：&quot;</span>;pre = L-&gt;next;<span class="hljs-keyword">while</span> (pre != <span class="hljs-literal">nullptr</span>) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; pre-&gt;data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;pre = pre-&gt;next;&#125;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre><h3 id="小根堆的实现"><a href="#小根堆的实现" class="headerlink" title="小根堆的实现"></a>小根堆的实现</h3><p>代办</p><h3 id="堆排序的应用"><a href="#堆排序的应用" class="headerlink" title="堆排序的应用"></a>堆排序的应用</h3><p>代办</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>交换排序算法——冒泡排序、快速排序</title>
    <link href="/ds_02_ExchangeSort/"/>
    <url>/ds_02_ExchangeSort/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：冒泡排序、快速排序算法思想以及C++代码的实现。</p><a id="more"></a><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><p>顾名思义，基于“交换”思想的排序，根据序列中两个关键字的比较结果来对换这两个记录在序列中的位置。</p><p>包含冒泡排序和快速排序两种。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>算法思想</strong>：从后往前，每次两两比较相邻元素的值，通过交换位置使得值较小的元素排在前面，这样经过一次排序，当前序列中最小的元素排在了最前面。</p><p>这称为一趟冒泡，每次冒出待排序序列中最小的那个，直到待排序序列只剩一个为止。</p><p>或者从前往后，每次排序使得最大的元素排在最末尾，“沉底🙃”。</p><p><strong>注意</strong>：若在冒泡排序中的某趟中没有发生交换，那就说明整体已经有序了，这时算法就可以停止运行了。</p><p><img src="https://img2020.cnblogs.com/blog/2001960/202101/2001960-20210108113628009-1243543462.gif" alt="冒泡排序"></p><center>图源：拉勾教育</center><center>图中为“沉底”的方式</center><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">int</span> &amp;b)</span> </span>&#123;<span class="hljs-keyword">int</span> tmp = a;a = b;b = tmp;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; i++) &#123;<span class="hljs-comment">//n个元素至多会进行n-1趟排序</span><span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;   <span class="hljs-comment">//标识这一次排序中是否发生了交换</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n<span class="hljs-number">-1</span>; j &gt; i; j--) &#123; <span class="hljs-comment">//从后往前，每次取最小的元素</span><span class="hljs-keyword">if</span> (A[j] &lt; A[j<span class="hljs-number">-1</span>]) &#123;swap(A[j], A[j<span class="hljs-number">-1</span>]);<span class="hljs-comment">//交换元素</span>flag = <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">false</span>)<span class="hljs-comment">//若未发生交换</span><span class="hljs-keyword">break</span>;&#125;&#125;</code></pre><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>空间复杂度：<code>O(1)</code>，需要常量个辅助空间。</li><li>时间复杂度：<ul><li>最好情况下，初始就有序，那就是<code>n</code>个元素进行<code>n-1</code>次比较，没有交换元素，<code>O(n)</code>。</li><li>最坏情况下，初始为逆序，<ul><li>第一趟：对比关键字<code>n-1</code>次，移动<code>3(n-1)</code>次，(swap函数中元素交换三次)</li><li>第二趟：对比关键字<code>n-2</code>次，移动<code>3(n-2)</code>次</li><li>…</li><li>第n-1趟：对比关键字1次，移动3次</li><li>一共对比$$\frac{n(n-1)}{2}$$ ,一共移动$$\frac{3n(n-1)}{2}$$（等差数列计算）</li><li><code>O(n^2)</code>.</li></ul></li><li>平均情况下，<code>O(n^2)</code>.</li></ul></li><li>冒泡排序是<strong>稳定</strong>的算法。</li><li>算法评价：简单、容易实现，适用于<strong>待排序序列比较小</strong>或者<strong>基本有序</strong>的情况。</li><li>算法适用：可用于顺序表、链表这样的数据结构。<ul><li>例如单链表，可以使用“沉底”的方式从表头将最大的元素沉到表尾。</li></ul></li><li>算法特点：每一趟排序都会确定一个元素在序列中的最终位置。</li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>算法思想</strong>：这是基于<strong>分治策略</strong>的思想，采用了<strong>划分交换排序</strong>。选定一个<code>枢轴元素pivot</code>，通过一次划分，将待排序数据分割为两部分，左边都比pivot小，右边都比pivot大。然后对这两部分数据再分别执行上述排序过程，直到任何一个子序列都为空或者只有一个元素为止，这样整个数据就变成了有序序列。</p><ul><li><strong>分治</strong>：将原问题划分为若干个与原问题相同的子问题；然后递归的求解子问题，当子问题规模足够小的时候就可以直接求解；然后将每个子问题的解组合成原问题的解。</li></ul><h3 id="实现方式1-——填坑法"><a href="#实现方式1-——填坑法" class="headerlink" title="实现方式1.——填坑法"></a>实现方式1.——填坑法</h3><p><img src="/ds_02_ExchangeSort/quicksort.png"></p><p>通过移动<code>low</code>和<code>high</code>指针，来交换元素的位置，使得<code>low</code>指针左边的元素都小于<code>pivot</code>，而右边元素都大于<code>pivot</code>。</p><ol><li>初始时刻选择low指向的49作为pivot枢轴元素，则low所指位置为空，high指向最末端的元素。</li><li>high指针所指元素大于等于<code>pivot=49</code>，则其向左移动，指向27，由于小于pivot，则要将其与low指针所指位置交换元素。此时high指向空。</li><li>然后移动low指针，low所指元素小于pivot，然后low向右移动，直到找到一个大于pivot的值，将其与high所指位置进行交换。然后low指向了空。</li><li>继续移动high指针，找寻比pivot小的元素，使其到达low即low的左边的位置，即<code>13</code>交换到low所指位置。</li><li>low指针来找寻比piovt大的元素，使其移动到high的位置。</li><li>high指针向左移动，直到和low指针相遇。这时第一次划分结束，low左边均比pivot要小，high右边均比pivot要大，这两指针所指位置就是pivot应当填充的位置。</li></ol><table><thead><tr><th align="center">步骤</th><th align="center">索引0</th><th align="center">索引1</th><th align="center">索引2</th><th align="center">索引3</th><th align="center">索引4</th><th align="center">索引5</th><th align="center">索引6</th><th align="center">索引7</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">#|low</td><td align="center">38</td><td align="center">65</td><td align="center">97</td><td align="center">76</td><td align="center">13</td><td align="center">27</td><td align="center">49|high</td></tr><tr><td align="center">2</td><td align="center">27|low</td><td align="center">38</td><td align="center">65</td><td align="center">97</td><td align="center">76</td><td align="center">13</td><td align="center">#|high</td><td align="center">49</td></tr><tr><td align="center">3</td><td align="center">27</td><td align="center">38</td><td align="center">#|low</td><td align="center">97</td><td align="center">76</td><td align="center">13</td><td align="center">65|high</td><td align="center">49</td></tr><tr><td align="center">4</td><td align="center">27</td><td align="center">38</td><td align="center">13|low</td><td align="center">97</td><td align="center">76</td><td align="center">#|high</td><td align="center">65</td><td align="center">49</td></tr><tr><td align="center">5</td><td align="center">27</td><td align="center">38</td><td align="center">13</td><td align="center">#|low</td><td align="center">76</td><td align="center">97|high</td><td align="center">65</td><td align="center">49</td></tr><tr><td align="center">6</td><td align="center">27</td><td align="center">38</td><td align="center">13</td><td align="center">49|low|high</td><td align="center">76</td><td align="center">97</td><td align="center">65</td><td align="center">49</td></tr></tbody></table><p><img src="/ds_02_ExchangeSort/quicksort1.png"></p><p>针对左半部分，继续进行划分、交换。</p><ol><li>选择0号位置的27作为pivot，low所指元素为空，high指向最末尾的元素。</li><li>high指向所指元素小于pivot，与low位置进行交换。</li><li>low指针向右移动，寻找比pivot要大的元素，并与high位置的元素进行交换。</li><li>high指针向左移动，遇到了low指针，划分结束，所指位置应当填入pivot。</li></ol><table><thead><tr><th align="center">步骤</th><th align="center">索引0</th><th align="center">索引1</th><th align="center">索引2</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">#|low</td><td align="center">38</td><td align="center">13|high</td></tr><tr><td align="center">2</td><td align="center">13|low</td><td align="center">38</td><td align="center">#|high</td></tr><tr><td align="center">3</td><td align="center">13</td><td align="center">#|low</td><td align="center">38|high</td></tr><tr><td align="center">4</td><td align="center">13</td><td align="center">27|low|high</td><td align="center">38</td></tr></tbody></table><p>剩余部分也是同样的方式。</p><p>很明显这是一个<strong>递归</strong>的过程，起始选择表首作为<code>pivot</code>，high指针指向末尾，向左移动寻找比pivot小的元素赋值给<code>A[low]</code>，而low向右移动，寻找比pivot大的元素赋值给<code>A[high]</code>，执行结束的条件是<code>low=high</code>。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<span class="hljs-keyword">int</span> pivot = A[low];<span class="hljs-comment">//选取枢轴元素</span><span class="hljs-keyword">while</span> (low &lt; high) &#123;<span class="hljs-comment">//寻找比pivot小的元素，比它大的直接忽略</span><span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) high--;A[low] = A[high];<span class="hljs-comment">//比Pivot小的移动到左侧</span>        <span class="hljs-comment">//寻找比pivot大的元素，比它小的直接忽略</span><span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) low++;A[high] = A[low];<span class="hljs-comment">//比Pivot大的移动到右侧</span>&#125;A[low] = pivot;<span class="hljs-comment">//赋值</span><span class="hljs-keyword">return</span> low;<span class="hljs-comment">//返回存放枢轴pivot的位置</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<span class="hljs-keyword">if</span> (low &lt; high) &#123;<span class="hljs-comment">//当low&lt;high时才执行</span><span class="hljs-keyword">int</span> pivotpos = Partition(A, low, high);<span class="hljs-comment">//划分</span>QuickSort(A, low, pivotpos<span class="hljs-number">-1</span>);<span class="hljs-comment">//左子表</span>QuickSort(A, pivotpos+<span class="hljs-number">1</span>,high);<span class="hljs-comment">//右子表</span>&#125;&#125;</code></pre><h3 id="实现方式2-——-前后指针法"><a href="#实现方式2-——-前后指针法" class="headerlink" title="实现方式2 —— 前后指针法"></a>实现方式2 —— 前后指针法</h3><p>前后指针法比上述填坑法有一些独特的优势，<strong>它的指针都是单侧移动</strong>，可支持单链表这种只能单向移动指针的数据结构。</p><ol><li>将待排序序列的最左元素记为<code>pivot</code>，创建<code>指针i，j</code>，<code>指针i</code>指向待排序序列A的最左边的元素，<code>指针j</code>指向<code>指针i</code>指向的下一位。</li><li>比较<code>A[j]</code>与<code>pivot</code>，若<code>A[j] &gt;= pivot</code>，<code>指针j</code>后移一位，<code>指针i</code>不动。若<code>A[j] &lt; pivot</code>，交换<code>i+1</code>和<code>j</code>的值，<code>指针i、j</code>同时后移一位。</li><li>当<code>指针j</code>走到数组的末尾时，先执行(2)操作，再交换<code>A[i]</code>与<code>pivot</code>的值。</li><li>通过<code>pivot</code>将原来的序列分割成了两个子序列，然后对两个子序列进行相同的操作。即递归执行。</li></ol><center><font color="red">针对一个序列{6 10 13 5 8 3 2 11}进行前后指针法的划分排序。</font></center><table><thead><tr><th align="center">步骤</th><th align="center">索引0</th><th align="center">索引1</th><th align="center">索引2</th><th align="center">索引3</th><th align="center">索引4</th><th align="center">索引5</th><th align="center">索引6</th><th align="center">索引7</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">6 | i</td><td align="center">10 | j</td><td align="center">13</td><td align="center">5</td><td align="center">8</td><td align="center">3</td><td align="center">2</td><td align="center">11</td></tr><tr><td align="center">2</td><td align="center">6 | i</td><td align="center">10</td><td align="center">13</td><td align="center">5 | j</td><td align="center">8</td><td align="center">3</td><td align="center">2</td><td align="center">11</td></tr><tr><td align="center">3</td><td align="center">6</td><td align="center">5 | i</td><td align="center">13</td><td align="center">10</td><td align="center">8 | j</td><td align="center">3</td><td align="center">2</td><td align="center">11</td></tr><tr><td align="center">4</td><td align="center">6</td><td align="center">5 | i</td><td align="center">13</td><td align="center">10</td><td align="center">8</td><td align="center">3 | j</td><td align="center">2</td><td align="center">11</td></tr><tr><td align="center">5</td><td align="center">6</td><td align="center">5</td><td align="center">3 | i</td><td align="center">10</td><td align="center">8</td><td align="center">13</td><td align="center">2 | j</td><td align="center">11</td></tr><tr><td align="center">6</td><td align="center">6</td><td align="center">5</td><td align="center">3</td><td align="center">2 | i</td><td align="center">8</td><td align="center">13</td><td align="center">10</td><td align="center">11 | j</td></tr><tr><td align="center">7</td><td align="center">6</td><td align="center">5</td><td align="center">3</td><td align="center">2 | i</td><td align="center">8</td><td align="center">13</td><td align="center">10</td><td align="center">11</td></tr><tr><td align="center">8</td><td align="center">2</td><td align="center">5</td><td align="center">3</td><td align="center">6 | i</td><td align="center">8</td><td align="center">13</td><td align="center">10</td><td align="center">11</td></tr></tbody></table><ol><li>选择6作为<code>pivot</code>，<code>指针i</code>指向6，<code>指针j</code>指向10.</li><li>比较<code>A[j]</code>与<code>pivot</code>，<code>A[j] &gt; pivot</code>，<code>指针j</code>向右移动直到指向5。</li><li>此时<code>A[j] &lt; pivot</code>，交换<code>i+1</code>和<code>j</code>的值，<code>指针i、j</code>同时后移一位。</li><li>比较<code>A[j]</code>与<code>pivot</code>，<code>A[j] &gt; pivot</code>，<code>指针j</code>向右移动直到指向3。</li><li>此时<code>A[j] &lt; pivot</code>，交换<code>i+1</code>和<code>j</code>的值，<code>指针i、j</code>同时后移一位。</li><li>此时<code>A[j] &lt; pivot</code>，交换<code>i+1</code>和<code>j</code>的值，<code>指针i、j</code>同时后移一位。</li><li>此时<code>指针j</code>走到了末尾，<code>A[j] &gt; pivot</code>，<code>指针j</code>后移一位，<code>指针i</code>不动。</li><li>交换<code>A[i]</code>与<code>pivot</code>的值。这样<code>指针i</code>指向的左边元素均小于<code>pivot</code>，右边均大于<code>pivot</code>。</li></ol><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">int</span> &amp;b)</span> </span>&#123;<span class="hljs-keyword">int</span> tmp = a;a = b;b = tmp;&#125;<span class="hljs-comment">//前后指针法</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Part</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<span class="hljs-keyword">int</span> pivot = A[left];<span class="hljs-keyword">int</span> pivotpos = left;<span class="hljs-comment">//记录pivot和其对应位置</span><span class="hljs-keyword">int</span> i = left;<span class="hljs-keyword">int</span> j = left + <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (j &lt;= right &amp;&amp; i&lt;j) &#123;<span class="hljs-keyword">if</span> (A[j] &lt; pivot) &#123;swap(A[i+<span class="hljs-number">1</span>],A[j]);i++; j++;&#125;<span class="hljs-keyword">else</span> &#123;j++;&#125;&#125;swap(A[i], A[pivotpos]);<span class="hljs-comment">//交换位置</span><span class="hljs-keyword">return</span> i;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<span class="hljs-keyword">if</span> (low &lt; high) &#123;<span class="hljs-comment">//当low&lt;high时才执行</span><span class="hljs-keyword">int</span> pivotpos = Part(A, low, high);<span class="hljs-comment">//划分</span>QuickSort(A, low, pivotpos<span class="hljs-number">-1</span>);<span class="hljs-comment">//左子表</span>QuickSort(A, pivotpos+<span class="hljs-number">1</span>,high);<span class="hljs-comment">//右子表</span>&#125;&#125;</code></pre><blockquote><p>参考链接：<a href="https://www.cnblogs.com/Unicron/p/9465403.html">https://www.cnblogs.com/Unicron/p/9465403.html</a></p></blockquote><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>对于序列中的递归调用，实际的处理如下：</p><p><img src="/ds_02_ExchangeSort/quickdeep.png"></p><p><strong>这就相当于把n个元素组织成了二叉树，二叉树的层数就是递归调用的层数。</strong></p><p>而n个节点的二叉树的最小高度为$\lfloor{log_2{n}}\rfloor + 1$，二叉树的最大高度为n。</p><p>所以：时间复杂度和空间复杂度取决于递归层数，空间复杂度=<code>O(递归层数)</code>，时间复杂度=<code>O(n*递归层数)</code>，因为每一层的<code>QuickSort</code>函数处理的元素都不会超过n个。</p><ul><li><p>空间复杂度：最好<code>O(log2_n)</code>，最坏<code>O(n)</code>。</p></li><li><p>时间复杂度：最好<code>O(n*log2_n)</code>，最坏<code>O(n*n)</code>。</p></li><li><p>不过平均时间复杂度为：<code>O(nlog2_n)</code>。<strong>快速排序是所有内部排序算法之中平均性能最优的算法。</strong></p></li><li><p>快速排序<strong>不稳定</strong>。eg: <code>2 2 1</code>，一次划分之后两个2的先后顺序发生了变化。</p></li></ul><ul><li>算法适用：顺序表或者单链表这样的数据结构。<strong>采用前后指针法可实现单链表的快速排序。</strong></li><li>算法特点：每次排序中会有元素确定其最终位置。</li></ul><h3 id="快速排序的优化"><a href="#快速排序的优化" class="headerlink" title="快速排序的优化"></a>快速排序的优化</h3><p>当每次的枢轴把待排序列表分割为长度相近的两个子表时，速度时最快的；而当表本身已经有序或者逆序的时候，速度是最慢的。</p><p>因为当每一次选中的枢轴元素将待排序序列分割成了两个很不均匀的部分时，会导致递归的深度加深，最终导致算法效率变低。</p><h4 id="一、枢轴元素的选取"><a href="#一、枢轴元素的选取" class="headerlink" title="一、枢轴元素的选取"></a>一、枢轴元素的选取</h4><p>尽可能的选择可以将数据序列中分的枢轴元素，例如从序列的头、尾以及中间位置选择三个元素，然后去这三个元素的中间值最为枢轴元素。或者是随机的从当前序列中选取枢轴元素。</p><pre><code class="hljs c++"><span class="hljs-comment">//三数取中法，获取中间值的索引</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetMidIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (A[left] &lt;= A[mid]) &#123;<span class="hljs-keyword">if</span> (A[mid] &lt;= A[right]) <span class="hljs-keyword">return</span> mid;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[mid] &lt;= A[right]) <span class="hljs-keyword">return</span> left;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> right;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (A[mid] &gt;= A[right]) <span class="hljs-keyword">return</span> mid;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[left] &gt;= A[right]) <span class="hljs-keyword">return</span> right;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> left;&#125;&#125;</code></pre><h4 id="二、加入插入排序"><a href="#二、加入插入排序" class="headerlink" title="二、加入插入排序"></a>二、加入插入排序</h4><p>当排序接近完成的时候，数组会被分的很小，这是可以采用直接插入排序来处理这种情况。</p><pre><code class="hljs c++"><span class="hljs-comment">//改进的快速排序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<span class="hljs-keyword">if</span> (low &lt; high) &#123;<span class="hljs-comment">//当low&lt;high时才执行</span><span class="hljs-keyword">if</span> (high - low &lt;= <span class="hljs-number">5</span>) &#123;<span class="hljs-comment">//当待排序长度小于等于6时，采用直接插入排序</span>InsertSort(A,low,high);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">int</span> pivotpos = Partition(A, low, high);<span class="hljs-comment">//划分</span>QuickSort(A, low, pivotpos - <span class="hljs-number">1</span>);<span class="hljs-comment">//左子表</span>QuickSort(A, pivotpos + <span class="hljs-number">1</span>, high);<span class="hljs-comment">//右子表</span>&#125;&#125;&#125;</code></pre><hr><h2 id="函数调用示例"><a href="#函数调用示例" class="headerlink" title="函数调用示例"></a>函数调用示例</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//直接插入排序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> begin,<span class="hljs-keyword">int</span> end)</span> </span>&#123;<span class="hljs-keyword">int</span> temp;<span class="hljs-comment">//临时变量，暂存数据</span><span class="hljs-keyword">int</span> i, j;<span class="hljs-keyword">for</span> (i = begin+<span class="hljs-number">1</span>; i &lt;= end; i++) &#123;<span class="hljs-comment">//对A[begin+1]到A[end]上的元素进行插入排序</span><span class="hljs-keyword">if</span> (A[i] &lt; A[i<span class="hljs-number">-1</span>]) &#123;<span class="hljs-comment">//若待排序元素小于其前面有序序列的最后一个元素</span>temp = A[i];<span class="hljs-keyword">for</span> (j = i<span class="hljs-number">-1</span>; j &gt;= begin &amp;&amp; A[j] &gt; temp; j--) &#123;A[j+<span class="hljs-number">1</span>] = A[j];<span class="hljs-comment">//所有大于temp的均向后移动</span>&#125;A[j+<span class="hljs-number">1</span>] = temp;<span class="hljs-comment">//对应的插入位置</span>&#125;&#125;&#125;<span class="hljs-comment">//三数取中法，获取中间值的索引</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetMidIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (A[left] &lt;= A[mid]) &#123;<span class="hljs-keyword">if</span> (A[mid] &lt;= A[right]) <span class="hljs-keyword">return</span> mid;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[mid] &lt;= A[right]) <span class="hljs-keyword">return</span> left;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> right;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (A[mid] &gt;= A[right]) <span class="hljs-keyword">return</span> mid;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[left] &gt;= A[right]) <span class="hljs-keyword">return</span> right;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> left;&#125;&#125;<span class="hljs-comment">//交换</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">int</span> &amp;b)</span> </span>&#123;<span class="hljs-keyword">int</span> tmp = a;a = b;b = tmp;&#125;<span class="hljs-comment">//填坑法</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<span class="hljs-keyword">int</span> pivotpos = GetMidIndex(A, low, high);swap(A[low], A[pivotpos]);<span class="hljs-comment">//交换，使得low位置为取得的枢轴值</span><span class="hljs-keyword">int</span> pivot = A[low];<span class="hljs-keyword">while</span> (low &lt; high) &#123;<span class="hljs-comment">//寻找比pivot小的元素，比它大的直接忽略</span><span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) high--;A[low] = A[high];<span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) low++;A[high] = A[low];&#125;A[low] = pivot;<span class="hljs-comment">//赋值</span><span class="hljs-keyword">return</span> low;<span class="hljs-comment">//返回存放枢轴pivot的位置</span>&#125;<span class="hljs-comment">//改进的快速排序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<span class="hljs-keyword">if</span> (low &lt; high) &#123;<span class="hljs-comment">//当low&lt;high时才执行</span><span class="hljs-keyword">if</span> (high - low &lt;= <span class="hljs-number">5</span>) &#123;<span class="hljs-comment">//当待排序长度小于等于6时，采用直接插入排序</span>InsertSort(A,low,high);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">int</span> pivotpos = Partition(A, low, high);<span class="hljs-comment">//划分</span>QuickSort(A, low, pivotpos - <span class="hljs-number">1</span>);<span class="hljs-comment">//左子表</span>QuickSort(A, pivotpos + <span class="hljs-number">1</span>, high);<span class="hljs-comment">//右子表</span>&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> nums = <span class="hljs-number">0</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入待排序的数量个数:&quot;</span>;<span class="hljs-built_in">cin</span> &gt;&gt; nums;<span class="hljs-keyword">int</span> *A = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(nums*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums; i++) &#123;<span class="hljs-built_in">cin</span> &gt;&gt; A[i];&#125;QuickSort(A, <span class="hljs-number">0</span>, nums<span class="hljs-number">-1</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums; i++) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;<span class="hljs-built_in">free</span>(A);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><img src="/ds_02_ExchangeSort/quickfruit.png" alt="执行结果"></p><center>执行结果</center><h3 id="随机数程序"><a href="#随机数程序" class="headerlink" title="随机数程序"></a>随机数程序</h3><p>顺带把随机数的生成程序放在这里，方便以后使用。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//rand()会返回一个范围在0到RAND_MAX（32767）之间的伪随机数（整数）。</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入随机数生成的起始范围：&quot;</span>;<span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;<span class="hljs-built_in">cin</span> &gt;&gt; begin;<span class="hljs-keyword">if</span> (begin &lt; <span class="hljs-number">0</span> || begin &gt;<span class="hljs-number">32767</span>) begin = <span class="hljs-number">0</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入随机数生成的终止范围：&quot;</span>;<span class="hljs-keyword">int</span> end = <span class="hljs-number">32767</span>;<span class="hljs-built_in">cin</span> &gt;&gt; end;<span class="hljs-keyword">if</span> (end &gt; <span class="hljs-number">32767</span>) end = <span class="hljs-number">32767</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入要产生的随机数的数量：&quot;</span>;<span class="hljs-keyword">int</span> num;<span class="hljs-built_in">cin</span> &gt;&gt; num;srand(time(<span class="hljs-number">0</span>));<span class="hljs-comment">//设置随机数种子，若随机种子相同，则每次产生的随机数也相同</span><span class="hljs-keyword">int</span> times = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> randnum = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (times &lt; num) &#123;randnum = rand() % (end - begin + <span class="hljs-number">1</span>) + begin;<span class="hljs-built_in">cout</span> &lt;&lt; randnum &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;times++;&#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插入排序算法——直接插入、折半插入、希尔排序</title>
    <link href="/ds_01_InsertSort/"/>
    <url>/ds_01_InsertSort/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：插入排序算法思想以及C++代码的实现。</p><a id="more"></a><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>算法思想</strong>：每次将⼀个待排序的记录按其关键字大小插入到前面<strong>已排好序的子序列中</strong>，直到全部记录插⼊完成。</p><p>即通过逐步构造局部有序，来最终到达全局有序。</p><p>起始时刻，可将第一个元素当作最初的有序子序列，然后逐步增加元素构成信息的有序子序列。</p><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>即插入排序最直接的实现方式。默认按照从小到大的顺序排序，从前向后逐步构造有序序列。</p><p><strong>只有当前待排序元素小于其前面的元素时才需要排序</strong>，否则直接插入即可。</p><p>分为无哨兵版和带哨兵版。</p><p><strong>哨兵</strong>：对于数组这样顺序存储的从0开始存储的数据结构，可将第0个位置来存储哨兵，来减少代码中判定的复杂度。看代码比较直接。</p><h3 id="无哨兵版"><a href="#无哨兵版" class="headerlink" title="无哨兵版"></a>无哨兵版</h3><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> n)</span></span>&#123;<span class="hljs-keyword">int</span> temp;<span class="hljs-comment">//临时变量，暂存数据</span><span class="hljs-keyword">int</span> i, j;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<span class="hljs-comment">//对A[1]到A[n-1]上的元素进行插入排序</span><span class="hljs-keyword">if</span> (A[i] &lt; A[i<span class="hljs-number">-1</span>]) &#123;<span class="hljs-comment">//若待排序元素小于其前面有序序列的最后一个元素</span>temp = A[i];<span class="hljs-keyword">for</span> (j = i<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; A[j] &gt; temp; j--) &#123;A[j+<span class="hljs-number">1</span>] = A[j];<span class="hljs-comment">//所有大于temp的均向后移动</span>&#125;A[j+<span class="hljs-number">1</span>] = temp;<span class="hljs-comment">//对应的插入位置</span>&#125;&#125;&#125;</code></pre><ul><li><code>i</code>从1开始，将0号元素当作初始的有序序列。</li></ul><h3 id="带哨兵版"><a href="#带哨兵版" class="headerlink" title="带哨兵版"></a>带哨兵版</h3><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-keyword">int</span> i, j;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<span class="hljs-comment">//对A[2]到A[n]上的元素进行插入排序</span><span class="hljs-keyword">if</span> (A[i] &lt; A[i<span class="hljs-number">-1</span>]) &#123;<span class="hljs-comment">//若待排序元素其前面有序序列的最后一个元素</span>A[<span class="hljs-number">0</span>] = A[i];<span class="hljs-comment">//哨兵暂存</span><span class="hljs-keyword">for</span> (j = i<span class="hljs-number">-1</span>; A[<span class="hljs-number">0</span>] &lt; A[j]; j--) &#123;A[j+<span class="hljs-number">1</span>] = A[j];<span class="hljs-comment">//向后挪位</span>&#125;A[j+<span class="hljs-number">1</span>] = A[<span class="hljs-number">0</span>];<span class="hljs-comment">//复制到插入位置</span>&#125;&#125;&#125;</code></pre><ul><li>哨兵就是将数组的0号位置作为暂存元素区，同时在for循环中作为最终的条件判断语句，当<code>A[0]&lt;A[j]</code>时继续向前查找元素，最终停止的条件是<code>j=0</code>时此时表示查到了尽头；而在无哨兵版则既需要判定<code>j</code>的范围又要比较数据大小。</li></ul><p><img src="/ds_01_InsertSort/shaobing.png"></p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>空间复杂度：<code>O(1)</code>，著需要常量个辅助空间。</li><li>时间复杂度：<ul><li>最好情况下，初始就有序，那就是<code>n</code>个元素进行<code>n-1</code>趟处理，每次只需比关键字<code>n-1</code>次，<code>O(n)</code>。</li><li>最坏情况下，初始为逆序，<ul><li>第一趟：对比关键字2次(for循环内部)，移动3次(哨兵暂存，元素移位，插入位置)，</li><li>第二趟：对比关键字3次，移动4次</li><li>…</li><li>第n-1趟：对比关键字n次，移动n+1次</li><li>一共对比$$\frac{(n+2)(n-1)}{2}$$ ,一共移动$$\frac{(n+4)(n-1)}{2}$$（等差数列计算）</li><li><code>O(n^2)</code>.</li></ul></li><li>平均情况下，即随机排列<ul><li>比较次数$$\frac{(n+2)(n-1)}{4}$$，移动次数$$\frac{(n+4)(n-1)}{4}$$</li><li><code>O(n^2)</code>.</li></ul></li></ul></li><li>直接插入算法是<strong>稳定</strong>的算法。即当待排序序列中有多个相同的元素时，排序之后这几个元素的相对次序仍不变。</li><li>算法评价：简单、容易实现，适用于<strong>待排序序列比较小</strong>或者<strong>基本有序</strong>的情况。</li><li>算法适用：可用于顺序表、链表这样的数据结构。</li></ul><h2 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h2><p><strong>算法思想</strong>：折半插入排序是对直接插入排序的一种优化，即采用折半查找这种方式找到应该插入的位置，再移动元素。</p><p>与直接插入排序相比，折半查找这种方式可以<strong>减少比较的次数</strong>，但是移动元素的次数没有发生变化。</p><p><img src="/ds_01_InsertSort/zheban.png"></p><p>使用折半查找的规则来进行查找，不过不是为了找到该元素，而是要找到比该元素都大的元素。</p><p>这里使用了<code>A[0]</code>作为哨兵，当<code>low&gt;high</code>的时候停止查找，此时将<code>[low,i-1]</code>内的元素全部右移，然后将<code>A[0]</code>移动<strong>到<code>low</code>所指的位置</strong>。</p><p>而当<code>A[mid] == A[0]</code>时，为了保证算法的稳定性，应当在mid的右边继续寻找插入位置。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BinaryInsertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-keyword">int</span> temp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;temp = A[i];<span class="hljs-comment">//暂存</span><span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> high = i<span class="hljs-number">-1</span>;<span class="hljs-comment">//折半查找范围</span><span class="hljs-keyword">while</span> (low &lt;= high) &#123;<span class="hljs-keyword">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (A[mid] &gt; temp) high = mid - <span class="hljs-number">1</span>;<span class="hljs-comment">//查左半表</span><span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<span class="hljs-comment">//查右半表</span>&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= low; j--)A[j + <span class="hljs-number">1</span>] = A[j];A[low] = temp;<span class="hljs-comment">//插入</span>&#125;&#125;</code></pre><p>这是非哨兵版本，哨兵实现差别不大。</p><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>由于只是通过折半查找减少了比较次数，但数据的移动并没有减少，故时间复杂度仍旧是<code>O(n^2)</code>。</li></ul><ul><li>算法适用：由于折半查找的限制，这种算法只能用于有序的顺序表，即拥有<strong>随机访问</strong>特性的数据结构。</li></ul><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><strong>算法思想</strong>：先追求表中元素部分有序，再逐渐逼近全局有序。</p><p>即通过<code>增量d</code>来将待排序的表分割为若干个待排序的特殊子表，例如：<code>A[i],A[i+d],A[i+2d],…,A[i+nd]</code>构成了一个子表，然后对这些子表进行直接插入排序。</p><p>然后逐步缩短<code>增量d</code>，重复上述的过程，直到<code>d=1</code>为止。<code>d=1</code>时进行的就是整个表的直接插入排序，并且由于整个表基本有序，非常适用于直接插入排序。</p><ul><li>对于<code>增量d</code>的通常做法是每次将增量缩小一半。</li></ul><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-keyword">int</span> i, j, temp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = n/<span class="hljs-number">2</span>; d &gt;= <span class="hljs-number">1</span>; d = d/<span class="hljs-number">2</span>) &#123;<span class="hljs-comment">//步长</span><span class="hljs-keyword">for</span> (i = d; i &lt; n; i++) &#123;<span class="hljs-comment">//从每个子序列的第二个元素开始</span>temp = A[i];<span class="hljs-comment">//暂存</span><span class="hljs-keyword">if</span> (A[i-d] &gt; temp) &#123;<span class="hljs-keyword">for</span> (j = i-d; j &gt;= <span class="hljs-number">0</span> &amp;&amp; A[j] &gt; temp; j-=d)A[j+d] = A[j];<span class="hljs-comment">//元素后移</span>A[j+d] = temp;<span class="hljs-comment">//插入元素</span>&#125;&#125;&#125;&#125;</code></pre><h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li>空间复杂度：<code>O(1)</code></li><li>时间复杂度：和增量序列d1, d2, d3… 的选择有关，⽬前⽆法⽤数学⼿段证明确切的时间复杂度最坏时间复杂度为 <code>O(n^2)</code>，当n在某个范围内时，可达<code>O(n^1.3)</code>.</li><li>希尔排序算法<strong>不稳定</strong>。<ul><li>eg: <code>65 50 50 </code>，初始<code>d=2</code>时，两个50的先后次序就会发生错位。</li></ul></li><li>算法适用：顺序表这种可以<strong>随机访问</strong>的数据结构。</li></ul><hr><h2 id="函数调用示例"><a href="#函数调用示例" class="headerlink" title="函数调用示例"></a>函数调用示例</h2><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> A[<span class="hljs-number">8</span>] = &#123; <span class="hljs-number">49</span>,<span class="hljs-number">38</span>,<span class="hljs-number">65</span>,<span class="hljs-number">97</span>,<span class="hljs-number">76</span>,<span class="hljs-number">13</span>,<span class="hljs-number">27</span>,<span class="hljs-number">45</span> &#125;;ShellSort(A, <span class="hljs-number">8</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>;i++) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021研究生入学考试总结</title>
    <link href="/NETEM_record/"/>
    <url>/NETEM_record/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：一次失败的考研经历</p><a id="more"></a><h2 id="考研历程"><a href="#考研历程" class="headerlink" title="考研历程"></a>考研历程</h2><h3 id="9月之前"><a href="#9月之前" class="headerlink" title="9月之前"></a>9月之前</h3><p>2020年3月-8月，属于非常低效的阶段，总共学习了高数基础（没有做题），以及大概10个小时的英语语法，读了一半多的恋恋有词的单词，以及两篇贪吃蛇的小游戏，总结了几个的博客，学了一点操作。</p><p>那时候整体的状态和效率都是非常差劲的，原因：</p><ul><li>在家里效率非常的低，在家中非常容易被打断，或者说我很不习惯休息生活和学习混杂在同一间屋子里，老是看到了床和沙发就没有学习下去的念头，此外由于好多时候我得自己做饭，加之洗碗，导致有很长的时间在做那些事情，加之偶尔的看些视频，会导致时间过得非常的快。</li><li>自我约束能力太差劲，根本控制不住自己的欲望，尽管玩游戏的时候有一种负罪感，但是仍然还是想要继续玩。</li><li>对自己目标的执行力不够，往往都是三分钟热度，应该六月初吧，那会前几天还坚定了要考哈工大的信心，结果过了几天就慢慢放松了自己，心里有那个念想，但是永远没有行动，这就是精神上的巨人，行动上的矮子。</li><li>对未来的认识模糊，不懂得当下的努力对未来的明确回报，只知道努力是会有好处了，但不知道不努力的后果，不知道自己面临的风险，思想上并没有高度重视这件事，自己还在心中小窃喜，整日过的悠闲自得。</li><li>营造出了一种我在努力的假象，看似每天坐在电脑面前的努力过于廉价低下，现在看来那几个月学习的主要时间其实不过就是在学校接近20天左右的付出罢了。做事情而不给自己加限度，不给自己明确的条件，不能充分调动自己，这样的后果就是这达半年的碌碌无为。</li></ul><h3 id="9月之后"><a href="#9月之后" class="headerlink" title="9月之后"></a>9月之后</h3><p>刚开学的那几天其实也没有任何学习的欲望，但是看到了两个舍友的那种积极的努力，看到了他们的进度，看到了他们的那种状态，我被深深的刺激到了，这就是同辈压力的力量。</p><p>9月中考完英语六级之后到9月28日完成了考研报名东北大学之间这段日子，我的游戏生涯还是在继续的，还记得那会每天做任务……。</p><p>9月末，也就是在姐姐的力劝之下，我决定报考哈工大，也是从那会起，我的目标渐渐明确，行动力渐渐提升，尤其是决定开始看csapp那本书之后，花了巨款买了王道的定向班，除了偶尔会看csapp看到崩溃，其余课程也算是在逐步推进，英语阅读，政治，高数强化，概率论基础和强化，计网以及数据结构。当时一直在用“爱今天”计时，全盛状态下的时间大概约一天8小时有效时间。那会的时候其实高数学的是有些痛苦的，上午到图书馆抛去背诵的时间，一直到中午吃饭前有效的时间不过2个多小时，学习中途还容易走神，基本上午听完武忠祥老师的一个高数强化视频课之后就没什么时间做题了。下午基本都是学习第一遍CSAPP，毕竟是一本新书，看的确实头皮有些发麻。晚上再看一会CASPP，之后做英语，看网络或者政治。</p><p>十一月搬到了工学馆学习，开始学习线代强化课以及概率论的东西，并且做05-14年的高数真题，分章节做的……。下午主要是数据结构和网络，偶尔一篇阅读，晚上以第二遍csapp为主，偶尔辅以政治的内容。</p><p>十二月初做了几张数学模拟卷的选择填空之后心态开始爆炸，有好几天没有看过高数，然后发现自己线性代数第二遍复习之后什么内容都没记住，然后开始过第三遍的线性代数讲义，还有概率论的强化没有看，于是匆匆掠过一便，着重看了概率论的统计部分，但是参数估计和假设检验看的很少，最后两周的时候那会还在学一些概率论的基础知识，外加肖四的背诵，以及英语作文的背诵，那会确实是有些着急了，数据结构没做什么题目，计算机网络也是内容过少，准备的过于不完善。</p><p>到了考前一天的时候，上午加急看完了线性代数讲义5/6章，之后做了2/3道高数的大题，这就来到了下午。下午做了肖四最后一套选择题，之后就是在楼道里背政治。工学馆闭馆之后回宿舍呆了一会但是没有任何效率，于是带着垫子来了图书馆，直接坐在楼道里背书，最后感觉背的还不错。第二天6点多起床之后，在餐厅里背了一个多小时。然后就上了考场。</p><p>第一天考完之后还是到了图书关楼道里学习，不过尴尬的是，数学应该是做几道题尤其是大题来把握思路的，我就硬生生看那些知识点……，也没看以前做错的题目。在考试中做数学的那会，尤其是大题，整个人心态就炸了，概率论那么简单的一个大题，竟然不会写……，一张试卷上可能概率论只能拿2-3分。高数四道大题，至少三道是基础题，就硬生生的只会做一道半，尤其第三题，明明自己方程列的是对的，结果不会算，算不出答案，以为自己方程列错了，硬生生全勾掉了……，连方程分都没了。</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ul><li>眼高手低，自觉地自己会做了，实际上思路并不清晰，甚至都没有做题来巩固，尤其是数学和计算机网络。明知道数学学习效果不好，却不舍得再多花时间去做题巩固，所做题目寥寥无几，却期待能取得100分的分数，做梦。尤其是高数视频里，武忠祥老师一直强调“看懂不是懂，听懂也不是懂，只有最懂才是真的懂。”，我就仍然保持着我的偏见继续那么做题。</li><li>对自己要求过低，我把哈工大期末试题的难度当成了考研的难度，把期末的范围当成了考研的范围，对自己要求过低，甚至还津津自喜觉得也没这么难，直到考场上把自己做的满头大汗、心乱如麻才知道准备的多么不充分。</li><li>11月分是知道自己应该刷题了，但我采取了那种分章节刷真题的方法，这也是一种错误，因为往年真题出题并不规律，难度体现的并不均衡，而且实际上题目也很少，十年真题的高数部分竟然硬生生的刷了一个多月，还是占据的是最宝贵的上午时间，这本身就是一种浪费。</li><li>不愿思考，我发现自己有时候对思考有一种抗拒，不愿意动脑子，觉得很累很烦，尤其是与人交流的时候，彷佛我想掩盖我自己学的一点都不好的事实一样，不愿与人分享。</li></ul><h2 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h2><ol><li><p>环境：一个固定的环境还是比较重要的，那里最好没有会让你觉得分心或者是让你陷入一种舒适的状态。再那里最应该做的事情就是学习，除此之外别无其他。最好不要在宿舍里学习，太容易被打断了。</p></li><li><p>学习状态：一旦决定开始就要保持这种状态，某一天的突然放松会让自己想着去放弃。要坚定自己要学习要考研的想法，不要过于放松。甚至包括起床一样，允许自己赖床一会，但是一定要起床去学习！</p></li><li><p>听课学习是一个输入的过程，被动输入就像是在本次数学学习中一样，名落孙山。一定要提高输出的占比，听一节课应该用比它更长的时间去巩固做题，而不是说因为这个视频两小时，看完之后就到中午了，下午还要学习专业课，所以就不做题了。<strong>练习与应用才是最重要的</strong>，不要听信上半年那个学长的经验，什么每次学习新知识前复习旧的知识点，这个可能对其他科目有用，但我之于数学绝对没用！！！！！</p></li><li><p>开始一件事情之前不要觉得它有多难，你越把他想得更难就越容易拖延，永不开始。无论有多难，硬着头皮先看两个小时，先摸索，第二天再看，第三天再看，这样就慢慢不再觉得很难了，做这种较大地事情给自己7天的缓冲，如果连续7天还是没有思绪的话那就可以考虑换方向了。</p></li><li><p>其实<strong>经历过这段考研时光还是应该对自己有信心的</strong>，csapp我都看完了，我没那么弱……，要相信觉得多数事情自己都能够做到！自信真的很重要。敢想敢去做，这样你就比绝大多数人要强了！</p></li><li><p>坚定自己的信念，要考研就踏实准备考研，不要三天打鱼两天晒网，甚至还在脑海中幻想自己可以三个月考上大学，踏实稳固的完成目标更重要！<strong>决定了就去开始，行动行动自己行动！</strong>要考研就买书开始考研，要找工作就踏实学技术找工作，路有很多条，但是你只能走一条，当然只要你不去行动还是好多条路。</p></li><li><p>心存侥幸不可取。有时候会莫名觉得自己比别人有些优越感，但是这样的感觉从何而来？根本没有什么扎实的基础，难道是脑海中无端的妄想？</p></li><li><p>战略比战术更加的重要，方向比努力更重要，多去思考，多动脑子。</p></li><li><p><strong>聚焦才能起火</strong>。<strong>学习就是聚焦到一个点上，这样才能起火，广泛涉猎，什么都得不到。注意力在哪里，生产力就在哪里。哪里都不愿意深耕，顶多就是学了一些皮毛，当作谈资罢了。</strong></p></li><li><p>测试自己有没有天赋的不是做简单的事情或者不做事，而是去考试、去工作、去实践。特别是那种投入大、竞争多、成功少的事情。不要觉得自己投入一项会失去很多机会成本，现实是大部分人大学压根没有努力过，都是在一大堆的选择上浅尝辄止，最终也搞不清自己的天赋在哪里，比别人强在哪里。</p></li><li><p>节约精力。看娱乐新闻、听歌、看剧、打游戏，不叫放松，叫虚耗。无聊但是又不困的时候习惯给自己提供一点信息刺激，然后就这样不死不活的消磨自己，这很容易让自己精神不振。</p></li><li><p>定期检查自己上一个阶段的时间分配，人们倾向于把生活过成无序的状态，但是这真的不是一个好状态，很容易变的一团糟，所以要尝试定期将自己的节奏，重新调整成有序状态。</p></li><li><blockquote><p>时代在对我们进行营销大屠杀，在我们接下来的24小时余生里，驱使我们努力工作，让我们在沉默中灭亡。所以，为了保护自己，防止无聊苦闷渗入我们的思想，我们必须学会阅读，来激发自己的想象力，来培养我们自己的意识，信仰。我们都需要这些技能来保卫来守护我们的思想。”</p><p>选择无处不在，若无法自己选择，就会被选择。而阅读，让我们和这个世界暂时疏远，我们运用想象力进入另一个隐匿的世界。如果你选择放弃这些，放弃关注内心、关注自我，选择不在乎，让世界进步的洪流夹裹着你前进，就像在黄金周旅行时让人群挤着你前进，那么你最终会发现自己迷失的不只是方向，还有自己。选择不在乎很容易，而选择在乎却需要千百倍的勇气和坚持。</p></blockquote></li></ol><h2 id="其他人的状态"><a href="#其他人的状态" class="headerlink" title="其他人的状态"></a>其他人的状态</h2>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>matplotlib —— Python图表绘图</title>
    <link href="/ML03_matplotlib/"/>
    <url>/ML03_matplotlib/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：matplotlib绘图操作。</p><a id="more"></a><p>导包</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-comment">#jupyter中的一个魔法指令</span>%matplotlib inline</code></pre><h2 id="线性图-plot"><a href="#线性图-plot" class="headerlink" title="线性图 - plot()"></a>线性图 - plot()</h2><pre><code class="hljs python">x = np.linspace(-np.pi,np.pi,num=<span class="hljs-number">10</span>)y = <span class="hljs-number">2</span>*x + <span class="hljs-number">0.123</span>plt.plot(x,y)</code></pre><p><img src="/ML03_matplotlib/plt1.png"></p><h3 id="在一个坐标系中绘制多条曲线"><a href="#在一个坐标系中绘制多条曲线" class="headerlink" title="在一个坐标系中绘制多条曲线"></a>在一个坐标系中绘制多条曲线</h3><pre><code class="hljs python">plt.plot(x,y,x+<span class="hljs-number">1</span>,y-<span class="hljs-number">1</span>) <span class="hljs-comment"># 直接放多对曲线</span></code></pre><p>或者</p><pre><code class="hljs python">plt.plot(x,y)plt.plot(x**<span class="hljs-number">2</span>,y**<span class="hljs-number">0.5</span>)</code></pre><h3 id="设置图例"><a href="#设置图例" class="headerlink" title="设置图例"></a>设置图例</h3><pre><code class="hljs python">plt.plot(x,y,label=<span class="hljs-string">&#x27;temp&#x27;</span>)plt.plot(x+<span class="hljs-number">2</span>,y-<span class="hljs-number">1</span>,label=<span class="hljs-string">&#x27;dist&#x27;</span>)plt.legend(loc=<span class="hljs-number">9</span>,ncol=<span class="hljs-number">1</span>)</code></pre><p><img src="/ML03_matplotlib/pltlabel.png"></p><h3 id="图片保存"><a href="#图片保存" class="headerlink" title="图片保存"></a>图片保存</h3><pre><code class="hljs python"><span class="hljs-comment">#step1</span>fig = plt.figure() <span class="hljs-comment">#step2:绘图</span>plt.plot(x,y,label=<span class="hljs-string">&#x27;temp&#x27;</span>)plt.plot(x+<span class="hljs-number">2</span>,y-<span class="hljs-number">1</span>,label=<span class="hljs-string">&#x27;dist&#x27;</span>)plt.legend(loc=<span class="hljs-number">9</span>,ncol=<span class="hljs-number">1</span>)<span class="hljs-comment">#step3：保存</span>fig.savefig(<span class="hljs-string">&#x27;./123.png&#x27;</span>)</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><code>plt.figure(figsize=(5,5))</code> #设置坐标系的比例</li></ul><h2 id="柱状图-bar"><a href="#柱状图-bar" class="headerlink" title="柱状图 - bar()"></a>柱状图 - bar()</h2><p>参数：第一个参数是索引。第二个参数是数据值。第三个参数是条形的宽度</p><pre><code class="hljs python">x = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]height = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>]plt.bar(x,height)</code></pre><p><img src="/ML03_matplotlib/bar.png"></p><h2 id="直方图-hist"><a href="#直方图-hist" class="headerlink" title="直方图 - hist()"></a>直方图 - hist()</h2><ul><li><p>是一个特殊的柱状图，又叫做密度图</p></li><li><p>plt.hist()的参数</p><ul><li>bins<br>可以是一个bin数量的整数值，也可以是表示bin的一个序列。默认值为10。<strong>即每张图柱子的个数</strong>。</li><li>normed<br>如果值为True，直方图的值将进行归一化处理，形成概率密度，默认值为False</li><li>color<br>指定直方图的颜色。可以是单一颜色值或颜色的序列。如果指定了多个数据集合,例如DataFrame对象，颜色序列将会设置为相同的顺序。如果未指定，将会使用一个默认的线条颜色</li><li>orientation<br>通过设置orientation为horizontal创建水平直方图。默认值为vertical</li></ul></li></ul><pre><code class="hljs python">x = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>]plt.hist(x,bins=<span class="hljs-number">15</span>)</code></pre><p><img src="/ML03_matplotlib/hist.png"></p><h2 id="饼图-pie"><a href="#饼图-pie" class="headerlink" title="饼图 - pie()"></a>饼图 - pie()</h2><pre><code class="hljs python"><span class="hljs-comment"># 1</span>arr=[<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">31</span>,<span class="hljs-number">15</span>]plt.pie(arr)<span class="hljs-comment"># 2</span>arr=[<span class="hljs-number">0.2</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.1</span>]plt.pie(arr)<span class="hljs-comment"># 3</span>arr=[<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">31</span>,<span class="hljs-number">15</span>]plt.pie(arr,labels=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>])<span class="hljs-comment"># 4</span>arr=[<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">31</span>,<span class="hljs-number">15</span>]plt.pie(arr,labels=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>],labeldistance=<span class="hljs-number">0.3</span>)<span class="hljs-comment"># 5</span>arr=[<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">31</span>,<span class="hljs-number">15</span>]plt.pie(arr,labels=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>],labeldistance=<span class="hljs-number">0.3</span>,autopct=<span class="hljs-string">&#x27;%.6f%%&#x27;</span>)<span class="hljs-comment"># 6</span>arr=[<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">31</span>,<span class="hljs-number">15</span>]plt.pie(arr,labels=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>],labeldistance=<span class="hljs-number">0.3</span>,shadow=<span class="hljs-literal">True</span>,explode=[<span class="hljs-number">0.2</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.4</span>])</code></pre><p><img src="/ML03_matplotlib/pie.png"></p><h2 id="散点图-scatter"><a href="#散点图-scatter" class="headerlink" title="散点图 - scatter()"></a>散点图 - scatter()</h2><pre><code class="hljs python">xx = np.random.random(size=(<span class="hljs-number">30</span>,))yy = np.random.random(size=(<span class="hljs-number">30</span>,))plt.scatter(xx,yy)</code></pre><p><img src="/ML03_matplotlib/scatter.png"></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandas —— Python数据分析库</title>
    <link href="/ML02_pandas/"/>
    <url>/ML02_pandas/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：Pandas介绍，Series与DataFrame的使用。</p><a id="more"></a><h2 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h2><p>numpy能够帮助我们处理的是数值型的数据，当然在数据分析中除了数值型的数据还有好多其他类型的数据（字符串，时间序列），那么<strong>pandas就可以帮我们很好的处理除了数值型的其他数据</strong>！</p><p>pandas包含两个常用类：</p><ul><li>Series</li><li>DataFrame</li></ul><h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><p>类似于一位数组，由values以及index组成。</p><ul><li>index：相关的数据索引标签</li><li>values：一组数据，ndarray类型。</li></ul><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ol><li><p>列表创建</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> pandas <span class="hljs-keyword">import</span> DataFrame,Series<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npSeries(data=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<span class="hljs-comment">#</span><span class="hljs-comment">#结果：</span><span class="hljs-comment">#0    1</span><span class="hljs-comment">#1    2</span><span class="hljs-comment">#2    3</span><span class="hljs-comment">#dtype: int64</span><span class="hljs-comment"># 左边是index，右边是value</span></code></pre></li><li><p>用Numpy数组创建</p><pre><code class="hljs python">Series(data=np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]))</code></pre></li><li><p>用字典创建</p><pre><code class="hljs python">dic = &#123; <span class="hljs-comment">#字典中的key作为了Series的索引</span>    <span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;bobo&#x27;</span>,    <span class="hljs-string">&#x27;salary&#x27;</span>:<span class="hljs-number">10000</span>&#125;Series(data=dic)<span class="hljs-comment">#</span><span class="hljs-comment">#name       bobo</span><span class="hljs-comment">#salary    10000</span><span class="hljs-comment">#dtype: object</span></code></pre><h3 id="索引与切片"><a href="#索引与切片" class="headerlink" title="索引与切片"></a>索引与切片</h3></li></ol><ul><li>默认形式的索引是0,1,2,3……这是<strong>隐式索引</strong></li><li>显式索引:自定义索引。</li></ul><pre><code class="hljs python">Series(data=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],index=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>])</code></pre><pre><code class="hljs python">s[<span class="hljs-number">1</span>] <span class="hljs-comment">#隐式索引为1的数据</span>s[<span class="hljs-string">&#x27;a&#x27;</span>]<span class="hljs-comment">#显式索引取数据</span>s.a         <span class="hljs-comment">#显式索引取数据</span>s[[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]]  <span class="hljs-comment">#隐式索引为1，3，5的数据</span>s[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>] <span class="hljs-comment">#切片 范围[0,2]</span>s[<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-string">&#x27;c&#x27;</span>]  <span class="hljs-comment">#这样也可以,范围[a,c]</span></code></pre><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>head(n=5),tail()：查看前/后n个元素</li><li>unique()：去重</li><li>nunique()：统计去重后元素的个数</li><li>isnull() notnull() ：判定元素是否为空，如果有空则返回True\false，否则返回false</li><li>add() sub() mul() div()</li></ul><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><ul><li> 索引一致的元素进行算数运算否则补空。</li></ul><pre><code class="hljs python">s1 = Series(data=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],index=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>])s2 = Series(data=[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],index=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>])s = s1 + s2<span class="hljs-comment"># a    5.0</span><span class="hljs-comment"># b    NaN</span><span class="hljs-comment"># c    9.0</span><span class="hljs-comment"># d    NaN</span><span class="hljs-comment"># dtype: float64</span></code></pre><h3 id="使用bool索引来取值"><a href="#使用bool索引来取值" class="headerlink" title="使用bool索引来取值"></a>使用bool索引来取值</h3><p>应用：过滤空值</p><pre><code class="hljs python"><span class="hljs-comment">#特殊索引取值的形式(将布尔值作为了索引)(true对应的元素保留，否则删除)</span>s[[<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>,<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>]]<span class="hljs-comment">#过滤Series中的空值</span>s[s.notnull()]</code></pre><h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p>DataFrame是一个<strong>表格型</strong>的数据结构。DataFrame由按一定顺序排列的多列数据组成。设计初衷是将Series的使用场景从一维拓展到多维。DataFrame既有行索引，也有列索引。</p><ul><li><p>DataFrame取出的行或者列都是一个Series。</p></li><li><p>行索引：index</p></li><li><p>列索引：columns</p></li><li><p>值：values</p></li></ul><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><ol><li><p>ndarray创建</p><pre><code class="hljs python">DataFrame(data=np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>,size=(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)))</code></pre></li><li><p>字典创建</p><pre><code class="hljs python">dic = &#123;    <span class="hljs-string">&#x27;names&#x27;</span>:[<span class="hljs-string">&#x27;jay&#x27;</span>,<span class="hljs-string">&#x27;bobo&#x27;</span>,<span class="hljs-string">&#x27;tom&#x27;</span>],    <span class="hljs-string">&#x27;score&#x27;</span>:[<span class="hljs-number">100</span>,<span class="hljs-number">99</span>,<span class="hljs-number">80</span>]&#125;df = DataFrame(data=dic)df.index=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>] <span class="hljs-comment">#指定行索引</span></code></pre><p>字典创建数据源，字典的key作为列索引。</p></li></ol><h3 id="将某一列设置为行索引"><a href="#将某一列设置为行索引" class="headerlink" title="将某一列设置为行索引"></a>将某一列设置为行索引</h3><ul><li><code>df.set_index()</code></li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>values：df的元素值</li><li>index：行索引</li><li>columns：列索引</li><li>shape：形状。</li></ul><h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><p><code>df.info()</code>可以查看DF的具体信息。</p><p><code>df.describe()</code>返回每列的数量、均值、方差等信息。</p><h3 id="索引与切片-1"><a href="#索引与切片-1" class="headerlink" title="索引与切片"></a>索引与切片</h3><ul><li><p>取列</p><ul><li><code>df[&#39;names&#39;]</code></li></ul></li><li><p>取行</p><ul><li><code>df.loc[&#39;a&#39;]</code>通过显示索引取行</li><li><code>df.iloc[0]</code>通过隐式索引取行</li><li><code>df.loc[True,...,Flase]</code> #通过布尔取得为真的行</li></ul></li><li><p>取元素</p><ul><li><code>df.iloc[1,1]</code>通过隐式索引取元素，左行右列</li><li><code>df.loc[&#39;a&#39;,&#39;names&#39;]</code>通过显式索引取元素，左行右列</li></ul></li><li><p>切行</p><ul><li><code>df[0:2]</code>切出前两行df。</li></ul></li><li><p>切列</p><ul><li><code>df.iloc[:,0:1]</code>所有行，第0列。</li></ul></li></ul><h3 id="丢失数据与处理"><a href="#丢失数据与处理" class="headerlink" title="丢失数据与处理"></a>丢失数据与处理</h3><p>两种丢失数据：</p><ul><li><code>None</code>：对象类型</li><li><code>np.nan</code>即<code>NaN</code>：float类型</li></ul><p>对象类型的空值是不可以直接参与运算的，而nan是可以直接参与运算。会自动将None转为NaN.</p><pre><code class="hljs python">np.nan + <span class="hljs-number">1</span> <span class="hljs-comment">#可以运算</span></code></pre><ul><li><code>np.isnull().any(axis=)</code>：可以查看每列是否为空等信息。<code>any()</code>常<code>isnull()</code>等搭配。</li></ul><ol><li>dropna(axis=)`：可以直接将缺失的行或者列进行删除，0为行</li><li><code>fillna(value=)</code> ：使用指定值做填充<ul><li><code>df.fillna(method=&#39;bfill&#39;,axis=0)</code>使用临近值做填充。</li></ul></li></ol><h3 id="使用均值填充数据"><a href="#使用均值填充数据" class="headerlink" title="使用均值填充数据"></a>使用均值填充数据</h3><pre><code class="hljs python"><span class="hljs-comment">#使用均值填充</span><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> df.columns:    <span class="hljs-comment">#每一次循环col表示某一列的列索引</span>    <span class="hljs-keyword">if</span> df[col].isnull().<span class="hljs-built_in">sum</span>() &gt; <span class="hljs-number">0</span>:<span class="hljs-comment">#df[col]列中存有空值</span>        df[col].fillna(value=df[col].mean(),inplace=<span class="hljs-literal">True</span>)</code></pre><h3 id="使用中位数填充数据"><a href="#使用中位数填充数据" class="headerlink" title="使用中位数填充数据"></a>使用中位数填充数据</h3><ul><li>如果序列中存在空值，则返回的中位数为空.故要去掉中位数。</li></ul><pre><code class="hljs python"><span class="hljs-comment">#使用中位数填充空值</span><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> df.columns:    <span class="hljs-keyword">if</span> df[col].isnull().<span class="hljs-built_in">sum</span>() &gt; <span class="hljs-number">0</span>:        df[col].fillna(value=np.median(df[col][df[col].notnull()]),inplace=<span class="hljs-literal">True</span>)</code></pre><h3 id="处理重复行"><a href="#处理重复行" class="headerlink" title="处理重复行"></a>处理重复行</h3><ul><li><p><code>df.duplicated()</code>查看是否有重复的数据。</p></li><li><p><code>df.drop_duplicates(keep=&#39;last&#39;)</code>：删除重复的行，keep表示保留最后一个重复的行。</p></li></ul><h3 id="删除行"><a href="#删除行" class="headerlink" title="删除行"></a>删除行</h3><ul><li><code>df.drop(labels=&#39;&#39;,axis=0,inplace=True)</code>：指定行的标签。</li></ul><h3 id="日期转换与resample"><a href="#日期转换与resample" class="headerlink" title="日期转换与resample"></a>日期转换与resample</h3><ul><li><code>pd.to_datetime(col)</code>时间数据类型转换。</li></ul><p>列的数据为str，形如<code>2020-.1-12</code>.</p><ul><li><p>提取年：<code>pd.to_datetime(df[&#39;date&#39;])dt.year</code></p></li><li><p><code>data[&#39;2010-1&#39;:&#39;2020-9&#39;]</code> #对日期索引的切片，只有对日期可以这样</p></li></ul><p>Pandas中的resample，重新采样，是对原样本重新处理的一个方法，是一个对常规时间序列数据重新采样和频率转换的便捷的方法。</p><blockquote><p><a href="https://www.cnblogs.com/jingsupo/p/pandas-resample.html">https://www.cnblogs.com/jingsupo/p/pandas-resample.html</a></p></blockquote><ul><li><code>resample(&#39;M&#39;)</code>：获取了每一年每一个月</li><li><code>df.resample(&#39;A&#39;)</code>：获取每个年</li></ul><h3 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h3><p><code>pd.concat((df1,df2),axis=0,join=&#39;outer&#39;)</code></p><ul><li>axis0表示按列，纵向级联。1表示按行横向级联。</li><li><code>join=&#39;outer&#39;</code>表示将所有的项进行级联（忽略匹配和不匹配），而<code>inner</code>表示只会将匹配的项级联到一起，不匹配的不级联。</li><li>不匹配级联<ul><li>不匹配指的是级联的维度的索引不一致。例如纵向级联时列索引不一致，横向级联时行索引不一致</li><li>有2种连接方式：<ul><li>外连接：补NaN（默认模式）</li><li>内连接：只连接匹配的项</li></ul></li></ul></li></ul><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p><strong>级联是对表格做拼接，合并是对数据做合并</strong></p><ul><li>merge与concat的区别在于，<strong>merge需要依据某一共同列来进行合并</strong></li><li>使用pd.merge()合并时，会自动根据两者相同column名称的那一列，作为key来进行合并。</li><li>注意每一列元素的顺序不要求一致</li></ul><pre><code class="hljs python">pd.merge(left=df3,right=df4,how=<span class="hljs-string">&#x27;inner&#x27;</span>,on=<span class="hljs-string">&#x27;group&#x27;</span>)</code></pre><ul><li>left左表，right右表，on表示按照哪一列进行合并。</li><li>how可取<code>left</code>、<code>right</code>、<code>outer</code>、<code>inner</code>。<ul><li>left：按照左边的列值来进行合并，类似于左连接</li><li>outer使用并集的方式，inner使用交集的方式。</li></ul></li></ul><p>而当两表没有可以进行连接的列时，可使用<code>left_on</code>和<code>right_on</code>手动指定<code>merge</code>中左右两边的哪一列列作为连接的列。</p><pre><code class="hljs python">pd.merge(left=df1,right=df5,how=<span class="hljs-string">&#x27;outer&#x27;</span>,left_on=<span class="hljs-string">&#x27;employee&#x27;</span>,right_on=<span class="hljs-string">&#x27;name&#x27;</span>)</code></pre><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><ol><li><p>单值替换</p><pre><code class="hljs python">df.replace(to_replace=<span class="hljs-number">10</span>,value=<span class="hljs-string">&#x27;ten&#x27;</span>) <span class="hljs-comment">#替换所有值为10的值</span>df.replace(to_replace=&#123;<span class="hljs-number">3</span>:<span class="hljs-number">10</span>&#125;,value=<span class="hljs-string">&#x27;ten&#x27;</span>) <span class="hljs-comment">#将指定列中的相关数据进行替换，第3列的全部10进行替换。</span></code></pre></li><li><p>多值替换</p><ul><li>列表替换: <code>to_replace=[] value=[]</code></li><li>字典替换：<code>to_replace=&#123;to_replace:value,to_replace:value&#125;</code></li></ul></li></ol><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>创建一个映射关系列表，把values元素和一个特定的标签或者字符串绑定（给一个元素值提供不同的表现形式）。</p><p>实例：创建一个df，两列分别是姓名和薪资，然后给其名字起对应的英文名</p><pre><code class="hljs python">dic = &#123;    <span class="hljs-string">&#x27;name&#x27;</span>:[<span class="hljs-string">&#x27;jay&#x27;</span>,<span class="hljs-string">&#x27;bobo&#x27;</span>,<span class="hljs-string">&#x27;jay&#x27;</span>,<span class="hljs-string">&#x27;tom&#x27;</span>],    <span class="hljs-string">&#x27;salary&#x27;</span>:[<span class="hljs-number">10000</span>,<span class="hljs-number">20000</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">30000</span>]&#125;df = DataFrame(data=dic)<span class="hljs-comment">#给英文名起一个中文名</span>dic = &#123;    <span class="hljs-string">&#x27;jay&#x27;</span>:<span class="hljs-string">&#x27;周杰伦&#x27;</span>,    <span class="hljs-string">&#x27;bobo&#x27;</span>:<span class="hljs-string">&#x27;波波&#x27;</span>,    <span class="hljs-string">&#x27;tom&#x27;</span>:<span class="hljs-string">&#x27;张三&#x27;</span>&#125;<span class="hljs-comment">#字典充当映射关系表</span>df[<span class="hljs-string">&#x27;c_name&#x27;</span>] = df[<span class="hljs-string">&#x27;name&#x27;</span>].<span class="hljs-built_in">map</span>(dic)</code></pre><p><img src="/ML02_pandas/map.png"></p><ul><li><strong>map是Series的方法，只能被Series调用</strong>。</li></ul><h3 id="map充当运算工具"><a href="#map充当运算工具" class="headerlink" title="map充当运算工具"></a>map充当运算工具</h3><p>针对上述案例，超过3000部分的钱缴纳50%的税，计算每个人的税后薪资。</p><p>map()中传入一个接收一个参数的函数，来对每一个元素执行函数的操作。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">after_sal</span>(<span class="hljs-params">s</span>):</span>    <span class="hljs-keyword">return</span> s - (s-<span class="hljs-number">3000</span>)*<span class="hljs-number">0.5</span>df[<span class="hljs-string">&#x27;after_sal&#x27;</span>] = df[<span class="hljs-string">&#x27;salary&#x27;</span>].<span class="hljs-built_in">map</span>(after_sal)</code></pre><p><img src="/ML02_pandas/map1.png"></p><h3 id="随机抽样"><a href="#随机抽样" class="headerlink" title="随机抽样"></a>随机抽样</h3><ul><li><p><code>numpy.random.permutation(x)</code>： 随机排列一个序列，或者数组。 </p><ul><li>x是整数则随机排列<code>np.arange(x)</code>。</li><li>如果x是多维数组，则沿其第一个坐标轴的索引随机排列数组。</li></ul><pre><code class="hljs python">np.random.permutation(<span class="hljs-number">3</span>)<span class="hljs-comment"># array([1, 0, 2])</span></code></pre></li><li><p><code>take(indices, axis=0)</code>：沿着指定轴的给定索引返回按索引排序后的DataFrame。</p><pre><code class="hljs python"><span class="hljs-comment">#注意：indices只能跟隐式索引</span>df.take(indices=np.random.permutation(<span class="hljs-number">3</span>),axis=<span class="hljs-number">1</span>)</code></pre><h3 id="分类处理"><a href="#分类处理" class="headerlink" title="分类处理"></a>分类处理</h3></li><li><p><code>groupby(by=&#39;&#39;)</code>来对指定的列进行分组。</p></li><li><p><code>groupby(by=&#39;&#39;).groups</code>来查看分组的情况。</p></li></ul><h3 id="高级数据聚合"><a href="#高级数据聚合" class="headerlink" title="高级数据聚合"></a>高级数据聚合</h3><p>使用groupby分组后，也可以使用transform和apply提供自定义函数实现更多的运算。</p><ul><li>df.groupby(‘item’)[‘price’].sum() &lt;==&gt; df.groupby(‘item’)[‘price’].apply(sum)</li><li>transform和apply都会进行运算，在transform或者apply中传入函数即可</li><li>transform和apply也可以传入一个lambda表达式</li><li>apply和transform的区别：transform返回的是经过映射的结果，而apply返回的是没有经过映射的结果。</li></ul><h2 id="存取文件"><a href="#存取文件" class="headerlink" title="存取文件"></a>存取文件</h2><pre><code class="hljs python"><span class="hljs-comment">#存储数据</span>df.to_csv(<span class="hljs-string">&#x27;./maotai.csv&#x27;</span>)<span class="hljs-comment">#读取数据</span>data = pd.read_csv(<span class="hljs-string">&#x27;./maotai.csv&#x27;</span>)<span class="hljs-comment">#高级数据读取</span>pd.read_csv(<span class="hljs-string">&#x27;./type-.txt&#x27;</span>,sep=<span class="hljs-string">&#x27;-&#x27;</span>,header=<span class="hljs-literal">None</span>) <span class="hljs-comment">#sep为字符之间的分隔符，header为None则不会降第一行数据作为列索引。</span></code></pre><h3 id="透视表-7"><a href="#透视表-7" class="headerlink" title="透视表-7"></a>透视表-7</h3><h3 id="交叉表-7"><a href="#交叉表-7" class="headerlink" title="交叉表-7"></a>交叉表-7</h3>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Numpy —— 科学计算基础库</title>
    <link href="/ML01_numpy/"/>
    <url>/ML01_numpy/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：Numpy的使用。</p><a id="more"></a><h2 id="Numpy与ndarray"><a href="#Numpy与ndarray" class="headerlink" title="Numpy与ndarray"></a>Numpy与ndarray</h2><p>NumPy(Numerical Python) 是 Python 语言中做科学计算的基础库。重在于数值计算，也是大部分Python科学计算库的基础，多用于在大型、多维数组上执行的数值运算。</p><p>NumPy 是 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。</p><ul><li> ndarray 对象是用于存放同类型元素的多维数组。 </li><li>ndarray 中的每个元素在内存中都有相同存储大小的区域。</li><li>ndarray 内部由以下内容组成：<ul><li>一个指向数据（内存或内存映射文件中的一块数据）的指针</li><li>数据类型或 dtype，描述在数组中的固定大小值的格子。</li><li>一个表示数组形状（shape）的元组，表示各维度大小的元组。</li><li>一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要”跨过”的字节数。</li></ul></li></ul><h2 id="numpy与python列表的区别"><a href="#numpy与python列表的区别" class="headerlink" title="numpy与python列表的区别"></a>numpy与python列表的区别</h2><ul><li>numpy数组中只能存放相同类型的数组元素。</li><li>并且数据类型优先级：<code>str&gt;float&gt;int</code><ul><li>eg:一维数组中只要有一个浮点数，所有的数都将是浮点数。</li></ul></li></ul><h2 id="numpy创建"><a href="#numpy创建" class="headerlink" title="numpy创建"></a>numpy创建</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</code></pre><ol><li><p>使用np.array()创建</p><pre><code class="hljs python">arr = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]) <span class="hljs-comment"># 一维数组</span>arr2 = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]) <span class="hljs-comment"># 二维数组</span></code></pre></li><li><p>使用matplotlib将外部图片的数据加载入np数组</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> pltimg_arr = plt.imread(<span class="hljs-string">&#x27;./bobo.jpg&#x27;</span>)</code></pre></li><li><p>使用linespace、random等随机生成</p><pre><code class="hljs python">np.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">20</span>,num=<span class="hljs-number">10</span>) <span class="hljs-comment">#返回一个一维形式的等差数列,10个数字</span>np.arange(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,step=<span class="hljs-number">2</span>) <span class="hljs-comment">#返回也是一个等差数列 array([0, 2, 4, 6, 8])</span>np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>,size=(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)) <span class="hljs-comment">#返回一个三行四列二维数组，数组元素是从0-100随机选取</span></code></pre><h2 id="numpy常用属性"><a href="#numpy常用属性" class="headerlink" title="numpy常用属性"></a>numpy常用属性</h2></li></ol><ul><li>shape：数组的形状，二维就是(m,n)</li><li>ndim：数组维度</li><li>size：数组元素个数</li><li>dtype：数组元素的数据类型，上面提到numpy数组只能存放同一类型的数据。</li></ul><h3 id="numpy数据类型"><a href="#numpy数据类型" class="headerlink" title="numpy数据类型"></a>numpy数据类型</h3><ul><li><p>array(dtype=?)：创建时可以设定数据类型</p></li><li><p>arr.dtype = ‘?’：之后可以修改数据类型</p></li></ul><p><img src="/ML01_numpy/dtype.png"></p><h3 id="reshape变形"><a href="#reshape变形" class="headerlink" title="reshape变形"></a>reshape变形</h3><p>可以将x维度的数组变换成y维度的数组，但是<strong>变形前和变形后数组的容量不可以发生变化</strong>。</p><ul><li><code>arr.reshape((2,15)) </code>#两行15列的二维数组</li><li><code>arr.reshape((3,-1)) </code>#-1表示自行计算，保证3行n列的数组</li><li><code>arr.reshape((30,))</code>注意逗号后面没有数字，会变形成为一个一维数组。</li></ul><h3 id="concatenate级联"><a href="#concatenate级联" class="headerlink" title="concatenate级联"></a>concatenate级联</h3><p>将多个numpy数组进行横向或者纵向的拼接。</p><pre><code class="hljs python">np.concatenate((arr,arr,arr),axis=<span class="hljs-number">1</span>)</code></pre><ul><li>axis表示轴向，0为列，1为行。</li><li>维度不一致，一定不可以级联，但是维度一致，行列不一致也可以适当级联。</li></ul><h2 id="索引与切片"><a href="#索引与切片" class="headerlink" title="索引与切片"></a>索引与切片</h2><pre><code class="hljs python">arr = np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>,size=(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>))arr[<span class="hljs-number">2</span>] <span class="hljs-comment">#单行</span>arr[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]] <span class="hljs-comment"># 多行</span>arr[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <span class="hljs-comment"># 单值</span>arr[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],<span class="hljs-number">3</span>] <span class="hljs-comment">#索引取多值,(1,3)与(2，3)</span><span class="hljs-comment"># ---</span>arr[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>] <span class="hljs-comment">#切出前两行</span>arr[:,<span class="hljs-number">0</span>:<span class="hljs-number">2</span>] <span class="hljs-comment">#切出前两列，逗号左边表示行，右边表示列</span>arr[::-<span class="hljs-number">1</span>] <span class="hljs-comment">#将行倒置</span>arr[:,::-<span class="hljs-number">1</span>] <span class="hljs-comment">#列倒置</span>arr[::-<span class="hljs-number">1</span>,::-<span class="hljs-number">1</span>] <span class="hljs-comment">#元素倒置</span></code></pre><h2 id="聚合操作、数学函数、统计函数"><a href="#聚合操作、数学函数、统计函数" class="headerlink" title="聚合操作、数学函数、统计函数"></a>聚合操作、数学函数、统计函数</h2><ul><li>sum(axis=0)：按列求和</li><li>max(axis=0)</li><li>min(axis=0)</li><li>mean(axis=0)：均值</li></ul><pre><code class="hljs python">arr.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>)</code></pre><ul><li>sin()、cos()、tan()</li><li><code>numpy.around(a,decimals)</code> 函数返回指定数字的四舍五入值。<ul><li>a：np数组</li><li>decimals: 舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置。</li></ul></li></ul><pre><code class="hljs python">np.sin(<span class="hljs-number">3.123</span>)</code></pre><ul><li>numpy.amin() 和 numpy.amax()，用于计算数组中的元素沿<strong>指定轴的最小、最大值</strong>。</li><li>numpy.ptp():计算数组中元素最大值与最小值的差（最大值 - 最小值）。</li><li>numpy.median() 函数用于计算数组 a 中元素的<strong>中位数</strong>（中值），计算不能有空值。</li><li>标准差std()：标准差是一组数据平均值分散程度的一种度量。<br>公式：std = sqrt(mean((x - x.mean())**2))<br>如果数组是 [1，2，3，4]，则其平均值为 2.5。 因此，差的平方是 [2.25,0.25,0.25,2.25]，并且其平均值的平方根除以 4，即 sqrt(5/4) ，结果为 1.1180339887498949。</li><li>方差var()：统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，即 mean((x - x.mean())** 2)。换句话说，标准差是方差的平方根。</li></ul><pre><code class="hljs python">np.median(arr[<span class="hljs-number">0</span>]) <span class="hljs-comment">#返回一组数据的中位数</span>np.std(arr[<span class="hljs-number">0</span>])</code></pre><h2 id="矩阵相关"><a href="#矩阵相关" class="headerlink" title="矩阵相关"></a>矩阵相关</h2><p>NumPy 中包含了一个矩阵库 numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象。一个 的矩阵是一个由行（row）列（column）元素排列成的矩形阵列。</p><p><code>numpy.matlib.identity() </code>函数返回给定大小的单位矩阵。单位矩阵是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为 1，除此以外全都为 0。</p><ul><li>矩阵转置：<code>arr.T</code></li><li>矩阵相乘：<code>numpy.dot(a, b, out=None)</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++文件读写与操作</title>
    <link href="/cpp-file/"/>
    <url>/cpp-file/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：C语言与C++读写文件，简单操作事例。</p><a id="more"></a><hr><blockquote><p>代码全部运行于VS2019</p></blockquote><h2 id="C语言读写文件"><a href="#C语言读写文件" class="headerlink" title="C语言读写文件"></a>C语言读写文件</h2><h3 id="打开文件-fopen"><a href="#打开文件-fopen" class="headerlink" title="打开文件 - fopen"></a>打开文件 - fopen</h3><p>C语言使用fopen函数打开文件</p><p>fopen位于<code>stdio.h</code>中，</p><pre><code class="hljs c"><span class="hljs-function">FILE *<span class="hljs-title">fopen</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *mode )</span></span>;</code></pre><ul><li>filename是文件名</li><li>mode指文件访问模式</li></ul><p><img src="/cpp-file/filemode.png"></p><h3 id="写文件-fwrite"><a href="#写文件-fwrite" class="headerlink" title="写文件 - fwrite"></a>写文件 - fwrite</h3><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">fwrite</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buffer, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">size_t</span> count, FILE *stream )</span></span>;</code></pre><p>写入文件使用fwrite</p><ul><li><p>buffer是指向写入对象的指针</p></li><li><p>size是要写入对象的大小</p></li><li><p>count 是要写入对象的数量</p></li><li><p>stream是文件流。</p></li><li><p>返回值是成功写入的对象数</p></li></ul><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> &#123;</span><span class="hljs-keyword">int</span> id;<span class="hljs-keyword">int</span> age;<span class="hljs-keyword">char</span> name[<span class="hljs-number">32</span>];<span class="hljs-keyword">bool</span> gender;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> height;&#125;;Student stu[] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">17</span>,<span class="hljs-string">&quot;lisa&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">179</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&quot;kaly&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">159</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;luccy&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">109</span>&#125;,&#125;;FILE* fp = fopen(<span class="hljs-string">&quot;test.bin&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>);<span class="hljs-comment">//以二进制文件写</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;fwrite(stu + i, <span class="hljs-keyword">sizeof</span>(Student), <span class="hljs-number">1</span>, fp);&#125;fclose(fp);<span class="hljs-comment">//关闭流</span></code></pre><h3 id="读文件-fread"><a href="#读文件-fread" class="headerlink" title="读文件 - fread"></a>读文件 - fread</h3><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">fread</span><span class="hljs-params">( <span class="hljs-keyword">void</span> *buffer, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">size_t</span> count, FILE *stream )</span></span>;</code></pre><ul><li>buffer指存储对象的缓冲区。</li><li>返回数据是成功读取的对象的数目。</li></ul><pre><code class="hljs c">FILE* fp = fopen(<span class="hljs-string">&quot;test.bin&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);Student stus;<span class="hljs-keyword">while</span> (!feof(fp))&#123;<span class="hljs-comment">//fread 返回值是读到的对象数目，而不是字节</span><span class="hljs-keyword">int</span> bytes = fread(&amp;stus, <span class="hljs-keyword">sizeof</span>(stus), <span class="hljs-number">1</span>, fp);<span class="hljs-keyword">if</span> (bytes &lt;= <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;id=%d,age=%d,name=%s,sex=%s,height=%d\n&quot;</span>, stus.id, stus.age, stus.name,(stus.gender ? <span class="hljs-string">&quot;male&quot;</span> : <span class="hljs-string">&quot;famale&quot;</span>), stus.height);&#125;fclose(fp);</code></pre><h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><ul><li><code>int feof(FILE *stream);</code>：检查文件流是否达到末尾，到末尾为非零值，未到末尾为0.</li><li><code>int ferror(FILE *stream);</code>：检查文件流是否发生错误。非零值表示发生错误，0表示未发生错误。</li></ul><h2 id="C-文件输入输出"><a href="#C-文件输入输出" class="headerlink" title="C++ 文件输入输出"></a>C++ 文件输入输出</h2><p><code>fstream</code>头文件中定义了三个类型来支持文件IO：</p><ul><li><p><code>ifstream</code>：从一个给定文件读取数据。</p></li><li><p><code>ofstream</code>：向一个给定文件写入数据</p></li><li><p><code>fstream</code>：可读写给定文件。</p><p>这些类型提供的操作与<code>cin</code>以及<code>cout</code>操作一样，可以使用IO运算符（&lt;&lt;以及&gt;&gt;）来读写文件，使用<code>getline</code>来从一个<code>ifstream</code>中读取数据。</p></li></ul><h3 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h3><p>读写文件时，定义一个文件流对象，然后将对象与文件关联起来。</p><p>同时，每个文件流类都定义类一个名为open的成员函数，它会完成一些系统相关操作。</p><p>创建文件流对象时，文件名是可选的，如果提供文件名，那么open就会被自动调用。</p><pre><code class="hljs c++"><span class="hljs-function">ifstream <span class="hljs-title">in</span><span class="hljs-params">(ifile)</span></span>;<span class="hljs-comment">//构建一个ifstream并且打开给定文件</span>ofstream out;<span class="hljs-comment">//输出文件流并未写入任何数据</span></code></pre><h3 id="文件流对象关联文件"><a href="#文件流对象关联文件" class="headerlink" title="文件流对象关联文件"></a>文件流对象关联文件</h3><p>对于定义的空文件流对象，可以使用open来将其与文件关联起来。</p><p>但是使用open有可能失败，所以加上检测是一个良好的习惯。</p><pre><code class="hljs c++">ofstream out;<span class="hljs-comment">//输出文件流并未写入任何数据</span>out.open(ifile + <span class="hljs-string">&quot;.copy&quot;</span>);<span class="hljs-keyword">if</span>(out)<span class="hljs-comment">//检测是否open成功</span>&#123; <span class="hljs-comment">//成功执行代码   </span>    如果open成功，open会设置流的状态，使good()为<span class="hljs-literal">true</span>&#125;</code></pre><p>一旦一个文件流与一个文件关联，就会持续保持与对应文件的关联。</p><blockquote><p>对一个已经打开的文件流调用open会失败，随后使用文件流操作都会失败。</p><p>要让文件流关联其他文件就要先close()。</p></blockquote><p>当一个fstream对象离开其作用域的时候，与之关联的文件会自动关闭。当fstream对象被销毁时，close会自动被调用。</p><h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><ul><li>in：读</li><li>out：写</li><li>app：每次写操作前定位到文件末尾</li><li>ate：打开文件后立即定位到文件末尾</li><li>trunc：截断文件</li><li>binary：以二进制方式进行IO</li></ul><p>打开文件时，可以指定文件模式</p><ul><li>只有ofstream以及fstream可以设定out</li><li>只有ifstream以及fstream可以设定in</li><li>只有当out被设定时才能设定trunc</li><li>只要trunc没被设定，就可以设定app</li><li>app模式下，即使没有显式指定out，文件也是用<strong>输出</strong>方式打开的</li><li>默认情况下，以out模式打开，文件也会被截断。而为<strong>了保留out模式打开文件下的内容，必须同时指定app模式，这样会将数据追加写入道文件末尾，或者同时指定In，打开文件同时进行读写操作</strong>。</li><li>ate与binary可用于任何类型的文件流对象下，且可以与其他任何文件模式组合使用。</li></ul><p>以out模式打开文件，文件的内容会被丢弃。（截断指丢弃文件内容）</p><p>而<code>ofstream out(&quot;file&quot;)</code>就是默认以out模式打开，直接会截断文件。</p><p> <a href="https://www.cnblogs.com/jianyungsun/archive/2011/02/19/1958587.html">https://www.cnblogs.com/jianyungsun/archive/2011/02/19/1958587.html</a></p><h2 id="Demo-基本操作"><a href="#Demo-基本操作" class="headerlink" title="Demo-基本操作"></a>Demo-基本操作</h2><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;ifstream in;in.open(<span class="hljs-string">&quot;a.txt&quot;</span>);<span class="hljs-built_in">string</span> line;<span class="hljs-keyword">if</span> (in)&#123;<span class="hljs-keyword">while</span> (getline(in, line))&#123;<span class="hljs-built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;in.close();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;ofstream out;out.open(<span class="hljs-string">&quot;a.txt&quot;</span>, ios::out | ios::app);<span class="hljs-keyword">if</span> (out)&#123;out &lt;&lt; <span class="hljs-string">&quot;aac&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;out.close();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bwrite</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;ofstream out;out.open(<span class="hljs-string">&quot;cc&quot;</span>, ios::out | ios::app | ios::binary);<span class="hljs-comment">//没有文件就自动建立文件</span><span class="hljs-keyword">if</span> (out)&#123;out &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-number">10</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;2020.0507&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;out &lt;&lt; <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-number">20</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;2020.0607&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;out &lt;&lt; <span class="hljs-number">3</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-number">30</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;2020.0707&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;out &lt;&lt; <span class="hljs-number">4</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-number">40</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-number">4</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;2020.0907&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;    <span class="hljs-comment">//如果是纯数字的话，二进制文件打开也全是数字，而如果有中文的话就会有乱码。</span>out.close();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bread</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;ifstream in;in.open(<span class="hljs-string">&quot;20200412141332.rp&quot;</span>, ios::in | ios::binary);<span class="hljs-comment">//没有文件就打开失败</span><span class="hljs-keyword">if</span> (in)&#123;<span class="hljs-built_in">string</span> line;<span class="hljs-keyword">while</span> (getline(in, line))&#123;<span class="hljs-built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;打开失败&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;in.close();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AutoHotkey应用</title>
    <link href="/autohotkey-apl/"/>
    <url>/autohotkey-apl/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：自用脚本分享以及明日方舟简单脚本。</p><a id="more"></a><p>语法参考这篇文章 <a href="www.colourso.top/autohotkey/">AutoHotkey入门 ~ Windows下自动化脚本</a></p><hr><h2 id="我的常用脚本（慢慢更新）"><a href="#我的常用脚本（慢慢更新）" class="headerlink" title="我的常用脚本（慢慢更新）"></a>我的常用脚本（慢慢更新）</h2><blockquote><p>说明：部分脚本源自<a href="https://zhuanlan.zhihu.com/p/103357456">https://zhuanlan.zhihu.com/p/103357456</a></p></blockquote><h3 id="1-脚本暂停-继续"><a href="#1-脚本暂停-继续" class="headerlink" title="1.脚本暂停/继续"></a>1.脚本暂停/继续</h3><p>暂停脚本，ctrl+esc，再按一次可继续脚本。</p><pre><code class="hljs autohotkey"><span class="hljs-title">^Esc::</span><span class="hljs-keyword">Pause</span><span class="hljs-keyword">return</span></code></pre><h3 id="2-获取选中文件的路径"><a href="#2-获取选中文件的路径" class="headerlink" title="2.获取选中文件的路径"></a>2.获取选中文件的路径</h3><p>用win+alt+c得到当前选中文件的路径</p><pre><code class="hljs autohotkey"><span class="hljs-title">#!c::</span> send ^c<span class="hljs-built_in">sleep,</span><span class="hljs-number">200</span><span class="hljs-built_in">clipboard</span>=<span class="hljs-variable">%clipboard%</span> <span class="hljs-comment">;windows 复制的时候，剪贴板保存的是“路径”。只是路径不是字符串，只要转换成字符串就可以粘贴出来了</span><span class="hljs-built_in">tooltip,</span><span class="hljs-variable">%clipboard%</span> <span class="hljs-comment">;提示文本</span><span class="hljs-built_in">sleep,</span><span class="hljs-number">500</span><span class="hljs-built_in">tooltip,</span><span class="hljs-keyword">return</span></code></pre><h3 id="3-窗口置顶（愿称之为最强）"><a href="#3-窗口置顶（愿称之为最强）" class="headerlink" title="3.窗口置顶（愿称之为最强）"></a>3.窗口置顶（愿称之为最强）</h3><blockquote><p>脚本源自上面的那个知乎链接</p></blockquote><p>在当前窗口下，win+alt+enter，来置顶窗口，即保持窗口永远在最上方。</p><pre><code class="hljs autohotkey"><span class="hljs-title">#!enter::</span> <span class="hljs-comment">;窗口置顶</span>    WinGet ow, id, A    WinTopToggle(ow)    <span class="hljs-keyword">return</span>WinTopToggle(w) &#123; <span class="hljs-built_in">    WinGetTitle,</span> oTitle, <span class="hljs-keyword">ahk_id</span> <span class="hljs-variable">%w%</span><span class="hljs-built_in">    Winset,</span> AlwaysOnTop, Toggle, <span class="hljs-keyword">ahk_id</span> <span class="hljs-variable">%w%</span><span class="hljs-built_in">    WinGet,</span> ExStyle, ExStyle, <span class="hljs-keyword">ahk_id</span> <span class="hljs-variable">%w%</span>    if (ExStyle &amp; <span class="hljs-number">0</span>x8)  <span class="hljs-comment">; 0x8 为 WS_EX_TOPMOST.在WinGet的帮助中</span>        oTop = 置顶    else        oTop = 取消置顶<span class="hljs-built_in">    tooltip %</span>oTitle% <span class="hljs-variable">%oTop%</span><span class="hljs-built_in">    SetTimer,</span> RemoveToolTip, <span class="hljs-number">5000</span>    <span class="hljs-keyword">return</span> <span class="hljs-title">    RemoveToolTip:</span><span class="hljs-built_in">    SetTimer,</span> RemoveToolTip, Off    ToolTip    <span class="hljs-keyword">return</span>&#125;</code></pre><h3 id="4-重大考试倒计时"><a href="#4-重大考试倒计时" class="headerlink" title="4.重大考试倒计时"></a>4.重大考试倒计时</h3><p>用来显示距离一个重大考试还剩多长时间。win+alt+space</p><pre><code class="hljs llvm">#<span class="hljs-title">!space</span>:: <span class="hljs-comment">;倒计时</span>var<span class="hljs-number">1</span> <span class="hljs-operator">=</span> <span class="hljs-number">20210120080000</span><span class="hljs-comment">;考试的时间，年月日时分秒</span>var<span class="hljs-number">2</span> :<span class="hljs-operator">=</span> <span class="hljs-variable">%A_Now</span>%<span class="hljs-comment">;获取系统的规格时间</span>Envsub<span class="hljs-punctuation">,</span> var<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-variable">%var2</span>%<span class="hljs-punctuation">,</span>days<span class="hljs-comment">;按照day的形式相减，时间存储到var1</span>MsgBox<span class="hljs-punctuation">,</span><span class="hljs-number">4</span><span class="hljs-punctuation">,</span>倒计时<span class="hljs-punctuation">,</span>距离考试还有<span class="hljs-variable">%var1</span>%天，加油ᕦ(ò_ó)ᕤreturn</code></pre><h3 id="5-秒表倒计时"><a href="#5-秒表倒计时" class="headerlink" title="5.秒表倒计时"></a>5.秒表倒计时</h3><blockquote><p>也源自知乎链接</p></blockquote><p>win+shift+t，输入多少秒，倒计时后弹窗。</p><pre><code class="hljs gauss"><span class="hljs-meta">#+t:: ;计时器</span>InputBox, <span class="hljs-built_in">time</span>, 计时器, 请输入一个时间（单位是秒）<span class="hljs-built_in">time</span> := <span class="hljs-built_in">time</span>*<span class="hljs-number">1000</span><span class="hljs-built_in">Sleep</span>,%<span class="hljs-built_in">time</span>%msgbox 时间到，ᕦ(ò_ó)ᕤ<span class="hljs-keyword">return</span></code></pre><hr><h2 id="明日方舟极简脚本"><a href="#明日方舟极简脚本" class="headerlink" title="明日方舟极简脚本"></a>明日方舟极简脚本</h2><p>脚本作用于：<strong>Win10下的MuMu模拟器</strong>。</p><p>脚本功能：对于指定的关卡刷指定数量的次数。不过刷关卡期间，<strong>不能使用电脑做其他事情</strong>……。</p><h3 id="脚本分析"><a href="#脚本分析" class="headerlink" title="脚本分析"></a>脚本分析</h3><p>等待用户的唤起。唤起之后接收用户的输入数据，对用户选定的关卡进行点击操作，通过预先的坐标，隔一定的时长进行点击即可。当刷完之后，弹出弹框告诉用户结束。</p><p>主要问题在于获取固定的坐标方标软件点击。</p><h3 id="使用Window-Spy来获取软件内部坐标"><a href="#使用Window-Spy来获取软件内部坐标" class="headerlink" title="使用Window Spy来获取软件内部坐标"></a>使用Window Spy来获取软件内部坐标</h3><p><strong>Window Spy</strong>： 一个软件，用于查看有关鼠标悬停在其上的窗口的信息。</p><p>找到<code>Window Spy</code>的两种方式：</p><p>第一种，点击开始按钮，找到AutoHotkey的位置，点击spy即可。</p><p><img src="/autohotkey-apl/spy1.png"></p><p>第二种，运行一个脚本，脚本里最好有能运行的语句。运行之后，右键点击状态栏的图标也能找到<code>Window Spy</code>。</p><p>当运行这个软件之后，他就会默认在窗口的最前方，当你的鼠标点击其他软件时，Spy会自动检测识别出，并显示鼠标当前位置、该点的颜色等各种信息。</p><p><img src="/autohotkey-apl/getpos.png"></p><p>上图中主要用到的信息一个是当前窗口的标题：<code>明日方舟 - MuMu模拟器 </code>。</p><p>另一个就是鼠标所在的位置信息，因为截图的缘故，没看到我的鼠标……</p><p><code>Window</code>和<code>Client</code>所指的信息是当前鼠标相对于当前这个软件最左上角的坐标位置。而<code>Screen</code>是指的当前鼠标位于整个电脑屏幕左上角的坐标位置。</p><blockquote><p>windows软件一般默认以左上角为原点，水平向右为x轴递增方向。铅直向下为y轴递增方向。</p></blockquote><p>获取到软件以及软件内部的坐标，我们就可以通过模拟鼠标点击来实现脚本自动化执行。</p><h3 id="普通关卡实例"><a href="#普通关卡实例" class="headerlink" title="普通关卡实例"></a>普通关卡实例</h3><p>普通关卡的刷材料步骤就是：(默认已经选中这一关的条件下)</p><ol><li>点击开始行动，进入到人员配置界面</li><li>在人员配置界面点击开始行动。开始刷关卡。</li><li>等待关卡刷完之后，点击屏幕，返回到关卡入口处。</li></ol><p><img src="/autohotkey-apl/shua1.png"></p><p>上图就是默认选中关卡的状态，记得要有体力，以及确保勾选了<code>代理指挥</code>。</p><p>然后在这个界面执行脚本，就可以自动刷材料了。</p><p>以下是代码：</p><pre><code class="hljs autoit"><span class="hljs-comment">;快捷键为 ctrl + alt + m</span>^!m::IfWinActive 明日方舟 - MuMu模拟器&#123;CoordMode ,mouse,Window<span class="hljs-built_in">InputBox</span>, time, 计数, 请输入体力值以及单刷消耗值，使用小数点分隔TimeArray := StrSplit(time, <span class="hljs-string">&quot;.&quot;</span>)a := TimeArray[<span class="hljs-number">1</span>]<span class="hljs-comment">;数组是从1开始</span>b := TimeArray[<span class="hljs-number">2</span>]times := a/btimes := <span class="hljs-built_in">Floor</span>(times)<span class="hljs-comment">;Floor向下取整</span>alltime := times*<span class="hljs-number">3.1</span><span class="hljs-built_in">MsgBox</span>,一共要进行%times%次，需要时间为%alltime%。  loop %times%  &#123;<span class="hljs-built_in">Sleep</span> <span class="hljs-number">1000</span><span class="hljs-built_in">send</span> &#123;click <span class="hljs-number">1223</span>,<span class="hljs-number">781</span>&#125;<span class="hljs-comment">;步骤1的坐标</span><span class="hljs-built_in">Sleep</span> <span class="hljs-number">3000</span><span class="hljs-built_in">send</span> &#123;click <span class="hljs-number">1246</span>,<span class="hljs-number">591</span>&#125;<span class="hljs-comment">;步骤2的坐标</span><span class="hljs-built_in">Sleep</span> <span class="hljs-number">180000</span><span class="hljs-comment">;等待3分钟</span><span class="hljs-built_in">send</span> &#123;click <span class="hljs-number">790</span>,<span class="hljs-number">284</span>&#125;<span class="hljs-comment">;步骤3的坐标</span><span class="hljs-built_in">Sleep</span> <span class="hljs-number">3000</span>  &#125;<span class="hljs-built_in">MsgBox</span> 代理完成。&#125;<span class="hljs-keyword">return</span></code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>将上述脚本写入到你新建的脚本中。然后记得修改上面的坐标为自己电脑上的坐标，可能不一样，拿Spy检测以下位置，修改数值就可以了。</p><p>而第三步骤刷完关卡时，只要点击材料上方的任何位置都能退出去，所以这个坐标可以随意设置，只要注意规则就行了。上面两个坐标要严格按照spy的值来设置。</p><p>至于<code>Sleep 180000</code>表示等待3分钟，即关卡的代理时间，一般没有超过3分钟的关卡吧~(或许)，自己动态调整，这里的单位时毫秒，1秒 = 1000ms。</p><p><img src="/autohotkey-apl/shua2.png"></p><p>选好你要刷的关卡，然后运行脚本，要以<strong>管理员的身份运行！！！</strong>这一点很重要，具体原因是：</p><blockquote><p>当活动窗口以管理权限运行而当前脚本不是时, <strong>Send 在 Windows Vista 或更高版本中可能没有效果</strong>. 这是由于用户接口和特权分离的安全机制. </p><p>而MUMU模拟器是以管理员身份运行的！</p><p>来自参考文档：<a href="http://ahkcn.sourceforge.net/docs/commands/Send.htm#SendPlay">http://ahkcn.sourceforge.net/docs/commands/Send.htm#SendPlay</a> </p></blockquote><p>在软件中同时按下<code>Ctrl</code>、<code>Alt</code>以及<code>m</code>键，将会弹出上图的弹框，输入你当前的体力值以及单刷的消耗值，使用小数点隔离开来，点击OK就会自动计算需要时间，之后就会自动开始刷了。</p><h3 id="剿灭关卡的使用"><a href="#剿灭关卡的使用" class="headerlink" title="剿灭关卡的使用"></a>剿灭关卡的使用</h3><pre><code class="hljs autoit">^!q::<span class="hljs-comment">;剿灭作战 15分中</span>IfWinActive 明日方舟 - MuMu模拟器&#123;CoordMode ,mouse,Window<span class="hljs-built_in">InputBox</span>, time, 剿灭, 请输入体力值以及单刷消耗值，使用小数点分隔TimeArray := StrSplit(time, <span class="hljs-string">&quot;.&quot;</span>)a := TimeArray[<span class="hljs-number">1</span>]<span class="hljs-comment">;数组是从1开始</span>b := TimeArray[<span class="hljs-number">2</span>]times := a/btimes := <span class="hljs-built_in">Floor</span>(times)<span class="hljs-comment">;Floor向下取整</span>alltime := times*<span class="hljs-number">16</span><span class="hljs-built_in">MsgBox</span>,一共要进行%times%次，需要时间为%alltime%。  loop %times%  &#123;<span class="hljs-built_in">Sleep</span> <span class="hljs-number">1000</span><span class="hljs-built_in">send</span> &#123;click <span class="hljs-number">1223</span>,<span class="hljs-number">781</span>&#125;<span class="hljs-built_in">Sleep</span> <span class="hljs-number">3000</span><span class="hljs-built_in">send</span> &#123;click <span class="hljs-number">1246</span>,<span class="hljs-number">591</span>&#125;<span class="hljs-built_in">Sleep</span> <span class="hljs-number">930000</span><span class="hljs-built_in">send</span> &#123;click <span class="hljs-number">790</span>,<span class="hljs-number">284</span>&#125;<span class="hljs-built_in">Sleep</span> <span class="hljs-number">10000</span><span class="hljs-built_in">send</span> &#123;click <span class="hljs-number">790</span>,<span class="hljs-number">284</span>&#125;<span class="hljs-built_in">Sleep</span> <span class="hljs-number">10000</span>  &#125;<span class="hljs-built_in">MsgBox</span> 代理完成。&#125;<span class="hljs-keyword">return</span></code></pre><p>适用于第三张剿灭图。刷一次大概要15分钟，这么看这个游戏好浪费时间。</p><p>大致操作和上面的普通关卡类似，预先选定好关卡，执行脚本就行了。</p><p>上述的坐标就用上面介绍的方法修改。</p><h3 id="最后的说明"><a href="#最后的说明" class="headerlink" title="最后的说明"></a>最后的说明</h3><p>简单来讲这个脚本功能很弱，只能刷固定的关卡，还需要用户计算好关卡的时间。</p><p>没有任何检错机制，没有任何应对非常规问题的能力。比如如果网络不好，同步失败显示错误，它没法检测。例如代理失败等待用户确认，它没法检测。</p><p>原本想尝试做图片识别的方式来优化流程的，但是总是有离奇的错误，图片识别失败，最后放弃了。</p><p>简单来讲，勉强能用。</p><p>后续不会再更新这个脚本了。</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AutoHotkey入门 ~ Windows下自动化脚本</title>
    <link href="/autohotkey/"/>
    <url>/autohotkey/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：自动化脚本AutoHotket语言相关基础知识。</p><a id="more"></a><h2 id="关于AutoHotKey"><a href="#关于AutoHotKey" class="headerlink" title="关于AutoHotKey"></a>关于AutoHotKey</h2><p>Windows的终极自动化脚本语言。</p><p>官网： <a href="https://www.autohotkey.com/">https://www.autohotkey.com/</a> </p><p>使用AutoHotKey这个脚本语言可以很迅速方便的创建Windows下的便捷操作。例如一键打开多个网页，一键代替多个操作步骤。化繁为简，非常的方便好用。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在上述官网下载<code>当前版本</code>即<code>Current Version</code>下载，我当前使用的版本还是1.xx的。</p><p>下载后自行安装即可。</p><h2 id="新建脚本与运行"><a href="#新建脚本与运行" class="headerlink" title="新建脚本与运行"></a>新建脚本与运行</h2><p>鼠标右键 –&gt; 新建，就能看到一个<code>AutoHotkey script</code>的选项，点击即可新建一个脚本。</p><p>对这个脚本右键选择用文本编辑器打开即可。</p><p>默认文件会有几行注释以及一些代码，没太搞懂啥意思，直接删掉脚本也能正常使用。</p><p>在其中填入要执行的脚本代码，例如下面的入门代码<code>#space::Run www.baidu.com</code>。保存文件之后，双击脚本或者右键选择<code>Run Script</code>，脚本就会被执行，如果你的脚本编写有语法错误的话，会直接弹出提醒。</p><p>脚本运行的话，你的状态栏那里就可以看到这个软件的图标。当你不需要运行这个脚本时，右键图标选择关闭退出即可。</p><p>除此之外还有脚本转<code>.exe</code>，自行探究~</p><h2 id="入门学习相关资料"><a href="#入门学习相关资料" class="headerlink" title="入门学习相关资料"></a>入门学习相关资料</h2><p>中文在线API： <a href="https://wyagd001.github.io/zh-cn/docs/AutoHotkey.htm">https://wyagd001.github.io/zh-cn/docs/AutoHotkey.htm</a> </p><p>此外，安装软件之后也会自带帮助文件<code>chm</code>，与<code>exe</code>文件放在一起，可自行查看，不过那是英文版本。</p><p>除此之外，我还在知乎看到一位作者在分享他写好的一些脚本，涵盖面非常的广，链接：<a href="https://zhuanlan.zhihu.com/p/103357456">https://zhuanlan.zhihu.com/p/103357456</a></p><p>以下内容是我在接触脚本时做的一点笔记，不太完整，并且比较杂乱。主要参考了上面的中文在线API链接。</p><hr><h2 id="入门第一行"><a href="#入门第一行" class="headerlink" title="入门第一行"></a>入门第一行</h2><pre><code class="hljs css"><span class="hljs-selector-id">#space</span><span class="hljs-selector-pseudo">::Run</span> <span class="hljs-selector-tag">www</span><span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span></code></pre><ul><li>这行代码表示同时按下Win+空格，浏览器就会自动打开百度的网址。</li><li><code>#</code>代表Windows键，<code>space</code>表示空格键，组合起来表示Win+空格。</li><li><code>::</code>双冒号表示，每次按下热键会执行其后面的操作。</li><li><code>Run</code>命令后可以接程序、文档、URL或者快捷方式，这里后接网址会自动打开默认浏览器打开网址。</li></ul><pre><code class="hljs asciidoc"><span class="hljs-meta">::btw::by</span> the way</code></pre><ul><li>上述这种叫做热字串，当输入btw后面跟着空格或者逗号时，会自动将btw替换为by the way。</li></ul><h3 id="其他符号"><a href="#其他符号" class="headerlink" title="其他符号"></a>其他符号</h3><ul><li><code>^</code>：表示<code>Control</code>，</li><li><code>!</code>：表示<code>Alt</code>键。</li><li><code>+</code>：表示<code>shift</code>。</li></ul><pre><code class="hljs dockerfile">;多行热键<span class="hljs-comment">#n::</span><span class="hljs-keyword">Run</span><span class="bash"> www.baidu.com</span><span class="hljs-keyword">Run</span><span class="bash"> Notepad.exe</span>return</code></pre><ul><li><code>RunWait</code>：与Run类似，表示脚本等到程序或者文档结束之后才能执行热键</li></ul><h2 id="发送键击"><a href="#发送键击" class="headerlink" title="发送键击"></a>发送键击</h2><p><code>send</code>命令可以发送键击到活动窗口（最前面的窗口）中。</p><pre><code class="hljs rust">^!c::<span class="hljs-built_in">Send</span> 我爱你，&#123;Enter&#125;&#123;Tab&#125; 骗你的<span class="hljs-keyword">return</span></code></pre><p>这段命令是，向当前的文本编辑器中输入两句话，<code>&#123;Enter&#125;</code>表示模拟按下回车键，<code>&#123;Tab&#125;</code>表示模拟按下缩进键。</p><h2 id="鼠标点击"><a href="#鼠标点击" class="headerlink" title="鼠标点击"></a>鼠标点击</h2><p>发送鼠标点击到窗口。</p><p>使用Window Spy来获取目标窗口中的位置，相对当前窗口左上角的位置。</p><p>然后再<code>Click x,y</code>，模拟鼠标左击即可。</p><p>Click里不支持表达式，对于变量来说，变量要加百分号。</p><h2 id="激活与操作窗口"><a href="#激活与操作窗口" class="headerlink" title="激活与操作窗口"></a>激活与操作窗口</h2><p>激活窗口就是指使窗口位于最前边，可使用<code>WinActivate</code></p><p><code>IfWinActive</code>：检查指定的窗口是否活动，后接窗口标题。</p><p><code>IfWinNotActive</code>：</p><pre><code class="hljs arduino">^!v::IfWinActive 入门.md - Typora&#123;MsgBox Active!&#125;<span class="hljs-keyword">return</span></code></pre><p><code>WinWaitActive</code>：等待指定窗口变为活动窗口。</p><p><code>WinClose</code>：关闭指定窗口</p><p><code>WinMove</code>：改变指定窗口的位置和/或大小。</p><p><code>WinMinimize</code>, <code>WinMaximize</code>, <code>WinRestore</code> 分别最小化, 最大化或还原指定窗口.</p><h2 id="获取用户输入或者提示"><a href="#获取用户输入或者提示" class="headerlink" title="获取用户输入或者提示"></a>获取用户输入或者提示</h2><p><code>MsgBox</code>：用于显示提示框</p><p><code>InputBox</code>：提示用户输入字符串。</p><pre><code class="hljs autohotkey"><span class="hljs-built_in">MsgBox,</span> <span class="hljs-number">4</span>, , Would you like to <span class="hljs-keyword">continue</span>?<span class="hljs-built_in">IfMsgBox,</span> No    <span class="hljs-keyword">return</span><span class="hljs-comment">; 否则, 用户选择了是.</span>MsgBox You pressed YES.</code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是脚本用来<strong>存储文本或数字的内存块</strong>. 只包含数字的变量 (可以含小数点) 在数学运算或比较时会被<strong>自动转换</strong>为数字.</p><p>除了函数中的局部变量外, 所有的变量都是<strong>全局</strong>的; 即可以在脚本的任意位置读取或改变它们的内容. 此外, <strong>变量不需要声明</strong>; 简单地使用它们就可以让它们存在 (且每个变量都以空或空白开始).</p><pre><code class="hljs applescript">^!b::MyVar1 = <span class="hljs-number">123</span>MyVar2 = <span class="hljs-keyword">my</span> <span class="hljs-built_in">string</span><span class="hljs-keyword">if</span> MyVar2 = <span class="hljs-keyword">my</span> <span class="hljs-built_in">string</span>&#123;    MsgBox MyVar2 <span class="hljs-keyword">contains</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">string</span> <span class="hljs-string">&quot;my string&quot;</span>.&#125;<span class="hljs-keyword">if</span> MyVar1 &gt;= <span class="hljs-number">100</span>&#123;    MsgBox MyVar1 <span class="hljs-keyword">contains</span> %MyVar1%, which <span class="hljs-keyword">is</span> a <span class="hljs-built_in">number</span> <span class="hljs-keyword">greater than</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">equal</span> <span class="hljs-keyword">to</span> <span class="hljs-number">100.</span>&#125;<span class="hljs-built_in">return</span></code></pre><ul><li><code>%MyVar1%</code>用百分号包含变量，用于显示变量的内容。</li><li><code>MyVarConcatenated = %MyVar1% %MyVar2%</code>则字符串为<code>123 my string</code></li></ul><p>使用<code>if</code>来比较两个变量的内容。</p><pre><code class="hljs mel"><span class="hljs-keyword">if</span> (ItemCount &gt; ItemLimit)&#123;    MsgBox The value <span class="hljs-keyword">in</span> ItemCount, which is %ItemCount%, is greater than %ItemLimit%.&#125;</code></pre><p> 注意上面例子的首行包含小括号. 小括号表示这个 if 语句包含表达式. 如果没有它们, 那行将被视为 “非表达式 if 语句”, 并且因此需要使用百分号括住 ItemLimit (这样的 if 语句被限制为只能包含简单的比较运算符, 而不能包含数学运算符或像 “AND” 和 “OR” 这样的联合运算符). </p><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p>赋值：<code>:=</code>，冒号等号运算符</p><pre><code class="hljs apache"><span class="hljs-attribute">NetPrice</span> := Price * (<span class="hljs-number">1</span> - Discount/<span class="hljs-number">100</span>)</code></pre><h2 id="剪贴板"><a href="#剪贴板" class="headerlink" title="剪贴板"></a>剪贴板</h2><p><code> Clipboard</code> 变量是特殊变量, 因为它包含了 <code>Windows 剪贴板</code>中当前的文本. 即使如此, 它的用法也和普通变量一样. </p><pre><code class="hljs autohotkey"><span class="hljs-built_in">MsgBox %</span><span class="hljs-built_in">clipboard</span>%<span class="hljs-comment">;显示剪切板的内容</span></code></pre><p>替换剪切板内容</p><pre><code class="hljs autohotkey"><span class="hljs-built_in">clipboard</span> = A line of text.`r`nA second line of text.`r`n</code></pre><ul><li>``r`加上n表示回车+换行。</li></ul><p>追加剪切板内容，就像变量一样</p><pre><code class="hljs xquery">clipboard = <span class="hljs-meta">%clipboard</span>% And here <span class="hljs-literal">is</span> the <span class="hljs-type">text</span> <span class="hljs-keyword">to</span> append.</code></pre><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><pre><code class="hljs mathematica"><span class="hljs-variable">Loop</span> <span class="hljs-number">3</span><span class="hljs-operator">;</span><span class="hljs-number">3</span>表示循环次数<span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">Run</span> <span class="hljs-built_in">C</span><span class="hljs-operator">:</span>\<span class="hljs-built_in">Check</span> <span class="hljs-variable">Server</span> <span class="hljs-variable">Status</span><span class="hljs-operator">.</span><span class="hljs-variable">exe</span><span class="hljs-variable">Sleep</span> <span class="hljs-number">60000</span> <span class="hljs-operator">;</span>暂停 <span class="hljs-number">60</span> 秒<span class="hljs-operator">.</span><span class="hljs-punctuation">&#125;</span></code></pre><p> 当一个或多个条件改变时循环还可以终止它自己. 下面的例子中当用户按住 F1 键时会重复点击鼠标左键: </p><pre><code class="hljs elixir"><span class="hljs-variable">$F1</span>::  ;把F1键设置为热键(<span class="hljs-variable">$符</span>号会有助于下面GetKeyState的<span class="hljs-string">&quot;P&quot;</span>模式).Loop  ;由于没有指定数字,所以这是个无限循环,直到遇到内部的<span class="hljs-string">&quot;break&quot;</span>或<span class="hljs-string">&quot;return&quot;</span>.&#123;    if <span class="hljs-keyword">not</span> GetKeyState(<span class="hljs-string">&quot;F1&quot;</span>, <span class="hljs-string">&quot;P&quot;</span>)  ;如果此状态为<span class="hljs-keyword">true</span>,那么用户实际已经释放了F1键.        <span class="hljs-keyword">break</span>  ;中断循环.    ;否则 (由于上面没有<span class="hljs-string">&quot;中断&quot;</span>),继续点击鼠标.    Click  ;在当前指针位置点击鼠标左键.&#125;<span class="hljs-keyword">return</span></code></pre><p>while循环：</p><pre><code class="hljs cpp">$F1::<span class="hljs-function"><span class="hljs-keyword">while</span> <span class="hljs-title">GetKeyState</span><span class="hljs-params">(<span class="hljs-string">&quot;F1&quot;</span>,<span class="hljs-string">&quot;P&quot;</span>)</span>  </span>;当F1键实际被按住时.&#123;    Click&#125;<span class="hljs-keyword">return</span></code></pre><h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><p>要添加文本到文件的末尾 (或创建新文件), 请使用 FileAppend, 如下面的例子所示. 注意它使用 `n (换行符) 来开始新的文本行:</p><pre><code class="hljs vhdl">FileAppend, A <span class="hljs-literal">line</span> <span class="hljs-keyword">of</span> <span class="hljs-literal">text</span> <span class="hljs-keyword">to</span> append.`n, C:\My Documents\My <span class="hljs-literal">Text</span> <span class="hljs-keyword">File</span>.txt</code></pre><p>要覆盖现有的文件, 请在 FileAppend 之前使用 FileDelete. 例如：</p><pre><code class="hljs mathematica"><span class="hljs-variable">FileDelete</span><span class="hljs-operator">,</span> <span class="hljs-built_in">C</span><span class="hljs-operator">:</span>\<span class="hljs-variable">My</span> <span class="hljs-variable">Documents</span>\<span class="hljs-variable">My</span> <span class="hljs-built_in">Text</span> <span class="hljs-built_in">File</span><span class="hljs-operator">.</span><span class="hljs-variable">txt</span></code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre><code class="hljs pgsql">^w::; 创建数组后, 初始为空:<span class="hljs-keyword">Array</span> := <span class="hljs-keyword">Object</span>(); 写入数据到数组:<span class="hljs-keyword">Loop</span>, <span class="hljs-keyword">Read</span>, C:\Users\colou\Desktop\list.txt ; 此循环获取文件中的每行, 一次一行.&#123;    <span class="hljs-keyword">Array</span>.<span class="hljs-keyword">Insert</span>(A_LoopReadLine) ; 添加此行到数组中.&#125;; 从数组中读取:; <span class="hljs-keyword">Loop</span> % <span class="hljs-keyword">Array</span>.MaxIndex()   ; 较传统的方式.<span class="hljs-keyword">for</span> <span class="hljs-keyword">index</span>, element <span class="hljs-keyword">in</span> <span class="hljs-keyword">Array</span> ; 在大多数情况下建议使用的方式.&#123;    ; 使用 &quot;Loop&quot;, 索引必须是连续的数字, 从 <span class="hljs-number">1</span> 到    ; 数组中元素的个数 (或者必须在循环中进行计算).    ; MsgBox % &quot;Element number &quot; . A_Index . &quot; is &quot; . <span class="hljs-keyword">Array</span>[A_Index]        ; 使用“<span class="hljs-keyword">for</span>”，同时提供了索引（或“键”）及与它关联    ; 的值，并且索引可以是您选择的*任何*值。    MsgBox % &quot;Element number &quot; . <span class="hljs-keyword">index</span> . &quot; is &quot; . element&#125;<span class="hljs-keyword">return</span></code></pre><h2 id="图片识别"><a href="#图片识别" class="headerlink" title="图片识别"></a>图片识别</h2><pre><code class="hljs autohotkey"><span class="hljs-title">^c::</span><span class="hljs-built_in">ImageSearch,</span> FoundA, FoundB, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>, <span class="hljs-built_in">A_ScreenWidth</span>, <span class="hljs-built_in">A_ScreenHeight</span>, C:\Users\colou\Desktop\end.pngif <span class="hljs-built_in">ErrorLevel</span> = <span class="hljs-number">0</span>Sleep <span class="hljs-number">1500</span><span class="hljs-built_in">Click %</span>FoundA%,<span class="hljs-variable">%FoundB%</span>MsgBox end.<span class="hljs-keyword">return</span></code></pre><ul><li>如果找到了图片，FoundA与FoundB用来存储坐标。</li><li>0，0 表示起始的左上角的位置</li><li>A_ScreenWidth, A_ScreenHeight表示右下角的坐标</li><li>最后一个参数是路径</li><li>如果找到了图片，ErrorLevel就为0.</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ol><li><p>命令和变量不区分大小写</p></li><li><p>命令中的第一个逗号可以省略，特殊请矿除外（首个参数为空，以<code>:=</code>或者<code>=</code>开始，或者命令单独处于延续片段的顶部）。</p><pre><code class="hljs mercury">MsgBox This <span class="hljs-keyword">is</span> ok.MsgBox, This <span class="hljs-keyword">is</span> ok too.</code></pre><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2></li></ol><p><code>A_Now</code>是当前系统时间</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++基于EasyX制作贪吃蛇游戏（六）第三版代码与程序</title>
    <link href="/c-snake-pro6/"/>
    <url>/c-snake-pro6/</url>
    
    <content type="html"><![CDATA[<p>上接<a href="http://www.colourso.top/c-snake-pro5/">C++基于EasyX制作贪吃蛇游戏（五）第三版文档</a> ，本文是代码的实现。</p><a id="more"></a><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>工具：VS2017</p><p>依赖：EasyX Library for C++ (Ver:20200520(beta))</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>源代码可能有点多，但还是决定粘一份上来，底部会贴出网盘地址以及GIthub地址的。</p><p><img src="/c-snake-pro6/jiegou.png"></p><h3 id="common-h"><a href="#common-h" class="headerlink" title="common.h"></a>common.h</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;graphics.h&gt;</span></span><span class="hljs-comment">//蛇的节点半径</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SNAKE_RADIU 9</span><span class="hljs-comment">//食物的半径</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOOD_RADIU 8</span><span class="hljs-comment">//蛇的节点宽度</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SNAKE_WIDTH 20</span><span class="hljs-comment">//COLORREF BG_COLOR = RGB(0,0,0);//背景颜色为黑色</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BG_COLOR 0</span><span class="hljs-comment">//方向的枚举</span><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dir</span> &#123;</span> DIR_UP = <span class="hljs-number">1</span>, DIR_RIGHT = <span class="hljs-number">2</span>, DIR_DOWN = <span class="hljs-number">3</span>, DIR_LEFT = <span class="hljs-number">4</span> &#125;;<span class="hljs-comment">//点的结构体</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> &#123;</span><span class="hljs-keyword">int</span> x;<span class="hljs-keyword">int</span> y;Point() :x(<span class="hljs-number">-1</span>), y(<span class="hljs-number">-1</span>) &#123;&#125;Point(<span class="hljs-keyword">int</span> dx, <span class="hljs-keyword">int</span> dy) :x(dx), y(dy) &#123;&#125;Point(<span class="hljs-keyword">const</span> Point&amp; point) :x(point.x), y(point.y) &#123;&#125;<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> Point&amp; point)&#123;<span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>-&gt;x == point.x) &amp;&amp; (<span class="hljs-keyword">this</span>-&gt;y == point.y);&#125;&#125;;<span class="hljs-comment">//记录游玩信息</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PlayerMsg</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">int</span> id;<span class="hljs-keyword">int</span> score;<span class="hljs-keyword">int</span> len;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> r_time;<span class="hljs-comment">//记录时间</span>PlayerMsg()&#123;id = <span class="hljs-number">99</span>;score = <span class="hljs-number">0</span>;len = <span class="hljs-number">0</span>;r_time = <span class="hljs-string">&quot;&quot;</span>;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SortPlayerMsg</span> </span><span class="hljs-class">&#123;</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PlayerMsg &amp;msg1, <span class="hljs-keyword">const</span> PlayerMsg &amp;msg2)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (msg1.score == msg2.score)&#123;<span class="hljs-keyword">return</span> msg1.r_time &gt; msg2.r_time;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> msg1.score &gt; msg2.score;&#125;&#125;;</code></pre><h3 id="Snake-h"><a href="#Snake-h" class="headerlink" title="Snake.h"></a>Snake.h</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;common.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Snake</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MinSpeed = <span class="hljs-number">1</span>;<span class="hljs-comment">//蛇的最小速度</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MaxSpeed = <span class="hljs-number">25</span>;<span class="hljs-comment">//蛇的最大速度</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> OrgSpeed = <span class="hljs-number">15</span>;<span class="hljs-comment">//蛇的原始速度</span><span class="hljs-keyword">private</span>:<span class="hljs-keyword">int</span> m_len;<span class="hljs-comment">//蛇的长度</span><span class="hljs-keyword">int</span> m_speed;<span class="hljs-comment">//蛇的速度</span>Dir m_direction;<span class="hljs-comment">//蛇的方向</span><span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;Point&gt; m_snakelist;<span class="hljs-comment">//蛇的链表</span>Point m_tail;<span class="hljs-comment">//蛇移动过后的尾部节点，主要用于吃食物</span><span class="hljs-keyword">public</span>:Snake();<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLen</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//获取长度</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSpeed</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//获取速度</span><span class="hljs-function">Dir <span class="hljs-title">getDirection</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//获取方向</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">setSpeed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> speed)</span></span>;<span class="hljs-comment">//设置速度，设置成功返回true</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Move</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//移动一节</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EatFood</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//吃食物</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ChangeDir</span><span class="hljs-params">(Dir dir)</span></span>;<span class="hljs-comment">//改变方向</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dead</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//死亡</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ColideWall</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom)</span></span>;<span class="hljs-comment">//碰撞到墙</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ColideSnake</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//碰撞到了自身</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ColideFood</span><span class="hljs-params">(Point point)</span></span>;<span class="hljs-comment">//碰到了食物</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawSnake</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绘制蛇</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawSnakeHead</span><span class="hljs-params">(Point pos)</span></span>;<span class="hljs-comment">//绘制蛇头</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawSnakeNode</span><span class="hljs-params">(Point pos)</span></span>;<span class="hljs-comment">//绘制蛇的身体结点</span><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;Point&gt; <span class="hljs-title">GetSnakeAllNode</span><span class="hljs-params">()</span></span>;&#125;;</code></pre><h3 id="Snake-cpp"><a href="#Snake-cpp" class="headerlink" title="Snake.cpp"></a>Snake.cpp</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Snake.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;graphics.h&gt;</span></span>Snake::Snake()&#123;<span class="hljs-function">Point <span class="hljs-title">pos0</span><span class="hljs-params">(<span class="hljs-number">210</span>, <span class="hljs-number">230</span>)</span></span>;<span class="hljs-function">Point <span class="hljs-title">pos1</span><span class="hljs-params">(<span class="hljs-number">190</span>, <span class="hljs-number">230</span>)</span></span>;<span class="hljs-function">Point <span class="hljs-title">pos2</span><span class="hljs-params">(<span class="hljs-number">170</span>, <span class="hljs-number">230</span>)</span></span>;<span class="hljs-keyword">this</span>-&gt;m_snakelist.push_back(pos0);<span class="hljs-keyword">this</span>-&gt;m_snakelist.push_back(pos1);<span class="hljs-keyword">this</span>-&gt;m_snakelist.push_back(pos2);<span class="hljs-keyword">this</span>-&gt;m_direction = Dir::DIR_RIGHT;<span class="hljs-keyword">this</span>-&gt;m_len = <span class="hljs-number">3</span>;<span class="hljs-keyword">this</span>-&gt;m_speed = <span class="hljs-keyword">this</span>-&gt;OrgSpeed;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Snake::getLen</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_len;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Snake::getSpeed</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_speed;&#125;<span class="hljs-function">Dir <span class="hljs-title">Snake::getDirection</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_direction;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Snake::setSpeed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> speed)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (speed &gt; <span class="hljs-keyword">this</span>-&gt;MaxSpeed)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_speed != <span class="hljs-keyword">this</span>-&gt;MaxSpeed)&#123;<span class="hljs-keyword">this</span>-&gt;m_speed = <span class="hljs-keyword">this</span>-&gt;MaxSpeed;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (speed &lt; <span class="hljs-keyword">this</span>-&gt;MinSpeed)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_speed != <span class="hljs-keyword">this</span>-&gt;MinSpeed)&#123;<span class="hljs-keyword">this</span>-&gt;m_speed = <span class="hljs-keyword">this</span>-&gt;MinSpeed;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">this</span>-&gt;m_speed = speed;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Snake::Move</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">this</span>-&gt;m_tail = <span class="hljs-keyword">this</span>-&gt;m_snakelist.back();<span class="hljs-comment">//移除最后一个节点，复制第一个节点两份</span><span class="hljs-keyword">this</span>-&gt;m_snakelist.pop_back();Point headPos = <span class="hljs-keyword">this</span>-&gt;m_snakelist.front();<span class="hljs-keyword">this</span>-&gt;m_snakelist.push_front(headPos);<span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>-&gt;m_direction)&#123;<span class="hljs-keyword">case</span> Dir::DIR_UP:<span class="hljs-keyword">this</span>-&gt;m_snakelist.begin()-&gt;y -= SNAKE_WIDTH;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> Dir::DIR_RIGHT:<span class="hljs-keyword">this</span>-&gt;m_snakelist.begin()-&gt;x += SNAKE_WIDTH;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> Dir::DIR_DOWN:<span class="hljs-keyword">this</span>-&gt;m_snakelist.begin()-&gt;y += SNAKE_WIDTH;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> Dir::DIR_LEFT:<span class="hljs-keyword">this</span>-&gt;m_snakelist.begin()-&gt;x -= SNAKE_WIDTH;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Snake::EatFood</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//吃到食物尾部增长</span><span class="hljs-keyword">this</span>-&gt;m_snakelist.push_back(<span class="hljs-keyword">this</span>-&gt;m_tail);<span class="hljs-keyword">this</span>-&gt;m_len += <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Snake::ChangeDir</span><span class="hljs-params">(Dir dir)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">switch</span> (dir)&#123;<span class="hljs-keyword">case</span> Dir::DIR_UP:<span class="hljs-keyword">case</span> Dir::DIR_DOWN:<span class="hljs-keyword">if</span> (m_direction != Dir::DIR_UP &amp;&amp; m_direction != Dir::DIR_DOWN)&#123;m_direction = dir;&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> Dir::DIR_RIGHT:<span class="hljs-keyword">case</span> Dir::DIR_LEFT:<span class="hljs-keyword">if</span> (m_direction != Dir::DIR_RIGHT &amp;&amp; m_direction != Dir::DIR_LEFT)&#123;m_direction = dir;&#125;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Snake::Dead</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//TODO</span><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;<span class="hljs-comment">//x、y表示坐标的该变量</span><span class="hljs-keyword">int</span> z = <span class="hljs-number">0</span>;<span class="hljs-comment">//z表示改变方向</span><span class="hljs-comment">//使用随机函数</span>srand(time(<span class="hljs-number">0</span>));<span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;Point&gt;::iterator it = <span class="hljs-keyword">this</span>-&gt;m_snakelist.begin();<span class="hljs-keyword">for</span> (; it != <span class="hljs-keyword">this</span>-&gt;m_snakelist.end(); ++it)&#123;x = (rand() % <span class="hljs-number">4</span>) * SNAKE_WIDTH;y = (rand() % <span class="hljs-number">4</span>) * SNAKE_WIDTH;z = (rand() % <span class="hljs-number">8</span>);<span class="hljs-keyword">switch</span> (z)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-comment">//右</span>(*it).x += x;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-comment">//下</span>(*it).y += y;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-comment">//左</span>(*it).x -= x;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-comment">//上</span>(*it).y -= y;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<span class="hljs-comment">//右下</span>(*it).x += x;(*it).y += y;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<span class="hljs-comment">//左下</span>(*it).x -= x;(*it).y += y;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<span class="hljs-comment">//左上</span>(*it).x -= x;(*it).y -= y;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<span class="hljs-comment">//右上</span>(*it).x += x;(*it).y -= y;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Snake::ColideWall</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> x = <span class="hljs-keyword">this</span>-&gt;m_snakelist.front().x;<span class="hljs-keyword">int</span> y = <span class="hljs-keyword">this</span>-&gt;m_snakelist.front().y;<span class="hljs-keyword">return</span> (x &lt; left || x &gt; right || y &lt; top || y &gt; bottom);&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Snake::ColideSnake</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (m_len &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;Point&gt;::iterator it = <span class="hljs-keyword">this</span>-&gt;m_snakelist.begin();Point pos = *it;Point next_pos;it++;<span class="hljs-keyword">while</span>(it != <span class="hljs-keyword">this</span>-&gt;m_snakelist.end())&#123;next_pos = *it;<span class="hljs-keyword">if</span> (pos == next_pos)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;it++;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Snake::ColideFood</span><span class="hljs-params">(Point point)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_snakelist.front() == point)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Snake::DrawSnake</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;Point&gt;::iterator it = <span class="hljs-keyword">this</span>-&gt;m_snakelist.begin();<span class="hljs-keyword">for</span> (; it != <span class="hljs-keyword">this</span>-&gt;m_snakelist.end(); ++it)&#123;DrawSnakeNode(*it);&#125;DrawSnakeHead(<span class="hljs-keyword">this</span>-&gt;m_snakelist.front());&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Snake::DrawSnakeHead</span><span class="hljs-params">(Point pos)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//紫色，全填充，无边框的正方形</span>setfillcolor(<span class="hljs-number">0xAA00AA</span>);setfillstyle(BS_SOLID);solidrectangle(pos.x - SNAKE_RADIU, pos.y + SNAKE_RADIU, pos.x + SNAKE_RADIU, pos.y - SNAKE_RADIU);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Snake::DrawSnakeNode</span><span class="hljs-params">(Point pos)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//绿色，全填充，无边框的正方形</span>setfillcolor(GREEN);setfillstyle(BS_SOLID);solidrectangle(pos.x - SNAKE_RADIU, pos.y + SNAKE_RADIU, pos.x + SNAKE_RADIU, pos.y - SNAKE_RADIU);&#125;<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;Point&gt; <span class="hljs-title">Snake::GetSnakeAllNode</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_snakelist;&#125;</code></pre><h3 id="Food-h"><a href="#Food-h" class="headerlink" title="Food.h"></a>Food.h</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;common.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Snake.h&quot;</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:Point m_pos;<span class="hljs-keyword">bool</span> m_state;<span class="hljs-keyword">public</span>:Food();<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">getState</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> state)</span></span>;<span class="hljs-function">Point <span class="hljs-title">getPos</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//获取食物坐标</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Generate</span><span class="hljs-params">(Snake *snake)</span></span>;<span class="hljs-comment">//产生新的食物</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawFood</span><span class="hljs-params">()</span></span>;&#125;;</code></pre><h3 id="Food-cpp"><a href="#Food-cpp" class="headerlink" title="Food.cpp"></a>Food.cpp</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Food.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;graphics.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>Food::Food()&#123;<span class="hljs-comment">//初始化食物的数据</span><span class="hljs-keyword">this</span>-&gt;m_state = <span class="hljs-literal">true</span>;<span class="hljs-keyword">this</span>-&gt;m_pos = Point(<span class="hljs-number">310</span>, <span class="hljs-number">230</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Food::getState</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_state;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Food::setState</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> state)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">this</span>-&gt;m_state = state;&#125;<span class="hljs-function">Point <span class="hljs-title">Food::getPos</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_pos;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Food::Generate</span><span class="hljs-params">(Snake * snake)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//产生食物要求获取蛇的身体节点来检查是否生成的食物出现在了蛇的身上</span><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;<span class="hljs-keyword">bool</span> isOk = <span class="hljs-literal">false</span>;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<span class="hljs-comment">//使用随机函数产生食物</span>srand(time(<span class="hljs-number">0</span>));x = (rand() % <span class="hljs-number">24</span>) * <span class="hljs-number">20</span> + <span class="hljs-number">10</span>;y = (rand() % <span class="hljs-number">24</span>) * <span class="hljs-number">20</span> + <span class="hljs-number">10</span>;<span class="hljs-comment">//检查是否在蛇的身上</span>isOk = <span class="hljs-number">1</span>;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;Point&gt; pos = snake-&gt;GetSnakeAllNode();<span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;Point&gt;::iterator it = find(pos.begin(),pos.end(),Point(x,y));<span class="hljs-comment">//find()需要用到Point的重载 == 操作符</span><span class="hljs-keyword">if</span> (it == pos.end())<span class="hljs-comment">//不在</span>&#123;<span class="hljs-keyword">this</span>-&gt;m_pos = Point(x,y);<span class="hljs-comment">//修改坐标</span><span class="hljs-keyword">this</span>-&gt;m_state = <span class="hljs-literal">true</span>;<span class="hljs-keyword">return</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Food::DrawFood</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//红色，全填充，无边框的圆</span>setfillcolor(RED);setfillstyle(BS_SOLID);solidcircle(<span class="hljs-keyword">this</span>-&gt;m_pos.x, <span class="hljs-keyword">this</span>-&gt;m_pos.y, FOOD_RADIU);&#125;</code></pre><h3 id="RankList-h"><a href="#RankList-h" class="headerlink" title="RankList.h"></a>RankList.h</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;common.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RankList</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;PlayerMsg&gt; m_msg;<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> m_rankfile = <span class="hljs-string">&quot;retro&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_RANK = <span class="hljs-number">10</span>;<span class="hljs-keyword">public</span>:RankList();<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SaveMsg</span><span class="hljs-params">(PlayerMsg msg)</span></span>;<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;PlayerMsg&gt; <span class="hljs-title">getRankList</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SaveToRank</span><span class="hljs-params">()</span></span>;<span class="hljs-keyword">private</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WriteTime</span><span class="hljs-params">(PlayerMsg &amp;msg)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ReadFile</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WriteFile</span><span class="hljs-params">()</span></span>;&#125;;</code></pre><h3 id="RankList-cpp"><a href="#RankList-cpp" class="headerlink" title="RankList.cpp"></a>RankList.cpp</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;RankList.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>RankList::RankList()&#123;<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>-&gt;m_msg.empty())&#123;<span class="hljs-keyword">this</span>-&gt;m_msg.clear();&#125;ReadFile();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RankList::SaveMsg</span><span class="hljs-params">(PlayerMsg msg)</span></span><span class="hljs-function"></span>&#123;WriteTime(msg);<span class="hljs-comment">//写入时间</span>m_msg.push_back(msg);<span class="hljs-built_in">std</span>::sort(m_msg.begin(), m_msg.end(), SortPlayerMsg());<span class="hljs-keyword">if</span> (m_msg.size() &gt; <span class="hljs-keyword">this</span>-&gt;MAX_RANK)&#123;m_msg.pop_back();&#125;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;PlayerMsg&gt;::iterator it = m_msg.begin();<span class="hljs-comment">//修改id</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_msg.size(); i++, it++)&#123;it-&gt;id = i + <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;PlayerMsg&gt; <span class="hljs-title">RankList::getRankList</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_msg;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RankList::SaveToRank</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;WriteFile();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RankList::WriteTime</span><span class="hljs-params">(PlayerMsg &amp; msg)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">// 基于当前系统的当前日期/时间</span><span class="hljs-keyword">time_t</span> now = time(<span class="hljs-number">0</span>);<span class="hljs-comment">//1970 到目前经过秒数</span>tm *ltm = localtime(&amp;now);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">stringstream</span> sstream;<span class="hljs-comment">// 输出 tm 结构的各个组成部分</span>sstream &lt;&lt; ltm-&gt;tm_year + <span class="hljs-number">1900</span> - <span class="hljs-number">2000</span> &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;<span class="hljs-comment">//年</span>sstream &lt;&lt; ((ltm-&gt;tm_mon + <span class="hljs-number">1</span> &gt;= <span class="hljs-number">10</span>) ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;0&quot;</span>) &lt;&lt; ltm-&gt;tm_mon + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;<span class="hljs-comment">//月</span>sstream &lt;&lt; ((ltm-&gt;tm_mday &gt;= <span class="hljs-number">10</span>) ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;0&quot;</span>) &lt;&lt; ltm-&gt;tm_mday &lt;&lt; <span class="hljs-string">&quot;_&quot;</span>;<span class="hljs-comment">//日</span>sstream &lt;&lt; ((ltm-&gt;tm_hour &gt;= <span class="hljs-number">10</span>) ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;0&quot;</span>) &lt;&lt; ltm-&gt;tm_hour &lt;&lt; <span class="hljs-string">&quot;:&quot;</span>;<span class="hljs-comment">//时</span>sstream &lt;&lt; ((ltm-&gt;tm_min &gt;= <span class="hljs-number">10</span>) ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;0&quot;</span>) &lt;&lt; ltm-&gt;tm_min;<span class="hljs-comment">//分</span>msg.r_time = sstream.str();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RankList::ReadFile</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">std</span>::ifstream infile;infile.open(m_rankfile, <span class="hljs-built_in">std</span>::ios::in | <span class="hljs-built_in">std</span>::ios::binary);<span class="hljs-keyword">if</span> (!infile)&#123;<span class="hljs-comment">//如果文件不存在，则创建</span><span class="hljs-built_in">std</span>::ofstream os;os.open(m_rankfile);<span class="hljs-comment">//默认会创建</span><span class="hljs-keyword">if</span> (!os)&#123;<span class="hljs-comment">//如果创建失败，只能结束程序</span><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;os.close();&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> line;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">stringstream</span> stream;<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;PlayerMsg msg;<span class="hljs-keyword">while</span> (<span class="hljs-built_in">std</span>::getline(infile, line))&#123;stream.clear();stream.str(line);stream &gt;&gt; msg.id &gt;&gt; msg.score &gt;&gt; msg.len &gt;&gt; msg.r_time;m_msg.push_back(msg);index++;&#125;<span class="hljs-built_in">std</span>::sort(m_msg.begin(), m_msg.end(), SortPlayerMsg());&#125;infile.close();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RankList::WriteFile</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">std</span>::ofstream outfile;outfile.open(m_rankfile, <span class="hljs-built_in">std</span>::ios::out | <span class="hljs-built_in">std</span>::ios::binary); <span class="hljs-comment">//每次写文件都重新写一遍</span><span class="hljs-keyword">if</span> (!outfile)&#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_msg.size(); ++i)&#123;outfile &lt;&lt; m_msg[i].id &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; m_msg[i].score &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; m_msg[i].len&lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; m_msg[i].r_time &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;outfile.close();&#125;</code></pre><h3 id="Game-h"><a href="#Game-h" class="headerlink" title="Game.h"></a>Game.h</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;common.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Snake.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Food.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;RankList.h&quot;</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Game</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:<span class="hljs-keyword">int</span> m_GameState;<span class="hljs-comment">//游戏状态,0在主UI，1在游戏中，2在排行榜，3在游戏规则中</span>PlayerMsg m_msg;<span class="hljs-comment">//游玩数据</span>Snake *m_snake;<span class="hljs-comment">//蛇</span>Food *m_food;<span class="hljs-comment">//食物</span>RankList *m_ranklist;<span class="hljs-comment">//排行榜</span><span class="hljs-keyword">public</span>:Game();<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//初始化</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//控制程序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//关闭程序，释放资源</span><span class="hljs-keyword">private</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitData</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//初始化数据</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PlayGame</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//开始游戏</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowMainUI</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//展示主UI</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowRank</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//排行榜展示</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowRule</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//展示规则界面</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawGamePlay</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绘制初始游戏界面</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawScore</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绘制分数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawSnakeLen</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绘制长度</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawSpeed</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绘制速度</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawRunning</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绘制正在运行</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawPause</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绘制暂停提示</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawRebegin</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绘制重新开始</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawGameOver</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绘制游戏结束</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ChangeChooseUI</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom, <span class="hljs-keyword">int</span> kind)</span></span>;<span class="hljs-comment">//修改选中的选项颜色</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ClearRegion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom)</span></span>;<span class="hljs-comment">//使用黑色清除指定区域</span>&#125;;</code></pre><h3 id="Game-cpp"><a href="#Game-cpp" class="headerlink" title="Game.cpp"></a>Game.cpp</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Game.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;graphics.h&gt;</span></span>Game::Game()&#123;<span class="hljs-keyword">this</span>-&gt;m_snake = <span class="hljs-literal">nullptr</span>;<span class="hljs-keyword">this</span>-&gt;m_food = <span class="hljs-literal">nullptr</span>;<span class="hljs-keyword">this</span>-&gt;m_GameState = <span class="hljs-number">0</span>;<span class="hljs-keyword">this</span>-&gt;m_msg = PlayerMsg();<span class="hljs-keyword">this</span>-&gt;m_ranklist = <span class="hljs-keyword">new</span> RankList();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Game::Init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;initgraph(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Game::Run</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;ShowMainUI();<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<span class="hljs-keyword">if</span> (m_GameState == <span class="hljs-number">0</span> &amp;&amp; MouseHit())<span class="hljs-comment">//在主界面点击鼠标</span>&#123;MOUSEMSG mouse = GetMouseMsg();<span class="hljs-comment">//获取鼠标点击消息</span><span class="hljs-keyword">if</span> (mouse.mkLButton)&#123;<span class="hljs-keyword">if</span> (mouse.x &gt;= <span class="hljs-number">240</span> &amp;&amp; mouse.x &lt;= <span class="hljs-number">400</span> &amp;&amp; mouse.y &gt;= <span class="hljs-number">195</span> &amp;&amp; mouse.y &lt;= <span class="hljs-number">235</span>)&#123;<span class="hljs-comment">//如果点击到了开始选项</span>ChangeChooseUI(<span class="hljs-number">240</span>, <span class="hljs-number">195</span>, <span class="hljs-number">400</span>, <span class="hljs-number">235</span>, <span class="hljs-number">1</span>);m_GameState = <span class="hljs-number">1</span>;FlushMouseMsgBuffer();<span class="hljs-comment">//清空鼠标消息缓冲区。</span>Sleep(<span class="hljs-number">500</span>);PlayGame();&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mouse.x &gt;= <span class="hljs-number">240</span> &amp;&amp; mouse.x &lt;= <span class="hljs-number">400</span> &amp;&amp; mouse.y &gt;= <span class="hljs-number">255</span> &amp;&amp; mouse.y &lt;= <span class="hljs-number">295</span>)&#123;<span class="hljs-comment">//排行榜选项</span>ChangeChooseUI(<span class="hljs-number">240</span>, <span class="hljs-number">255</span>, <span class="hljs-number">400</span>, <span class="hljs-number">295</span>, <span class="hljs-number">2</span>);m_GameState = <span class="hljs-number">2</span>;FlushMouseMsgBuffer();<span class="hljs-comment">//清空鼠标消息缓冲区。</span>Sleep(<span class="hljs-number">500</span>);ShowRank();&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mouse.x &gt;= <span class="hljs-number">240</span> &amp;&amp; mouse.x &lt;= <span class="hljs-number">400</span> &amp;&amp; mouse.y &gt;= <span class="hljs-number">315</span> &amp;&amp; mouse.y &lt;= <span class="hljs-number">355</span>)&#123;<span class="hljs-comment">//帮助选项</span>ChangeChooseUI(<span class="hljs-number">240</span>, <span class="hljs-number">315</span>, <span class="hljs-number">400</span>, <span class="hljs-number">355</span>, <span class="hljs-number">3</span>);m_GameState = <span class="hljs-number">3</span>;FlushMouseMsgBuffer();<span class="hljs-comment">//清空鼠标消息缓冲区。</span>Sleep(<span class="hljs-number">500</span>);ShowRule();&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mouse.x &gt;= <span class="hljs-number">240</span> &amp;&amp; mouse.x &lt;= <span class="hljs-number">400</span> &amp;&amp; mouse.y &gt;= <span class="hljs-number">375</span> &amp;&amp; mouse.y &lt;= <span class="hljs-number">415</span>)&#123;<span class="hljs-comment">//退出选项</span>ChangeChooseUI(<span class="hljs-number">240</span>, <span class="hljs-number">375</span>, <span class="hljs-number">400</span>, <span class="hljs-number">415</span>, <span class="hljs-number">4</span>);Sleep(<span class="hljs-number">1000</span>);<span class="hljs-keyword">return</span>;&#125;&#125;&#125;<span class="hljs-keyword">if</span> ((m_GameState == <span class="hljs-number">2</span> || m_GameState == <span class="hljs-number">3</span>) &amp;&amp; MouseHit()) <span class="hljs-comment">//在排行榜或者游戏帮助中点击</span>&#123;MOUSEMSG mouse = GetMouseMsg();<span class="hljs-comment">//获取鼠标点击消息</span><span class="hljs-keyword">if</span> (mouse.mkLButton)&#123;<span class="hljs-keyword">if</span> (mouse.x &gt;= <span class="hljs-number">20</span> &amp;&amp; mouse.x &lt;= <span class="hljs-number">63</span> &amp;&amp; mouse.y &gt;= <span class="hljs-number">20</span> &amp;&amp; mouse.y &lt;= <span class="hljs-number">43</span>)&#123;<span class="hljs-comment">//点击返回选项</span>ChangeChooseUI(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">63</span>, <span class="hljs-number">43</span>, <span class="hljs-number">5</span>);Sleep(<span class="hljs-number">500</span>);FlushMouseMsgBuffer();<span class="hljs-comment">//清空鼠标消息缓冲区。</span>m_GameState = <span class="hljs-number">0</span>;ShowMainUI();&#125;&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Game::Close</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;closegraph();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Game::InitData</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_snake != <span class="hljs-literal">nullptr</span>)&#123;<span class="hljs-keyword">delete</span>(<span class="hljs-keyword">this</span>-&gt;m_snake);<span class="hljs-keyword">this</span>-&gt;m_snake = <span class="hljs-literal">nullptr</span>;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_food != <span class="hljs-literal">nullptr</span>)&#123;<span class="hljs-keyword">delete</span>(<span class="hljs-keyword">this</span>-&gt;m_food);<span class="hljs-keyword">this</span>-&gt;m_food = <span class="hljs-literal">nullptr</span>;&#125;<span class="hljs-keyword">this</span>-&gt;m_msg = PlayerMsg();<span class="hljs-keyword">this</span>-&gt;m_snake = <span class="hljs-keyword">new</span> Snake();<span class="hljs-keyword">this</span>-&gt;m_food = <span class="hljs-keyword">new</span> Food();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Game::PlayGame</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;InitData();DrawGamePlay();BeginBatchDraw();<span class="hljs-keyword">bool</span> backMainUI = <span class="hljs-literal">false</span>;<span class="hljs-keyword">bool</span> rePlayGame = <span class="hljs-literal">false</span>;<span class="hljs-keyword">bool</span> changeShowData = <span class="hljs-literal">false</span>;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;changeShowData = <span class="hljs-literal">false</span>;<span class="hljs-comment">//食物</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_food-&gt;getState() == <span class="hljs-literal">false</span>)&#123;m_food-&gt;Generate(<span class="hljs-keyword">this</span>-&gt;m_snake);m_food-&gt;DrawFood();&#125;<span class="hljs-comment">//按键检测</span><span class="hljs-keyword">if</span> (_kbhit())&#123;<span class="hljs-keyword">char</span> key = _getch();<span class="hljs-keyword">switch</span> (key)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">72</span>:  <span class="hljs-comment">//↑</span><span class="hljs-keyword">case</span> <span class="hljs-number">119</span>: <span class="hljs-comment">//w</span>m_snake-&gt;ChangeDir(Dir::DIR_UP);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">80</span>:  <span class="hljs-comment">//↓</span><span class="hljs-keyword">case</span> <span class="hljs-number">115</span>: <span class="hljs-comment">//s</span>m_snake-&gt;ChangeDir(Dir::DIR_DOWN);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">75</span>: <span class="hljs-comment">//←</span><span class="hljs-keyword">case</span> <span class="hljs-number">97</span>: <span class="hljs-comment">//a</span>m_snake-&gt;ChangeDir(Dir::DIR_LEFT);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">77</span>:  <span class="hljs-comment">//→</span><span class="hljs-keyword">case</span> <span class="hljs-number">100</span>: <span class="hljs-comment">//d</span>m_snake-&gt;ChangeDir(Dir::DIR_RIGHT);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">99</span>: <span class="hljs-comment">//c 加速</span>changeShowData = m_snake-&gt;setSpeed(m_snake-&gt;getSpeed() + <span class="hljs-number">1</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">120</span>:<span class="hljs-comment">//x 减速</span>changeShowData = m_snake-&gt;setSpeed(m_snake-&gt;getSpeed() - <span class="hljs-number">1</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">122</span>:<span class="hljs-comment">//z 回归原速</span>changeShowData = m_snake-&gt;setSpeed(m_snake-&gt;OrgSpeed);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">32</span>: <span class="hljs-comment">//空格暂停</span>DrawPause();<span class="hljs-comment">//状态区显示</span>FlushBatchDraw();<span class="hljs-comment">//立即批量绘制</span><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<span class="hljs-keyword">if</span> (_kbhit())&#123;<span class="hljs-keyword">char</span> key = _getch();<span class="hljs-keyword">if</span> (key == <span class="hljs-number">32</span>)<span class="hljs-comment">//按空格继续</span>&#123;ClearRegion(<span class="hljs-number">505</span>, <span class="hljs-number">240</span>, <span class="hljs-number">640</span>, <span class="hljs-number">480</span>);DrawRunning();<span class="hljs-comment">//绘制程序正在运行中</span>FlushBatchDraw();<span class="hljs-comment">//立即批量绘制</span><span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-number">27</span>) <span class="hljs-comment">//esc键 退出</span>&#123;ChangeChooseUI(<span class="hljs-number">510</span>, <span class="hljs-number">347</span>, <span class="hljs-number">588</span>, <span class="hljs-number">373</span>, <span class="hljs-number">6</span>);FlushBatchDraw();<span class="hljs-comment">//立即批量绘制</span>Sleep(<span class="hljs-number">500</span>);backMainUI = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (MouseHit())&#123;MOUSEMSG mouse = GetMouseMsg();<span class="hljs-comment">//获取鼠标点击消息</span><span class="hljs-keyword">if</span> (mouse.mkLButton)&#123;<span class="hljs-keyword">if</span> (mouse.x &gt;= <span class="hljs-number">510</span> &amp;&amp; mouse.x &lt;= <span class="hljs-number">588</span> &amp;&amp; mouse.y &gt;= <span class="hljs-number">347</span> &amp;&amp; mouse.y &lt;= <span class="hljs-number">373</span>)&#123;<span class="hljs-comment">//点击返回选项</span>ChangeChooseUI(<span class="hljs-number">510</span>, <span class="hljs-number">347</span>, <span class="hljs-number">588</span>, <span class="hljs-number">373</span>, <span class="hljs-number">6</span>);FlushBatchDraw();<span class="hljs-comment">//立即批量绘制</span>Sleep(<span class="hljs-number">500</span>);backMainUI = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-comment">//如果要回到主UI</span><span class="hljs-keyword">if</span> (backMainUI)&#123;FlushMouseMsgBuffer();<span class="hljs-comment">//清空鼠标消息缓冲区。</span><span class="hljs-keyword">break</span>;<span class="hljs-comment">//跳出主循环</span>&#125;&#125;<span class="hljs-comment">//更新显示数据</span><span class="hljs-keyword">if</span> (changeShowData)&#123;ClearRegion(<span class="hljs-number">505</span>, <span class="hljs-number">115</span>, <span class="hljs-number">640</span>, <span class="hljs-number">200</span>);DrawScore();DrawSnakeLen();DrawSpeed();&#125;<span class="hljs-comment">//移动</span>m_snake-&gt;Move();<span class="hljs-comment">//吃食物</span><span class="hljs-keyword">if</span> (m_snake-&gt;ColideFood(m_food-&gt;getPos()))&#123;m_snake-&gt;EatFood();<span class="hljs-keyword">this</span>-&gt;m_food-&gt;setState(<span class="hljs-literal">false</span>);<span class="hljs-comment">//分数增加，长度增加</span><span class="hljs-keyword">this</span>-&gt;m_msg.score += <span class="hljs-number">10</span>;<span class="hljs-comment">//更新数据</span>ClearRegion(<span class="hljs-number">505</span>, <span class="hljs-number">115</span>, <span class="hljs-number">640</span>, <span class="hljs-number">200</span>);DrawScore();DrawSnakeLen();DrawSpeed();&#125;<span class="hljs-comment">//碰撞检测</span><span class="hljs-keyword">if</span> (m_snake-&gt;ColideWall(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">470</span>, <span class="hljs-number">470</span>) || m_snake-&gt;ColideSnake())&#123;<span class="hljs-comment">////游戏结束</span>m_snake-&gt;Dead();<span class="hljs-comment">//清空游戏区，重绘死去的蛇</span>ClearRegion(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">479</span>, <span class="hljs-number">480</span>);m_snake-&gt;DrawSnake();<span class="hljs-comment">//绘制重新开始</span>DrawRebegin();<span class="hljs-comment">//绘制GameOVer</span>DrawGameOver();FlushBatchDraw();<span class="hljs-comment">//批量绘制</span><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<span class="hljs-keyword">if</span> (_kbhit())&#123;<span class="hljs-keyword">char</span> key = _getch();<span class="hljs-keyword">if</span> (key == <span class="hljs-number">32</span>)<span class="hljs-comment">//按空格继续</span>&#123;<span class="hljs-comment">//点击再来一局选项</span>ChangeChooseUI(<span class="hljs-number">510</span>, <span class="hljs-number">397</span>, <span class="hljs-number">588</span>, <span class="hljs-number">423</span>, <span class="hljs-number">7</span>);FlushBatchDraw();<span class="hljs-comment">//立即批量绘制</span>Sleep(<span class="hljs-number">500</span>);rePlayGame = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-number">27</span>) <span class="hljs-comment">//esc键 退出</span>&#123;ChangeChooseUI(<span class="hljs-number">510</span>, <span class="hljs-number">347</span>, <span class="hljs-number">588</span>, <span class="hljs-number">373</span>, <span class="hljs-number">6</span>);FlushBatchDraw();<span class="hljs-comment">//立即批量绘制</span>Sleep(<span class="hljs-number">500</span>);backMainUI = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (MouseHit())&#123;MOUSEMSG mouse = GetMouseMsg();<span class="hljs-comment">//获取鼠标点击消息</span><span class="hljs-keyword">if</span> (mouse.mkLButton)&#123;<span class="hljs-keyword">if</span> (mouse.x &gt;= <span class="hljs-number">510</span> &amp;&amp; mouse.x &lt;= <span class="hljs-number">588</span> &amp;&amp; mouse.y &gt;= <span class="hljs-number">347</span> &amp;&amp; mouse.y &lt;= <span class="hljs-number">373</span>)&#123;<span class="hljs-comment">//点击返回选项</span>ChangeChooseUI(<span class="hljs-number">510</span>, <span class="hljs-number">347</span>, <span class="hljs-number">588</span>, <span class="hljs-number">373</span>, <span class="hljs-number">6</span>);FlushBatchDraw();<span class="hljs-comment">//立即批量绘制</span>Sleep(<span class="hljs-number">500</span>);backMainUI = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mouse.x &gt;= <span class="hljs-number">510</span> &amp;&amp; mouse.x &lt;= <span class="hljs-number">588</span> &amp;&amp; mouse.y &gt;= <span class="hljs-number">397</span> &amp;&amp; mouse.y &lt;= <span class="hljs-number">423</span>)&#123;<span class="hljs-comment">//点击再来一局选项</span>ChangeChooseUI(<span class="hljs-number">510</span>, <span class="hljs-number">397</span>, <span class="hljs-number">588</span>, <span class="hljs-number">423</span>, <span class="hljs-number">7</span>);FlushBatchDraw();<span class="hljs-comment">//立即批量绘制</span>Sleep(<span class="hljs-number">500</span>);rePlayGame = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;<span class="hljs-comment">//如果要回到主UI</span><span class="hljs-keyword">if</span> (backMainUI)&#123;FlushMouseMsgBuffer();<span class="hljs-comment">//清空鼠标消息缓冲区。</span><span class="hljs-keyword">break</span>;<span class="hljs-comment">//跳出主循环</span>&#125;<span class="hljs-comment">//如果要重新开始游戏</span><span class="hljs-keyword">if</span> (rePlayGame)&#123;FlushMouseMsgBuffer();<span class="hljs-comment">//清空鼠标消息缓冲区。</span><span class="hljs-keyword">break</span>;<span class="hljs-comment">//跳出主循环</span>&#125;&#125;<span class="hljs-comment">//清空屏幕</span>setbkcolor(BG_COLOR);<span class="hljs-comment">//设置背景色</span>ClearRegion(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">479</span>, <span class="hljs-number">480</span>);<span class="hljs-keyword">this</span>-&gt;m_snake-&gt;DrawSnake();<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_food-&gt;getState() == <span class="hljs-literal">true</span>)&#123;m_food-&gt;DrawFood();&#125;FlushBatchDraw();<span class="hljs-comment">//立即批量绘制</span><span class="hljs-keyword">int</span> sleep = <span class="hljs-number">30</span> - m_snake-&gt;getSpeed();Sleep(sleep * <span class="hljs-number">10</span>);&#125;EndBatchDraw();<span class="hljs-comment">//结束批量绘制</span><span class="hljs-comment">//如果要回到主UI</span><span class="hljs-keyword">if</span> (backMainUI)&#123;m_msg.len = m_snake-&gt;getLen();m_ranklist-&gt;SaveMsg(m_msg);m_ranklist-&gt;SaveToRank();m_GameState = <span class="hljs-number">0</span>;ShowMainUI();&#125;<span class="hljs-comment">//如果要重新开始游戏</span><span class="hljs-keyword">if</span> (rePlayGame)&#123;m_msg.len = m_snake-&gt;getLen();m_ranklist-&gt;SaveMsg(m_msg);m_ranklist-&gt;SaveToRank();PlayGame();&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Game::ShowMainUI</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//清空屏幕</span>setbkcolor(BG_COLOR);<span class="hljs-comment">//设置背景色</span>cleardevice();<span class="hljs-comment">/*--------------绘制标题----------*/</span>settextstyle(<span class="hljs-number">80</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;微软雅黑&quot;</span>);settextcolor(<span class="hljs-number">0XFFFFFF</span>);outtextxy(<span class="hljs-number">230</span>, <span class="hljs-number">60</span>, <span class="hljs-string">L&quot;贪吃蛇&quot;</span>);settextstyle(<span class="hljs-number">18</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;微软雅黑&quot;</span>);outtextxy(<span class="hljs-number">380</span>, <span class="hljs-number">140</span>, <span class="hljs-string">L&quot;By Colourso&quot;</span>);settextstyle(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;微软雅黑&quot;</span>);settextcolor(<span class="hljs-number">0XFF5555</span>);outtextxy(<span class="hljs-number">365</span>, <span class="hljs-number">160</span>, <span class="hljs-string">L&quot;(www.colourso.top)&quot;</span>);settextcolor(<span class="hljs-number">0XFFFFFF</span>);<span class="hljs-comment">/*--------------绘制选项----------*/</span>setlinecolor(<span class="hljs-number">0xFF00FF</span>);rectangle(<span class="hljs-number">240</span>, <span class="hljs-number">195</span>, <span class="hljs-number">400</span>, <span class="hljs-number">235</span>);rectangle(<span class="hljs-number">240</span>, <span class="hljs-number">255</span>, <span class="hljs-number">400</span>, <span class="hljs-number">295</span>);rectangle(<span class="hljs-number">240</span>, <span class="hljs-number">315</span>, <span class="hljs-number">400</span>, <span class="hljs-number">355</span>);rectangle(<span class="hljs-number">240</span>, <span class="hljs-number">375</span>, <span class="hljs-number">400</span>, <span class="hljs-number">415</span>);settextstyle(<span class="hljs-number">28</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;微软雅黑&quot;</span>);settextcolor(<span class="hljs-number">0x55FFFF</span>);<span class="hljs-comment">//黄色</span>outtextxy(<span class="hljs-number">297</span>, <span class="hljs-number">200</span>, <span class="hljs-string">L&quot;开始&quot;</span>);outtextxy(<span class="hljs-number">287</span>, <span class="hljs-number">260</span>, <span class="hljs-string">L&quot;排行榜&quot;</span>);outtextxy(<span class="hljs-number">297</span>, <span class="hljs-number">320</span>, <span class="hljs-string">L&quot;帮助&quot;</span>);outtextxy(<span class="hljs-number">297</span>, <span class="hljs-number">380</span>, <span class="hljs-string">L&quot;退出&quot;</span>);settextstyle(<span class="hljs-number">24</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;微软雅黑&quot;</span>);settextcolor(<span class="hljs-number">0xAAAAAA</span>);outtextxy(<span class="hljs-number">255</span>, <span class="hljs-number">450</span>, <span class="hljs-string">L&quot;(鼠标点击选项)&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CharToTCHAR</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * _char, TCHAR * tchar)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> iLength;iLength = MultiByteToWideChar(CP_UTF8, <span class="hljs-number">0</span>, _char, <span class="hljs-built_in">strlen</span>(_char) + <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);MultiByteToWideChar(CP_UTF8, <span class="hljs-number">0</span>, _char, <span class="hljs-built_in">strlen</span>(_char) + <span class="hljs-number">1</span>, tchar, iLength);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Game::ShowRank</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//清空屏幕</span>setbkcolor(BG_COLOR);<span class="hljs-comment">//设置背景色</span>cleardevice();<span class="hljs-comment">/*--------------绘制规则----------*/</span>settextstyle(<span class="hljs-number">60</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;微软雅黑&quot;</span>);settextcolor(<span class="hljs-number">0XFFFFFF</span>);outtextxy(<span class="hljs-number">160</span>, <span class="hljs-number">40</span>, <span class="hljs-string">L&quot;贪吃蛇排行榜&quot;</span>);<span class="hljs-comment">/*--------------绘制返回键----------*/</span>setlinecolor(<span class="hljs-number">0xFFFFFF</span>);rectangle(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">63</span>, <span class="hljs-number">43</span>);settextcolor(<span class="hljs-number">0XFFFFFF</span>);settextstyle(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">22</span>, <span class="hljs-number">22</span>, <span class="hljs-string">L&quot; ← &quot;</span>);<span class="hljs-comment">/*---------------绘制排行榜信息---------------*/</span>settextcolor(<span class="hljs-number">0XFFFFFF</span>);settextstyle(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">140</span>, <span class="hljs-number">120</span>, <span class="hljs-string">L&quot;排名&quot;</span>);outtextxy(<span class="hljs-number">240</span>, <span class="hljs-number">120</span>, <span class="hljs-string">L&quot;分数&quot;</span>);outtextxy(<span class="hljs-number">340</span>, <span class="hljs-number">120</span>, <span class="hljs-string">L&quot;长度&quot;</span>);outtextxy(<span class="hljs-number">490</span>, <span class="hljs-number">120</span>, <span class="hljs-string">L&quot;日期&quot;</span>);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;PlayerMsg&gt; msg = m_ranklist-&gt;getRankList();<span class="hljs-keyword">if</span> (msg.size() == <span class="hljs-number">0</span>)&#123;settextcolor(<span class="hljs-number">0x5555FF</span>);settextstyle(<span class="hljs-number">40</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">230</span>, <span class="hljs-number">200</span>, <span class="hljs-string">L&quot;暂无排名&quot;</span>);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; msg.size(); ++i)&#123;<span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)&#123;settextcolor(<span class="hljs-number">0x5555FF</span>);settextstyle(<span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);&#125;<span class="hljs-keyword">else</span>&#123;settextcolor(<span class="hljs-number">0XFFFFFF</span>);settextstyle(<span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);&#125;TCHAR t[<span class="hljs-number">40</span>];_stprintf_s(t, _T(<span class="hljs-string">&quot;%d&quot;</span>), msg[i].id);outtextxy(<span class="hljs-number">145</span>, <span class="hljs-number">150</span> + <span class="hljs-number">30</span> * i, t);_stprintf_s(t, _T(<span class="hljs-string">&quot;%d&quot;</span>), msg[i].score);outtextxy(<span class="hljs-number">245</span>, <span class="hljs-number">150</span> + <span class="hljs-number">30</span> * i, t);_stprintf_s(t, _T(<span class="hljs-string">&quot;%d&quot;</span>), msg[i].len);outtextxy(<span class="hljs-number">345</span>, <span class="hljs-number">150</span> + <span class="hljs-number">30</span> * i, t);<span class="hljs-comment">//_stprintf_s(t, _T(&quot;%s&quot;), msg[i].r_time.c_str());</span>CharToTCHAR(msg[i].r_time.c_str(), t);outtextxy(<span class="hljs-number">450</span>, <span class="hljs-number">150</span> + <span class="hljs-number">30</span> * i, t);settextcolor(<span class="hljs-number">0XFFFFFF</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Game::ShowRule</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//清空屏幕</span>setbkcolor(BG_COLOR);<span class="hljs-comment">//设置背景色黑色</span>cleardevice();<span class="hljs-comment">/*--------------绘制规则----------*/</span>settextstyle(<span class="hljs-number">60</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;微软雅黑&quot;</span>);settextcolor(<span class="hljs-number">0XFFFFFF</span>);outtextxy(<span class="hljs-number">160</span>, <span class="hljs-number">40</span>, <span class="hljs-string">L&quot;贪吃蛇按键介绍&quot;</span>);settextcolor(<span class="hljs-number">0XFFFFFF</span>);settextstyle(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">230</span>, <span class="hljs-number">150</span>, <span class="hljs-string">L&quot;↑ ← ↓ → 控制方向&quot;</span>);outtextxy(<span class="hljs-number">230</span>, <span class="hljs-number">180</span>, <span class="hljs-string">L&quot;w  a  s  d  控制方向&quot;</span>);outtextxy(<span class="hljs-number">230</span>, <span class="hljs-number">210</span>, <span class="hljs-string">L&quot;速度等级1-25，默认12&quot;</span>);outtextxy(<span class="hljs-number">240</span>, <span class="hljs-number">240</span>, <span class="hljs-string">L&quot;c键加速，x键减速&quot;</span>);outtextxy(<span class="hljs-number">240</span>, <span class="hljs-number">270</span>, <span class="hljs-string">L&quot;z键恢复原始速度&quot;</span>);outtextxy(<span class="hljs-number">240</span>, <span class="hljs-number">300</span>, <span class="hljs-string">L&quot;空格键暂停/继续&quot;</span>);outtextxy(<span class="hljs-number">180</span>, <span class="hljs-number">350</span>, <span class="hljs-string">L&quot;请将输入法调至英文输入法状态下&quot;</span>);<span class="hljs-comment">/*--------------绘制返回键----------*/</span>setlinecolor(<span class="hljs-number">0xFFFFFF</span>);rectangle(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">63</span>, <span class="hljs-number">43</span>);settextcolor(<span class="hljs-number">0XFFFFFF</span>);settextstyle(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">22</span>, <span class="hljs-number">22</span>, <span class="hljs-string">L&quot; ← &quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Game::DrawGamePlay</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//清空屏幕</span>setbkcolor(BG_COLOR);<span class="hljs-comment">//设置背景色</span>cleardevice();<span class="hljs-comment">//画宽度为2的棕色实线，分割游戏区</span>setlinecolor(BROWN);setlinestyle(PS_SOLID, <span class="hljs-number">2</span>);line(<span class="hljs-number">482</span>, <span class="hljs-number">0</span>, <span class="hljs-number">482</span>, <span class="hljs-number">480</span>);<span class="hljs-comment">//画蛇和食物</span><span class="hljs-keyword">this</span>-&gt;m_snake-&gt;DrawSnake();<span class="hljs-comment">//绘制分数</span>DrawScore();<span class="hljs-comment">//绘制蛇身长度</span>DrawSnakeLen();<span class="hljs-comment">//绘制速度</span>DrawSpeed();<span class="hljs-comment">//绘制游戏状态</span>DrawRunning();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Game::DrawScore</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;TCHAR s[] = _T(<span class="hljs-string">&quot;获得分数：&quot;</span>);settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, _T(<span class="hljs-string">&quot;宋体&quot;</span>));settextcolor(<span class="hljs-number">0xFFFFFF</span>);<span class="hljs-comment">//白</span>outtextxy(<span class="hljs-number">510</span>, <span class="hljs-number">120</span>, s);settextcolor(<span class="hljs-number">0xFF5555</span>);<span class="hljs-comment">//亮蓝</span>TCHAR t[<span class="hljs-number">5</span>];_stprintf_s(t, _T(<span class="hljs-string">&quot;%d&quot;</span>), m_msg.score); <span class="hljs-comment">// 高版本 VC 推荐使用 _stprintf_s 函数</span>outtextxy(<span class="hljs-number">590</span>, <span class="hljs-number">120</span>, t);settextcolor(<span class="hljs-number">0xFFFFFF</span>);<span class="hljs-comment">//白</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Game::DrawSnakeLen</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">510</span>, <span class="hljs-number">150</span>, <span class="hljs-string">L&quot;蛇身长度：&quot;</span>);settextcolor(<span class="hljs-number">0xFF55FF</span>);<span class="hljs-comment">//亮紫</span>TCHAR t[<span class="hljs-number">5</span>];_stprintf_s(t, _T(<span class="hljs-string">&quot;%d&quot;</span>), m_snake-&gt;getLen()); <span class="hljs-comment">// 高版本 VC 推荐使用 _stprintf_s 函数</span>outtextxy(<span class="hljs-number">590</span>, <span class="hljs-number">150</span>, t);settextcolor(<span class="hljs-number">0xFFFFFF</span>);<span class="hljs-comment">//白</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Game::DrawSpeed</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;TCHAR s[] = _T(<span class="hljs-string">&quot;当前速度：&quot;</span>);settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, _T(<span class="hljs-string">&quot;宋体&quot;</span>));outtextxy(<span class="hljs-number">510</span>, <span class="hljs-number">180</span>, s);<span class="hljs-keyword">int</span> speed = m_snake-&gt;getSpeed();<span class="hljs-comment">//速度等级显示为1 - 25</span><span class="hljs-keyword">if</span> (speed &lt;= <span class="hljs-number">9</span>)&#123;settextcolor(<span class="hljs-number">0x00AA00</span>);<span class="hljs-comment">//禄</span>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (speed &gt;= <span class="hljs-number">18</span>)&#123;settextcolor(<span class="hljs-number">0x0000AA</span>);<span class="hljs-comment">//红</span>&#125;<span class="hljs-keyword">else</span>&#123;settextcolor(<span class="hljs-number">0x55FFFF</span>);<span class="hljs-comment">//黄</span>&#125;TCHAR t[<span class="hljs-number">5</span>];_stprintf_s(t, _T(<span class="hljs-string">&quot;%d&quot;</span>), speed); <span class="hljs-comment">// 高版本 VC 推荐使用 _stprintf_s 函数</span>outtextxy(<span class="hljs-number">590</span>, <span class="hljs-number">180</span>, t);settextcolor(<span class="hljs-number">0xFFFFFF</span>);<span class="hljs-comment">//白</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Game::DrawRunning</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;settextcolor(<span class="hljs-number">0x55FF55</span>);<span class="hljs-comment">//亮绿</span>settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">510</span>, <span class="hljs-number">250</span>, <span class="hljs-string">L&quot;游戏 运行&quot;</span>);outtextxy(<span class="hljs-number">510</span>, <span class="hljs-number">280</span>, <span class="hljs-string">L&quot;祝玩的开心&quot;</span>);settextcolor(<span class="hljs-number">0xFFFFFF</span>);<span class="hljs-comment">//白</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Game::DrawPause</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;settextcolor(<span class="hljs-number">0xFF55FF</span>);<span class="hljs-comment">//亮紫</span>settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">510</span>, <span class="hljs-number">250</span>, <span class="hljs-string">L&quot;游戏 暂停&quot;</span>);outtextxy(<span class="hljs-number">510</span>, <span class="hljs-number">280</span>, <span class="hljs-string">L&quot;空格键继续&quot;</span>);outtextxy(<span class="hljs-number">510</span>, <span class="hljs-number">310</span>, <span class="hljs-string">L&quot;Esc键退出&quot;</span>);settextcolor(<span class="hljs-number">0xFFFFFF</span>);<span class="hljs-comment">//白</span>setlinecolor(<span class="hljs-number">0xFFFFFF</span>);rectangle(<span class="hljs-number">510</span>, <span class="hljs-number">347</span>, <span class="hljs-number">588</span>, <span class="hljs-number">373</span>);settextcolor(<span class="hljs-number">0XFFFFFF</span>);settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">517</span>, <span class="hljs-number">352</span>, <span class="hljs-string">L&quot;退出游戏&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Game::DrawRebegin</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;settextcolor(<span class="hljs-number">0x5555FF</span>);<span class="hljs-comment">//亮红</span>settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">510</span>, <span class="hljs-number">250</span>, <span class="hljs-string">L&quot;游戏 结束&quot;</span>);outtextxy(<span class="hljs-number">510</span>, <span class="hljs-number">280</span>, <span class="hljs-string">L&quot;空格键再来一局&quot;</span>);outtextxy(<span class="hljs-number">510</span>, <span class="hljs-number">310</span>, <span class="hljs-string">L&quot;Esc键退出&quot;</span>);settextcolor(<span class="hljs-number">0xFFFFFF</span>);<span class="hljs-comment">//白</span>setlinecolor(<span class="hljs-number">0xFFFFFF</span>);rectangle(<span class="hljs-number">510</span>, <span class="hljs-number">347</span>, <span class="hljs-number">588</span>, <span class="hljs-number">373</span>);rectangle(<span class="hljs-number">510</span>, <span class="hljs-number">397</span>, <span class="hljs-number">588</span>, <span class="hljs-number">423</span>);settextcolor(<span class="hljs-number">0XFFFFFF</span>);settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">517</span>, <span class="hljs-number">352</span>, <span class="hljs-string">L&quot;退出游戏&quot;</span>);outtextxy(<span class="hljs-number">517</span>, <span class="hljs-number">402</span>, <span class="hljs-string">L&quot;再来一局&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Game::DrawGameOver</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;settextcolor(<span class="hljs-number">0xFFFFFF</span>);<span class="hljs-comment">//亮红</span>settextstyle(<span class="hljs-number">48</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">170</span>, <span class="hljs-number">210</span>, <span class="hljs-string">L&quot;GAMEOVER&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Game::ChangeChooseUI</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom, <span class="hljs-keyword">int</span> kind)</span></span><span class="hljs-function"></span>&#123;setfillcolor(<span class="hljs-number">0XFFFFFF</span>);<span class="hljs-comment">//使用白色填充这一区域</span>fillrectangle(left, top, right, bottom);setlinecolor(<span class="hljs-number">0x55FF55</span>);<span class="hljs-comment">//画线边框设置为亮绿色</span>rectangle(left, top, right, bottom);settextstyle(<span class="hljs-number">28</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;微软雅黑&quot;</span>);settextcolor(<span class="hljs-number">0xFF5555</span>);<span class="hljs-comment">//亮蓝色</span>setbkcolor(<span class="hljs-number">0XFFFFFF</span>);<span class="hljs-comment">//设置背景色为白色，文字的背景色就会变成白色</span><span class="hljs-keyword">switch</span> (kind)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:outtextxy(<span class="hljs-number">297</span>, <span class="hljs-number">200</span>, <span class="hljs-string">L&quot;开始&quot;</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:outtextxy(<span class="hljs-number">287</span>, <span class="hljs-number">260</span>, <span class="hljs-string">L&quot;排行榜&quot;</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:outtextxy(<span class="hljs-number">297</span>, <span class="hljs-number">320</span>, <span class="hljs-string">L&quot;帮助&quot;</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:outtextxy(<span class="hljs-number">297</span>, <span class="hljs-number">380</span>, <span class="hljs-string">L&quot;退出&quot;</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:settextcolor(<span class="hljs-number">0</span>);settextstyle(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">22</span>, <span class="hljs-number">22</span>, <span class="hljs-string">L&quot; ← &quot;</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:settextcolor(<span class="hljs-number">0</span>);settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">517</span>, <span class="hljs-number">352</span>, <span class="hljs-string">L&quot;退出游戏&quot;</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:settextcolor(<span class="hljs-number">0</span>);settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">517</span>, <span class="hljs-number">402</span>, <span class="hljs-string">L&quot;再来一局&quot;</span>);<span class="hljs-keyword">break</span>;&#125;setbkcolor(BG_COLOR);<span class="hljs-comment">//恢复背景色</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Game::ClearRegion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//黑色，全填充，无边框的矩形</span>setfillcolor(BG_COLOR);setfillstyle(BS_SOLID);solidrectangle(left, top, right, bottom);&#125;</code></pre><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Snake.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Game.h&quot;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;Game game;game.Init();game.Run();game.Close();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="程序展示"><a href="#程序展示" class="headerlink" title="程序展示"></a>程序展示</h2><p>以下是B站视频</p><iframe src="//player.bilibili.com/player.html?aid=371573766&bvid=BV1fZ4y1T7xo&cid=218646009&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" style="height: 430px; max-width: 100%"> </iframe>上面视频不能播放请移步：https://www.bilibili.com/video/BV1fZ4y1T7xo/<h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><p>百度链接：<a href="https://pan.baidu.com/s/1mUupX0KVOY7W3W2G_OyjmQ">https://pan.baidu.com/s/1mUupX0KVOY7W3W2G_OyjmQ</a><br>提取码：p7qi</p><p>Github地址：<a href="https://github.com/Colourso/Simple-CPP-project-by-Colourso/">https://github.com/Colourso/Simple-CPP-project-by-Colourso/</a></p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>文件下载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基于EasyX制作贪吃蛇游戏（五）第三版文档</title>
    <link href="/c-snake-pro5/"/>
    <url>/c-snake-pro5/</url>
    
    <content type="html"><![CDATA[<p>继续完善贪吃蛇，改用面向对象的思想完成代码，引入界面UI以及排行榜。</p><a id="more"></a><p>上接 <a href="http://www.colourso.top/c-snake-pro3/">C++基于EasyX制作贪吃蛇游戏（三）第二版文档</a> 继续更新制作贪吃蛇游戏的一些相关设计。</p><h2 id="程序展示"><a href="#程序展示" class="headerlink" title="程序展示"></a>程序展示</h2><p>以下是B站视频</p><iframe src="//player.bilibili.com/player.html?aid=371573766&bvid=BV1fZ4y1T7xo&cid=218646009&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" style="height: 430px; max-width: 100%"> </iframe><p>上面视频不能播放请移步：<a href="https://www.bilibili.com/video/BV1fZ4y1T7xo/">https://www.bilibili.com/video/BV1fZ4y1T7xo/</a></p><h2 id="改用面向对象"><a href="#改用面向对象" class="headerlink" title="改用面向对象"></a>改用面向对象</h2><p>原先两版程序都是使用的面向过程方式编写的，函数以及全局变量在整个文件之中飘……，本次决定改用面向对象的方式重写代码，毕竟挺缺少面向对象的练习，可能写出来的代码不是很好，但是我会尽量去完善的。</p><p>改用面向对象之后，我会尽力将绘制与数据计算这两者分开，不让两者混杂在一个函数内。所以重写的代码会改变以前两个版本的代码，不过核心流程还是一样的。</p><h3 id="公共数据-common-h"><a href="#公共数据-common-h" class="headerlink" title="公共数据 common.h"></a>公共数据 common.h</h3><pre><code class="hljs c++"><span class="hljs-comment">//蛇的节点半径</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SNAKE_RADIU 9</span><span class="hljs-comment">//食物的半径</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOOD_RADIU 8</span><span class="hljs-comment">//蛇的节点宽度</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SNAKE_WIDTH 20</span><span class="hljs-comment">//背景颜色，黑色</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BG_COLOR 0</span><span class="hljs-comment">//方向的枚举</span><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dir</span> &#123;</span> DIR_UP = <span class="hljs-number">1</span>, DIR_RIGHT = <span class="hljs-number">2</span>, DIR_DOWN = <span class="hljs-number">3</span>, DIR_LEFT = <span class="hljs-number">4</span> &#125;;<span class="hljs-comment">//点的结构体</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> &#123;</span><span class="hljs-keyword">int</span> x;<span class="hljs-keyword">int</span> y;Point() :x(<span class="hljs-number">-1</span>), y(<span class="hljs-number">-1</span>) &#123;&#125;Point(<span class="hljs-keyword">int</span> dx, <span class="hljs-keyword">int</span> dy) :x(dx), y(dy) &#123;&#125;Point(<span class="hljs-keyword">const</span> Point&amp; point) :x(point.x), y(point.y) &#123;&#125;<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> Point&amp; point)&#123;<span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>-&gt;x == point.x) &amp;&amp; (<span class="hljs-keyword">this</span>-&gt;y == point.y);&#125;&#125;;<span class="hljs-comment">//记录游玩信息</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PlayerMsg</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">int</span> id;<span class="hljs-keyword">int</span> score;<span class="hljs-keyword">int</span> len;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> r_time;<span class="hljs-comment">//记录时间</span>PlayerMsg()&#123;id = <span class="hljs-number">99</span>;score = <span class="hljs-number">0</span>;len = <span class="hljs-number">0</span>;r_time = <span class="hljs-string">&quot;&quot;</span>;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SortPlayerMsg</span> </span><span class="hljs-class">&#123;</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PlayerMsg &amp;msg1, <span class="hljs-keyword">const</span> PlayerMsg &amp;msg2)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (msg1.score == msg2.score)&#123;<span class="hljs-keyword">return</span> msg1.r_time &gt; msg2.r_time;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> msg1.score &gt; msg2.score;&#125;&#125;;</code></pre><p>公共数据头文件，定义以及存储一些常用的数据结构。</p><p><code>Dir</code>是枚举方向类。</p><p><code>Point</code>是点的结构体，重载了<code>==</code>操作符， 便于两个点集的比较。</p><p><code>PlayerMes</code>是用来存储游玩信息。<code>SortPlayerMsg</code>重载了<code>()</code>操作符， 便于两个<code>PlayerMes</code>的<code>sort</code>排序。详情请看：<a href="http://www.colourso.top/lanqiao-2/">STL专题-sort、reverse</a></p><h3 id="Snake类的设计-——-贪吃蛇类"><a href="#Snake类的设计-——-贪吃蛇类" class="headerlink" title="Snake类的设计 —— 贪吃蛇类"></a>Snake类的设计 —— 贪吃蛇类</h3><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Snake</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MinSpeed = <span class="hljs-number">1</span>;<span class="hljs-comment">//蛇的最小速度</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MaxSpeed = <span class="hljs-number">25</span>;<span class="hljs-comment">//蛇的最大速度</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> OrgSpeed = <span class="hljs-number">15</span>;<span class="hljs-comment">//蛇的原始速度</span><span class="hljs-keyword">private</span>:<span class="hljs-keyword">int</span> m_len;<span class="hljs-comment">//蛇的长度</span><span class="hljs-keyword">int</span> m_speed;<span class="hljs-comment">//蛇的速度</span>Dir m_direction;<span class="hljs-comment">//蛇的方向</span><span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;Point&gt; m_snakelist;<span class="hljs-comment">//蛇的链表</span>Point m_tail;<span class="hljs-comment">//蛇移动过后的尾部节点，主要用于吃食物</span><span class="hljs-keyword">public</span>:Snake();~Snake();<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLen</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//获取长度</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSpeed</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//获取速度</span><span class="hljs-function">Dir <span class="hljs-title">getDirection</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//获取方向</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">setSpeed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> speed)</span></span>;<span class="hljs-comment">//设置速度，设置成功返回true</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Move</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//移动一节</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EatFood</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//吃食物</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ChangeDir</span><span class="hljs-params">(Dir dir)</span></span>;<span class="hljs-comment">//改变方向</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dead</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//死亡</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ColideWall</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> top,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> bottom)</span></span>;<span class="hljs-comment">//碰撞到墙</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ColideSnake</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//碰撞到了自身</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ColideFood</span><span class="hljs-params">(Point point)</span></span>;<span class="hljs-comment">//碰到了食物</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawSnake</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绘制蛇</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawSnakeHead</span><span class="hljs-params">(Point pos)</span></span>;<span class="hljs-comment">//绘制蛇头</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawSnakeNode</span><span class="hljs-params">(Point pos)</span></span>;<span class="hljs-comment">//绘制蛇的身体结点</span>        <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;Point&gt; <span class="hljs-title">GetSnakeAllNode</span><span class="hljs-params">()</span></span>;&#125;;</code></pre><p>贪吃蛇类，开始使用STL中的<code>list</code>作为蛇的链表，不再使用自定义的链表。链表中存储Point类型的值，及节点的横纵坐标。</p><p>额外还需要蛇的方向、长度以及速度这几个参数。<code>Point m_tail;</code>参数在<code>EatFood()</code>函数那里进行说明。</p><p>三个 <code>public const int</code> 的速度是预先设置好的速度等级，方便之后使用。</p><ul><li><code>bool setSpeed(int speed);</code>函数用于改变蛇的速度，如若改变的蛇的速度超过最大值，那就将蛇的速度设置为最大值；最小值同理。如果修改速度成功就返回<code>true</code>。</li><li><code>void Move();</code>函数向蛇的方向移动一格，蛇的除蛇头以外的全部节点均<strong>向前复制一格</strong>。对应链表的操作可以用<strong>去除链表末尾的节点，复制链表头部的节点再插入头部，然后额外改变头部的值</strong>。</li><li><code>void EatFood();    </code>函数主要描述蛇吃到食物之后的动作。在本游戏中，我设定蛇吃到食物后，尾部增长一格。因此需要一个变量来保存蛇刚刚走过的尾部节点，即<code>Point m_tail;</code>。蛇吃到食物后，将这个尾部节点加入链表即可。</li><li><code>void ChangeDir(Dir dir);</code>改变方向，本来想起函数名为<code>setDir(Dir dir)</code>的，但是名字不太直观就换了。改变方向时，不是同方向或者不是反方向才能改变。</li><li><code>void Dead();</code>死亡效果，因为蛇碰撞死后效果不太直观，就用随机函数改变一下各个节点的位置。但是效果很难看。</li><li><code>ColideWall</code>、<code>ColideSnake</code>以及<code>ColideFood</code>来检测蛇的头部有没有碰撞到什么。</li><li><code>std::list&lt;Point&gt; GetSnakeAllNode();</code>用于获取蛇的全部结点，主要用于食物生成检测时使用。</li></ul><h3 id="Food类的设计-——-食物类"><a href="#Food类的设计-——-食物类" class="headerlink" title="Food类的设计 —— 食物类"></a>Food类的设计 —— 食物类</h3><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:Point m_pos;<span class="hljs-keyword">bool</span> m_state;<span class="hljs-keyword">public</span>:Food();<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">getState</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> state)</span></span>;<span class="hljs-function">Point <span class="hljs-title">getPos</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//获取食物坐标</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Generate</span><span class="hljs-params">(Snake *snake)</span></span>;<span class="hljs-comment">//产生新的食物</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawFood</span><span class="hljs-params">()</span></span>;&#125;;</code></pre><ul><li>两个数据成员：食物位置以及食物状态。</li><li><code>Food();</code>构造参数，其内设定了初始的食物位置，之后的位置需要使用<code>Generate</code>函数生成</li><li><code>void Generate(Snake *snake);</code>生成食物函数，因为生成食物不能与蛇的节点重合，所以需要蛇的节点信息。</li></ul><h3 id="RankList类的设计-——-排行榜类"><a href="#RankList类的设计-——-排行榜类" class="headerlink" title="RankList类的设计 —— 排行榜类"></a>RankList类的设计 —— 排行榜类</h3><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RankList</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;PlayerMsg&gt; m_msg;<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> m_rankfile = <span class="hljs-string">&quot;retro&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_RANK = <span class="hljs-number">10</span>;<span class="hljs-keyword">public</span>:RankList();<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SaveMsg</span><span class="hljs-params">(PlayerMsg msg)</span></span>;<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;PlayerMsg&gt; <span class="hljs-title">getRankList</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SaveToRank</span><span class="hljs-params">()</span></span>;<span class="hljs-keyword">private</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WriteTime</span><span class="hljs-params">(PlayerMsg &amp;msg)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ReadFile</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WriteFile</span><span class="hljs-params">()</span></span>;&#125;;</code></pre><ul><li>排行榜类主要作用是存储管理用户游玩结束之后的游戏数据，涉及了读写文件操作。</li><li>使用<code>vector</code>来存储用户的游玩数据，上限是10条，即<code>MAX_RANK</code>。也就是排行榜只保存前10名的数据。固定的读写文件名为<code>retro</code>。</li><li>私有函数中<code>void WriteTime(PlayerMsg &amp;msg);</code>来写入用户达成成绩的时间。<code>ReadFile()</code>读取配置文件数据，存入到<code>vector</code>中。<code>WriteFile()</code>将<code>vector</code>中的数据写回配置文件中。</li><li>构造函数<code>RankList();</code>中调用<code>ReadFile()</code>来初始化<code>vector</code>。</li><li><code>void SaveMsg(PlayerMsg msg);</code>是保存用户数据到<code>vector</code>中，如果其排名在10名之外，则不会保存成功。</li><li><code>void SaveToRank();</code>是将<code>vector</code>中的数据写回文件，实际调用的是<code>WriteFile()</code>函数。</li></ul><h3 id="Game类的设计-——-游戏控制类"><a href="#Game类的设计-——-游戏控制类" class="headerlink" title="Game类的设计 —— 游戏控制类"></a>Game类的设计 —— 游戏控制类</h3><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Game</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:<span class="hljs-keyword">int</span> m_GameState;<span class="hljs-comment">//游戏状态,0在主UI，1在游戏中，2在排行榜，3在游戏规则中</span>PlayerMsg m_msg;<span class="hljs-comment">//游玩数据</span>Snake *m_snake;<span class="hljs-comment">//蛇</span>Food *m_food;<span class="hljs-comment">//食物</span>RankList *m_ranklist;<span class="hljs-comment">//排行榜</span><span class="hljs-keyword">public</span>:Game();<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//初始化</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//控制程序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//关闭程序，释放资源</span><span class="hljs-keyword">private</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitData</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//初始化数据</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PlayGame</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//开始游戏</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowMainUI</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//展示主UI</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowRank</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//排行榜展示</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowRule</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//展示规则界面</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawGamePlay</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绘制初始游戏界面</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawScore</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绘制分数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawSnakeLen</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绘制长度</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawSpeed</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绘制速度</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawRunning</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绘制正在运行</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawPause</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绘制暂停提示</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawRebegin</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绘制重新开始</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawGameOver</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绘制游戏结束</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ChangeChooseUI</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom, <span class="hljs-keyword">int</span> kind)</span></span>;<span class="hljs-comment">//修改选中的选项颜色</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ClearRegion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom)</span></span>;<span class="hljs-comment">//使用背景色清除指定区域</span>&#125;;</code></pre><p><code>Game</code>类是游戏的控制类，也是游戏的主体，所以融合了上述全部的类。</p><p><code>Game</code>主要被用于主函数调用，所以只有构造函数以及三个函数是<code>public</code>，其余全部<code>private</code>。</p><ul><li><p>程序状态<code>m_GameState</code>，标识程序的运行状态，是在主界面？在游戏中？在排行榜中？还是在游戏帮助中，方便控制程序。</p></li><li><p><code>void Init();</code>初始化，主要是进行图形库的初始化。</p></li><li><p><code>void Close();</code>结束，主要是图形库释放资源。</p></li><li><p><code>void Run();</code>用来运行程序，展示UI，等待用户操作。</p></li><li><p>构造函数<code>Game();</code>主要是初始化一些数据，最主要的是设置程序状态<code>m_GameState</code>为0，以及初始化<code>RankList</code>，便于访问排行榜时可以看到数据。</p></li><li><p><code>InitData()</code>初始化一些在开始游戏时才需要用到的数据，比如<code>Snake</code>以及<code>Food</code>，重置<code>PlayMsg</code>，防止原来的数据对新开一局的数据产生干扰。</p></li><li><p><code>PlayGame()</code>则是游戏的控制函数，主要完成游戏中的全部控制，留在下面细说。</p></li><li><p><code>ChangeChooseUI</code>这个函数主要就是改变选中选项的效果，重新绘制这个按钮的样式，增加程序与用户的交互。</p></li></ul><h2 id="UI设计"><a href="#UI设计" class="headerlink" title="UI设计"></a>UI设计</h2><img src="/c-snake-pro5/mainui.png" style="zoom:80%;"><p>相较于之前的两版程序增加了UI，更加方便用户的控制，同时增加了鼠标的点选，更加直接。</p><img src="/c-snake-pro5/back.png" style="zoom:80%;"><p>例如上图左上角的返回键可以点击。</p><h2 id="鼠标点击操作"><a href="#鼠标点击操作" class="headerlink" title="鼠标点击操作"></a>鼠标点击操作</h2><pre><code class="hljs c++"><span class="hljs-keyword">if</span> ((m_GameState == <span class="hljs-number">2</span> || m_GameState == <span class="hljs-number">3</span>) &amp;&amp; MouseHit()) <span class="hljs-comment">//在排行榜或者游戏帮助中点击</span>&#123;MOUSEMSG mouse = GetMouseMsg();<span class="hljs-comment">//获取鼠标点击消息</span><span class="hljs-keyword">if</span> (mouse.mkLButton)<span class="hljs-comment">//左键按下</span>&#123;<span class="hljs-keyword">if</span> (mouse.x &gt;= <span class="hljs-number">20</span> &amp;&amp; mouse.x &lt;= <span class="hljs-number">63</span> &amp;&amp; mouse.y &gt;= <span class="hljs-number">20</span> &amp;&amp; mouse.y &lt;= <span class="hljs-number">43</span>)&#123;<span class="hljs-comment">//点击返回选项</span>ChangeChooseUI(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">63</span>, <span class="hljs-number">43</span>, <span class="hljs-number">5</span>);Sleep(<span class="hljs-number">500</span>);            FlushMouseMsgBuffer();<span class="hljs-comment">//清空鼠标消息缓冲区。</span>            m_GameState = <span class="hljs-number">0</span>;ShowMainUI();&#125;&#125;&#125;</code></pre><ul><li><code>MouseHit()</code>来检测有没有鼠标点击事件，有的话为true。</li><li><code>GetMouseMsg()</code>来获取鼠标点击消息，返回一个<code>MOUSEMSG</code>类型的数据。</li><li><code>FlushMouseMsgBuffer()</code>来清空鼠标消息缓冲区，防止残存的消息对其他函数产生干扰。</li></ul><h2 id="游戏控制-PlayGame"><a href="#游戏控制-PlayGame" class="headerlink" title="游戏控制 - PlayGame()"></a>游戏控制 - PlayGame()</h2><p>相较于前两版程序，我换用了重绘机制。原版程序使用的是仅消除蛇的尾端，局部擦除与重绘的方式。</p><p>但是由于数据运算与绘制的分离，原版的方式不容易实现，于是现在使用的是每一次循环就重新绘制一次游戏界面的方式，也就是最常规的方式。</p><p>以下是伪流程：</p><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-variable"><span class="hljs-literal">true</span></span>)</span>&#123;<span class="hljs-function"><span class="hljs-title">if</span>(检测食物是否存在)</span>&#123;不存在生成&#125;<span class="hljs-function"><span class="hljs-title">if</span>(按键检测)</span>&#123;改变方向或者暂停程序&#125;<span class="hljs-function"><span class="hljs-title">Move</span>();<span class="hljs-comment">//移动</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">if</span>(吃到食物)</span>&#123;长度增加分数增加食物状态改变&#125;<span class="hljs-function"><span class="hljs-title">if</span>(碰撞检测)</span>&#123;碰撞则死亡...&#125;清空区域重绘蛇<span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">sleep</span></span>(<span class="hljs-number">200</span>);</span><span class="hljs-function"></span><span class="hljs-function">&#125;</span></code></pre><p>具体的内容可以在函数实现里看到</p><h3 id="批量绘图"><a href="#批量绘图" class="headerlink" title="批量绘图"></a>批量绘图</h3><p>上述循环完成之后，界面每一次重新绘制都有些不太稳定，有闪烁的情况，这时就需要使用批量绘图。</p><ul><li><p><code>BeginBatchDraw();</code>开始批量绘图，其后的任何绘图操作暂时都不会进行绘制，直到执行 <code>FlushBatchDraw()</code> 或 <code>EndBatchDraw()</code> 才将之前的绘图输出。</p></li><li><p> <code>FlushBatchDraw()</code> 用于执行绘制任务。</p></li><li><p><code>EndBatchDraw()</code>结束批量绘图模式，并将还没有绘制的图完成绘制。</p></li></ul><p>这三者加入到<code>PlayGame()</code>函数中，保证画面的流畅性。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>至此，面向对象版贪吃蛇程序完成。这版程序主要做了一些事情：</p><ul><li>改用面向对象方式编写程序</li><li>换用蛇的数据结构为STL的<code>list</code>，操作更加方便。</li><li>将数据运算与绘制操作分离</li><li>增加UI与用户交互效果</li><li>增加排行榜机制，使用了文件读写操作。</li></ul><p>一些不足：</p><ul><li>食物类的生成算法需要检测蛇的节点保证不覆盖，因此效率可能比较差，实际运行时会有卡顿现象。考虑后续引入多线程解决。</li><li>UI还是挺难看的……</li><li>等待补充……</li></ul>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java实现的Telnet协议 - 计算机网络课设</title>
    <link href="/telnet-with-java/"/>
    <url>/telnet-with-java/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：Java实现的Telnet协议，Telnet相关知识，操作协商细节，代码实现。</p><a id="more"></a><h2 id="课设题目"><a href="#课设题目" class="headerlink" title="课设题目"></a>课设题目</h2><p>设计题目：利用JAVA实现TELNET协议</p><p>设计要求：TELNET协议允许用户用一台终端来访问远程的主机 ，它允许终端于主机之间以半双工的方式交换信息，可参阅RFC864[6-13]。本次设计要求利用JAVA实现TELNET协议的基本功能 。</p><h2 id="Telnet相关知识"><a href="#Telnet相关知识" class="headerlink" title="Telnet相关知识"></a>Telnet相关知识</h2><p>Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议。Telnet协议的目的是提供一个相对通用的，双向的通信方法，允许界面终端设备和面向终端的过程能通过一个标准过程进行互相交互。应用Telnet协议能够把本地用户所使用的计算机变成远程主机系统的一个终端。</p><p>Telnet协议具有如下的特点：Telnet协议可以适应于多个不同的操作系统，在Windows电脑上连接的Linux系统的机器可以传输命令，Telnet协议可以传输特定的控制命令，例如中止进程的命令等，并且由于Telnei两端的机器与操作系统之间的异构型，Telnet不能严格规定每一个Telnet连接的详细配置，故Telnet协议支持双方进行协商。</p><p>Telnet协议主要由三部分组成：</p><p>（1）网络虚拟终端 NVT；</p><p>（2）操作协商定义；</p><p>（3）协商有限自动机。</p><h3 id="网络虚拟终端-NVT"><a href="#网络虚拟终端-NVT" class="headerlink" title="网络虚拟终端 NVT"></a>网络虚拟终端 NVT</h3><p>网络虚拟终端（NVT）是一种虚拟的终端设备，它被客户和服务器所采用，用来<strong>建立数据表示和解释的一致性</strong>。Telne使用网络虚拟终端字符集来处理异构系统的远程登录问题。网络虚拟终端字符集是一个通用接口， 在远程登陆连接上，客户软件将终端用户输入转化为标准的NVT数据和命令序列，经TCP连接传到远地机上的服务器，服务器再将NVT序列转换为原地系统的内部格式。这样终端键盘输入的异质性就被NVT所屏蔽，NVT这里实现了统一，只需要与NVT打交道即可。</p><p><img src="/telnet-with-java/nvt.png"></p><h3 id="Telnet的操作协商"><a href="#Telnet的操作协商" class="headerlink" title="Telnet的操作协商"></a>Telnet的操作协商</h3><p>TELNET协议允许通信机器协商会话过程中所使用的各种选项，通过一组标准过程来建立这些选项。协商选项的使用考虑了主计算机可提供超出虚拟终端服务范围的服务的可能性。例如窗口的大小、终端类型、字符回显等信息都要进行协商。</p><p><img src="/telnet-with-java/neg.png"></p><p>协商主要是通过Telnet指令来进行的，Telnet指令格式是：</p><table><thead><tr><th>IAC</th><th>命令码</th><th>选项码</th></tr></thead><tbody><tr><td>255</td><td></td><td></td></tr></tbody></table><p>常见的命令码：</p><table><thead><tr><th>名称</th><th>码字(byte)</th><th>描述</th></tr></thead><tbody><tr><td>EOF</td><td>236</td><td>文件结束符</td></tr><tr><td>SUSP</td><td>237</td><td>挂起当前进程（作业控制）</td></tr><tr><td>ABORT</td><td>238</td><td>异常终止进程</td></tr><tr><td>EOR</td><td>239</td><td>记录结束符i</td></tr><tr><td>NOP</td><td>241</td><td>无操作</td></tr><tr><td>WILL</td><td>251</td><td>开始执行指示选项或证实设备现已经开始执行指示选项</td></tr><tr><td>WONT</td><td>252</td><td>拒绝执行指示选项或证实设备现已开始执行指示选项。</td></tr><tr><td>DO</td><td>253</td><td>另一方执行的请求，或者证实期望对方执行的请求</td></tr><tr><td>DONT</td><td>254</td><td>另一方停止执行的命令，或者证实一方不再期待另一方执行的命令。</td></tr></tbody></table><p>常见选项码：</p><table><thead><tr><th>选项标识(byte)</th><th>名称</th></tr></thead><tbody><tr><td>1</td><td>回显</td></tr><tr><td>3</td><td>抑制继续进行</td></tr><tr><td>5</td><td>状态</td></tr><tr><td>6</td><td>定时标记</td></tr><tr><td>24</td><td>终端类型</td></tr><tr><td>31</td><td>窗口大小</td></tr></tbody></table><h3 id="选项协商的6种情况"><a href="#选项协商的6种情况" class="headerlink" title="选项协商的6种情况"></a>选项协商的6种情况</h3><p>进行协商有4中类型的请求：</p><p>（1）WILL：发送方本身想激活某个选项。</p><p>（2）DO：发送方想让接受端激活某个选项。</p><p>（3）WONT：发送方本身想禁止某个选项。</p><p>（4）DONT：发送方想让接受端去禁止某个选项。</p><table><thead><tr><th>发送者</th><th>接收者</th><th>说明</th></tr></thead><tbody><tr><td>WILL</td><td>DO</td><td>发送者想激活某选项，接收者接受该选项请求</td></tr><tr><td>WILL</td><td>DONT</td><td>发送者想激活某选项，接收者拒接该选项请求</td></tr><tr><td>DO</td><td>WILL</td><td>发送者希望接收者激活某选项，接收者接受该请求</td></tr><tr><td>DO</td><td>WONT</td><td>发送者希望接收者激活某选项，接收者拒绝该请求</td></tr><tr><td>WONT</td><td>DONT</td><td>发送者希望使某选项无效，接收者必须接受该请求</td></tr><tr><td>WONT</td><td>WONT</td><td>发送者希望对方使某选项无效，接收者必须接受该请求</td></tr></tbody></table><h2 id="Linux开启Telnet"><a href="#Linux开启Telnet" class="headerlink" title="Linux开启Telnet"></a>Linux开启Telnet</h2><p>因为本次实验是拿一台虚拟机上的Linux作为服务器来做测试，所以需要开启Linux的Telnet服务。</p><p>参考我的博文： <a href="http://www.colourso.top/Linux-Telnet/">Linux-Telnet配置</a>  </p><h2 id="Telnet的协商流程测试"><a href="#Telnet的协商流程测试" class="headerlink" title="Telnet的协商流程测试"></a>Telnet的协商流程测试</h2><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">import</span> java.io.OutputStream;<span class="hljs-keyword">import</span> java.net.Socket;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//尝试建立socket连接</span>        Socket telnetSocket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;192.168.117.129&quot;</span>,<span class="hljs-number">23</span>);<span class="hljs-comment">//TCP,注意修改为自己的IP</span>        OutputStream outputStream = telnetSocket.getOutputStream();        InputStream inputStream = telnetSocket.getInputStream();        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">8</span>];        <span class="hljs-keyword">int</span> len = inputStream.read(bytes);        System.out.println(<span class="hljs-string">&quot;第一次接收响应，接受到的回应长度为&quot;</span>+len);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)&#123;            <span class="hljs-keyword">int</span> x = byteToInt(bytes[j]);            System.out.println(x);        &#125;        <span class="hljs-comment">/*</span><span class="hljs-comment">        第一次连接服务器，服务器会向客户端发送12个字节</span><span class="hljs-comment">        Do-253表示期望对方执行的请求</span><span class="hljs-comment">        1. 255 253 24：IAC Do 24表示终端类型</span><span class="hljs-comment">        2. 255 253 32：IAC Do 32表示终端速度</span><span class="hljs-comment">        3. 255 253 35：IAC Do 35表示X显示定位</span><span class="hljs-comment">        4. 255 253 39：IAC Do 39不知道</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">byte</span>[] first_responce = &#123;(<span class="hljs-keyword">byte</span>)<span class="hljs-number">255</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">252</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">24</span>,                (<span class="hljs-keyword">byte</span>)<span class="hljs-number">255</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">252</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">32</span>,                (<span class="hljs-keyword">byte</span>)<span class="hljs-number">255</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">252</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">35</span>,                (<span class="hljs-keyword">byte</span>)<span class="hljs-number">255</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">252</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">39</span>&#125;;        outputStream.write(first_responce);        outputStream.flush();        System.out.println(<span class="hljs-string">&quot;第一次发送过去了&quot;</span>);        <span class="hljs-comment">/*</span><span class="hljs-comment">        第一次回应，拒绝掉服务器的全部请求</span><span class="hljs-comment">        Won&#x27;t - 252表示拒绝执行指示选项</span><span class="hljs-comment">        1. 255 252 24 IAC WONT 24 拒绝</span><span class="hljs-comment">        2. 255 252 32 IAC WONT 32</span><span class="hljs-comment">        3. 255 252 35 IAC WONT 35</span><span class="hljs-comment">        4. 255 252 39 IAC WONT 39</span><span class="hljs-comment">        */</span>        len = inputStream.read(bytes);        System.out.println(<span class="hljs-string">&quot;第二次接收响应，接受到的回应长度为&quot;</span>+len);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)&#123;            <span class="hljs-keyword">int</span> x = byteToInt(bytes[j]);            System.out.println(x);        &#125;        <span class="hljs-comment">/*</span><span class="hljs-comment">        服务器第二次响应，继续向客户端发送15个字节</span><span class="hljs-comment">        Will 表示自己请求使用的服务</span><span class="hljs-comment">        Do -253表示期望对方执行的请求</span><span class="hljs-comment">        1. 255 251 3：IAC Will 3表示抑制向前，</span><span class="hljs-comment">        2. 255 253 1：IAC Do 1表示回显，期望客户端进行回显</span><span class="hljs-comment">        3. 255 253 31：IAC Do 31表示窗口尺寸</span><span class="hljs-comment">        4. 255 251 5：IAC Will 5表示状态</span><span class="hljs-comment">        5. 255 253 33：IAC Do 33表示远程流控制 期望客户端进行远程流控制</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">byte</span>[] second_responce = &#123;(<span class="hljs-keyword">byte</span>)<span class="hljs-number">255</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">253</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">3</span>,                (<span class="hljs-keyword">byte</span>)<span class="hljs-number">255</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">252</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">1</span>,                (<span class="hljs-keyword">byte</span>)<span class="hljs-number">255</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">252</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">31</span>,                (<span class="hljs-keyword">byte</span>)<span class="hljs-number">255</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">254</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">5</span>,                (<span class="hljs-keyword">byte</span>)<span class="hljs-number">255</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">252</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">33</span>&#125;;        outputStream.write(second_responce);<span class="hljs-comment">//发送给服务器</span>        outputStream.flush();        System.out.println(<span class="hljs-string">&quot;第二次发送过去了&quot;</span>);        <span class="hljs-comment">/*</span><span class="hljs-comment">        第二次回应，拒绝掉服务器的全部请求</span><span class="hljs-comment">        Won&#x27;t 表示拒绝执行指示选项</span><span class="hljs-comment">        1. 255 253 3 Do 表示期望服务器开启抑制向前的功能</span><span class="hljs-comment">        2. 255 252 1 Won&#x27;t 拒绝客户端回显</span><span class="hljs-comment">        3. 255 252 31 拒绝客户端窗口尺寸</span><span class="hljs-comment">        4. 255 254 5 Don&#x27;t 希望服务端禁止状态功能</span><span class="hljs-comment">        5. 255 252 33 拒绝执行远程流控制</span><span class="hljs-comment">        */</span>        len = inputStream.read(bytes);        System.out.println(<span class="hljs-string">&quot;第三次接收响应，接受到的回应长度为&quot;</span>+len);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)&#123;            <span class="hljs-keyword">int</span> x = byteToInt(bytes[j]);            System.out.println(x);        &#125;        <span class="hljs-comment">/*</span><span class="hljs-comment">        服务器第三次响应，继续向客户端发送3个字节</span><span class="hljs-comment">        Will 表示自己请求使用的服务</span><span class="hljs-comment">        Do 表示期望对方执行的请求</span><span class="hljs-comment">        1. 255 251 1：IAC Will 1表示服务器请求回显</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">byte</span>[] three_responce = &#123;(<span class="hljs-keyword">byte</span>)<span class="hljs-number">255</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">253</span>,(<span class="hljs-keyword">byte</span>)<span class="hljs-number">1</span>&#125;;        outputStream.write(three_responce);        outputStream.flush();        System.out.println(<span class="hljs-string">&quot;第三次发送过去了&quot;</span>);        <span class="hljs-comment">/*</span><span class="hljs-comment">        第三次回应，表示赞成服务器使用回显</span><span class="hljs-comment">        1. 255 253 1</span><span class="hljs-comment">         */</span>        System.out.println(<span class="hljs-string">&quot;-----------&quot;</span>);        len = inputStream.read(bytes);        System.out.println(<span class="hljs-string">&quot;第四次接收响应&quot;</span>);        String str = <span class="hljs-keyword">new</span> String(bytes,<span class="hljs-number">0</span>,len,<span class="hljs-string">&quot;UTF-8&quot;</span>);        System.out.println(str);        <span class="hljs-comment">//接收到登陆信息</span>    &#125;    <span class="hljs-comment">//byte转int</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">byteToInt</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> b)</span> </span>&#123;        <span class="hljs-keyword">int</span> x = b &amp; <span class="hljs-number">0xff</span>;        <span class="hljs-keyword">return</span> x;    &#125;&#125;</code></pre><p>当程序与虚拟机中的linux建立连接之后，服务器会立刻发送协商信息给程序，接收信息后进行协商即可。具体的协商过程都在代码与注释中。</p><h2 id="Telnet协商自动机"><a href="#Telnet协商自动机" class="headerlink" title="Telnet协商自动机"></a>Telnet协商自动机</h2><p>协商自动机是我在看别人的博客时发现的名词，就拿来用了。协商自动机的主要任务是，对于服务器发送过来的数据，分辨清楚它是协商消息还就是普通的数据。</p><p>如果是协商消息的话，就根据预先设置好的策略，进行回复，如果是数据的话，就展示给用户。</p><p>这解析服务器数据的过程就像是读取文件获得固定内容或者编译器读取代码那样。</p><pre><code class="hljs java"><span class="hljs-comment">//检测接收到的数据是协商还是数据，进行协商，处理并返回数据</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">negotiate</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> buf[],<span class="hljs-keyword">int</span> lens)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;    <span class="hljs-keyword">byte</span> front = (<span class="hljs-keyword">byte</span>)<span class="hljs-number">0</span>;<span class="hljs-comment">//用来存储当前正在解析的buf[]中的数据</span>    List&lt;Byte&gt; databuf = <span class="hljs-keyword">new</span> ArrayList&lt;Byte&gt;(); <span class="hljs-comment">//存储数据</span>    List&lt;Byte&gt; negbuf = <span class="hljs-keyword">new</span> ArrayList&lt;Byte&gt;();  <span class="hljs-comment">//存储协商命令</span>    <span class="hljs-keyword">int</span> seg_offset = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录处理的位置</span>    <span class="hljs-keyword">byte</span> neg_state = STATE_DATA;<span class="hljs-comment">//协商状态，表明解析数据类型</span>    <span class="hljs-keyword">while</span>(seg_offset &lt; lens)&#123;        <span class="hljs-comment">//获取到当前要处理的字节</span>        front = buf[seg_offset];        seg_offset++;        <span class="hljs-keyword">switch</span> (neg_state)&#123;            <span class="hljs-keyword">case</span> STATE_DATA:<span class="hljs-comment">//是数据</span>                <span class="hljs-keyword">if</span>(front == IAC)&#123;<span class="hljs-comment">//255</span>                    neg_state = STATE_IAC;                    negbuf.add(IAC);<span class="hljs-comment">//加入到待回复的数组中</span>                &#125;                <span class="hljs-keyword">else</span>&#123;                    databuf.add(front);                &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> STATE_IAC:<span class="hljs-comment">//是IAC</span>                <span class="hljs-keyword">switch</span>(front)&#123;                    <span class="hljs-keyword">case</span> WILL:                        <span class="hljs-comment">//IAC后接WILL</span>                        neg_state = STATE_IACWILL;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> WONT:                        neg_state = STATE_IACWONT;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> DONT:                        neg_state = STATE_IACDONT;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> DO:                        neg_state = STATE_IACDO;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">default</span>:<span class="hljs-comment">//其它情况都是数据类型</span>                        <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>有可能读出了IAC但是，实际上只是一个单独的字符</span>                        neg_state = STATE_DATA;                        databuf.add(IAC);                        <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> STATE_IACWILL:<span class="hljs-comment">//如果是协商类型 IAC WILL，表示服务器自己想做的服务</span>                <span class="hljs-keyword">switch</span> (front)&#123;                    <span class="hljs-comment">//这里如果是功能1 ECHO或者功能3 E3是选择DO，其他都是DONT</span>                    <span class="hljs-keyword">case</span> TELOPT_ECHO:                        <span class="hljs-comment">//negbuf[] = TELOPT_ECHO;</span>                        <span class="hljs-comment">//TODO： 记得继续往下</span>                        negbuf.add(DO);                        negbuf.add(TELOPT_ECHO);                        neg_state = STATE_DATA;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> TELOPT_E3:                        negbuf.add(DO);                        negbuf.add(TELOPT_E3);                        neg_state = STATE_DATA;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">default</span>:                        <span class="hljs-comment">//其他情况都先拒绝</span>                        negbuf.add(DONT);                        negbuf.add(front);                        neg_state = STATE_DATA;                        <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> STATE_IACDO:<span class="hljs-comment">//如果协商类型是IAC DO，表示服务器期待客户端做某事</span>                <span class="hljs-comment">//对于服务器发送的DO请求，全部使用WONT拒绝</span>                negbuf.add(WONT);                negbuf.add(front);                neg_state = STATE_DATA;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> STATE_IACWONT:<span class="hljs-comment">//如果协商类型是IAC WONT，表示服务器拒绝执行我的请求</span>                <span class="hljs-comment">//实际上服务器并没有发过这种请求，不做处理</span>            <span class="hljs-keyword">case</span> STATE_IACDONT:<span class="hljs-comment">//如果协商类型是IAC DONT，表示服务器不希望我做某些请求</span>                <span class="hljs-comment">//服务器也没有发送过这种请求，不处理</span>                neg_state  =STATE_DATA;                <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-comment">//回应服务器的协商</span>    <span class="hljs-keyword">if</span>(!negbuf.isEmpty() &amp;&amp; (negbuf.size() % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>))&#123;        Byte[] bytes = negbuf.toArray(<span class="hljs-keyword">new</span> Byte[negbuf.size()]);<span class="hljs-comment">//ArrayList转Byte[]数组</span>        <span class="hljs-keyword">byte</span>[] responce = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[negbuf.size()];        ByteTobyte(bytes,responce); <span class="hljs-comment">//转为byte[]</span>        send(responce);             <span class="hljs-comment">//发送数据</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">//如果没有协商而是数据的话，通过函数返回</span>    <span class="hljs-keyword">if</span>(databuf != <span class="hljs-keyword">null</span>)&#123;        Byte[] bytes = databuf.toArray(<span class="hljs-keyword">new</span> Byte[databuf.size()]);<span class="hljs-comment">//ArrayList转Byte[]数组</span>        <span class="hljs-keyword">byte</span>[] message = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[databuf.size()];        ByteTobyte(bytes,message);<span class="hljs-comment">//转为byte[]</span>        String str = <span class="hljs-keyword">new</span> String(message,<span class="hljs-number">0</span>,databuf.size(),<span class="hljs-string">&quot;UTF-8&quot;</span>);        <span class="hljs-keyword">return</span> str;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p>协商自动机执行的结果是，对于服务器发送的协商，程序解析完成后，根据预先设置的情况，向服务器发送协商结果。如果是服务器发送来的数据，就显示到控制台。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><h3 id="TelnetClient-java"><a href="#TelnetClient-java" class="headerlink" title="TelnetClient.java"></a>TelnetClient.java</h3><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">import</span> java.io.OutputStream;<span class="hljs-keyword">import</span> java.net.Socket;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TelnetClient</span> </span>&#123;    <span class="hljs-keyword">private</span> Socket telnetSocket;    <span class="hljs-keyword">private</span> OutputStream outputStream;    <span class="hljs-keyword">private</span> InputStream inputStream;    <span class="hljs-comment">/*-------------协商状态常数-------------*/</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span> STATE_DATA = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span> STATE_IAC = <span class="hljs-number">1</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span> STATE_IACWILL = <span class="hljs-number">2</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span> STATE_IACWONT = <span class="hljs-number">3</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span> STATE_IACDO = <span class="hljs-number">4</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span> STATE_IACDONT = <span class="hljs-number">5</span>;    <span class="hljs-comment">/*-------------协商过程中用到的数据-------------*/</span>    <span class="hljs-comment">//IAC - init sequence for telnet negotiation.telnet协商的初始化序列</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span> IAC = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">255</span>;    <span class="hljs-comment">//EF [IAC] WILL 开始执行指示选项或证实设备现已开始执行指示选项</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span> WILL = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">251</span>;    <span class="hljs-comment">//FB [IAC] WON&#x27;T  拒绝执行指示选项或拒绝计息执行指示选项</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span> WONT = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">252</span>;    <span class="hljs-comment">//FC [IAC] DO 另一方执行的请求，或者证实期望对方执行的请求，指示选项</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span> DO = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">253</span>;    <span class="hljs-comment">//FD [IAC] DON&#x27;T  另一方停止执行的命令，或者证实乙方不再期待另一方执行的命令，指示选项</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span> DONT = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">254</span>;    <span class="hljs-comment">//FO Telnet option: echo text 回显字符 RFC:857</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span> TELOPT_ECHO = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">1</span>;  <span class="hljs-comment">/* echo on/off */</span>    <span class="hljs-comment">//一次传送一个字符方式</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span> TELOPT_E3 = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">3</span>;    <span class="hljs-comment">//与特定的主机建立telnet连接</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">link</span><span class="hljs-params">(String host,<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;        telnetSocket = <span class="hljs-keyword">new</span> Socket(host,port);        outputStream = telnetSocket.getOutputStream();        inputStream = telnetSocket.getInputStream();        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">8</span>];        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;            len = inputStream.read(bytes);            String str = negotiate(bytes,len);            <span class="hljs-keyword">if</span>(str != <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//                len = inputStream.read(bytes);</span><span class="hljs-comment">//                String str1 = negotiate(bytes,len);</span><span class="hljs-comment">//                str += str1;</span>                System.out.print(str);                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">//发送数据给服务器</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        outputStream.write(bytes);        outputStream.flush();    &#125;    <span class="hljs-comment">//从服务器接收数据</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">receive</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">8</span>];        <span class="hljs-keyword">int</span> len = inputStream.read(bytes);        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;Connection closed.&quot;</span>);        String str = negotiate(bytes,len);        <span class="hljs-keyword">return</span> str;    &#125;    <span class="hljs-comment">//检测接收到的数据是协商还是数据，进行协商，处理并返回数据</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">negotiate</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> buf[],<span class="hljs-keyword">int</span> lens)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;        <span class="hljs-keyword">byte</span> front = (<span class="hljs-keyword">byte</span>)<span class="hljs-number">0</span>;        List&lt;Byte&gt; databuf = <span class="hljs-keyword">new</span> ArrayList&lt;Byte&gt;(); <span class="hljs-comment">//存储数据</span>        List&lt;Byte&gt; negbuf = <span class="hljs-keyword">new</span> ArrayList&lt;Byte&gt;();  <span class="hljs-comment">//存储协商命令</span>        <span class="hljs-keyword">int</span> seg_offset = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录处理的位置</span>        <span class="hljs-keyword">byte</span> neg_state = STATE_DATA;        <span class="hljs-keyword">while</span>(seg_offset &lt; lens)&#123;            <span class="hljs-comment">//获取到当前要处理的字节</span>            front = buf[seg_offset];            seg_offset++;            <span class="hljs-keyword">switch</span> (neg_state)&#123;                <span class="hljs-keyword">case</span> STATE_DATA:<span class="hljs-comment">//是数据</span>                    <span class="hljs-keyword">if</span>(front == IAC)&#123;<span class="hljs-comment">//255</span>                        neg_state = STATE_IAC;                        negbuf.add(IAC);<span class="hljs-comment">//加入到待回复的数组中</span>                    &#125;                    <span class="hljs-keyword">else</span>&#123;                        databuf.add(front);                    &#125;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> STATE_IAC:<span class="hljs-comment">//是IAC</span>                    <span class="hljs-keyword">switch</span>(front)&#123;                        <span class="hljs-keyword">case</span> WILL:                            <span class="hljs-comment">//IAC后接WILL</span>                            neg_state = STATE_IACWILL;                            <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">case</span> WONT:                            neg_state = STATE_IACWONT;                            <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">case</span> DONT:                            neg_state = STATE_IACDONT;                            <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">case</span> DO:                            neg_state = STATE_IACDO;                            <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">default</span>:<span class="hljs-comment">//其它情况都是数据类型</span>                            <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>有可能读出了IAC但是，实际上只是一个单独的字符</span>                            neg_state = STATE_DATA;                            databuf.add(IAC);                            <span class="hljs-keyword">break</span>;                    &#125;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> STATE_IACWILL:<span class="hljs-comment">//如果是协商类型 IAC WILL，表示服务器自己想做的服务</span>                    <span class="hljs-keyword">switch</span> (front)&#123;                        <span class="hljs-comment">//这里如果是功能1 ECHO或者功能3 E3是选择DO，其他都是DONT</span>                        <span class="hljs-keyword">case</span> TELOPT_ECHO:                            <span class="hljs-comment">//negbuf[] = TELOPT_ECHO;</span>                            <span class="hljs-comment">//TODO： 记得继续往下</span>                            negbuf.add(DO);                            negbuf.add(TELOPT_ECHO);                            neg_state = STATE_DATA;                            <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">case</span> TELOPT_E3:                            negbuf.add(DO);                            negbuf.add(TELOPT_E3);                            neg_state = STATE_DATA;                            <span class="hljs-keyword">break</span>;                        <span class="hljs-keyword">default</span>:                            <span class="hljs-comment">//其他情况都先拒绝</span>                            negbuf.add(DONT);                            negbuf.add(front);                            neg_state = STATE_DATA;                            <span class="hljs-keyword">break</span>;                    &#125;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> STATE_IACDO:<span class="hljs-comment">//如果协商类型是IAC DO，表示服务器期待客户端做某事</span>                    <span class="hljs-comment">//对于服务器发送的DO请求，全部使用WONT拒绝</span>                    negbuf.add(WONT);                    negbuf.add(front);                    neg_state = STATE_DATA;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> STATE_IACWONT:<span class="hljs-comment">//如果协商类型是IAC WONT，表示服务器拒绝执行我的请求</span>                    <span class="hljs-comment">//实际上服务器并没有发过这种请求，不做处理</span>                <span class="hljs-keyword">case</span> STATE_IACDONT:<span class="hljs-comment">//如果协商类型是IAC DONT，表示服务器不希望我做某些请求</span>                    <span class="hljs-comment">//服务器也没有发送过这种请求，不处理</span>                    neg_state  =STATE_DATA;                    <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-comment">//回应服务器的协商</span>        <span class="hljs-keyword">if</span>(!negbuf.isEmpty() &amp;&amp; (negbuf.size() % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>))&#123;            Byte[] bytes = negbuf.toArray(<span class="hljs-keyword">new</span> Byte[negbuf.size()]);<span class="hljs-comment">//ArrayList转Byte[]数组</span>            <span class="hljs-keyword">byte</span>[] responce = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[negbuf.size()];            ByteTobyte(bytes,responce); <span class="hljs-comment">//转为byte[]</span>            send(responce);             <span class="hljs-comment">//发送数据</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">//如果没有协商而是数据的话，通过函数返回</span>        <span class="hljs-keyword">if</span>(databuf != <span class="hljs-keyword">null</span>)&#123;            Byte[] bytes = databuf.toArray(<span class="hljs-keyword">new</span> Byte[databuf.size()]);<span class="hljs-comment">//ArrayList转Byte[]数组</span>            <span class="hljs-keyword">byte</span>[] message = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[databuf.size()];            ByteTobyte(bytes,message);<span class="hljs-comment">//转为byte[]</span>            String str = <span class="hljs-keyword">new</span> String(message,<span class="hljs-number">0</span>,databuf.size(),<span class="hljs-string">&quot;UTF-8&quot;</span>);            <span class="hljs-keyword">return</span> str;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">//byte转int</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">byteToInt</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> b)</span> </span>&#123;        <span class="hljs-keyword">int</span> x = b &amp; <span class="hljs-number">0xff</span>;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-comment">//Byte[] 转byte[]</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ByteTobyte</span><span class="hljs-params">(Byte[] bytes,<span class="hljs-keyword">byte</span>[] byts)</span></span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;bytes.length;i++)&#123;            byts[i] = bytes[i];        &#125;    &#125;    <span class="hljs-comment">//延迟等待时间</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">int</span> second)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(second*<span class="hljs-number">1000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">//减去接收到的服务器的数据中与输入命令重复的部分</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">subStr</span><span class="hljs-params">(String orgstr,String objstr)</span></span>&#123;        <span class="hljs-comment">//orgstr: 子串 ， objstr：目标处理串</span>        <span class="hljs-keyword">if</span>(orgstr == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> objstr;<span class="hljs-comment">//如果原串为空，说明是第一次执行，直接返回数据</span>        &#125;        <span class="hljs-keyword">if</span>(objstr.indexOf(orgstr.substring(<span class="hljs-number">0</span>,orgstr.length()-<span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果子串位于目标串的开头位置再进行处理</span>            <span class="hljs-keyword">return</span> objstr.substring(orgstr.length()+<span class="hljs-number">1</span>);        &#125;        <span class="hljs-comment">//发送的数据为 msfadmin\n</span>        <span class="hljs-comment">//接收的数据为 msfadmin\r\n</span>        <span class="hljs-comment">//所以检索时orgstr长度减1，return时orgstr长度加1</span>        <span class="hljs-keyword">return</span> objstr;<span class="hljs-comment">//其他情况也返回原串</span>    &#125;&#125;</code></pre><h3 id="Main-java"><a href="#Main-java" class="headerlink" title="Main.java"></a>Main.java</h3><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-comment">//ip地址</span>        String remotehost = <span class="hljs-string">&quot;192.168.117.129&quot;</span>;        String inputStr = <span class="hljs-keyword">null</span>;        String showStr = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//建立连接，并进行协商</span>        TelnetClient tc = <span class="hljs-keyword">new</span> TelnetClient();        tc.link(remotehost,<span class="hljs-number">23</span>);        <span class="hljs-comment">//协商完成,开始和用户交互</span>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;            <span class="hljs-comment">//获取用户输入</span>            inputStr = sc.nextLine();            inputStr += <span class="hljs-string">&quot;\n&quot;</span>;            <span class="hljs-comment">//发送用户的数据</span>            tc.send(inputStr.getBytes());            tc.sleep(<span class="hljs-number">2</span>);            <span class="hljs-comment">//接收服务器的数据</span>            showStr = tc.receive();            <span class="hljs-comment">//字符串处理</span>            showStr = tc.subStr(inputStr,showStr);            System.out.print(showStr);        &#125;    &#125;&#125;</code></pre><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p><img src="/telnet-with-java/link.png"></p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>在资料中看到了NVT的说明，但是至今没搞懂NVT在哪里实现，我在Windows端下发送的命令加上<code>\n</code>，就可以被执行，加上<code>\r\n</code>就不会被执行，但是NVT不是统一使用的<code>\r\n</code>作为换行符吗？</p><p>关于协商自动机，因为大多数Telnet协议的参数说明都很模糊，大部分网上查不到，并且RFC文档我看不太明白，所以那个协商函数是根据我在本地测试的情况编写的，好多问题根本没有考虑到。所以向这些基本操作可以使用，但是像是<code>vi</code>这种命令去编辑文本就不能用了。</p><p>答辩的时候，老师询问了如果服务器的telnet进程突然出现了问题，一直给你发送消息你该怎么办，等好多特殊情况，我确实不知道该如何解决.</p><h2 id="参考链接与资料分享"><a href="#参考链接与资料分享" class="headerlink" title="参考链接与资料分享"></a>参考链接与资料分享</h2><p><a href="https://tools.ietf.org/html/rfc854">https://tools.ietf.org/html/rfc854</a></p><p><a href="http://www.cnpaf.net/Class/RFC/200411/1049.html">中文RFC文档阅读 701-1000</a></p><p><a href="https://www.cnblogs.com/spinsoft/archive/2012/06/27/2566069.html">Telnet协议详解</a></p><p><a href="https://www.cnblogs.com/yechuan/archive/2013/01/30/2882837.html">Telnet协议的java实现</a></p><p>《基于Windows的TCPIP编程》王罡 清华大学出版社：<a href="https://pan.baidu.com/s/1jvDF1zBPmD0e4YyBQWebkw">https://pan.baidu.com/s/1jvDF1zBPmD0e4YyBQWebkw</a>  提取码：y8dg</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件下载</tag>
      
      <tag>Java</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-Telnet配置</title>
    <link href="/Linux-Telnet/"/>
    <url>/Linux-Telnet/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：Linux的TELNET配置，Ubuntu与Kail亲测可用，以及查看Linux的IP地址与端口。</p><a id="more"></a><p>Telnet是明文传输，非常的不安全。大部分已经被SSH协议取代了。</p><h2 id="Linux安装TELNET"><a href="#Linux安装TELNET" class="headerlink" title="Linux安装TELNET"></a>Linux安装TELNET</h2><p>1.安装这两个包。</p><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> install xinetd telnetd</code></pre><p>2.编辑/etc/inetd.conf</p><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/i</span>netd.conf</code></pre><p>这个文件默认不存在，所以里面也没有任何内容。把下列内容填入到文件之中。</p><pre><code class="hljs awk">telnet stream tcp nowait telnetd <span class="hljs-regexp">/usr/</span>sbin<span class="hljs-regexp">/tcpd /u</span>sr<span class="hljs-regexp">/sbin/i</span>n.telnetd</code></pre><p>3.编辑/etc/xinetd.conf</p><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/</span>xinetd.conf</code></pre><p>文件默认是有内容的，但是主要内容需要我们进行填充。</p><pre><code class="hljs properties"><span class="hljs-comment"># Simple configuration file for xinetd </span><span class="hljs-comment"># </span><span class="hljs-comment"># Some defaults, and include /etc/xinetd.d/ </span><span class="hljs-attr">defaults</span> <span class="hljs-string"></span><span class="hljs-meta">&#123;</span> <span class="hljs-string"></span><span class="hljs-comment"># Please note that you need a log_type line to be able to use log_on_success </span><span class="hljs-comment"># and log_on_failure. The default is the following : </span><span class="hljs-comment"># log_type = SYSLOG daemon info </span><span class="hljs-attr">instances</span> = <span class="hljs-string">60 </span><span class="hljs-attr">log_type</span> = <span class="hljs-string">SYSLOG authpriv </span><span class="hljs-attr">log_on_success</span> = <span class="hljs-string">HOST PID </span><span class="hljs-attr">log_on_failure</span> = <span class="hljs-string">HOST </span><span class="hljs-attr">cps</span> = <span class="hljs-string">25 30 </span><span class="hljs-meta">&#125;</span> <span class="hljs-string"></span><span class="hljs-attr">includedir</span> <span class="hljs-string">/etc/xinetd.d</span></code></pre><p>填充内容为<code>instances=60</code>一直到<code>cps = 25 30</code>。</p><p>4.编辑/etc/xinetd.d/telnet文件</p><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/</span>xinetd.d/telnet</code></pre><p>修改添加如下内容</p><pre><code class="hljs pgsql"># <span class="hljs-keyword">default</span>: <span class="hljs-keyword">on</span> # description: The telnet <span class="hljs-keyword">server</span> serves telnet sessions; it uses \ # <span class="hljs-keyword">unencrypted</span> username/<span class="hljs-keyword">password</span> pairs <span class="hljs-keyword">for</span> authentication. service telnet &#123; <span class="hljs-keyword">disable</span> = <span class="hljs-keyword">no</span> flags = REUSE socket_type = stream wait = <span class="hljs-keyword">no</span> <span class="hljs-keyword">user</span> = root <span class="hljs-keyword">server</span> = /usr/sbin/<span class="hljs-keyword">in</span>.telnetd log_on_failure  = USERID &#125;</code></pre><p>5.重启网络</p><pre><code class="hljs awk">sudo <span class="hljs-regexp">/eyc/i</span>nit.d/xinetd restart</code></pre><p>到此Linux的TELNET配置完成。</p><p><strong>注意：Kail机器貌似每次开即都需要输入这个命令才能开启TELNET</strong>。</p><h2 id="查看TELNET端口是否打开"><a href="#查看TELNET端口是否打开" class="headerlink" title="查看TELNET端口是否打开"></a>查看TELNET端口是否打开</h2><p>可以使用nmap来查看端口是否打开。</p><p>如果没有安装nmap，按照提示安装即可。</p><p>查看命令</p><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> -p <span class="hljs-number">23</span> <span class="hljs-number">127.0.0.1</span></code></pre><p><img src="/Linux-Telnet/nmap.png"></p><h2 id="查看Linux的网络IP"><a href="#查看Linux的网络IP" class="headerlink" title="查看Linux的网络IP"></a>查看Linux的网络IP</h2><p>可以使用命令<code>ifconfig</code>来进行查看。</p><p>如果没有安装的话，命令行会提示安装对应的包<code>net-tools</code></p><p>除此之外有时安装了这个包，但是机器还是显示未安装此命令。此时可以加上sudo.</p><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo ifconfig</span></code></pre><p><img src="/Linux-Telnet/ifconfig.png"></p><ul><li>inet表示网络地址</li><li>netmask表示子网掩码</li><li>broadcast表示广播地址。</li></ul><blockquote><p> 参考链接：<a href="https://www.cnblogs.com/walkbro/archive/2010/01/23/1655802.html">linux打开telnet端口</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python爬虫入门——简单的爬取小说</title>
    <link href="/python-grabnovel/"/>
    <url>/python-grabnovel/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：Python爬虫，非常简单的爬取一个小说网站。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我找到的小说网站是无错小说网，网址是<code>www.read8.net</code>。</p><p>这是一个免费小说网站，不需要登陆注册就能看小说，重要的是网站设计比较简单，网页结构并不复杂，非常适合拿来尝试爬虫。</p><p>要爬取的小说名叫《神武主宰》，作者鬼舞沙。之所以爬取这本书，是因为我与这本小说还稍微有点渊源。</p><p>高中的时候，这本书的小说作者在偶家中文网连载这本书，我开玩笑地给作者发帖，如果他把我一个同学地名字写进去，我就给他打赏一点小礼物，没想到作者还真的写了进去，后来偶家中文网倒闭了，我就再也没看过这本书。</p><p>最近突然想起了这件事，找到了这本书，没想到作者超乎我的想象，我原以为作者会安排一个龙套角色，活不过十章，没想到简单翻了一下，在小说的末尾还发现了那个名字，而且还是主角阵营比较重要的一员，真的是没有想到。</p><p>在此谢谢那位作者鬼舞沙。</p><h2 id="网页结构"><a href="#网页结构" class="headerlink" title="网页结构"></a>网页结构</h2><p>书籍链接： <a href="https://www.read8.net/dushu/41/41357/">https://www.read8.net/dushu/41/41357/</a> </p><p><img src="/python-grabnovel/index.png"></p><p>这是这本小说的全部章节所在，所有章节的链接都存在于<code>&lt;dd&gt;</code>标签之中的<code>&lt;a&gt;</code>标签。</p><p><img src="/python-grabnovel/content.png"></p><p>上图是小说的某一章，小说内容的主体都存在于一个<code>id=&quot;content&quot;</code>的<code>&lt;div&gt;</code>之中。</p><p>所以实现起来就很简单了。</p><p>先在小说的章节目录页中取得全部小说的章节名以及章节对应的链接。</p><p>然后依次爬取每一章小说，获取小说内容之后写入到一个txt文件之中。</p><p>得益于网页结构非常简单，所以这个爬虫也非常的简单。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="hljs python"><span class="hljs-comment"># 目标：爬取无错小说网的一本小说的内容：https://www.read8.net/dushu/41/41357/</span><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> time<span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoupnovel_title = []    <span class="hljs-comment">#小说章节名称</span>novel_link = []     <span class="hljs-comment">#小说章节链接</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getChapter</span>(<span class="hljs-params">baseurl,novel_link_pre</span>):</span>    html = requests.get(baseurl)  <span class="hljs-comment"># 获取网页代码</span>    soup = BeautifulSoup(html.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)  <span class="hljs-comment"># html.parser为python自带的一个html解析器，</span>    novelList = soup.find_all(<span class="hljs-string">&quot;dd&quot;</span>)  <span class="hljs-comment"># 获取小说全部章节的链接，查看文件结构可发现都在dd标签之中</span>    <span class="hljs-comment"># print(novelList)               # &lt;dd&gt;&lt;a href=&quot;/dushu/41/41357/15990720.html&quot;&gt;第488章 十年&lt;/a&gt;&lt;/dd&gt;</span>    <span class="hljs-keyword">for</span> title <span class="hljs-keyword">in</span> novelList:        <span class="hljs-comment"># print(title.get_text()) # 小说的章节名称</span>        novel_title.append(<span class="hljs-built_in">str</span>(title.get_text()))        <span class="hljs-comment"># print(title.a[&#x27;href&#x27;])  # 小说的链接  /dushu/41/41357/15990708.html</span>        <span class="hljs-comment"># https://www.read8.net/dushu/41/41357/15990708.html</span>        novel_link.append(<span class="hljs-built_in">str</span>(novel_link_pre + title.a[<span class="hljs-string">&#x27;href&#x27;</span>]))<span class="hljs-comment"># 爬取单独一章里的小说主体</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getChapterText</span>(<span class="hljs-params">baseurl</span>):</span>    html = requests.get(baseurl)    soup = BeautifulSoup(html.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)    text = soup.find(<span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;content&quot;</span>)  <span class="hljs-comment">#内容</span>    text = <span class="hljs-built_in">str</span>(text.get_text())    text = text.replace(<span class="hljs-string">&quot;    &quot;</span>,<span class="hljs-string">&quot;\n  &quot;</span>)                                  <span class="hljs-comment">#增加换行</span>    text = text.replace(<span class="hljs-string">&quot;天才一秒记住本站地址：https://www.read8.net&quot;</span>,<span class="hljs-string">&quot;&quot;</span>) <span class="hljs-comment">#去除广告</span>    text = text.replace(<span class="hljs-string">&quot;网上直接搜索: ”(阅)(读)(悦)” 20万本热门小说免费看,,精彩!&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)    text = text.replace(<span class="hljs-string">&quot;章节错误，点此报送，报送后维护人员会在两分钟内校正章节内容，请耐心等待。&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)    text = text.replace(<span class="hljs-string">&quot;转载请注明出处：https://www.read8.net&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)    text = text.replace(<span class="hljs-string">&quot;《神武主宰》来源：&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)    text = text.replace(<span class="hljs-string">&quot;https://www.read8.net&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)    <span class="hljs-keyword">return</span> text<span class="hljs-comment"># 将内容写入到txt文件中</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">saveTxt</span>(<span class="hljs-params">title,text,filename</span>):</span>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;a&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:        file.write(title+<span class="hljs-string">&quot;\n\n&quot;</span>)        file.write(text)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>    baseurl = <span class="hljs-string">&quot;https://www.read8.net/dushu/41/41357/&quot;</span>  <span class="hljs-comment"># 小说链接</span>    novel_link_pre = <span class="hljs-string">&quot;https://www.read8.net&quot;</span>        <span class="hljs-comment"># 链接前缀</span>    novel_begin_index = <span class="hljs-number">12</span>  <span class="hljs-comment"># 因为网站原因，前一部分是最新更新的章节，后面才是从第一章开始的内容</span>    filename = <span class="hljs-string">&quot;神武主宰.txt&quot;</span>    print(<span class="hljs-string">&quot;开始时间: %s&quot;</span> % time.ctime())    getChapter(baseurl, novel_link_pre)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(novel_begin_index,<span class="hljs-built_in">len</span>(novel_title)):        text = getChapterText(novel_link[i])        saveTxt(novel_title[i],text,filename)        print(<span class="hljs-string">&quot;已经爬取:&quot;</span>,novel_title[i],<span class="hljs-string">&quot;进度: (&quot;</span>,i-novel_begin_index+<span class="hljs-number">1</span>,<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-built_in">len</span>(novel_title)-novel_begin_index,<span class="hljs-string">&quot;)&quot;</span>)        time.sleep(<span class="hljs-number">1</span>)    print(<span class="hljs-string">&quot;结束时间: %s&quot;</span> % time.ctime())<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    main()</code></pre><p>代码逻辑也非常简单，就不再赘述了。</p><p>因为我延迟等待1秒的原因，加之没有采用多线程爬取，所以爬取这个大概500章的小说，爬了接近20分钟。</p><p>……</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb —— 网上书城项目</title>
    <link href="/javaweb-bookshop/"/>
    <url>/javaweb-bookshop/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：JavaWeb课程设计，网上书城，主要用到了JSP、Servlet、MySQL数据库。</p><a id="more"></a><h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><p>JDK 1.8.0_221，64位</p><p>Tomcat 8.5.55，64位</p><p>MySQL 5.5.54， 64位</p><p>IDEA 2019.1</p><h2 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h2><p>本系统拟采用JSP和servlet作为开发工具，html、css和javascript开发页面，MySQL作为数据存储的工具。</p><p>通过对网上书店项目的业务逻辑的了解，抽象出具体的需求分析，我们可以把网上书店系统分为以下六个模块：注册与登陆，在线销售，书籍管理，用户管理，订单管理和管理员管理。</p><p>网站主界面分为用户登陆和管理员登陆两个页面，对于用户来说，可以不进行登陆直接访问或者浏览商品，但是不能购买，购买的时候如果用户没有登陆，就会提示用户进行登陆，用户登陆之后的主界面依旧还是购物网站的主体，为了简化页面，可以将页面相同的部分抽调出hader以及footer部分供具有相同页面的其他页面调用。</p><p>而对于管理员来说，必须登陆之后才能看到管理项目与数据，所以管理员如果不登陆只能看到登陆页面。</p><p>在线销售模块包括书籍展示，书籍分类，购物车以及订单结算等功能。书籍展示是根据数据库中得数据，显示推荐的书籍信息以及最新上架的书籍信息，书籍分类可以查询到属于同一种类的书籍信息，购物车模块可以将用户选择的数据添加到购物车，并且可以修改要购买书籍的数量或者是删除书籍。订单结算可以付款，等待付款成功之后就可以等待卖家发货。</p><p>用户管理模块显示所有用户，并且提供查询用户，冻结员工等功能。</p><p>书籍管理模块包括书籍列表和书籍类别。书籍列表界面提供显示，查询和添加书籍的功能；而书籍类别界面用来显示书籍类型，还可以添加、修改或者删除书籍类别。</p><p>订单管理模块用于显示所有订单，以及发货、送货等功能。</p><p>管理员管理模块包括管理员列表，用来显示系统管理员，还可以添加新的管理员账号，修改管理员账号迷惑或者删除管理员账号。</p><p>通过分析该网站的具体功能和详细的设计，决定采用mvc模式实现我们的网站。即数据存储（mysql），界面显示（jsp）和逻辑处理（servlet）分隔开来实现，把网站实现划分模块，不同模块之间提供相应的接口，不仅便于实现，而且便于日后管理和维护。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><table><thead><tr><th>表名</th><th>说明</th></tr></thead><tbody><tr><td>s_admin</td><td>管理员表</td></tr><tr><td>s_book</td><td>书籍表</td></tr><tr><td>s_catalog</td><td>书籍类别表</td></tr><tr><td>s_order</td><td>订单表</td></tr><tr><td>s_orderitem</td><td>订单从表</td></tr><tr><td>s_uploading</td><td>书籍图片表</td></tr><tr><td>s_user</td><td>用户表</td></tr></tbody></table><p>详细的数据库，已经通过Navicat导出sql文件了，新建数据库名为<code>shinebookshop</code>，UTF-8编码。</p><p>新建完数据库，导入运行sql文件之后，记得分配给用户的权限。</p><p><img src="/javaweb-bookshop/sql.png"></p><h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="/javaweb-bookshop/banner2.jpg"></p><center>自己专门做了一张轮播图</center><p><img src="/javaweb-bookshop/login.png"></p><center>注册登陆</center><p><img src="/javaweb-bookshop/booklist.png"></p><center>图书列表</center><p><img src="/javaweb-bookshop/car.png"></p><center>购物车</center><p><img src="/javaweb-bookshop/admin.png"></p><center>管理员</center><p><img src="/javaweb-bookshop/adminbook.png"></p><center>管理员-图书列表</center><p><img src="/javaweb-bookshop/order.png"></p><center>管理员-待处理订单列表</center>## 运行步骤<ol><li>数据库先导入shinebookshop.sql文件，授予数据库用户访问这个数据库的权限。</li><li>IDEA打开这个项目，编辑<code>src</code>目录下的配置文件<code>dbinfo.properties</code>，修改里面的数据库连接信息。</li><li>在IDEA中配置Tomcat信息，发布目录修改为<code>/shinebookshop</code>。</li><li>发布到tomcat中，<a href="http://localhost:8080/shinebookshop%E4%B8%BA%E4%B9%B0%E5%AE%B6%E9%A6%96%E9%A1%B5%E3%80%82http://localhost:8080/shinebookshop/admin%E4%B8%BA%E7%AE%A1%E7%90%86%E5%91%98%E9%A6%96%E9%A1%B5%E3%80%82%E7%AE%A1%E7%90%86%E5%91%98%E5%88%9D%E5%A7%8B%E8%B4%A6%E5%8F%B7%EF%BC%9Aadmin">http://localhost:8080/shinebookshop为买家首页。http://localhost:8080/shinebookshop/admin为管理员首页。管理员初始账号：admin</a> 初始密码：admin</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>原项目是Eclipse项目，把它转成了IDEA项目。当然我修改替换了一些图片，微微调整了一些文字描述。</p><ol><li>项目来源：shine网上书城 <a href="https://gitee.com/thuihuang/shine_bookshop">https://gitee.com/thuihuang/shine_bookshop</a> </li><li><a href="https://github.com/coderzcr/JavaWeb-Project-Source-Share/blob/master/newcomer/preview/NEW202006221301.md">https://github.com/coderzcr/JavaWeb-Project-Source-Share/blob/master/newcomer/preview/NEW202006221301.md</a></li><li><a href="https://github.com/coderzcr/JavaWeb-Project-Source-Share/blob/master/newcomer/detail/JSP+Servlet+JDBC%E5%AE%9E%E7%8E%B0%E7%9A%84shine%E7%BD%91%E4%B8%8A%E4%B9%A6%E5%9F%8E.md">https://github.com/coderzcr/JavaWeb-Project-Source-Share/blob/master/newcomer/detail/JSP+Servlet+JDBC%E5%AE%9E%E7%8E%B0%E7%9A%84shine%E7%BD%91%E4%B8%8A%E4%B9%A6%E5%9F%8E.md</a> </li></ol><p>在找JavaWeb项目的时候，我最终找到了<strong>张有路</strong>大佬的一个github项目，主要用于 <strong>分享基于Servlet、SSH、SSM、SpringBoot等流行技术实现的JavaWeb项目，难度分为5个等级，帮助小白入门JavaWeb开发，协助JavaWeb开发者熟悉最新技术</strong> 。</p><p>项目众多，还有大佬亲自运行测试，有的还会有视频。</p><p>项目链接： <a href="https://github.com/coderzcr/JavaWeb-Project-Source-Share">https://github.com/coderzcr/JavaWeb-Project-Source-Share</a> </p><h2 id="项目下载"><a href="#项目下载" class="headerlink" title="项目下载"></a>项目下载</h2><p>百度网盘链接：<a href="https://pan.baidu.com/s/1cosmMtK1kwzF6hGfOqANVQ">https://pan.baidu.com/s/1cosmMtK1kwzF6hGfOqANVQ</a> 提取码：b2m9</p><p>蓝奏云链接： <a href="https://colourso.lanzous.com/im7xbee1nxa">https://colourso.lanzous.com/im7xbee1nxa</a> 密码:3p5x </p><p>项目gitee有原作者的，可以去下载原作者的代码。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件下载</tag>
      
      <tag>Java</tag>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基于EasyX制作贪吃蛇游戏（四）第二版代码与程序</title>
    <link href="/c-snake-pro4/"/>
    <url>/c-snake-pro4/</url>
    
    <content type="html"><![CDATA[<p>上接<a href="http://www.colourso.top/c-snake-pro3/">C++基于EasyX制作贪吃蛇游戏（三）第二版文档</a> ，本文是代码的实现。</p><a id="more"></a><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>工具：VS2017</p><p>依赖：EasyX Library for C++ (Ver:20200520(beta))</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;graphics.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-comment">//蛇头方向预定义</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UP 1<span class="hljs-comment">//↑</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RIGHT 2 <span class="hljs-comment">//→</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DOWN 3  <span class="hljs-comment">//↓</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LEFT 4  <span class="hljs-comment">//←</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_SPEED 5<span class="hljs-comment">//最大速度</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_SPEED 29<span class="hljs-comment">//最小速度</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ORG_SPEED 18<span class="hljs-comment">//原始速度</span></span><span class="hljs-comment">/*-------------结构体定义---------------*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> //蛇的节点</span><span class="hljs-class">&#123;</span><span class="hljs-keyword">int</span> x;   <span class="hljs-comment">//横左边</span><span class="hljs-keyword">int</span> y;   <span class="hljs-comment">//纵坐标</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//指向下一个节点的指针</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">pre</span>;</span>  <span class="hljs-comment">//指向前一个节点的指针</span>&#125; *LinkNode;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Snake</span> //蛇的结构体</span><span class="hljs-class">&#123;</span>LinkNode head; <span class="hljs-comment">//指向头节点的指针</span>LinkNode tail; <span class="hljs-comment">//指向尾节点的指针</span><span class="hljs-keyword">int</span> direction; <span class="hljs-comment">//蛇头方向</span><span class="hljs-keyword">int</span> num;   <span class="hljs-comment">//节点数目</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Food</span> //食物结构体</span><span class="hljs-class">&#123;</span><span class="hljs-keyword">int</span> x;<span class="hljs-comment">//横坐标</span><span class="hljs-keyword">int</span> y;<span class="hljs-comment">//纵坐标</span><span class="hljs-keyword">bool</span> exist; <span class="hljs-comment">//是否存在，1表示存在</span>&#125;;<span class="hljs-comment">/*-------------全局变量---------------*/</span><span class="hljs-keyword">int</span> g_score = <span class="hljs-number">0</span>; <span class="hljs-comment">//获得分数</span><span class="hljs-keyword">int</span> g_speed = ORG_SPEED; <span class="hljs-comment">//控制速度，即延迟等待时间</span>Snake snake; <span class="hljs-comment">//游戏中的蛇本体</span>Food food; <span class="hljs-comment">//食物</span><span class="hljs-comment">/*-------------函数声明---------------*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//初始化</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//释放资源</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//开始游戏</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initdata</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//游戏数据初始化</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawgame</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//绘制界面</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gameplay</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//游戏流程控制</span><span class="hljs-comment">/*---游戏区相关函数---*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawfood</span><span class="hljs-params">(Food food)</span></span>;  <span class="hljs-comment">//绘制食物</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawsnake</span><span class="hljs-params">(Snake snake)</span></span>;  <span class="hljs-comment">//绘制蛇</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawsnakenode</span><span class="hljs-params">(Node node)</span></span>;  <span class="hljs-comment">//绘制蛇的结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawsnakehead</span><span class="hljs-params">(Node node)</span></span>;  <span class="hljs-comment">//画蛇的头部</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearsnakenode</span><span class="hljs-params">(Node node)</span></span>;   <span class="hljs-comment">//清除蛇的结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">snakebodymove</span><span class="hljs-params">(Snake &amp;snake)</span></span>; <span class="hljs-comment">//蛇身体结点向前复制</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">collidesnake</span><span class="hljs-params">(Snake snake)</span></span>;   <span class="hljs-comment">//碰撞自身检测</span><span class="hljs-comment">/*---数据展示区相关函数---*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleardisplay</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//清除数据展示区内容</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawscore</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//绘制分数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawnodes</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//绘制蛇长度</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawspeed</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//绘制速度</span><span class="hljs-comment">/*---程序状态区相关函数---*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearstate</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//清除程序状态区内容</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawpause</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//输出暂停信息</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawruntime</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//输出正在运行的信息</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawover</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//输出游戏结束信息</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawoverchoose</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//绘制游戏结束后的选项</span><span class="hljs-comment">/*-------------程序入口---------------*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;init();play();close();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*-------------函数实现---------------*/</span><span class="hljs-comment">//初始化</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;initgraph(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>);   <span class="hljs-comment">//初始化窗口</span>&#125;<span class="hljs-comment">//游戏</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;initdata();drawgame();gameplay();&#125;<span class="hljs-comment">//释放资源</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;_getch();closegraph();&#125;<span class="hljs-comment">//初始化数据</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initdata</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//蛇与食物初始化</span><span class="hljs-comment">//食物初始坐标为(310,230)</span>food.x = <span class="hljs-number">310</span>;food.y = <span class="hljs-number">230</span>;food.exist = <span class="hljs-literal">true</span>;<span class="hljs-comment">//蛇初始长度为3，蛇头坐标为(210,230)</span><span class="hljs-comment">//如果蛇的头节点和尾节点有信息</span><span class="hljs-keyword">if</span> (snake.head != <span class="hljs-literal">NULL</span> &amp;&amp; snake.tail != <span class="hljs-literal">NULL</span>)&#123;LinkNode linknode = snake.head;<span class="hljs-keyword">while</span> (linknode != snake.tail)&#123;linknode = linknode-&gt;next;<span class="hljs-built_in">free</span>(linknode-&gt;pre);&#125;<span class="hljs-built_in">free</span>(snake.tail);snake.head = <span class="hljs-literal">NULL</span>;snake.tail = <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-comment">//在堆上开辟空间，防止此函数的生命周期结束后结点全部被释放掉</span>LinkNode nodes2 = (LinkNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));nodes2-&gt;x = <span class="hljs-number">170</span>;nodes2-&gt;y = <span class="hljs-number">230</span>;nodes2-&gt;next = <span class="hljs-literal">nullptr</span>;LinkNode nodes1 = (LinkNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));nodes1-&gt;x = <span class="hljs-number">190</span>;nodes1-&gt;y = <span class="hljs-number">230</span>;nodes1-&gt;next = nodes2;LinkNode nodes0 = (LinkNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));nodes0-&gt;x = <span class="hljs-number">210</span>;nodes0-&gt;y = <span class="hljs-number">230</span>;nodes0-&gt;next = nodes1;nodes2-&gt;pre = nodes1;nodes1-&gt;pre = nodes0;nodes0-&gt;pre = <span class="hljs-literal">nullptr</span>;snake.head = nodes0;snake.tail = nodes2;snake.direction = RIGHT;snake.num = <span class="hljs-number">3</span>;<span class="hljs-comment">//初始分数</span>g_score = (snake.num - <span class="hljs-number">3</span>) * <span class="hljs-number">10</span>;<span class="hljs-comment">//初始化速度</span>g_speed = ORG_SPEED;&#125;<span class="hljs-comment">//绘制界面</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawgame</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//清空屏幕</span>setbkcolor(<span class="hljs-number">0</span>);<span class="hljs-comment">//设置背景色黑色</span>cleardevice();<span class="hljs-comment">//画宽度为2的棕色实线，分割游戏区</span>setlinecolor(BROWN);setlinestyle(PS_SOLID, <span class="hljs-number">2</span>);line(<span class="hljs-number">482</span>, <span class="hljs-number">0</span>, <span class="hljs-number">482</span>, <span class="hljs-number">480</span>);<span class="hljs-comment">/*--------------绘制功能介绍区----------*/</span>settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);settextcolor(<span class="hljs-number">0XFFFFFF</span>);outtextxy(<span class="hljs-number">530</span>,<span class="hljs-number">20</span>,<span class="hljs-string">L&quot;玩法介绍&quot;</span>);settextstyle(<span class="hljs-number">14</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">490</span>, <span class="hljs-number">50</span>, <span class="hljs-string">L&quot;↑ ← ↓ → 控制方向&quot;</span>);outtextxy(<span class="hljs-number">490</span>, <span class="hljs-number">70</span>, <span class="hljs-string">L&quot;w a s d 控制方向&quot;</span>);outtextxy(<span class="hljs-number">490</span>, <span class="hljs-number">90</span>, <span class="hljs-string">L&quot;速度等级1-25，默认12&quot;</span>);outtextxy(<span class="hljs-number">500</span>, <span class="hljs-number">110</span>, <span class="hljs-string">L&quot;c键加速，x键减速&quot;</span>);outtextxy(<span class="hljs-number">500</span>, <span class="hljs-number">130</span>, <span class="hljs-string">L&quot;z键恢复原始速度&quot;</span>);outtextxy(<span class="hljs-number">500</span>, <span class="hljs-number">150</span>, <span class="hljs-string">L&quot;空格键暂停/继续&quot;</span>);outtextxy(<span class="hljs-number">500</span>, <span class="hljs-number">170</span>, <span class="hljs-string">L&quot;Esc键直接关闭程序&quot;</span>);setlinecolor(BROWN);setlinestyle(PS_SOLID, <span class="hljs-number">2</span>);line(<span class="hljs-number">482</span>, <span class="hljs-number">190</span>, <span class="hljs-number">640</span>, <span class="hljs-number">190</span>);<span class="hljs-comment">/*--------------绘制数据展示区----------*/</span>settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);settextcolor(<span class="hljs-number">0XFFFFFF</span>);outtextxy(<span class="hljs-number">530</span>, <span class="hljs-number">200</span>, <span class="hljs-string">L&quot;数据展示&quot;</span>);<span class="hljs-comment">//绘制分数</span>drawscore();<span class="hljs-comment">//绘制蛇身长度</span>drawnodes();<span class="hljs-comment">//绘制速度</span>drawspeed();setlinecolor(BROWN);setlinestyle(PS_SOLID, <span class="hljs-number">2</span>);line(<span class="hljs-number">482</span>, <span class="hljs-number">300</span>, <span class="hljs-number">640</span>, <span class="hljs-number">300</span>);<span class="hljs-comment">/*--------------绘制程序状态区----------*/</span>settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);settextcolor(<span class="hljs-number">0XFFFFFF</span>);outtextxy(<span class="hljs-number">530</span>, <span class="hljs-number">310</span>, <span class="hljs-string">L&quot;游戏状态&quot;</span>);<span class="hljs-comment">//绘制程序正在运行中</span>drawruntime();settextstyle(<span class="hljs-number">14</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);settextcolor(<span class="hljs-number">0XFFFFFF</span>);outtextxy(<span class="hljs-number">530</span>, <span class="hljs-number">450</span>, <span class="hljs-string">L&quot;By Colourso&quot;</span>);<span class="hljs-comment">//作者信息</span>outtextxy(<span class="hljs-number">510</span>, <span class="hljs-number">465</span>, <span class="hljs-string">L&quot;www.colourso.top&quot;</span>);<span class="hljs-comment">/*--------------游戏区----------*/</span><span class="hljs-comment">//绘制食物</span>drawfood(food);<span class="hljs-comment">//绘制蛇</span>drawsnake(snake);&#125;<span class="hljs-comment">//开始游戏</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gameplay</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;Node ends; <span class="hljs-comment">//末尾结点</span><span class="hljs-keyword">bool</span> speedchange = <span class="hljs-literal">false</span>;BeginBatchDraw();<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;ends.x = snake.tail-&gt;x;ends.y = snake.tail-&gt;y;<span class="hljs-keyword">if</span> (!food.exist)&#123;<span class="hljs-keyword">int</span> x;<span class="hljs-keyword">int</span> y;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;srand(time(<span class="hljs-number">0</span>));x = (rand() % <span class="hljs-number">24</span>) * <span class="hljs-number">20</span> + <span class="hljs-number">10</span>;y = (rand() % <span class="hljs-number">24</span>) * <span class="hljs-number">20</span> + <span class="hljs-number">10</span>;<span class="hljs-comment">//食物位置检测算法</span>LinkNode linknode = snake.head;<span class="hljs-keyword">bool</span> cont = <span class="hljs-literal">true</span>;<span class="hljs-keyword">while</span> (linknode != snake.tail-&gt;next)&#123;<span class="hljs-keyword">if</span> (linknode-&gt;x == x &amp;&amp; linknode-&gt;y == y)&#123;cont = <span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;linknode = linknode-&gt;next;&#125;<span class="hljs-keyword">if</span> (cont)&#123;<span class="hljs-keyword">break</span>;&#125;&#125;food.x = x;food.y = y;food.exist = <span class="hljs-literal">true</span>;drawfood(food);&#125;<span class="hljs-comment">//按键检测</span><span class="hljs-keyword">if</span> (_kbhit())&#123;<span class="hljs-keyword">char</span> key = _getch();<span class="hljs-keyword">switch</span> (key)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">72</span>:  <span class="hljs-comment">//↑</span><span class="hljs-keyword">case</span> <span class="hljs-number">119</span>: <span class="hljs-comment">//w</span><span class="hljs-keyword">if</span> (snake.direction != UP &amp;&amp; snake.direction != DOWN)snake.direction = UP;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">80</span>:  <span class="hljs-comment">//↓</span><span class="hljs-keyword">case</span> <span class="hljs-number">115</span>: <span class="hljs-comment">//s</span><span class="hljs-keyword">if</span> (snake.direction != UP &amp;&amp; snake.direction != DOWN)snake.direction = DOWN;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">75</span>: <span class="hljs-comment">//←</span><span class="hljs-keyword">case</span> <span class="hljs-number">97</span>: <span class="hljs-comment">//a</span><span class="hljs-keyword">if</span> (snake.direction != LEFT &amp;&amp; snake.direction != RIGHT)snake.direction = LEFT;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">77</span>:  <span class="hljs-comment">//→</span><span class="hljs-keyword">case</span> <span class="hljs-number">100</span>: <span class="hljs-comment">//d</span><span class="hljs-keyword">if</span> (snake.direction != LEFT &amp;&amp; snake.direction != RIGHT)snake.direction = RIGHT;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">99</span>: <span class="hljs-comment">//c 加速</span><span class="hljs-keyword">if</span> (g_speed &gt; MAX_SPEED)&#123;g_speed -= <span class="hljs-number">1</span>;speedchange = <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">120</span>:<span class="hljs-comment">//x 减速</span><span class="hljs-keyword">if</span> (g_speed &lt; MIN_SPEED)&#123;g_speed += <span class="hljs-number">1</span>;speedchange = <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">122</span>:<span class="hljs-comment">//z 回归原速</span>g_speed = ORG_SPEED;speedchange = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">32</span>: <span class="hljs-comment">//空格暂停</span>drawpause();<span class="hljs-comment">//状态区显示</span><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<span class="hljs-keyword">if</span>(_kbhit())&#123;<span class="hljs-keyword">char</span> key = _getch();<span class="hljs-keyword">if</span> (key == <span class="hljs-number">32</span>)<span class="hljs-comment">//按空格继续</span>&#123;clearstate();drawruntime();<span class="hljs-comment">//绘制程序正在运行中</span><span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">27</span>:<span class="hljs-comment">//Esc直接退出</span><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-comment">//速度变化的话绘制数据展示区内容</span><span class="hljs-keyword">if</span> (speedchange)&#123;speedchange = <span class="hljs-literal">false</span>;cleardisplay();drawscore();drawnodes();drawspeed();&#125;<span class="hljs-comment">//消除走过的尾端结点</span>clearsnakenode(ends);<span class="hljs-comment">//前进，绘制头部走过的节点</span><span class="hljs-keyword">switch</span> (snake.direction)&#123;<span class="hljs-keyword">case</span> UP:&#123;<span class="hljs-comment">//头部y-20,x不变</span>snakebodymove(snake);snake.head-&gt;y -= <span class="hljs-number">20</span>;drawsnakehead(*(snake.head));drawsnakenode(*(snake.head-&gt;next));<span class="hljs-comment">//将原来的头部变成身体的颜色</span><span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> RIGHT:&#123;<span class="hljs-comment">//头部x+20,y不变</span>snakebodymove(snake);snake.head-&gt;x += <span class="hljs-number">20</span>;drawsnakehead(*(snake.head));drawsnakenode(*(snake.head-&gt;next));<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> DOWN:&#123;<span class="hljs-comment">//头部y+20,x不变</span>snakebodymove(snake);snake.head-&gt;y += <span class="hljs-number">20</span>;drawsnakehead(*(snake.head));drawsnakenode(*(snake.head-&gt;next));<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> LEFT:&#123;<span class="hljs-comment">//头部x-20,y不变</span>snakebodymove(snake);snake.head-&gt;x -= <span class="hljs-number">20</span>;drawsnakehead(*(snake.head));drawsnakenode(*(snake.head-&gt;next));<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-comment">//蛇吃食物</span><span class="hljs-keyword">if</span> (snake.head-&gt;x == food.x &amp;&amp; snake.head-&gt;y == food.y &amp;&amp; food.exist)&#123;food.exist = <span class="hljs-literal">false</span>;<span class="hljs-comment">//分数变化</span>g_score += <span class="hljs-number">10</span>;<span class="hljs-comment">//在末尾增加新的结点，维护双向链表的关系</span>LinkNode nodes = (LinkNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));nodes-&gt;x = ends.x;nodes-&gt;y = ends.y;nodes-&gt;next = snake.tail-&gt;next;nodes-&gt;pre = snake.tail;snake.tail-&gt;next = nodes;snake.tail = nodes;++snake.num;drawsnakenode(ends);cleardisplay();drawscore();drawnodes();drawspeed();&#125;FlushBatchDraw();<span class="hljs-comment">//碰撞判断</span><span class="hljs-keyword">bool</span> collidewall = snake.head-&gt;x &lt; <span class="hljs-number">10</span> || snake.head-&gt;x &gt; <span class="hljs-number">470</span> || snake.head-&gt;y &lt; <span class="hljs-number">10</span> || snake.head-&gt;y &gt; <span class="hljs-number">470</span>;<span class="hljs-keyword">if</span> (collidewall || collidesnake(snake))&#123;drawover();drawoverchoose();<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<span class="hljs-keyword">if</span> (_kbhit())&#123;<span class="hljs-keyword">char</span> key = _getch();<span class="hljs-keyword">if</span> (key == <span class="hljs-number">114</span>)<span class="hljs-comment">//按r重新开始</span>&#123;Sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">//延迟1秒</span>play();&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-number">113</span>)<span class="hljs-comment">//按q退出</span>&#123;cleardevice();TCHAR s[] = _T(<span class="hljs-string">&quot;Game Over&quot;</span>);settextstyle(<span class="hljs-number">48</span>, <span class="hljs-number">0</span>, _T(<span class="hljs-string">&quot;黑体&quot;</span>));outtextxy(<span class="hljs-number">230</span>, <span class="hljs-number">210</span>, s);settextstyle(<span class="hljs-number">24</span>, <span class="hljs-number">0</span>, _T(<span class="hljs-string">&quot;宋体&quot;</span>));outtextxy(<span class="hljs-number">250</span>, <span class="hljs-number">260</span>, <span class="hljs-string">L&quot;获得分数：&quot;</span>);settextcolor(<span class="hljs-number">0xFF5555</span>);<span class="hljs-comment">//亮蓝</span>TCHAR t[<span class="hljs-number">5</span>];_stprintf_s(t, _T(<span class="hljs-string">&quot;%d&quot;</span>), g_score); <span class="hljs-comment">// 高版本 VC 推荐使用 _stprintf_s 函数</span>outtextxy(<span class="hljs-number">380</span>, <span class="hljs-number">260</span>, t);settextcolor(<span class="hljs-number">0xFFFFFF</span>);<span class="hljs-comment">//白</span>Sleep(<span class="hljs-number">1500</span>);<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;&#125;&#125;<span class="hljs-keyword">break</span>;&#125;Sleep(g_speed*<span class="hljs-number">10</span>);EndBatchDraw();&#125;&#125;<span class="hljs-comment">//绘制食物</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawfood</span><span class="hljs-params">(Food food)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//红色，全填充，无边框的圆</span>setfillcolor(RED);setfillstyle(BS_SOLID);solidcircle(food.x, food.y, <span class="hljs-number">8</span>);&#125;<span class="hljs-comment">//绘制蛇的结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawsnakenode</span><span class="hljs-params">(Node node)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//绿色，全填充，无边框的正方形</span>setfillcolor(GREEN);setfillstyle(BS_SOLID);solidrectangle(node.x - <span class="hljs-number">9</span>, node.y + <span class="hljs-number">9</span>, node.x + <span class="hljs-number">9</span>, node.y - <span class="hljs-number">9</span>);&#125;<span class="hljs-comment">//画蛇的头部</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawsnakehead</span><span class="hljs-params">(Node node)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//紫色，全填充，无边框的正方形</span>setfillcolor(<span class="hljs-number">0xAA00AA</span>);setfillstyle(BS_SOLID);solidrectangle(node.x - <span class="hljs-number">9</span>, node.y + <span class="hljs-number">9</span>, node.x + <span class="hljs-number">9</span>, node.y - <span class="hljs-number">9</span>);&#125;<span class="hljs-comment">//清除蛇的结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearsnakenode</span><span class="hljs-params">(Node node)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//黑色，全填充，无边框的正方形</span>setfillcolor(BLACK);setfillstyle(BS_SOLID);solidrectangle(node.x - <span class="hljs-number">9</span>, node.y + <span class="hljs-number">9</span>, node.x + <span class="hljs-number">9</span>, node.y - <span class="hljs-number">9</span>);&#125;<span class="hljs-comment">//绘制蛇</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawsnake</span><span class="hljs-params">(Snake snake)</span></span><span class="hljs-function"></span>&#123;LinkNode linknode = snake.head;drawsnakehead(*linknode);<span class="hljs-comment">//画头部</span>linknode = linknode-&gt;next;<span class="hljs-keyword">while</span> (linknode != snake.tail-&gt;next)&#123;drawsnakenode(*linknode);linknode = linknode-&gt;next;&#125;&#125;<span class="hljs-comment">//蛇身体结点向前复制</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">snakebodymove</span><span class="hljs-params">(Snake &amp;snake)</span></span><span class="hljs-function"></span>&#123;LinkNode linknode = snake.tail;<span class="hljs-keyword">while</span> (linknode != snake.head)&#123;linknode-&gt;x = linknode-&gt;pre-&gt;x;linknode-&gt;y = linknode-&gt;pre-&gt;y;linknode = linknode-&gt;pre;&#125;&#125;<span class="hljs-comment">//碰撞自身检测</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">collidesnake</span><span class="hljs-params">(Snake snake)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (snake.num &lt;= <span class="hljs-number">3</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;LinkNode node = snake.head-&gt;next;<span class="hljs-keyword">while</span> (node != snake.tail-&gt;next)&#123;<span class="hljs-keyword">if</span> (node-&gt;x == snake.head-&gt;x &amp;&amp; node-&gt;y == snake.head-&gt;y)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;node = node-&gt;next;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-comment">//清除功能展示区</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleardisplay</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//黑色，全填充，无边框的正方形</span>setfillcolor(BLACK);setfillstyle(BS_SOLID);solidrectangle(<span class="hljs-number">485</span>, <span class="hljs-number">220</span>, <span class="hljs-number">640</span>, <span class="hljs-number">290</span>);&#125;<span class="hljs-comment">//绘制分数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawscore</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;TCHAR s[] = _T(<span class="hljs-string">&quot;获得分数：&quot;</span>);settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, _T(<span class="hljs-string">&quot;宋体&quot;</span>));outtextxy(<span class="hljs-number">500</span>, <span class="hljs-number">230</span>, s);settextcolor(<span class="hljs-number">0xFF5555</span>);<span class="hljs-comment">//亮蓝</span>TCHAR t[<span class="hljs-number">5</span>];_stprintf_s(t, _T(<span class="hljs-string">&quot;%d&quot;</span>), g_score); <span class="hljs-comment">// 高版本 VC 推荐使用 _stprintf_s 函数</span>outtextxy(<span class="hljs-number">580</span>, <span class="hljs-number">230</span>, t);settextcolor(<span class="hljs-number">0xFFFFFF</span>);<span class="hljs-comment">//白</span>&#125;<span class="hljs-comment">//绘制蛇长度</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawnodes</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">500</span>, <span class="hljs-number">250</span>, <span class="hljs-string">L&quot;蛇身长度：&quot;</span>);settextcolor(<span class="hljs-number">0xFF55FF</span>);<span class="hljs-comment">//亮紫</span>TCHAR t[<span class="hljs-number">5</span>];_stprintf_s(t, _T(<span class="hljs-string">&quot;%d&quot;</span>), snake.num); <span class="hljs-comment">// 高版本 VC 推荐使用 _stprintf_s 函数</span>outtextxy(<span class="hljs-number">580</span>, <span class="hljs-number">250</span>, t);settextcolor(<span class="hljs-number">0xFFFFFF</span>);<span class="hljs-comment">//白</span>&#125;<span class="hljs-comment">//绘制速度</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawspeed</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;TCHAR s[] = _T(<span class="hljs-string">&quot;当前速度：&quot;</span>);settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, _T(<span class="hljs-string">&quot;宋体&quot;</span>));outtextxy(<span class="hljs-number">500</span>, <span class="hljs-number">270</span>, s);<span class="hljs-keyword">int</span> speed = <span class="hljs-number">30</span> - g_speed;<span class="hljs-comment">//速度等级显示为1 - 25</span><span class="hljs-keyword">if</span> (speed &lt;= <span class="hljs-number">9</span>)&#123;settextcolor(<span class="hljs-number">0x0000AA</span>);<span class="hljs-comment">//红-</span>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (speed &gt;= <span class="hljs-number">18</span>)&#123;settextcolor(<span class="hljs-number">0x00AA00</span>);<span class="hljs-comment">//绿</span>&#125;<span class="hljs-keyword">else</span>&#123;settextcolor(<span class="hljs-number">0x55FFFF</span>);<span class="hljs-comment">//黄</span>&#125;TCHAR t[<span class="hljs-number">5</span>];_stprintf_s(t, _T(<span class="hljs-string">&quot;%d&quot;</span>), speed); <span class="hljs-comment">// 高版本 VC 推荐使用 _stprintf_s 函数</span>outtextxy(<span class="hljs-number">580</span>, <span class="hljs-number">270</span>, t);settextcolor(<span class="hljs-number">0xFFFFFF</span>);<span class="hljs-comment">//白</span>&#125;<span class="hljs-comment">//清除程序状态区内容</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearstate</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//黑色，全填充，无边框的正方形</span>setfillcolor(BLACK);setfillstyle(BS_SOLID);solidrectangle(<span class="hljs-number">485</span>, <span class="hljs-number">330</span>, <span class="hljs-number">640</span>, <span class="hljs-number">450</span>);&#125;<span class="hljs-comment">//绘制程序暂停状态</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawpause</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;settextcolor(<span class="hljs-number">0xFF55FF</span>);<span class="hljs-comment">//亮紫</span>settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">530</span>, <span class="hljs-number">340</span>, <span class="hljs-string">L&quot;游戏暂停&quot;</span>);outtextxy(<span class="hljs-number">500</span>, <span class="hljs-number">360</span>, <span class="hljs-string">L&quot;按空格键继续&quot;</span>); settextcolor(<span class="hljs-number">0xFFFFFF</span>);<span class="hljs-comment">//白</span>&#125;<span class="hljs-comment">//绘制程序正在运行中</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawruntime</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;settextcolor(<span class="hljs-number">0x55FF55</span>);<span class="hljs-comment">//亮绿</span>settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">530</span>, <span class="hljs-number">340</span>, <span class="hljs-string">L&quot;畅玩ing&quot;</span>);settextcolor(<span class="hljs-number">0xFFFFFF</span>);<span class="hljs-comment">//白</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawover</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;settextcolor(<span class="hljs-number">0x5555FF</span>);<span class="hljs-comment">//亮红</span>settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">530</span>, <span class="hljs-number">340</span>, <span class="hljs-string">L&quot;GameOver&quot;</span>);settextcolor(<span class="hljs-number">0xFFFFFF</span>);<span class="hljs-comment">//白</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawoverchoose</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;setlinecolor(<span class="hljs-number">0xFFFFFF</span>);rectangle(<span class="hljs-number">530</span>,<span class="hljs-number">370</span>,<span class="hljs-number">600</span>,<span class="hljs-number">400</span>);settextcolor(<span class="hljs-number">0x55FF55</span>);<span class="hljs-comment">//亮绿</span>settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">540</span>, <span class="hljs-number">377</span>, <span class="hljs-string">L&quot;重来(r)&quot;</span>);settextcolor(<span class="hljs-number">0xFFFFFF</span>);<span class="hljs-comment">//白</span>setlinecolor(<span class="hljs-number">0xFFFFFF</span>);rectangle(<span class="hljs-number">530</span>, <span class="hljs-number">420</span>, <span class="hljs-number">600</span>, <span class="hljs-number">450</span>);settextcolor(<span class="hljs-number">0x5555FF</span>);<span class="hljs-comment">//亮绿</span>settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-string">L&quot;宋体&quot;</span>);outtextxy(<span class="hljs-number">540</span>, <span class="hljs-number">427</span>, <span class="hljs-string">L&quot;退出(q)&quot;</span>);settextcolor(<span class="hljs-number">0xFFFFFF</span>);<span class="hljs-comment">//白</span>&#125;</code></pre><h2 id="程序展示"><a href="#程序展示" class="headerlink" title="程序展示"></a>程序展示</h2><p>以下是B站视频</p><iframe src="//player.bilibili.com/player.html?aid=884004070&bvid=BV1mK4y1e7Uo&cid=218472438&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" style="height: 430px; max-width: 100%"> </iframe>上面视频不能播放请移步：https://www.bilibili.com/video/BV1mK4y1e7Uo/<p>也可以在博客园查看效果： <a href="https://www.cnblogs.com/colourso/p/12989716.html">https://www.cnblogs.com/colourso/p/12989716.html</a></p><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><p>链接：<a href="https://pan.baidu.com/s/1aR_p9Ji1lkj-nUoN2-o28Q">https://pan.baidu.com/s/1aR_p9Ji1lkj-nUoN2-o28Q</a><br>提取码：16eu</p><p>Github地址：<a href="https://github.com/Colourso/Simple-CPP-project-by-Colourso/">https://github.com/Colourso/Simple-CPP-project-by-Colourso/</a></p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>文件下载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基于EasyX制作贪吃蛇游戏（三）第二版文档</title>
    <link href="/c-snake-pro3/"/>
    <url>/c-snake-pro3/</url>
    
    <content type="html"><![CDATA[<p>填补一下原来留下来的坑，上接 <a href="http://www.colourso.top/c-snake-pro0/">C++基于EasyX制作贪吃蛇游戏（一）文档</a> 继续更新制作贪吃蛇游戏的一些相关设计。</p><a id="more"></a><h2 id="游戏界面设置"><a href="#游戏界面设置" class="headerlink" title="游戏界面设置"></a>游戏界面设置</h2><p><img src="/c-snake-pro3/jiemian.png"></p><p>游戏界面分为四个区域：</p><ul><li>游戏区：贪吃蛇游戏、动画展示的区域。</li><li>玩法介绍区：主要描述游戏控制相关内容。</li><li>数据展示区：展示游戏的分数、蛇身长度以及速度信息。</li><li>游戏状态区：显示游戏当前状态，运行、暂停还是游戏结束。</li></ul><h2 id="游戏展示画面的思路"><a href="#游戏展示画面的思路" class="headerlink" title="游戏展示画面的思路"></a>游戏展示画面的思路</h2><p>整个程序是基于Easyx图形库进行制作的，所以界面的全部内容都是调用相关函数绘制上去的。</p><p>提到绘制，最初的想法就是在整个程序运行的大循环之中，每次循环开始之时重新绘制整个界面的内容，这就需要保存蛇的节点以及食物、还有其他三个区域的信息，每次重新进行绘制。</p><p>但是这样感觉效率可能会是问题，所以在设计之初，就采用了<strong>局部绘制</strong>与<strong>擦除</strong>的方式。</p><ul><li>局部绘制：就是单独绘制界面需要更新的位置，而不需要重新绘制整个界面。</li><li>擦除方式：这里采用了使用<strong>背景色黑色</strong>进行覆盖的方式，整个界面背景色都是黑色，不需要的部分直接使用黑色矩阵进行覆盖掉，那么在外观上看来就是擦除的效果。</li></ul><p>例如蛇身体的绘制就是采用的局部绘制：</p><p>正常情况下蛇前进一格，就是蛇头向某个方向行走一格，然后蛇头后的其他节点都是依次复制前一个节点的位置，然后最后一个节点空余出来。这时候只需要单独绘制一个蛇的头部节点，然后擦除掉蛇的尾部节点走过的地方即可。</p><p>当然当数据展示区以及游戏状态区的内容需要更新的时候也是采用擦除然后局部绘制的方式。</p><p>当然这样会有一些不妥，如果你想把背景设置为一张图片，这种做法就会失效，当想在图片上绘制内容或者修改内容时，整个显示界面都需要重新进行绘制。</p><h2 id="显示蛇头"><a href="#显示蛇头" class="headerlink" title="显示蛇头"></a>显示蛇头</h2><p>第一版程序之中没有区分蛇头与蛇身，无论时观察还是游玩都有些不太明显。</p><p>因为蛇是一个链表的数据结构，蛇头就是链表的头节点。只需要额外对头节点绘制特殊的图形，然后擦除掉原先头节点即可。</p><pre><code class="hljs c++"><span class="hljs-comment">//在蛇头部节点的数据更新之后</span>drawsnakehead(*(snake.head));<span class="hljs-comment">//画新的头部</span>drawsnakenode(*(snake.head-&gt;next));<span class="hljs-comment">//将原来的头部变成身体的颜色</span></code></pre><h2 id="蛇的速度"><a href="#蛇的速度" class="headerlink" title="蛇的速度"></a>蛇的速度</h2><p>所谓的控制蛇的速度，也就是控制蛇每次前进一格的速度，简单点就是控制每个循环中最终<code>Sleep()</code>的时间。</p><p>延迟等待时间越长、蛇的速度也就越慢。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_SPEED 5<span class="hljs-comment">//最大速度</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_SPEED 29<span class="hljs-comment">//最小速度</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ORG_SPEED 18<span class="hljs-comment">//原始速度</span></span><span class="hljs-keyword">int</span> g_speed = ORG_SPEED; <span class="hljs-comment">//控制速度，全局变量</span></code></pre><p>这里定义三个宏，对应允许的最大速度、最小速度和原始速度。</p><p>然后定义一个全部变量<code>g_speed</code>来保存速度。</p><p>这里的速度对应的<code>Slepp()</code>延迟是1:10的关系，即<code>Sleep(g_speed*10)</code>。</p><h3 id="按键控制蛇的速度"><a href="#按键控制蛇的速度" class="headerlink" title="按键控制蛇的速度"></a>按键控制蛇的速度</h3><p>在设定中c键加速，x键减速，z键恢复原始速度。</p><p>就在代码中的按键监听部分加上相应的代码。</p><pre><code class="hljs c++"><span class="hljs-keyword">bool</span> speedchange = <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (_kbhit())&#123;    <span class="hljs-keyword">char</span> key = _getch();    <span class="hljs-keyword">switch</span> (key)    &#123;    <span class="hljs-keyword">case</span> <span class="hljs-number">99</span>: <span class="hljs-comment">//c 加速</span>        <span class="hljs-keyword">if</span> (g_speed &gt; MAX_SPEED)        &#123;            g_speed -= <span class="hljs-number">1</span>;            speedchange = <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">120</span>: <span class="hljs-comment">//x 减速</span>        <span class="hljs-keyword">if</span> (g_speed &lt; MIN_SPEED)        &#123;            g_speed += <span class="hljs-number">1</span>;            speedchange = <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">122</span>: <span class="hljs-comment">//z 回归原速</span>        g_speed = ORG_SPEED;        speedchange = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre><p>如果速度改变了，那就将<code>speedchange</code>置为true，便于之后在数据显示区进行是否刷新的判断。</p><h3 id="显示蛇的速度"><a href="#显示蛇的速度" class="headerlink" title="显示蛇的速度"></a>显示蛇的速度</h3><p>定义蛇的速度等级不能简单粗暴的从5到29，不直观。直接采用<code>30 - g_speed</code>这样的方式，得到的结果就是1到25级，初始默认是12级，等级越低速度越慢，玩家可以自行调节速度等级。</p><h2 id="游戏暂停与继续"><a href="#游戏暂停与继续" class="headerlink" title="游戏暂停与继续"></a>游戏暂停与继续</h2><p>刚开始想这个问题的时候头疼了一下，如何让一个死循环停止运行呢，答案是进入另一个死循环就行了。</p><p>设定的是空格键暂停与继续，在按键监听那里加入空格键<code>32</code>。当按了空格键之后就直接进入了另一个循环，整个界面游戏循环就暂时停滞了。</p><p>在另一个循环中一直处于按键监听等待空格键的再次按下，break循环，从而回到原来的大循环中，继续执行，这样就达到了暂停的效果。</p><pre><code class="hljs c++"><span class="hljs-keyword">case</span> <span class="hljs-number">32</span>:         <span class="hljs-comment">//空格暂停</span>        drawpause(); <span class="hljs-comment">//状态区显示</span>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)        &#123;            <span class="hljs-keyword">if</span> (_kbhit())            &#123;                <span class="hljs-keyword">char</span> key = _getch();                <span class="hljs-keyword">if</span> (key == <span class="hljs-number">32</span>) <span class="hljs-comment">//按空格继续</span>                &#123;                    clearstate();                    drawruntime(); <span class="hljs-comment">//绘制程序正在运行中</span>                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">break</span>;</code></pre><p>当然要在对应的游戏状态区给出提示，让人知道这个游戏是暂停了，而非卡死了。</p><h2 id="游戏重新开始"><a href="#游戏重新开始" class="headerlink" title="游戏重新开始"></a>游戏重新开始</h2><p><img src="/c-snake-pro3/over.png"></p><p>当失败的时候，可以选择重新开始游戏或者是退出游戏。</p><p>如何重新开始一个游戏呢？我的思路是<strong>将整个游戏的玩耍过程封装成一个函数</strong>，当我们最后游戏结束的时候，调用这个函数就能够重新开始了。</p><p>那么以为着要改动一下原来第一版的函数结构了。</p><ul><li>将原先程序中的<code>init()</code>函数中的数据初始化部分拿出来创建成<code>initdata()</code>函数。</li><li>原先的函数主体是<code>drawgame()</code>绘制游戏初始界面，以及<code>gameplay()</code>游戏玩耍控制，这两个函数。<ul><li>现在将这两个函数以及<code>initdata()</code>三个函数封装成一个<code>play()</code>函数，当需要开始游戏时直接调用<code>play()</code>函数即可。</li></ul></li></ul><p>当游戏结束的时候会给出提示r键重新开始、q键退出游戏，这一部分也是按键检测和控制的，参照上面的按键检测代码也是很容易写出来的。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于数据展示以及游戏状态展示这一部分的代码就不详细介绍了，比较简单。</p><p>还有问题就是在中文输入法下按键会优先弹出输入法的框，需要手动将输入法切换为英文。</p><p>大致这样吧，后续再更新代码。</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基于EasyX制作贪吃蛇游戏（二）第一版代码与程序简单更新</title>
    <link href="/c-snake-pro2/"/>
    <url>/c-snake-pro2/</url>
    
    <content type="html"><![CDATA[<p>填坑博客。</p><a id="more"></a><p><a href="http://www.colourso.top/c-snake-pro0/">上一篇博客</a>写了贪吃蛇的文档，这一篇博客就把第一版本的贪吃蛇代码展示一下，附带源码与可执行文件的下载。</p><p>本篇博客是原博客：<a href="http://www.colourso.top/c-snake-pro1/">C++基于EasyX制作贪吃蛇游戏（二）第一版代码与程序</a>的后续更新，填一填将近留了一年的坑。</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>原博客环境：</p><blockquote><p>工具： VS2013</p><p>依赖： EasyX Library for C++ (Ver:20180727(beta)</p></blockquote><p>整理时环境：</p><p>工具：VS2017</p><p>依赖：EasyX Library for C++ (Ver:20200520(beta))</p><h2 id="VS2017设置"><a href="#VS2017设置" class="headerlink" title="VS2017设置"></a>VS2017设置</h2><p><img src="/c-snake-pro2/peizhi.png"></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;graphics.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-comment">//蛇头方向预定义</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UP 1<span class="hljs-comment">//↑</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RIGHT 2 <span class="hljs-comment">//→</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DOWN 3  <span class="hljs-comment">//↓</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LEFT 4  <span class="hljs-comment">//←</span></span><span class="hljs-comment">/*-------------结构体定义---------------*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> //蛇的节点</span><span class="hljs-class">&#123;</span><span class="hljs-keyword">int</span> x;   <span class="hljs-comment">//横左边</span><span class="hljs-keyword">int</span> y;   <span class="hljs-comment">//纵坐标</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//指向下一个节点的指针</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">pre</span>;</span>  <span class="hljs-comment">//指向前一个节点的指针</span>&#125; *LinkNode;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Snake</span> //蛇的结构体</span><span class="hljs-class">&#123;</span>LinkNode head; <span class="hljs-comment">//指向头节点的指针</span>LinkNode tail; <span class="hljs-comment">//指向尾节点的指针</span><span class="hljs-keyword">int</span> direction; <span class="hljs-comment">//蛇头方向</span><span class="hljs-keyword">int</span> num;   <span class="hljs-comment">//节点数目</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Food</span> //食物结构体</span><span class="hljs-class">&#123;</span><span class="hljs-keyword">int</span> x;<span class="hljs-comment">//横坐标</span><span class="hljs-keyword">int</span> y;<span class="hljs-comment">//纵坐标</span><span class="hljs-keyword">bool</span> exist; <span class="hljs-comment">//是否存在，1表示存在</span>&#125;;<span class="hljs-comment">/*-------------全局变量---------------*/</span><span class="hljs-keyword">int</span> g_score = <span class="hljs-number">0</span>; <span class="hljs-comment">//获得分数</span>Snake snake; <span class="hljs-comment">//游戏中的蛇本体</span>Food food; <span class="hljs-comment">//食物</span><span class="hljs-comment">/*-------------函数声明---------------*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//初始化</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawgame</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//绘制界面</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gameplay</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//开始游戏</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//释放资源</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawfood</span><span class="hljs-params">(Food food)</span></span>;  <span class="hljs-comment">//绘制食物</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawsnake</span><span class="hljs-params">(Snake snake)</span></span>;  <span class="hljs-comment">//绘制蛇</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawsnakenode</span><span class="hljs-params">(Node node)</span></span>;<span class="hljs-comment">//绘制蛇的结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearsnakenode</span><span class="hljs-params">(Node node)</span></span>;   <span class="hljs-comment">//清除蛇的结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">snakebodymove</span><span class="hljs-params">(Snake &amp;snake)</span></span>; <span class="hljs-comment">//蛇身体结点向前复制</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">collidesnake</span><span class="hljs-params">(Snake snake)</span></span>;   <span class="hljs-comment">//碰撞自身检测</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawscore</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//绘制分数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearscore</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//清除分数</span><span class="hljs-comment">/*-------------程序入口---------------*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;init();drawgame();gameplay();close();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*-------------函数实现---------------*/</span><span class="hljs-comment">//初始化</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;initgraph(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>);   <span class="hljs-comment">//初始化窗口</span><span class="hljs-comment">//setorigin(0, 480); //设置坐标原点</span><span class="hljs-comment">//setaspectratio(1, -1); //使y轴向上为正</span><span class="hljs-comment">//蛇与食物初始化</span><span class="hljs-comment">//食物初始坐标为(310,230)</span>food.x = <span class="hljs-number">310</span>;food.y = <span class="hljs-number">230</span>;food.exist = <span class="hljs-literal">true</span>;<span class="hljs-comment">//蛇初始长度为3，蛇头坐标为(210,230)</span><span class="hljs-comment">//在堆上开辟空间，防止此函数的生命周期结束后结点全部被释放掉</span>LinkNode nodes2 = (LinkNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));nodes2-&gt;x = <span class="hljs-number">170</span>;nodes2-&gt;y = <span class="hljs-number">230</span>;nodes2-&gt;next = <span class="hljs-literal">nullptr</span>;LinkNode nodes1 = (LinkNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));nodes1-&gt;x = <span class="hljs-number">190</span>;nodes1-&gt;y = <span class="hljs-number">230</span>;nodes1-&gt;next = nodes2;LinkNode nodes0 = (LinkNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));nodes0-&gt;x = <span class="hljs-number">210</span>;nodes0-&gt;y = <span class="hljs-number">230</span>;nodes0-&gt;next = nodes1;nodes2-&gt;pre = nodes1;nodes1-&gt;pre = nodes0;nodes0-&gt;pre = <span class="hljs-literal">nullptr</span>;snake.head = nodes0;snake.tail = nodes2;snake.direction = RIGHT;snake.num = <span class="hljs-number">3</span>;<span class="hljs-comment">//初始分数</span>g_score = (snake.num - <span class="hljs-number">3</span>) * <span class="hljs-number">10</span>;&#125;<span class="hljs-comment">//绘制界面</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawgame</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//画宽度为2的棕色实线，分割区域</span>setlinecolor(BROWN);setlinestyle(PS_SOLID, <span class="hljs-number">2</span>);line(<span class="hljs-number">482</span>, <span class="hljs-number">0</span>, <span class="hljs-number">482</span>, <span class="hljs-number">480</span>);<span class="hljs-comment">//绘制食物</span>drawfood(food);<span class="hljs-comment">//绘制蛇</span>drawsnake(snake);<span class="hljs-comment">//绘制分数</span>drawscore();&#125;<span class="hljs-comment">//开始游戏</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gameplay</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;Node ends; <span class="hljs-comment">//末尾结点</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;ends.x = snake.tail-&gt;x;ends.y = snake.tail-&gt;y;<span class="hljs-keyword">if</span> (!food.exist)&#123;<span class="hljs-keyword">int</span> x;<span class="hljs-keyword">int</span> y;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;srand(time(<span class="hljs-number">0</span>));x = (rand() % <span class="hljs-number">24</span>) * <span class="hljs-number">20</span> + <span class="hljs-number">10</span>;y = (rand() % <span class="hljs-number">24</span>) * <span class="hljs-number">20</span> + <span class="hljs-number">10</span>;<span class="hljs-comment">//食物位置检测算法</span>LinkNode linknode = snake.head;<span class="hljs-keyword">bool</span> cont = <span class="hljs-literal">true</span>;<span class="hljs-keyword">while</span> (linknode != snake.tail-&gt;next)&#123;<span class="hljs-keyword">if</span> (linknode-&gt;x == x &amp;&amp; linknode-&gt;y == y)&#123;cont = <span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;linknode = linknode-&gt;next;&#125;<span class="hljs-keyword">if</span> (cont)&#123;<span class="hljs-keyword">break</span>;&#125;&#125;food.x = x;food.y = y;food.exist = <span class="hljs-literal">true</span>;drawfood(food);&#125;<span class="hljs-comment">//按键</span><span class="hljs-keyword">if</span> (_kbhit())&#123;<span class="hljs-keyword">char</span> key = _getch();<span class="hljs-keyword">switch</span> (key)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">72</span>: <span class="hljs-comment">//↑</span><span class="hljs-keyword">if</span> (snake.direction != UP &amp;&amp; snake.direction != DOWN)snake.direction = UP;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">80</span>: <span class="hljs-comment">//↓</span><span class="hljs-keyword">if</span> (snake.direction != UP &amp;&amp; snake.direction != DOWN)snake.direction = DOWN;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">75</span>: <span class="hljs-comment">//←</span><span class="hljs-keyword">if</span> (snake.direction != LEFT &amp;&amp; snake.direction != RIGHT)snake.direction = LEFT;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">77</span>: <span class="hljs-comment">//→</span><span class="hljs-keyword">if</span> (snake.direction != LEFT &amp;&amp; snake.direction != RIGHT)snake.direction = RIGHT;<span class="hljs-keyword">break</span>;&#125;&#125;                <span class="hljs-comment">//消除走过的尾部结点</span>clearsnakenode(ends);        <span class="hljs-comment">//前进</span><span class="hljs-keyword">switch</span> (snake.direction)&#123;<span class="hljs-keyword">case</span> UP:&#123;<span class="hljs-comment">//头部y-20,x不变</span>snakebodymove(snake);snake.head-&gt;y -= <span class="hljs-number">20</span>;drawsnakenode(*(snake.head));<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> RIGHT:&#123;<span class="hljs-comment">//头部x+20,y不变</span>snakebodymove(snake);snake.head-&gt;x += <span class="hljs-number">20</span>;drawsnakenode(*(snake.head));<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> DOWN:&#123;<span class="hljs-comment">//头部y+20,x不变</span>snakebodymove(snake);snake.head-&gt;y += <span class="hljs-number">20</span>;drawsnakenode(*(snake.head));<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> LEFT:&#123;<span class="hljs-comment">//头部x-20,y不变</span>snakebodymove(snake);snake.head-&gt;x -= <span class="hljs-number">20</span>;drawsnakenode(*(snake.head));<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-comment">//蛇吃食物</span><span class="hljs-keyword">if</span> (snake.head-&gt;x == food.x &amp;&amp; snake.head-&gt;y == food.y &amp;&amp; food.exist)&#123;food.exist = <span class="hljs-literal">false</span>;<span class="hljs-comment">//isClear = false;</span><span class="hljs-comment">//分数变化</span>g_score += <span class="hljs-number">10</span>;<span class="hljs-comment">//在末尾增加新的结点，维护双向链表的关系</span>LinkNode nodes = (LinkNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));nodes-&gt;x = ends.x;nodes-&gt;y = ends.y;nodes-&gt;next = snake.tail-&gt;next;nodes-&gt;pre = snake.tail;snake.tail-&gt;next = nodes;snake.tail = nodes;++snake.num;drawsnakenode(ends);clearscore();drawscore();&#125;<span class="hljs-comment">//碰撞判断</span><span class="hljs-keyword">bool</span> collidewall = snake.head-&gt;x &lt; <span class="hljs-number">10</span> || snake.head-&gt;x &gt; <span class="hljs-number">470</span> || snake.head-&gt;y &lt; <span class="hljs-number">10</span> || snake.head-&gt;y &gt; <span class="hljs-number">470</span>;<span class="hljs-keyword">if</span> (collidewall || collidesnake(snake))&#123;cleardevice();TCHAR s[] = _T(<span class="hljs-string">&quot;game over&quot;</span>);settextstyle(<span class="hljs-number">48</span>, <span class="hljs-number">0</span>, _T(<span class="hljs-string">&quot;黑体&quot;</span>));outtextxy(<span class="hljs-number">230</span>, <span class="hljs-number">280</span>, s);<span class="hljs-keyword">break</span>;&#125;Sleep(<span class="hljs-number">150</span>);&#125;&#125;<span class="hljs-comment">//释放资源</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;_getch();closegraph();&#125;<span class="hljs-comment">//绘制食物</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawfood</span><span class="hljs-params">(Food food)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//红色，全填充，无边框的圆</span>setfillcolor(RED);setfillstyle(BS_SOLID);solidcircle(food.x, food.y, <span class="hljs-number">8</span>);&#125;<span class="hljs-comment">//绘制蛇的结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawsnakenode</span><span class="hljs-params">(Node node)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//绿色，全填充，无边框的正方形</span>setfillcolor(GREEN);setfillstyle(BS_SOLID);solidrectangle(node.x - <span class="hljs-number">9</span>, node.y + <span class="hljs-number">9</span>, node.x + <span class="hljs-number">9</span>, node.y - <span class="hljs-number">9</span>);&#125;<span class="hljs-comment">//清除蛇的结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearsnakenode</span><span class="hljs-params">(Node node)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//黑色，全填充，无边框的正方形</span>setfillcolor(BLACK);setfillstyle(BS_SOLID);solidrectangle(node.x - <span class="hljs-number">9</span>, node.y + <span class="hljs-number">9</span>, node.x + <span class="hljs-number">9</span>, node.y - <span class="hljs-number">9</span>);&#125;<span class="hljs-comment">//绘制蛇</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawsnake</span><span class="hljs-params">(Snake snake)</span></span><span class="hljs-function"></span>&#123;LinkNode linknode = snake.head;<span class="hljs-keyword">while</span> (linknode != snake.tail-&gt;next)&#123;drawsnakenode(*linknode);linknode = linknode-&gt;next;&#125;&#125;<span class="hljs-comment">//蛇身体结点向前复制</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">snakebodymove</span><span class="hljs-params">(Snake &amp;snake)</span></span><span class="hljs-function"></span>&#123;LinkNode linknode = snake.tail;<span class="hljs-keyword">while</span> (linknode != snake.head)&#123;linknode-&gt;x = linknode-&gt;pre-&gt;x;linknode-&gt;y = linknode-&gt;pre-&gt;y;linknode = linknode-&gt;pre;&#125;&#125;<span class="hljs-comment">//碰撞自身检测</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">collidesnake</span><span class="hljs-params">(Snake snake)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (snake.num &lt;= <span class="hljs-number">3</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;LinkNode node = snake.head-&gt;next;<span class="hljs-keyword">while</span> (node != snake.tail-&gt;next)&#123;<span class="hljs-keyword">if</span> (node-&gt;x == snake.head-&gt;x &amp;&amp; node-&gt;y == snake.head-&gt;y)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;node = node-&gt;next;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-comment">//绘制分数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawscore</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;TCHAR s[] = _T(<span class="hljs-string">&quot;获得分数：&quot;</span>);settextstyle(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>, _T(<span class="hljs-string">&quot;黑体&quot;</span>));outtextxy(<span class="hljs-number">485</span>, <span class="hljs-number">300</span>, s);TCHAR t[<span class="hljs-number">5</span>];_stprintf_s(t, _T(<span class="hljs-string">&quot;%d&quot;</span>), g_score); <span class="hljs-comment">// 高版本 VC 推荐使用 _stprintf_s 函数</span>outtextxy(<span class="hljs-number">560</span>, <span class="hljs-number">300</span>, t);&#125;<span class="hljs-comment">//清除分数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearscore</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//黑色，全填充，无边框的正方形</span>setfillcolor(BLACK);setfillstyle(BS_SOLID);solidrectangle(<span class="hljs-number">485</span>, <span class="hljs-number">480</span>, <span class="hljs-number">640</span>, <span class="hljs-number">300</span>);&#125;</code></pre><h2 id="程序展示"><a href="#程序展示" class="headerlink" title="程序展示"></a>程序展示</h2><p>以下是B站视频</p><iframe src="//player.bilibili.com/player.html?aid=329094241&bvid=BV1bA411Y7L9&cid=218470238&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" style="height: 430px; max-width: 100%"> </iframe>上面视频不能播放请移步：https://www.bilibili.com/video/BV1bA411Y7L9/<p><img src="/c-snake-pro2/show.png"></p><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><p>原先：百度网盘链接：<a href="https://pan.baidu.com/s/1O3EqtcAeciukwt2uixC7RQ">https://pan.baidu.com/s/1O3EqtcAeciukwt2uixC7RQ</a><br>提取码：tm95</p><p>新第一版：链接：<a href="https://pan.baidu.com/s/1hNfVsYZp-I6dH2875FR7iw">https://pan.baidu.com/s/1hNfVsYZp-I6dH2875FR7iw</a><br>提取码：a4b2 </p><p><img src="/c-snake-pro2/floder.png"></p><p>Github地址：<a href="https://github.com/Colourso/Simple-CPP-project-by-Colourso/">https://github.com/Colourso/Simple-CPP-project-by-Colourso/</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于上述程序之中的一些问题，比如使用vs生成的文件结构、字符集设置的问题，还有<code>_T()</code>是什么意思？</p><p>在此博客中查看： <a href="http://www.colourso.top/vs-use/">VS开发C++的一些问题——VS项目工程文件、Debug与Relase模式、字符集问题以及_T()宏</a>。</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>文件下载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转载】跟着9张思维导图学习Javascript</title>
    <link href="/Js-learn/"/>
    <url>/Js-learn/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：【转载】跟着9张思维导图学习Javascript</p><a id="more"></a><hr><blockquote><p>原文链接： <a href="https://www.cnblogs.com/coco1s/p/3953653.html">https://www.cnblogs.com/coco1s/p/3953653.html</a></p></blockquote><hr><h2 id="javascript变量"><a href="#javascript变量" class="headerlink" title="javascript变量"></a>javascript变量</h2><p><img src="https://s1.ax1x.com/2020/05/17/YgOBgx.gif" alt="YgOBgx.gif"></p><h2 id="javascript运算符"><a href="#javascript运算符" class="headerlink" title="javascript运算符"></a>javascript运算符</h2><p><img src="https://s1.ax1x.com/2020/05/17/YgO2UH.gif" alt="YgO2UH.gif"></p><h2 id="javascript数组"><a href="#javascript数组" class="headerlink" title="javascript数组"></a>javascript数组</h2><p><img src="https://s1.ax1x.com/2020/05/17/YgO6bD.gif" alt="YgO6bD.gif"></p><h2 id="javascript流程语句"><a href="#javascript流程语句" class="headerlink" title="javascript流程语句"></a>javascript流程语句</h2><p><img src="https://s1.ax1x.com/2020/05/17/YgOyDO.gif" alt="YgOyDO.gif"></p><h2 id="javascript字符串函数"><a href="#javascript字符串函数" class="headerlink" title="javascript字符串函数"></a>javascript字符串函数</h2><p><img src="https://s1.ax1x.com/2020/05/17/YgOR5d.gif" alt="YgOR5d.gif"></p><h2 id="javascript函数基础"><a href="#javascript函数基础" class="headerlink" title="javascript函数基础"></a>javascript函数基础</h2><p><img src="https://s1.ax1x.com/2020/05/17/YgODv6.gif" alt="YgODv6.gif"></p><h2 id="javascript基础DOM操作"><a href="#javascript基础DOM操作" class="headerlink" title="javascript基础DOM操作"></a>javascript基础DOM操作</h2><p><img src="https://s1.ax1x.com/2020/05/17/YgOsKK.gif" alt="YgOsKK.gif"></p><h2 id="文档对象模型DOM"><a href="#文档对象模型DOM" class="headerlink" title="文档对象模型DOM"></a>文档对象模型DOM</h2><p><img src="https://s1.ax1x.com/2020/05/17/YgjQXV.jpg" alt="YgjQXV.jpg"></p><h2 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a>BOM对象</h2><p><img src="https://s1.ax1x.com/2020/05/17/YgjM60.jpg" alt="YgjM60.jpg"></p><h2 id="javascript正则表达式"><a href="#javascript正则表达式" class="headerlink" title="javascript正则表达式"></a>javascript正则表达式</h2><p><img src="https://s1.ax1x.com/2020/05/17/YgOgVe.gif" alt="YgOgVe.gif"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小白文</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql数据库实例 —— 物流管理平台</title>
    <link href="/mysql-instance/"/>
    <url>/mysql-instance/</url>
    
    <content type="html"><![CDATA[<p>源自网络，仅作参考！</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="/mysql-instance/shuoming1.jpg"></p><p><img src="/mysql-instance/shuoming2.png"></p><h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><img src="/mysql-instance/link.png" style="zoom:80%;"><h2 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h2><img src="/mysql-instance/er.png" style="zoom:67%;"><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><pre><code class="hljs mysql">&#x2F;* Navicat MySQL Data Transfer Source Server         : 本地连接 Source Server Type    : MySQL Source Server Version : 50527 Source Host           : localhost:3306 Source Schema         : 物资管理数据库系统 Target Server Type    : MySQL Target Server Version : 50527 File Encoding         : 65001 Date: 22&#x2F;04&#x2F;2020 10:51:45*&#x2F;SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS &#x3D; 0;-- ------------------------------ Table structure for 仓库-- ----------------------------DROP TABLE IF EXISTS &#96;仓库&#96;;CREATE TABLE &#96;仓库&#96;  (  &#96;仓库编号&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  &#96;仓库管理员&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;联系电话&#96; int(11) NULL DEFAULT NULL,  &#96;仓库地址&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  PRIMARY KEY (&#96;仓库编号&#96;) USING BTREE) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Compact;-- ------------------------------ Table structure for 仓库存储系统-- ----------------------------DROP TABLE IF EXISTS &#96;仓库存储系统&#96;;CREATE TABLE &#96;仓库存储系统&#96;  (  &#96;仓库编号&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  &#96;产品编号&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  &#96;产品价格&#96; float(255, 2) NULL DEFAULT NULL,  &#96;库存数量&#96; int(255) NULL DEFAULT NULL,  PRIMARY KEY (&#96;仓库编号&#96;, &#96;产品编号&#96;) USING BTREE,  INDEX &#96;产品&#96;(&#96;产品编号&#96;) USING BTREE,  CONSTRAINT &#96;产品&#96; FOREIGN KEY (&#96;产品编号&#96;) REFERENCES &#96;医疗物资&#96; (&#96;产品编号&#96;) ON DELETE NO ACTION ON UPDATE NO ACTION,  CONSTRAINT &#96;仓库&#96; FOREIGN KEY (&#96;仓库编号&#96;) REFERENCES &#96;仓库&#96; (&#96;仓库编号&#96;) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Compact;-- ------------------------------ Table structure for 出售联系-- ----------------------------DROP TABLE IF EXISTS &#96;出售联系&#96;;CREATE TABLE &#96;出售联系&#96;  (  &#96;厂家登录名&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  &#96;产品编号&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  &#96;产品价格&#96; float(255, 2) NULL DEFAULT NULL,  &#96;库存数量&#96; int(255) NULL DEFAULT NULL,  PRIMARY KEY (&#96;厂家登录名&#96;, &#96;产品编号&#96;) USING BTREE,  INDEX &#96;医疗物资&#96;(&#96;产品编号&#96;) USING BTREE,  CONSTRAINT &#96;医疗物资&#96; FOREIGN KEY (&#96;产品编号&#96;) REFERENCES &#96;医疗物资&#96; (&#96;产品编号&#96;) ON DELETE NO ACTION ON UPDATE NO ACTION,  CONSTRAINT &#96;厂家&#96; FOREIGN KEY (&#96;厂家登录名&#96;) REFERENCES &#96;厂家&#96; (&#96;登录名&#96;) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Compact;-- ------------------------------ Table structure for 医疗物资-- ----------------------------DROP TABLE IF EXISTS &#96;医疗物资&#96;;CREATE TABLE &#96;医疗物资&#96;  (  &#96;产品编号&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  &#96;产品名称&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;产品类别&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;厂家名称&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  PRIMARY KEY (&#96;产品编号&#96;) USING BTREE,  INDEX &#96;所属公司&#96;(&#96;厂家名称&#96;) USING BTREE,  CONSTRAINT &#96;所属公司&#96; FOREIGN KEY (&#96;厂家名称&#96;) REFERENCES &#96;厂家&#96; (&#96;登录名&#96;) ON DELETE RESTRICT ON UPDATE RESTRICT) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Compact;-- ------------------------------ Table structure for 医院-- ----------------------------DROP TABLE IF EXISTS &#96;医院&#96;;CREATE TABLE &#96;医院&#96;  (  &#96;用户名&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  &#96;采购员&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;联系方式&#96; int(11) NULL DEFAULT NULL,  &#96;CID&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;口罩需求量&#96; int(255) NULL DEFAULT NULL,  &#96;防护服需求量&#96; int(255) NULL DEFAULT NULL,  &#96;呼吸机需求量&#96; int(255) NULL DEFAULT NULL,  PRIMARY KEY (&#96;用户名&#96;) USING BTREE,  INDEX &#96;CID&#96;(&#96;CID&#96;) USING BTREE) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Compact;-- ------------------------------ Table structure for 厂家-- ----------------------------DROP TABLE IF EXISTS &#96;厂家&#96;;CREATE TABLE &#96;厂家&#96;  (  &#96;登录名&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  &#96;联系电话&#96; int(11) NULL DEFAULT NULL,  &#96;有效营业执照&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;银行卡号&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;仓库编号&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  PRIMARY KEY (&#96;登录名&#96;) USING BTREE,  INDEX &#96;仓库号&#96;(&#96;仓库编号&#96;) USING BTREE,  CONSTRAINT &#96;仓库号&#96; FOREIGN KEY (&#96;仓库编号&#96;) REFERENCES &#96;仓库&#96; (&#96;仓库编号&#96;) ON DELETE RESTRICT ON UPDATE RESTRICT) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Compact;-- ------------------------------ Table structure for 取货货单-- ----------------------------DROP TABLE IF EXISTS &#96;取货货单&#96;;CREATE TABLE &#96;取货货单&#96;  (  &#96;货单编号&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  &#96;产品编号&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  &#96;仓库编号&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;取货数量&#96; int(255) NULL DEFAULT NULL,  &#96;取货时间&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;采购员编号&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;送货员联系方式&#96; int(11) NULL DEFAULT NULL,  PRIMARY KEY (&#96;货单编号&#96;) USING BTREE,  INDEX &#96;产品编号&#96;(&#96;产品编号&#96;) USING BTREE,  INDEX &#96;仓库编号&#96;(&#96;仓库编号&#96;) USING BTREE,  INDEX &#96;采购员&#96;(&#96;采购员编号&#96;) USING BTREE,  CONSTRAINT &#96;采购员&#96; FOREIGN KEY (&#96;采购员编号&#96;) REFERENCES &#96;医院&#96; (&#96;CID&#96;) ON DELETE NO ACTION ON UPDATE NO ACTION,  CONSTRAINT &#96;产品编号&#96; FOREIGN KEY (&#96;产品编号&#96;) REFERENCES &#96;医疗物资&#96; (&#96;产品编号&#96;) ON DELETE NO ACTION ON UPDATE NO ACTION,  CONSTRAINT &#96;仓库编号&#96; FOREIGN KEY (&#96;仓库编号&#96;) REFERENCES &#96;仓库&#96; (&#96;仓库编号&#96;) ON DELETE NO ACTION ON UPDATE NO ACTION,  CONSTRAINT &#96;取货员&#96; FOREIGN KEY (&#96;采购员编号&#96;) REFERENCES &#96;送货员&#96; (&#96;S_ID&#96;) ON DELETE RESTRICT ON UPDATE RESTRICT) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Compact;-- ------------------------------ Table structure for 物流公司-- ----------------------------DROP TABLE IF EXISTS &#96;物流公司&#96;;CREATE TABLE &#96;物流公司&#96;  (  &#96;公司名称&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT &#39;&#39;,  &#96;送货员&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;S_ID&#96; int(30) NULL DEFAULT NULL,  &#96;联系电话&#96; int(30) NULL DEFAULT NULL,  &#96;收货人&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;产品名称&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;寄货人&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;配送状态&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  PRIMARY KEY (&#96;公司名称&#96;) USING BTREE,  INDEX &#96;S_ID&#96;(&#96;S_ID&#96;) USING BTREE) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Compact;-- ------------------------------ Table structure for 签约-- ----------------------------DROP TABLE IF EXISTS &#96;签约&#96;;CREATE TABLE &#96;签约&#96;  (  &#96;厂家名&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  &#96;签约时间&#96; int(255) NULL DEFAULT NULL,  &#96;公司名称&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  PRIMARY KEY (&#96;厂家名&#96;, &#96;公司名称&#96;) USING BTREE,  INDEX &#96;物公司&#96;(&#96;公司名称&#96;) USING BTREE,  CONSTRAINT &#96;物公司&#96; FOREIGN KEY (&#96;公司名称&#96;) REFERENCES &#96;物流公司&#96; (&#96;公司名称&#96;) ON DELETE RESTRICT ON UPDATE RESTRICT,  CONSTRAINT &#96;公司名&#96; FOREIGN KEY (&#96;厂家名&#96;) REFERENCES &#96;厂家&#96; (&#96;登录名&#96;) ON DELETE RESTRICT ON UPDATE RESTRICT) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Compact;-- ------------------------------ Table structure for 送货员-- ----------------------------DROP TABLE IF EXISTS &#96;送货员&#96;;CREATE TABLE &#96;送货员&#96;  (  &#96;S_ID&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  &#96;姓名&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;联系方式&#96; int(11) NULL DEFAULT NULL,  &#96;所属公司&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  PRIMARY KEY (&#96;S_ID&#96;) USING BTREE,  INDEX &#96;所属&#96;(&#96;所属公司&#96;) USING BTREE,  CONSTRAINT &#96;所属&#96; FOREIGN KEY (&#96;所属公司&#96;) REFERENCES &#96;物流公司&#96; (&#96;公司名称&#96;) ON DELETE RESTRICT ON UPDATE RESTRICT) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Compact;-- ------------------------------ Table structure for 配送联系-- ----------------------------DROP TABLE IF EXISTS &#96;配送联系&#96;;CREATE TABLE &#96;配送联系&#96;  (  &#96;送货单号&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  &#96;送货员编号&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;联系方式&#96; int(255) NULL DEFAULT NULL,  &#96;货物编号&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;预计送达时间&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;出货仓库编号&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;收货人&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  PRIMARY KEY (&#96;送货单号&#96;) USING BTREE,  INDEX &#96;送货员&#96;(&#96;送货员编号&#96;) USING BTREE,  INDEX &#96;物资编号&#96;(&#96;货物编号&#96;) USING BTREE,  INDEX &#96;出货仓库&#96;(&#96;出货仓库编号&#96;) USING BTREE,  INDEX &#96;医院用户名&#96;(&#96;收货人&#96;) USING BTREE,  CONSTRAINT &#96;送货员&#96; FOREIGN KEY (&#96;送货员编号&#96;) REFERENCES &#96;送货员&#96; (&#96;S_ID&#96;) ON DELETE NO ACTION ON UPDATE NO ACTION,  CONSTRAINT &#96;出货仓库&#96; FOREIGN KEY (&#96;出货仓库编号&#96;) REFERENCES &#96;仓库&#96; (&#96;仓库编号&#96;) ON DELETE NO ACTION ON UPDATE NO ACTION,  CONSTRAINT &#96;医院用户名&#96; FOREIGN KEY (&#96;收货人&#96;) REFERENCES &#96;医院&#96; (&#96;用户名&#96;) ON DELETE RESTRICT ON UPDATE RESTRICT) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Compact;-- ------------------------------ Table structure for 采购联系-- ----------------------------DROP TABLE IF EXISTS &#96;采购联系&#96;;CREATE TABLE &#96;采购联系&#96;  (  &#96;订单号&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,  &#96;产品编号&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;采购数量&#96; int(255) NULL DEFAULT NULL,  &#96;采购时间&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;用户名&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  PRIMARY KEY (&#96;订单号&#96;) USING BTREE,  INDEX &#96;产品编号1&#96;(&#96;产品编号&#96;) USING BTREE,  INDEX &#96;医院名&#96;(&#96;用户名&#96;) USING BTREE,  CONSTRAINT &#96;医院名&#96; FOREIGN KEY (&#96;用户名&#96;) REFERENCES &#96;医院&#96; (&#96;用户名&#96;) ON DELETE RESTRICT ON UPDATE RESTRICT,  CONSTRAINT &#96;产品编号1&#96; FOREIGN KEY (&#96;产品编号&#96;) REFERENCES &#96;医疗物资&#96; (&#96;产品编号&#96;) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Compact;SET FOREIGN_KEY_CHECKS &#x3D; 1;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小白文</tag>
      
      <tag>数据库</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql语法小结</title>
    <link href="/mysql-use/"/>
    <url>/mysql-use/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：Mysql语句，Mysql的基本操作。</p><a id="more"></a><hr><h2 id="Mysql的服务端、客户端操作"><a href="#Mysql的服务端、客户端操作" class="headerlink" title="Mysql的服务端、客户端操作"></a>Mysql的服务端、客户端操作</h2><p>以下为Windows平台的操作</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 开启服务器</span>net start mysql<span class="hljs-meta">#</span><span class="bash"> &gt; 查看进程表中是否存在：mysqld.exe进程(存在)</span><span class="hljs-meta">#</span><span class="bash"> 关闭服务器</span>net stop mysql<span class="hljs-meta">#</span><span class="bash"> &gt; 查看进程表中是否存在：mysqld.exe进程(不存在)</span></code></pre><p>客户端操作</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 登陆服务器</span>mysql -uroot -p123 -hlocalhost</code></pre><ul><li><code>-u</code>：后面跟随用户名</li><li><code>-p</code>：后面跟随密码</li><li><code>-h</code>：后面跟随IP</li></ul><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 退出服务器</span>exit 或者 quit</code></pre><h2 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h2><ol><li>SQL语句可以在单行或多行书写，以分号结尾</li><li>可使用空格和缩进来增强语句的可读性</li><li>MySQL不区别大小写，建议使用大写</li></ol><h3 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h3><ol><li><p>DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：库、表、列等；<strong>创建、删除、修改：库、表结构</strong></p></li><li><p>DML（Data Manipulation Language）：数据操作语言，用来定义数据库记录（数据）；<strong>增、删、改：表记录</strong></p></li><li><p>DCL（Data Control Language）：数据控制语言，用来定义访问权限和安全级别；</p></li><li><p>DQL（Data Query Language）：数据查询语言，用来查询记录（数据）。</p></li></ol><h3 id="数据类型（列数据）"><a href="#数据类型（列数据）" class="headerlink" title="数据类型（列数据）"></a>数据类型（列数据）</h3><ul><li>int：整型</li><li>double：浮点型，例如double(5,2)表示最多5位，其中必须有2位小数，即最大值为999.99；</li><li>decimal：浮点型，在表单、钱方面使用该类型，因为不会出现精度缺失问题；</li><li>char：固定长度字符串类型； char(255)，数据的长度不足指定长度，补足到指定长度！</li><li>varchar：<strong>可变长度</strong>字符串类型； varchar(2)</li><li>text：字符串类型，长文本数据。</li><li>blob：二进制形式长文本数据。</li><li>date：日期类型，格式为：yyyy-MM-dd；</li><li>time：时间类型，格式为：hh:mm:ss</li><li>timestamp：时间戳类型；</li></ul><h2 id="DDL-–-数据定义语言"><a href="#DDL-–-数据定义语言" class="headerlink" title="DDL – 数据定义语言"></a>DDL – 数据定义语言</h2><p>数据库</p><pre><code class="hljs sql">查看所有数据库：<span class="hljs-keyword">SHOW</span> DATABASES创建数据库：<span class="hljs-keyword">CREATE</span> DATABASE [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] 数据库名 [CHARSET<span class="hljs-operator">=</span>utf8]切换（选择要操作的）数据库：USE 数据库名删除数据库：<span class="hljs-keyword">DROP</span> DATABASE [IF <span class="hljs-keyword">EXISTS</span>] 数据库名修改数据库编码：<span class="hljs-keyword">ALTER</span> DATABASE 数据库名 <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8</code></pre><p>表：</p><pre><code class="hljs sql">创建表：  <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] 表名(    列名 列类型,    列名 列类型,    ...    列名 列类型  );查看当前数据库中所有表名称：<span class="hljs-keyword">SHOW</span> TABLES;查看指定表的创建语句：<span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(了解);查看表结构：<span class="hljs-keyword">DESC</span> 表名;删除表：<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> 表名;修改表：前缀：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名  <span class="hljs-operator">&gt;</span> 修改之添加列：    <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> (      列名 列类型,      列名 列类型,      ...    );  <span class="hljs-operator">&gt;</span> 修改之修改列类型(如果被修改的列已存在数据，那么新的类型可能会影响到已存在数据)：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 列名 列新类型;  <span class="hljs-operator">&gt;</span> 修改之修改列名：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 CHANGE 原列名 新列名 列类型;  <span class="hljs-operator">&gt;</span> 修改之删除列：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> 列名;  <span class="hljs-operator">&gt;</span> 修改表名称：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 原表名 RENAME <span class="hljs-keyword">TO</span> 新表名;</code></pre><h2 id="DML-–-数据操作语言"><a href="#DML-–-数据操作语言" class="headerlink" title="DML – 数据操作语言"></a>DML – 数据操作语言</h2><ol><li>插入数据</li></ol><ul><li><p><code>INTERT INTO 表名(列名1,列名2, ...) VALUES(列值1, 列值2, ...);</code></p><blockquote><p>在表名后给出要插入的列名，其他没有指定的列等同与插入null值。所以插入记录总是插入一行，不可能是半行。<br>在VALUES后给出列值，值的顺序和个数必须与前面指定的列对应</p></blockquote></li><li><p><code>INTERT INTO 表名 VALUES(列值1, 列值2)</code></p><blockquote><p>没有给出要插入的列，那么表示插入所有列。<br>值的个数必须是该表列的个数。<br>值的顺序，必须与表创建时给出的列的顺序相同。</p></blockquote></li></ul><ol start="2"><li>修改数据</li></ol><ul><li><code>UPDATE 表名 SET 列名1=列值1, 列名2=列值2, ... [WHERE 条件]</code></li><li>条件(条件可选的)：<blockquote><p>条件必须是一个boolean类型的值或表达式：<code>UPDATE t_person SET gender=&#39;男&#39;, age=age+1 WHERE sid=&#39;1&#39;;</code><br>运算符：<code>=、!=、&lt;&gt;、&gt;、&lt;、&gt;=、&lt;=、BETWEEN...AND、IN(...)、IS NULL、NOT、OR、AND</code></p></blockquote></li></ul><pre><code class="hljs mysql">WHERE age &gt;&#x3D; 18 AND age &lt;&#x3D; 80WHERE age BETWEEN 18 AND 80WHERE name&#x3D;&#39;zhangSan&#39; OR name&#x3D;&#39;liSi&#39;WHERE name IN (&#39;zhangSan&#39;, &#39;liSi&#39;)WHERE age IS NULL# 判断NULL时不能使用等号WHERE age IS NOT NULL</code></pre><ol start="3"><li>删除数据</li></ol><ul><li><code>DELETE FROM 表名 [WHERE 条件];</code></li><li>TRUNCATE TABLE 表名：TRUNCATE是DDL语句，它是先删除drop该表，再create该表。而且无法回滚！！！</li></ul><blockquote><p>在数据库中所有的字符串类型，必须使用单引，不能使用双引！日期类型也要使用单引！？？？</p><p>留存疑问</p></blockquote><pre><code class="hljs mysql">&#x2F;&#x2F; 插入所有列INSERT INTO stu(  number, name, age, gender)VALUES(  &#39;ITCAST_0001&#39;, &#39;zhangSan&#39;, 28, &#39;male&#39;);&#x2F;&#x2F; 插入部分列，没有指定的列默认为NULL值INSERT INTO stu(  number, name) VAKLUES(  &#39;ITCAST_0002&#39;, &#39;liSi&#39;)&#x2F;&#x2F; 不给出插入列，那么默认为插入所有列！值的顺序要与创建表时列的顺序相同INSERT INTO stu VALUES(  &#39;ITCAST_0003&#39;, &#39;wangWu&#39;, 82, &#39;female&#39;);</code></pre><h2 id="DCL-–-数据控制语言-理解"><a href="#DCL-–-数据控制语言-理解" class="headerlink" title="DCL – 数据控制语言(理解)"></a>DCL – 数据控制语言(理解)</h2><ul><li>一个项目创建一个用户！一个项目对应的数据库只有一个！</li><li>这个用户只能对这个数据库有权限，其他数据库你就操作不了了！</li></ul><ol><li>创建用户</li></ol><ul><li><p><code>CREATE USER 用户名@IP地址 IDENTIFIED BY &#39;密码&#39;;</code></p><blockquote><p>用户只能在指定的IP地址上登录</p></blockquote></li><li><p><code>CREATE USER 用户名@&#39;%&#39; IDENTIFIED BY &#39;密码&#39;;</code></p><blockquote><p>用户可以在任意IP地址上登录</p></blockquote></li></ul><ol start="2"><li>给用户授权</li></ol><ul><li><p><code>GRANT 权限1, … , 权限n ON 数据库.* TO 用户名@IP地址</code></p><blockquote><p>权限、用户、数据库<br>给用户分派在指定的数据库上的指定的权限<br>例如；GRANT CREATE,ALTER,DROP,INSERT,UPDATE,DELETE,SELECT ON mydb1.* TO user1@localhost;</p><ul><li>给user1用户分派在mydb1数据库上的create、alter、drop、insert、update、delete、select权限</li></ul></blockquote></li><li><p><code>GRANT ALL ON 数据库.* TO 用户名@IP地址;</code></p><blockquote><p>给用户分派指定数据库上的所有权限</p></blockquote></li></ul><ol start="3"><li>撤销授权</li></ol><ul><li><p><code>REVOKE 权限1, … , 权限n ON 数据库.* FROM 用户名@IP地址;</code></p><blockquote><p>撤消指定用户在指定数据库上的指定权限<br>例如；REVOKE CREATE,ALTER,DROP ON mydb1.* FROM user1@localhost;</p><ul><li>撤消user1用户在mydb1数据库上的create、alter、drop权限</li></ul></blockquote></li></ul><ol start="4"><li>查看权限</li></ol><ul><li><p><code>SHOW GRANTS FOR 用户名@IP地址</code></p><blockquote><p>查看指定用户的权限</p></blockquote></li></ul><h2 id="DQL-–-数据查询语言"><a href="#DQL-–-数据查询语言" class="headerlink" title="DQL – 数据查询语言"></a>DQL – 数据查询语言</h2><p>查询不会修改数据库表记录。</p><h3 id="字段-列-控制"><a href="#字段-列-控制" class="headerlink" title="字段(列)控制"></a>字段(列)控制</h3><ol><li>查询所有列</li></ol><pre><code class="hljs mysql">SELECT * FROM 表名;SELECT * FROM emp;--&gt; 其中“*”表示查询所有列</code></pre><ol start="2"><li> 查询指定列</li></ol><pre><code class="hljs mysql">SELECT 列1 [, 列2, ... 列N] FROM 表名;SELECT empno, ename, sal, comm FROM 表名;</code></pre><ol start="3"><li>完全重复的记录只一次<br>当查询结果中的多行记录一模一样时，只显示一行。一般查询所有列时很少会有这种情况，但只查询一列（或几列）时，这总可能就大了！</li></ol><pre><code class="hljs mysql">SELECT DISTINCT * | 列1 [, 列2, ... 列N] FROM 表名;SELECT DISTINCT sal FROM emp; --&gt; 保查询员工表的工资，如果存在相同的工资只显示一次！</code></pre><ol start="4"><li>列运算</li></ol><ul><li>数量类型的列可以做加、减、乘、除运算</li></ul><pre><code class="hljs mysql">SELECT sal*1.5 FROM emp;SELECT sal+comm FROM emp;</code></pre><ul><li> 字符串类型可以做连续运算</li></ul><pre><code class="hljs mysql">SELECT CONCAT(&#39;$&#39;, sal) FROM emp;</code></pre><ul><li>转换NULL值<br>   有时需要把NULL转换成其它值，例如com+1000时，如果com列存在NULL值，那么NULL+1000还是NULL，而我们这时希望把NULL当前0来运算。</li></ul><pre><code class="hljs mysql">SELECT IFNULL(comm, 0)+1000 FROM emp;--&gt; IFNULL(comm, 0)：如果comm中存在NULL值，那么当成0来运算。</code></pre><ul><li>给列起别名<br>   你也许已经注意到了，当使用列运算后，查询出的结果集中的列名称很不好看，这时我们需要给列名起个别名，这样在结果集中列名就显示别名了</li></ul><pre><code class="hljs mysql">SELECT IFNULL(comm, 0)+1000 AS 奖金 FROM emp;--&gt; 其中AS可以省略</code></pre><h3 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h3><ol><li><p>条件查询<br>  与前面介绍的UPDATE和DELETE语句一样，SELECT语句也可以使用WHERE子句来控制记录。</p>  <pre><code class="hljs mysql">SELECT empno,ename,sal,comm FROM emp WHERE sal &gt; 10000 AND comm IS NOT NULL;SELECT empno,ename,sal FROM emp WHERE sal BETWEEN 20000 AND 30000;SELECT empno,ename,job FROM emp WHERE job IN (&#39;经理&#39;, &#39;董事长&#39;);</code></pre></li><li><p>模糊查询<br>当你想查询姓张，并且姓名一共两个字的员工时，这时就可以使用模糊查询</p><pre><code class="hljs mysql">SELECT * FROM emp WHERE ename LIKE &#39;张_&#39;;--&gt; 模糊查询需要使用运算符：LIKE，其中_匹配一个任意字符，注意，只匹配一个字符而不是多个。--&gt; 上面语句查询的是姓张，名字由两个字组成的员工。SELECT * FROM emp WHERE ename LIKE &#39;___&#39;; &#x2F;*姓名由3个字组成的员工*&#x2F;# 如果我们想查询姓张，名字是几个字都可以的员工时就要使用“%”了。SELECT * FROM emp WHERE ename LIKE &#39;张%&#39;;--&gt; 其中%匹配0~N个任意字符，所以上面语句查询的是姓张的所有员工。SELECT * FROM emp WHERE ename LIKE &#39;%阿%&#39;;--&gt; 千万不要认为上面语句是在查询姓名中间带有阿字的员工，因为%匹配0~N个字符，所以姓名以阿开头和结尾的员工也都会查询到。SELECT * FROM emp WHERE ename LIKE &#39;%&#39;;--&gt; 这个条件等同于不存在，但如果姓名为NULL的查询不出来！</code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3></li><li><p>升序</p><pre><code class="hljs mysql">SELECT * FROM emp ORDER BY sal ASC;--&gt; 按sal排序，升序！--&gt; 其中ASC是可以省略的</code></pre></li><li><p>降序</p> <pre><code class="hljs mysql">SELECT * FROM WHERE emp ORDER BY comm DESC;--&gt; 按comm排序，降序！--&gt; 其中DESC不能省略</code></pre></li><li><p>使用多列作为排序条件</p><pre><code class="hljs mysql">SELECT * FROM WHERE emp ORDER BY sal ASC, comm DESC;--&gt; 使用sal升序排，如果sal相同时，使用comm的降序排</code></pre><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3></li></ol><p>聚合函数用来做某列的纵向运算。</p><ol><li><p>COUNT</p> <pre><code class="hljs mysql">SELECT COUNT(*) FROM emp;--&gt; 计算emp表中所有列都不为NULL的记录的行数SELECT COUNT(comm) FROM emp;--&gt; 云计算emp表中comm列不为NULL的记录的行数</code></pre></li><li><p>MAX</p>  <pre><code class="hljs mysql">SELECT MAX(sal) FROM emp;--&gt; 查询最高工资</code></pre></li><li><p>MIN</p> <pre><code class="hljs mysql">SELECT MIN(sal) FROM emp;--&gt; 查询最低工资</code></pre></li><li><p>SUM</p>  <pre><code class="hljs mysql">SELECT SUM(sal) FROM emp;--&gt; 查询工资合</code></pre></li><li><p>AVG</p>  <pre><code class="hljs mysql">SELECT AVG(sal) FROM emp;--&gt; 查询平均工资</code></pre><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3></li></ol><p>分组查询是把记录使用某一列进行分组，然后查询组信息。<br>例如：查看所有部门的记录数。</p><pre><code class="hljs mysql">SELECT deptno, COUNT(*) FROM emp GROUP BY deptno;--&gt; 使用deptno分组，查询部门编号和每个部门的记录数SELECT job, MAX(SAL) FROM emp GROUP BY job;--&gt; 使用job分组，查询每种工作的最高工资</code></pre><p>组条件<br>以部门分组，查询每组记录数。条件为记录数大于3</p><pre><code class="hljs mysql">SELECT deptno, COUNT(*) FROM emp GROUP BY deptno HAVING COUNT(*) &gt; 3;</code></pre><h3 id="limit子句"><a href="#limit子句" class="headerlink" title="limit子句"></a>limit子句</h3><p>LIMIT用来限定查询结果的起始行，以及总行数。</p><p>例如：查询起始行为第5行，一共查询3行记录</p><pre><code class="hljs mysql">SELECT * FROM emp LIMIT 4, 3;--&gt; 其中4表示从第5行开始，其中3表示一共查询3行。即第5、6、7行记录。</code></pre><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>三种：</p><ul><li>合并结果集(了解)</li></ul><ul><li>连接查询</li><li>子查询</li></ul><h3 id="合并结果集"><a href="#合并结果集" class="headerlink" title="合并结果集"></a>合并结果集</h3><ul><li>要求被合并的表中，列的类型和列数相同</li><li>UNION，去除重复行</li><li>UNION ALL，不去除重复行</li></ul><pre><code class="hljs mysql">SELECT * FROM cd UNION ALL SELECT * FROM ab;</code></pre><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>三种：</p><ul><li><p>内连接</p></li><li><p>外连接</p><ul><li>左外连接</li><li>右外连接</li><li>全外连接(MySQL不支持)</li></ul></li><li><p>自然连接（属于一种简化方式）</p></li></ul><p>内连接：</p><pre><code>方言：SELECT * FROM 表1 别名1, 表2 别名2 WHERE 别名1.xx=别名2.xx标准：SELECT * FROM 表1 别名1 INNER JOIN 表2 别名2 ON 别名1.xx=别名2.xx自然：SELECT * FROM 表1 别名1 NATURAL JOIN 表2 别名2内连接查询出的所有记录都满足条件。</code></pre><p>外连接：</p><pre><code>左外：SELECT * FROM 表1 别名1 LEFT OUTER JOIN 表2 别名2 ON 别名1.xx=别名2.xx&gt; 左表记录无论是否满足条件都会查询出来，而右表只有满足条件才能出来。左表中不满足条件的记录，右表部分都为NULL左外自然：SELECT * FROM 表1 别名1 NATURAL LEFT OUTER JOIN 表2 别名2 ON 别名1.xx=别名2.xx右外：SELECT * FROM 表1 别名1 RIGHT OUTER JOIN 表2 别名2 ON 别名1.xx=别名2.xx&gt; 右表记录无论是否满足条件都会查询出来，而左表只有满足条件才能出来。右表不满足条件的记录，其左表部分都为NULL右外自然：SELECT * FROM 表1 别名1 NATURAL RIGHT OUTER JOIN 表2 别名2 ON 别名1.xx=别名2.xx全链接：可以使用UNION来完成全链接</code></pre><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>查询中有查询（查看select关键字的个数！）</p><ol><li>出现的位置：</li></ol><ul><li><p>where后作为条件存在</p></li><li><p>from后作为表存在(多行多列)</p><ol start="2"><li><p>条件</p><p>单行单列：SELECT * FROM 表1 别名1 WHERE 列1 [=、&gt;、&lt;、&gt;=、&lt;=、!=] (SELECT 列 FROM 表2 别名2 WHERE 条件)<br>多行单列：SELECT * FROM 表1 别名1 WHERE 列1 [IN, ALL, ANY] (SELECT 列 FROM 表2 别名2 WHERE 条件)<br>单行多列：SELECT * FROM 表1 别名1 WHERE (列1,列2) IN (SELECT 列1, 列2 FROM 表2 别名2 WHERE 条件)<br>多行多列：SELECT * FROM 表1 别名1 , (SELECT ….) 别名2 WHERE 条件</p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2></li></ol></li></ul><p>约束：约束是添加在列上的，用来约束列的！</p><h3 id="主键约束（唯一标识）"><a href="#主键约束（唯一标识）" class="headerlink" title="主键约束（唯一标识）"></a>主键约束（唯一标识）</h3><ul><li><p>非空</p></li><li><p>唯一</p></li><li><p>被引用（作外键时）</p></li></ul><p><strong>当表的某一列被指定为主键后，该列就不能为空，不能有重复值出现</strong>！</p><ul><li>创建表时指定主键的两种方式：</li></ul><pre><code class="hljs mysql">CREATE TABLE stu(sid    CHAR(6) PRIMARY KEY,snameVARCHAR(20),ageINT,genderVARCHAR(10) );# 指定sid列为主键列，即为sid列添加主键约束CREATE TABLE stu(sid    CHAR(6),snameVARCHAR(20),ageINT,genderVARCHAR(10),PRIMARY KEY(sid));# 指定sid列为主键列，即为sid列添加主键约束</code></pre><ul><li>修改表时指定主键：<code>ALTER TABLE stu ADD PRIMARY KEY(sid);</code></li><li>删除主键：<code>ALTER TABLE stu DROP PRIMARY KEY;</code></li></ul><h3 id="主键自增长"><a href="#主键自增长" class="headerlink" title="主键自增长"></a>主键自增长</h3><ul><li><p>因为主键列的特性是：必须唯一、不能为空，<strong>所以我们通常会指定主键类为整型，然后设置其自动增长</strong>，这样可以保证在插入数据时主键列的唯一和非空特性。</p></li><li><p>创建表时指定主键自增长</p><pre><code class="hljs mysql">CREATE TABLE stu(sid INT PRIMARY KEY AUTO_INCREMENT,snameVARCHAR(20),   ageINT,   genderVARCHAR(10)   );</code></pre></li><li><p>修改表时设置主键自增长：<code>ALTER TABLE stu CHANGE sid sid INT AUTO_INCREMENT;</code></p></li><li><p>修改表时删除主键自增长：<code>ALTER TABLE stu CHANGE sid sid INT;</code></p></li></ul><h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><p>因为某些列不能设置为NULL值，所以可以对列添加非空约束。</p><pre><code class="hljs mysql"># 对sname列设置了非空约束CREATE TABLE stu(sid INT PRIMARY KEY AUTO_INCREMENT,snameVARCHAR(20) NOT NULL,ageINT,genderVARCHAR(10));</code></pre><h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><p>某些列不能设置重复的值，所以可以对列添加唯一约束。</p><pre><code class="hljs mysql"># 对sname列设置了非空约束CREATE TABLE stu(sid INT PRIMARY KEY AUTO_INCREMENT,snameVARCHAR(20) NOT NULL UNIQUE,ageINT,genderVARCHAR(10));</code></pre><h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><p>对象模型：可以双向关联，而且引用的是对象，而不是一个主键！</p><p>关系模型：只能多方引用一方，而且引用的只是主键，而不是一整行记录。</p><blockquote><p> 对象模型：在java中是domain！例如：User、Student</p><p>关系模型：在数据库中表！</p><p>当我们要完成一个软件系统时，需要把系统中的实体抽取出来，形成概念模型。</p><p>例如部门、员工都是系统中的实体。概念模型中的实体最终会成为Java中的类、数据库中表。</p></blockquote><p>实体之间还存在着关系，关系有三种：</p><ul><li>1对多：例如每个员工都从属一个部门，而一个部门可以有多个员工，其中员工是多方，而部门是一方。</li><li>1对1：例如老公和老婆就是一对一的关系，一个老公只能有一个老婆，而一个老婆只能有一个老公。</li><li>多对多：老师与学生的关系就是多对多，一个老师可以有多个学生，一个学生可以有多个老师。</li></ul><p>概念模型在Java中成为实体类（javaBean）</p><p>类就使用成员变量来完成关系，一般都是双向关联！</p><p>多对一双向中关联，即员工关联部门，部门也关联员工</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<span class="hljs-comment">//多方关联一方</span>     ...     <span class="hljs-keyword">private</span> Department department;  &#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Department</span> </span>&#123;<span class="hljs-comment">//一方关联多方</span>     ...     <span class="hljs-keyword">private</span> List&lt;Employee&gt; employees;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Husband</span> </span>&#123;     ...     <span class="hljs-keyword">private</span> Wife wife;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wife</span> </span>&#123;     ...     <span class="hljs-keyword">private</span> Husband&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;     ...     <span class="hljs-keyword">private</span> List&lt;Teacher&gt; teachers&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;     ...     <span class="hljs-keyword">private</span> List&lt;Student&gt; students;&#125;</code></pre><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><ul><li><p>外键必须是另一表的主键的值(外键要引用主键！)</p></li><li><p>外键可以重复</p></li><li><p>外键可以为空</p></li><li><p>一张表中可以有多个外键！</p><p>概念模型在数据库中成为表<br>数据库表中的多对一关系，只需要在多方使用一个独立的列来引用1方的主键即可</p></li></ul><pre><code class="hljs mysql"># 员工表create talbe emp (  empno int primary key,&#x2F;*员工编号*&#x2F;  ...  deptno int&#x2F;*所属部门的编号*&#x2F;);# 部门表create table dept (  deptno int  primary key,&#x2F;*部门编号*&#x2F;  ...);</code></pre><p>emp表中的deptno列的值表示当前员工所从属的部门编号。也就是说emp.deptno必须在dept表中是真实存在！</p><p>但是我们必须要去对它进行约束，不然可能会出现员工所属的部门编号是不存在的。这种约束就是外键约束。</p><p>我们需要给emp.deptno添加外键约束，约束它的值必须在dept.deptno中存在。外键必须是另一个表的主键！</p><p>语法：<code>CONSTRAINT 约束名称 FOREIGN KEY(外键列名) REFERENCES 关联表(关联表的主键) </code></p><pre><code class="hljs mysql"># 创建表时指定外键约束create talbe emp (    empno int primary key,    ...    deptno int,    CONSTRAINT fk_emp FOREIGN KEY(mgr) REFERENCES emp(empno)  );# 修改表时添加外键约束ALERT TABLE emp ADD CONSTRAINT fk_emp_deptno FOREIGN KEY(deptno) REFERENCES dept(deptno);# 修改表时删除外键约束ALTER TABLE emp DROP FOREIGN KEY fk_emp_deptno;&#x2F;*约束名称*&#x2F;</code></pre><h3 id="数据库一对一关系"><a href="#数据库一对一关系" class="headerlink" title="数据库一对一关系"></a>数据库一对一关系</h3><p>在表中建立一对一关系比较特殊，需要让其中一张表的主键，即是主键又是外键。</p><pre><code class="hljs mysql">create table husband(hid int PRIMARY KEY,...);create table wife(wid int PRIMARY KEY,...ADD CONSTRAINT fk_wife_wid FOREIGN KEY(wid) REFERENCES husband(hid));</code></pre><p>其中wife表的wid即是主键，又是相对husband表的外键！</p><p>husband.hid是主键，不能重复！</p><p>wife.wid是主键，不能重复，又是外键，必须来自husband.hid。</p><p>所以如果在wife表中有一条记录的wid为1，那么wife表中的其他记录的wid就不能再是1了，因为它是主键。</p><p>同时在husband.hid中必须存在1这个值，因为wid是外键。这就完成了一对一关系。</p><p>从表的主键即是外键！</p><h3 id="数据库多对多关系"><a href="#数据库多对多关系" class="headerlink" title="数据库多对多关系"></a>数据库多对多关系</h3><p>在表中建立多对多关系需要使用中间表，即需要三张表，在中间表中使用两个外键，分别引用其他两个表的主键。</p><pre><code class="hljs mysql">create table student(    sid int PRIMARY KEY,    ...);create table teacher(    tid int PRIMARY KEY,    ...);create table stu_tea( sid int, tid int, ADD CONSTRAINT fk_stu_tea_sid FOREIGN KEY(sid) REFERENCES student(sid), ADD CONSTRAINT fk_stu_tea_tid FOREIGN KEY(tid) REFERENCES teacher(tid));</code></pre><p>  这时在stu_tea这个中间表中的每条记录都是来说明student和teacher表的关系.</p><p>  例如在stu_tea表中的记录：sid为1001，tid为2001，这说明编号为1001的学生有一个编号为2001的老师</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小白文</tag>
      
      <tag>数据库</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis的简单用法</title>
    <link href="/redis/"/>
    <url>/redis/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：Redis介绍、Redis应用场景、Redis的安装与配置、Redis常用语法。</p><a id="more"></a><blockquote><p>教程视频链接：<a href="https://www.bilibili.com/video/BV1LK4y187PK?p=60">2020最新<em>Python</em>(MySQL_SQL_Redis)数据库详解【千锋】50集到60集</a></p></blockquote><blockquote><p>Redis命令： <a href="http://redisdoc.com/">http://redisdoc.com/</a> </p></blockquote><p><strong>预警</strong>：本文仅作为Redis的简单了解。</p><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><p>非关系型数据库。</p><p>常见的几个数据库</p><ul><li>列族数据库：HBase</li><li>文档数据库：MongoDB</li><li>KV数据库：Redis</li></ul><p>数据库指标 qps：</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>一种基于键值对的NoSQL数据库</p><ul><li>将数据存放于内存，读写性能极高，并具有丰富的特性（发布/订阅、事务、通知等）。</li><li>适用于项目中的高速缓存与消息队列这样的服务。</li><li>支持数据的持久化，可将内存中的数据保存在磁盘中，重启时可再次加载使用。</li><li>支持多种数据类型，包括：string、hash、list、set、zset(有序集合)、bitmap、hyperloglog等。</li><li>Redis支持主从复制（实现读写分析）以及哨兵模式（监控master是否宕机并自动调整配置）。</li><li>Redis支持分布式集群，可以很容易的通过水平扩展来提升系统的整体性能。</li><li>Redis基于TCP提供的可靠传输服务进行通信，很多编程语言都提供了Redis客户端支持。</li></ul><h3 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h3><ol><li><strong>高速缓存</strong>：将不常变化但又经常被访问的热点数据放到Redis数据库中,可以大大降低关系型数据库的压力，从而提升系统的响应性能。</li><li><strong>排行榜</strong>：很多网站都有排行榜功能，利用Redis中的列表和有序集合可以非常方便的构造各种排行榜系统。</li><li><strong>商品秒杀/投票点赞</strong>：Redis提供了对计数操作的支持，网站上常见的秒杀、点赞等功能都可以利用Redis的计数器通过+1或1的操作来实现，从而避免了使用关系型数据的update操作。</li><li><strong>分布式锁</strong>：利用Redis可以跨多台服务器实现分布式锁(类似于线程锁，但是能够被多台机器上的多个线程或进程共享)的功能，用于实现一个阻塞式操作。</li><li><strong>消息队列</strong>：消息队列和高速缓存一样, 是一个大型网站不可缺少的基础服务，可以实现业务解耦和非实时业务削峰等特性。</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="hljs shell">wget http://download.redis.io/releases/redis-6.0.1.tar.gztar -zxvf redis-6.0.1.tar.gzcd redis-6.0.1/sudo make &amp;&amp; sudo make install</code></pre><h2 id="Redis的配置"><a href="#Redis的配置" class="headerlink" title="Redis的配置"></a>Redis的配置</h2><pre><code class="hljs shell">cd redis-6.0.1/vim redis.conf #配置文件</code></pre><p>1.配置Redis服务绑定到指定的IP地址和端口</p><pre><code class="hljs apache"><span class="hljs-attribute">bind</span> <span class="hljs-number">127.0.0.1</span><span class="hljs-attribute">port</span> <span class="hljs-number">6379</span></code></pre><p>2.配置后台运行（以守护进程方式运行）</p><pre><code class="hljs nginx"><span class="hljs-attribute">daemonize</span> <span class="hljs-literal">yes</span></code></pre><p>3.设置日志级别，可选值（debug：调试，verbose：详细，notice：通知，warning：警告）</p><pre><code class="hljs aspectj">loglevel <span class="hljs-keyword">warning</span></code></pre><p>4.配置数据库的数量，默认16个</p><pre><code class="hljs apache"><span class="hljs-attribute">databases</span> <span class="hljs-number">16</span></code></pre><p>5.配置数据写入规则</p><pre><code class="hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span># <span class="hljs-number">900</span>秒内修改过<span class="hljs-number">1</span>个key，写入一次数据库<span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span># <span class="hljs-number">300</span>秒内修改过<span class="hljs-number">10</span>个key，写入一次数据库<span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">1000</span># <span class="hljs-number">60</span>秒内修改过<span class="hljs-number">10000</span>个key，写入一次数据库</code></pre><p>6.配置Redis的持久化机制 - RDB.</p><pre><code class="hljs yaml"><span class="hljs-string">rdbcompression</span> <span class="hljs-literal">yes</span><span class="hljs-comment"># 压缩RDB文件</span><span class="hljs-string">rdbchecksum</span> <span class="hljs-literal">yes</span><span class="hljs-comment"># 对RDB文件进行校验</span><span class="hljs-string">dbfilename</span> <span class="hljs-string">dump.rdb</span><span class="hljs-comment"># RDB数据库文件的文件名</span><span class="hljs-string">dir</span> <span class="hljs-string">/var/local/redis</span><span class="hljs-comment"># RDB文件保存的目录</span></code></pre><p>7.配置Redis的持久化机制 - AOF.</p><pre><code class="hljs nginx"><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">no</span>appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span></code></pre><p>8.配置Redis的主从复制，通过主从复制可以实现读写分离</p><pre><code class="hljs armasm"><span class="hljs-symbol">replicaof</span> 主机<span class="hljs-built_in">IP</span>地址 主机端口</code></pre><p>9.配置慢查询</p><pre><code class="hljs livecodeserver">slowlog-<span class="hljs-built_in">log</span>-slower-than <span class="hljs-number">10000</span> <span class="hljs-comment"># 一次操作超过10000毫秒被视作一次慢查询</span>slowlog-<span class="hljs-built_in">max</span>-<span class="hljs-built_in">len</span> <span class="hljs-number">128</span><span class="hljs-comment"># 最多记录128次慢查询</span></code></pre><p>修改完配置项目后，建议将配置项目拷贝到一个地方，记住路径！</p><h3 id="Redis启动"><a href="#Redis启动" class="headerlink" title="Redis启动"></a>Redis启动</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 服务端启动</span>redis-serverredis-server /usr/local/etc/redis.conf #指定配置项，建议这种方式<span class="hljs-meta">#</span><span class="bash"> 客户端启动</span>redis-cliredis-cli -h localhost -p 6379</code></pre><h3 id="linux查询进程"><a href="#linux查询进程" class="headerlink" title="linux查询进程"></a>linux查询进程</h3><pre><code class="hljs shell">ps aux|grep redis</code></pre><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis运行时，所有数据都保存在内存中，进程结束以后，<strong>会将数据写入硬盘中</strong>，启动Redis时，会读取硬盘中的内容，并将内容全部加载到内存中(会大量占用内存)。</p><p>Redis持久化两种方式：</p><ul><li><p>RDB方式：默认的方式，对内存中的数据进行镜像，并以二进制的形式保存到<code>dump.rdb</code>文件中，会根据配置文件中的填写的时间节点对文件进行持久化。</p><pre><code class="hljs apache"><span class="hljs-comment"># 这个就是时间节点</span><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span># <span class="hljs-number">900</span>秒内修改过<span class="hljs-number">1</span>个key，写入一次数据库<span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span># <span class="hljs-number">300</span>秒内修改过<span class="hljs-number">10</span>个key，写入一次数据库<span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">1000</span># <span class="hljs-number">60</span>秒内修改过<span class="hljs-number">10000</span>个key，写入一次数据库</code></pre><ul><li>优点：速度快，直接镜像内存中的数据，文件小。</li><li>缺点：数据可能会丢失，在两次保存间隔内的数据，有可能会丢失。</li></ul></li><li><p>AOF方式：将修改的每一条指令记录进<code>appendonly.aof</code>中。</p><ul><li>appendfsync always：每次有新命令追加到aof文件时就执行一个持久化，非常慢但是安全。</li><li>appendfsync everysec：每秒执行一次持久化，足够快(和rdb差不多)，并且在故障时只会丢失一秒的数据。</li><li>appendsync no：从不持久化，将数据交给操作系统来处理，redis处理命令速度快但不安全。</li><li>优点：适合保存增量数据，数据不丢失</li><li>缺点：文件体积大，恢复时间长。</li></ul></li></ul><h2 id="Redis字符串"><a href="#Redis字符串" class="headerlink" title="Redis字符串"></a>Redis字符串</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">set</span> key values [ex seconds|px millinsecond]</span>set name zhnagsan # &quot;name&#x27;:&quot;zhangsan&quot;set name colourso # &quot;name&quot;:&quot;colourso&quot; 会覆盖上一条127.0.0.1:6379&gt; setnx name wangwu # setnx 如果key存在则不进行操作(integer) 0127.0.0.1:6379&gt; get name&quot;colourso&quot;127.0.0.1:6379&gt; strlen name # 获取key对应value的长度(integer) 8---127.0.0.1:6379&gt; set x 23 # 虽然存储的是字符串但是能够像数字一样操作127.0.0.1:6379&gt; get x&quot;23&quot;---127.0.0.1:6379&gt; keys * # 获取所有的key1) &quot;name&quot;2) &quot;x&quot;---127.0.0.1:6379&gt; set keywords IOU ex 20 # ex后接秒数，表示存在时间127.0.0.1:6379&gt; get keywords&quot;IOU&quot;127.0.0.1:6379&gt; ttl keywords # ttl 可查看过期剩余时间(integer) 12 # ttl查询结果为-1表示永不过期--- 等待15秒后127.0.0.1:6379&gt; get keywords(nil)---127.0.0.1:6379&gt; mset p 10 q 30 #一次设置多个值---127.0.0.1:6379&gt; set nu 1127.0.0.1:6379&gt; incr nu(integer) 2127.0.0.1:6379&gt; set nn 1.1127.0.0.1:6379&gt; incr nn(error) ERR value is not an integer or out of range127.0.0.1:6379&gt; incrby nu 11(integer) 13127.0.0.1:6379&gt; decr nu(integer) 12</code></pre><ul><li>set ：设置key value</li><li>setnx ： 如果key不存在就设置</li><li>mset：一次设置多个值</li><li>get：获取key对应的value</li><li>mget：一次获取多个值</li><li>strlen ：获取key对应value的长度</li><li>incr：自增，非整数数字无法自增，会报错</li><li>incrby：key对应的value值增加一定的量</li><li>decr：减一</li></ul><h2 id="Redis哈希表"><a href="#Redis哈希表" class="headerlink" title="Redis哈希表"></a>Redis哈希表</h2><pre><code class="hljs mysql">127.0.0.1:6379&gt; hset dog name kelly color white(integer) 2127.0.0.1:6379&gt; hget dog name&quot;kelly&quot;127.0.0.1:6379&gt; hset dog age 3 gender female #继续向dog中添加(integer) 2127.0.0.1:6379&gt; HEXISTS dog color #查看dog是否有color属性，有为1，没有为0(integer) 1127.0.0.1:6379&gt; HEXISTS dog height(integer) 0127.0.0.1:6379&gt; hdel dog gender #删除一个属性(integer) 1127.0.0.1:6379&gt; hget dog gender(nil)127.0.0.1:6379&gt; hlen dog #查看有几个属性(integer) 3127.0.0.1:6379&gt; hstrlen dog name #查看属性的具体长度(integer) 5127.0.0.1:6379&gt; hkeys dog #拿到dog所有的属性名1) &quot;name&quot;2) &quot;color&quot;3) &quot;age&quot;127.0.0.1:6379&gt; hvals dog #拿到dog所有的属性值1) &quot;kelly&quot;2) &quot;white&quot;3) &quot;3&quot;127.0.0.1:6379&gt; hgetall dog #拿到全部1) &quot;name&quot;2) &quot;kelly&quot;3) &quot;color&quot;4) &quot;white&quot;5) &quot;age&quot;6) &quot;3&quot;</code></pre><ul><li><p>hset key [field value]：创建一个hash形式大致如下：</p><p>“dog”:{</p><p>“name”:”kelly”,</p><p>“color”:”white”,</p><p>“age”:3,</p><p>“gender”:”female”</p><p>}</p></li></ul><h2 id="Redis列表"><a href="#Redis列表" class="headerlink" title="Redis列表"></a>Redis列表</h2><p>Redis中的列表可以实现类似于队列与栈的结构。</p><pre><code class="hljs mysql">127.0.0.1:6379&gt; lpush names zhangsan lisi wangwu #依次往左插入数据！(integer) 3127.0.0.1:6379&gt; lrange names 0 -1 # 获取一个范围的元素，-1表示最后一个元素1) &quot;wangwu&quot;# 按照顺序获得元素2) &quot;lisi&quot;3) &quot;zhangsan&quot;127.0.0.1:6379&gt; rpush english bob kelly tom kelly # 依次往右插入数据，列表值允许重复(integer) 4127.0.0.1:6379&gt; lrange english 0 -1# 按照顺序获得元素1) &quot;bob&quot;2) &quot;kelly&quot;3) &quot;tom&quot;4) &quot;kelly&quot;127.0.0.1:6379&gt; lpop english # 取走最左侧数据，不再保留&quot;bob&quot;127.0.0.1:6379&gt; lrange english 0 -1 1) &quot;kelly&quot;2) &quot;tom&quot;3) &quot;kelly&quot;127.0.0.1:6379&gt; lset english 2 carry # 修改index对应的值，下标从0开始OK127.0.0.1:6379&gt; lrange english 0 -11) &quot;kelly&quot;2) &quot;tom&quot;3) &quot;carry&quot;127.0.0.1:6379&gt; llen english #获取长度(integer) 3127.0.0.1:6379&gt; lindex english 1 # 获取下标对应的值&quot;tom&quot;</code></pre><h2 id="Redis集合"><a href="#Redis集合" class="headerlink" title="Redis集合"></a>Redis集合</h2><pre><code class="hljs mysql">127.0.0.1:6379&gt; sadd player liubei guanyu zhangfei(integer) 3127.0.0.1:6379&gt; sadd player caocao sunquan # 往player集合中添加成员(integer) 2127.0.0.1:6379&gt; sismember player liubei (integer) 1127.0.0.1:6379&gt; sismember player machao # 判断machao是都是集合Player的成员，是的话输出1，不是输出0(integer) 0127.0.0.1:6379&gt; srandmember player 3 #随机取三个成员1) &quot;caocao&quot;2) &quot;zhangfei&quot;3) &quot;sunquan&quot;127.0.0.1:6379&gt; smembers player #查看全部成员1) &quot;guanyu&quot;2) &quot;liubei&quot;3) &quot;caocao&quot;4) &quot;zhangfei&quot;5) &quot;sunquan&quot;127.0.0.1:6379&gt; sadd superplayer caocao liubei sunquan(integer) 3127.0.0.1:6379&gt; sdiff player superplayer # 返回player中与superplayer中不一样的部分1) &quot;guanyu&quot;2) &quot;zhangfei&quot;127.0.0.1:6379&gt; sunion player superplayer # 两个集合的并集1) &quot;guanyu&quot;2) &quot;liubei&quot;3) &quot;caocao&quot;4) &quot;zhangfei&quot;5) &quot;sunquan&quot;127.0.0.1:6379&gt; sinter player superplayer # 两个集合的交集1) &quot;liubei&quot;2) &quot;sunquan&quot;3) &quot;caocao&quot;</code></pre><h2 id="Redis有序集合"><a href="#Redis有序集合" class="headerlink" title="Redis有序集合"></a>Redis有序集合</h2><pre><code class="hljs mysql">127.0.0.1:6379&gt; zadd score 100 liubang 90 xiangyu 80 hanxin # score是key(integer) 3127.0.0.1:6379&gt; zrange score 0 -1 # 顺序输出，由小到大1) &quot;hanxin&quot;2) &quot;xiangyu&quot;3) &quot;liubang&quot;127.0.0.1:6379&gt; zrank score xiangyu # 查看xiangyu的排序(integer) 1127.0.0.1:6379&gt; ZREVRANGE score 0 -1 # 逆序输出1) &quot;liubang&quot;2) &quot;xiangyu&quot;3) &quot;hanxin&quot;127.0.0.1:6379&gt; ZREVRANGE score 0 -1 withscores # 逆序输出，并打印数据1) &quot;liubang&quot;2) &quot;100&quot;3) &quot;xiangyu&quot;4) &quot;90&quot;5) &quot;hanxin&quot;6) &quot;80&quot;127.0.0.1:6379&gt; zincrby score 5 xiangyu #给xiangyu增加5&quot;95&quot;</code></pre><h2 id="在Python中安装与使用Redis"><a href="#在Python中安装与使用Redis" class="headerlink" title="在Python中安装与使用Redis"></a>在Python中安装与使用Redis</h2><p>安装：<code>pip3 install redis</code></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> redisclient = redis.Redis()<span class="hljs-comment">#不写参数就使用其默认配置</span>client.get(<span class="hljs-string">&quot;name&quot;</span>)<span class="hljs-comment"># b&#x27;colourso&#x27;</span><span class="hljs-comment"># b表示为二进制</span>client.hget(<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>)<span class="hljs-comment"># &#123;b&#x27;name&#x27;: b&#x27;kelly&#x27;, b&#x27;color&#x27;: b&#x27;white&#x27;, b&#x27;age&#x27;: b&#x27;3&#x27;&#125;</span>client.zrange(<span class="hljs-string">&quot;score&quot;</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>)<span class="hljs-comment"># [b&#x27;hanxin&#x27;, b&#x27;xiangyu&#x27;, b&#x27;liubang&#x27;]</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小白文</tag>
      
      <tag>数据库</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS语法总结</title>
    <link href="/CSS-learn/"/>
    <url>/CSS-learn/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：CSS的语法，使用方式，各种选择器，伪类与伪元素，字体、文本与背景样式设置，以及盒模型相关知识点。</p><a id="more"></a><hr><p><strong>预警</strong>：本文是我于<font color="red">2020年5月总结的</font> <font color="gree">2018年7月我所学的</font> <font color="blue">2016年的前端课程</font>，简言之可能时效性比较差，可能落后于当今的技术，小心阅读~</p><blockquote><p>前端课程链接：<a href="http://www.atguigu.com/download_detail.shtml?v=63">李立超 —— 尚硅谷_HTML&amp;CSS核心基础</a></p></blockquote><hr><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>CSS —— 层叠样式表，可对网页进行装饰。</p><p>在前端中，<strong>HTML负责结构，CSS负责表现，JS则负责行为</strong>。</p><h2 id="CSS使用方式"><a href="#CSS使用方式" class="headerlink" title="CSS使用方式"></a>CSS使用方式</h2><h3 id="1-内联样式-嵌入式样式（不推荐）"><a href="#1-内联样式-嵌入式样式（不推荐）" class="headerlink" title="1.内联样式|嵌入式样式（不推荐）"></a>1.内联样式|嵌入式样式（不推荐）</h3><p>直接将CSS样式写在标签的style属性中。</p><ul><li>内联样式只对当前元素的内容起作用，不方便复用。</li><li>这样导致结构与表现耦合，不方便后期维护。</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red; font-size:20px;&quot;</span>&gt;</span>谁知盘中餐，粒粒皆辛苦。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><h3 id="2-内部样式表"><a href="#2-内部样式表" class="headerlink" title="2.内部样式表"></a>2.内部样式表</h3><p>将CSS样式表写在HTML文件的head标签中，然后通过CSS选择器来选中指定元素。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span>        p&#123;<span class="css">            <span class="hljs-selector-tag">color</span><span class="hljs-selector-pseudo">:red</span>;</span><span class="css">            <span class="hljs-selector-tag">background-color</span><span class="hljs-selector-pseudo">:red</span>;</span>        &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre><h3 id="3-外部样式表（推荐）"><a href="#3-外部样式表（推荐）" class="headerlink" title="3.外部样式表（推荐）"></a>3.外部样式表（推荐）</h3><p>将CSS样式表写在外部文件<code>.css</code>之中，然后在HTML的head标签中使用<code>&lt;link /&gt;</code>标签来引入到当前页面。</p><ul><li>将CSS样式统一编写到外部的样式表中，完全使结构与表现分离，使样式表可以在不同的页面中使用。</li><li>最大限度的可以使样式进行复用，可以利用浏览器的缓存，加快用户访问的速度，提高用户的体验。</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span> = <span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;demo.css&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre><h3 id="4-优先级顺序"><a href="#4-优先级顺序" class="headerlink" title="4.优先级顺序"></a>4.优先级顺序</h3><p>由高到低：</p><ol><li>内联样式</li><li>内部样式表</li><li>外部样式表</li><li>浏览器默认样式</li></ol><h2 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h2><p>注释：<code>/*  */</code></p><p>CSS的基本语法由<strong>选择器</strong>和<strong>声明块</strong>两部分组成。</p><ul><li><strong>选择器</strong>：用来指定页面中的元素，然后将会把声明块里的声明样式作用到该元素上。</li><li><strong>声明块</strong>：紧跟在选择器之后，使用一对大括号<code>&#123;&#125;</code>括起来，内容是名值对的形式，名值之间使用冒号<code>:</code>链接，多个名值对间使用分号<code>;</code>分隔。</li></ul><pre><code class="hljs css"><span class="hljs-comment">/*将作用于页面中所有的p标签的内容*/</span><span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">color</span>:red;<span class="hljs-attribute">background-color</span>:red;&#125;</code></pre><ul><li>如果采用<strong>内部样式表</strong>的方式，则<code>&lt;style&gt; &lt;/style&gt;</code>中的内容属于CSS所有。不允许写html中的内容，包括html的注释<code>&lt;!-- --&gt;</code>.</li><li>CSS规定，如果属性名称是两个或者两个以上的单词组成时，单词之间用<code>-</code>隔开，例如背景颜色：<code>background-color</code>。</li></ul><h2 id="常见选择器"><a href="#常见选择器" class="headerlink" title="常见选择器"></a>常见选择器</h2><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><p>通过id属性值来选中元素。</p><p>语法：<code>#idname&#123;&#125;</code></p><pre><code class="hljs css"><span class="hljs-selector-id">#ppp</span>&#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">20px</span>;&#125;</code></pre><h3 id="class选择器"><a href="#class选择器" class="headerlink" title="class选择器"></a>class选择器</h3><p>通过class来选择一组元素。</p><p>语法：<code> .classname&#123; &#125;</code></p><pre><code class="hljs css"><span class="hljs-selector-class">.classname</span>&#123;    <span class="hljs-attribute">color</span>:red;&#125;</code></pre><h3 id="通配选择器"><a href="#通配选择器" class="headerlink" title="通配选择器"></a>通配选择器</h3><p>选择页面所有的元素。</p><p>语法：<code>*&#123;&#125;</code></p><pre><code class="hljs css">*&#123;    <span class="hljs-attribute">color</span>:red;&#125;</code></pre><h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h3><p>可同时选择多个元素。</p><p>语法：<code>选择器1,选择器2,选择器n&#123;&#125;</code></p><pre><code class="hljs css"><span class="hljs-comment">/*为id为pp，类为cll的标签以及h1标签设置样式*/</span><span class="hljs-selector-id">#pp</span>,<span class="hljs-selector-class">.cll</span>,<span class="hljs-selector-tag">h1</span>&#123;    <span class="hljs-attribute">background-color</span>:red;&#125;</code></pre><h3 id="复合选择器（交集选择器）"><a href="#复合选择器（交集选择器）" class="headerlink" title="复合选择器（交集选择器）"></a>复合选择器（交集选择器）</h3><p>选择<strong>同时满足</strong>几个选择器的元素。</p><p>语法： <code>选择器1选择器2选择器3 &#123; &#125; </code>。中间无空格和其他符号。</p><pre><code class="hljs css"><span class="hljs-comment">/*为class为cll的span元素设置一个背景颜色*/</span><span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.cll</span>&#123;    <span class="hljs-attribute">background-color</span>:yellow;&#125;</code></pre><h3 id="后代元素选择器"><a href="#后代元素选择器" class="headerlink" title="后代元素选择器"></a>后代元素选择器</h3><p>选中指定元素的后代元素。</p><p>语法：<code>祖先元素 后代元素&#123;&#125;</code>。中间使用空格隔开，后代元素可以写多个，使用空格隔开。</p><ul><li>注意是<strong>元素</strong>，而非选择器！</li><li>但是可以使用id选择器代替元素。</li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">background-color</span>:red;&#125;</code></pre><h3 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h3><p>选中指定父元素的指定子元素<br>语法：<code>祖先元素 &gt; 后代元素</code>.</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &gt; <span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">background-color</span>:blue;&#125;</code></pre><h3 id="兄弟元素选择器"><a href="#兄弟元素选择器" class="headerlink" title="兄弟元素选择器"></a>兄弟元素选择器</h3><ul><li>可以选定指定元素后面紧挨的兄弟元素。</li></ul><p>语法：<code>前一个元素 + 后一个元素&#123;&#125;</code></p><ul><li>选中指定元素身后所有的同一种兄弟元素。</li></ul><p>语法：<code>前一个元素 ~ 后边所有&#123;&#125;</code></p><pre><code class="hljs css"><span class="hljs-comment">/*选中span后面所有的p元素*/</span><span class="hljs-selector-tag">span</span> ~ <span class="hljs-selector-tag">p</span>&#123;    <span class="hljs-attribute">background-color</span>:red;&#125;</code></pre><h3 id="选择器的优先级"><a href="#选择器的优先级" class="headerlink" title="选择器的优先级"></a>选择器的优先级</h3><p>当多个选择器发生冲突时，根据优先级来选择设置样式。</p><p>从高到低依次是：</p><ol><li>内联样式即嵌入式样式</li><li>id选择器</li><li>类与伪类</li><li>元素选择器</li><li>通配选择器</li></ol><h2 id="伪元素与伪类"><a href="#伪元素与伪类" class="headerlink" title="伪元素与伪类"></a>伪元素与伪类</h2><p>伪类专门用来表示一种<strong>特殊的状态</strong>。如：访问过的超链接。如获取焦点的文本框。用伪类可以为这些特殊元素设置特殊的状态。<br>有时候，你需要选择本身没有标签，但是仍然易于识别的网页部位，比如段落首行或鼠标滑过的连接。CSS为他们提供一些选择器：伪类和伪元素。</p><h3 id="链接的四个伪类"><a href="#链接的四个伪类" class="headerlink" title="链接的四个伪类"></a>链接的四个伪类</h3><ul><li>正常链接：<code>a:link</code></li><li>访问过的链接：<code>a:visited</code></li><li>鼠标滑过的链接：<code>a:hover</code></li><li>正在点击的链接：<code>a:active</code></li></ul><p>注意：</p><ol><li><code>visited</code>由于涉及隐私，只能够修改字体颜色。</li><li><code>hover</code>和<code>active</code>这两个也可以给其他元素使用。比如p标签。</li><li>这四个伪类的优先级是相同的，但一般按照上面的次序写，否则<code>link</code> 与<code>visited</code> 这两个伪类会覆盖两外两个元素。<code>active</code>也会覆盖掉<code>hover</code>。</li></ol><h3 id="否定伪类"><a href="#否定伪类" class="headerlink" title="否定伪类"></a>否定伪类</h3><p>可以从已经选中的元素中剔除某些元素。</p><p>语法：<code>:not(选择器)</code></p><pre><code class="hljs css"><span class="hljs-comment">/*为所有p标签设置背景颜色，除了class为hello的*/</span><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:not(.hello)</span>&#123;    <span class="hljs-attribute">backgorund-color</span>:red;&#125;</code></pre><h3 id="其他伪类"><a href="#其他伪类" class="headerlink" title="其他伪类"></a>其他伪类</h3><ol><li><code>input:focus&#123;&#125;</code> ——获取焦点</li><li><code>p::selection&#123; &#125;</code> ——为选中的文字设置样式。额外注意是有两个冒号。但是在火狐中不太好用，火狐使用<code>-moz-selection</code>，建议都写上。</li></ol><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p>使用伪元素来表示元素的一些特殊位置。</p><ul><li><code>p:first-letter&#123;&#125;</code>：表示p中的第一个字</li><li><code>p:first-line&#123;&#125;</code>：表示第一行</li><li><code>before</code>与<code>after</code>表示元素的最前边与最后边。<ul><li>例如<code>&lt;p&gt;Hello&lt;/p&gt;</code>中before指p标签与H之间的位置。</li><li><code>before</code>与<code>after</code>使用时要结合<code>content</code>添加一些元素，并且content添加的文本内容一般无法被鼠标选中。</li></ul></li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:before</span>&#123;<span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;出现且无法被选中&quot;</span>;    <span class="hljs-attribute">color</span>:red;&#125;</code></pre><h2 id="字体样式设置"><a href="#字体样式设置" class="headerlink" title="字体样式设置"></a>字体样式设置</h2><p><img src="/CSS-learn/font.png"></p><h3 id="字体属性简写"><a href="#字体属性简写" class="headerlink" title="字体属性简写"></a>字体属性简写</h3><p>即一次同时设置多个字体样式。</p><p>语法：<code>font: 加粗 斜体 小型大写 大小/行高 字体</code>。</p><ul><li> 加粗 斜体 小型大写这几个顺序无所谓，也可以不写。</li><li>但是<strong>大小与字体必须要写且写到最后两个</strong>！</li></ul><pre><code class="hljs css"><span class="hljs-selector-class">.hello</span>&#123;    <span class="hljs-attribute">font</span>:bold italic small-caps <span class="hljs-number">15px</span> <span class="hljs-string">&quot;微软雅黑&quot;</span>;&#125;</code></pre><h2 id="文本样式设置"><a href="#文本样式设置" class="headerlink" title="文本样式设置"></a>文本样式设置</h2><p><img src="/CSS-learn/text1.png"></p><p><img src="/CSS-learn/text2.png"></p><p><img src="/CSS-learn/text3.png"></p><h2 id="背景样式设置"><a href="#背景样式设置" class="headerlink" title="背景样式设置"></a>背景样式设置</h2><p><img src="/CSS-learn/bg.png"></p><h3 id="背景简写属性"><a href="#背景简写属性" class="headerlink" title="背景简写属性"></a>背景简写属性</h3><ul><li>这里的简写没有任何顺序或者数量要求。即顺序随意，不写就使用默认值。</li></ul><pre><code class="hljs css"><span class="hljs-selector-class">.hello</span>&#123;    <span class="hljs-attribute">background</span>: <span class="hljs-number">#bfa</span> <span class="hljs-built_in">url</span>(img/<span class="hljs-number">3</span>.png) fixed no-repeat;&#125;</code></pre><h2 id="透明-opacity"><a href="#透明-opacity" class="headerlink" title="透明 opacity"></a>透明 opacity</h2><p>用于设置元素的透明背景。</p><p>需要指定一个0-1之间的值，0表示完全透明，1表示完全不透明，0.5表示半透明。</p><ul><li>opacity属性在IE8以下的浏览器中不支持。</li></ul><pre><code class="hljs css"><span class="hljs-selector-class">.hello</span>&#123;    <span class="hljs-attribute">opacity</span>:<span class="hljs-number">0.5</span>;&#125;</code></pre><hr><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>CSS处理网页时，它认为每个元素都包含在一个不可见的盒子里。我们只需要将相应的盒子摆放到网页中相应的位置即可完成网页的布局。</p><p>盒子模型包含四部分：</p><ul><li>内容区(content) </li><li>内边距(padding)</li><li>边框(border) </li><li>外边距(margin)</li></ul><h3 id="内容区-content"><a href="#内容区-content" class="headerlink" title="内容区  content"></a>内容区  content</h3><p>内容区指的是盒子中放置内容的区域，也就是元素中的文本内容，子元素都是存在于内容区中的。</p><p>如果没有为元素设置内边距和边框，则内容区大小默认和盒子大小是一致的。</p><p>通过width和height两个属性可以设置内容区的大小，而不是整个盒子的大小。</p><p>整个盒子可见框的大小由内容区、内边距和边框共同决定。</p><p>width和height属性只适用于块元素。</p><h3 id="边框-border"><a href="#边框-border" class="headerlink" title="边框 border"></a>边框 border</h3><p>边框是元素可见框的最外部。 </p><p>边框三个必备属性：宽度<code>border-width </code> 、颜色<code>border-color</code> 、样式<code>border-style</code>。</p><p>大部分浏览器的边框设置中宽度与颜色都有默认值，而style的默认值为none(无边框)。</p><h3 id="内边距-padding"><a href="#内边距-padding" class="headerlink" title="内边距 padding"></a>内边距 padding</h3><p>内边距指的就是元素内容区与边框以内的空间。</p><p>默认情况下width和height不包含padding的大小。 </p><p>元素的背景会延伸到内边距。</p><h3 id="外边距-margin"><a href="#外边距-margin" class="headerlink" title="外边距 margin"></a>外边距 margin</h3><p>外边距是元素边框与周围元素相距的空间</p><p>外边距也可以设置成为负值，元素向相反的方向移动。</p><h3 id="清除浏览器的默认样式"><a href="#清除浏览器的默认样式" class="headerlink" title="清除浏览器的默认样式"></a>清除浏览器的默认样式</h3><p>浏览器会为很多元素默认设置了一些默认的<code>margin</code>和<code>padding</code>。</p><pre><code class="hljs css"><span class="hljs-comment">/*清除浏览器的默认样式*/</span>*&#123;    <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;    <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;&#125;</code></pre><h3 id="内联元素的盒子模型"><a href="#内联元素的盒子模型" class="headerlink" title="内联元素的盒子模型"></a>内联元素的盒子模型</h3><ul><li><p>内容区：内联元素不能设置width和height。</p></li><li><p>内边距：内联元素可以设置水平方向的内边距。</p><ul><li>对于垂直方向上的内边距，可以设置，但不会影响布局。数值过大只会覆盖掉其他元素</li></ul></li><li><p>边框：内联元素可以设置边框，但是垂直的边框不会影响到页面的布局。</p></li></ul><ul><li>外边距：内联元素支持水平方向的外边距。对于竖直方向的外边距不支持。</li></ul><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>作用：<strong>可以将元素设置为块元素或者内联元素等。</strong></p><p><strong>一个块元素独占一行</strong>。而<strong>一个内联元素只占它内容对应的空间</strong>。并且<strong>一个内联元素不能设置宽高</strong>。</p><ul><li>inline：将一个元素作为内联元素显示。</li><li>block：作为块元素显示。</li><li>inline-block：转换成行内块元素，既可以设置宽高，又不会独占一行。</li><li>none：不显示元素，且元素不会在页面中占据位置。</li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">span</span>&#123;    <span class="hljs-attribute">dispaly</span>:block;    <span class="hljs-comment">/*设置宽高*/</span>    <span class="hljs-attribute">width</span>:<span class="hljs-number">500px</span>;    <span class="hljs-attribute">height</span>:<span class="hljs-number">500px</span>;&#125;</code></pre><h3 id="visibility"><a href="#visibility" class="headerlink" title="visibility"></a>visibility</h3><p>作用：<strong>设置元素的可见状态</strong>。</p><ul><li>visible：默认值，显示。</li><li>hidden：隐藏，不显示，但位置会保留在页面中。</li></ul><pre><code class="hljs css">&#123;    <span class="hljs-attribute">visibility</span>:hidden;&#125;</code></pre><h3 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h3><p>作用：<strong>设置父元素如何处理溢出的内容</strong>。</p><p>子元素默认存在于父元素内容区，如果子元素大小超过了父元素的内容区，就会发生溢出。</p><ul><li>visible：默认值，不对溢出内容做处理，元素会在父元素以外显示。</li><li>hidden：溢出内容会被修剪，不显示。</li><li>scroll：为父元素添加滚动条，且不论是否溢出，都会添加水平与垂直方向的滚动条。</li><li>auto：根据需求自动添加滚动条。</li></ul><h3 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h3><p>文档流指的是文档中可现实的对象在排列时所占用的位置。</p><p>将窗体自上而下分成一行行，并在每行中按从左至右的顺序排 放元素，即为文档流。</p><p>也就是说在文档流中元素默认会紧贴到上一个元素的右边，如果右边不足以放下元素，元素则会另起一行，在新的一行中继续从左至右摆放。</p><p>这样一来每一个块元素都会另起一行，那么我们如果想在文档流中进行布局就会变得比较麻烦。</p><p>块元素：</p><ul><li>独占一行，块元素会自上向下排列。</li><li>在文档流的默认宽度是父元素的100%</li><li>高度默认由内容撑开。</li></ul><p>内联元素：</p><ul><li>默认只占据自身大小，默认从左到右排列。</li><li>高度宽度都默认被内容撑开。</li></ul><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><p>作用：使元素脱离原来的文档流，在父元素中浮动起来。</p><ul><li>none：默认值，默认在文档流中排列。</li><li>left：向页面左侧浮动。</li><li>right：向页面右侧浮动。</li></ul><p>注意：</p><ul><li><p>块级元素和行内元素都可以浮动，当一个<strong>行内元素浮动以后将会自动变为一个块级元素</strong>。</p></li><li><p>当一个块级元素浮动以后，宽度会默认被内容撑开，所以<strong>当漂浮一个块级元素时我们都会为其指定一个宽度</strong>。</p></li><li><p>浮动的元素不会覆盖住文字。文字会自动环绕在浮动元素的周围。所以可以通过浮动来设置文字环绕图片的效果。</p></li><li><p>当一个元素浮动以后，<strong>其下方的元素会上移</strong>。元素中的内容将会围绕在元素的周围。</p></li><li><p>浮动会使元素完全脱离文本流，也就是不再在文档中在占用位置。</p></li><li><p>元素设置浮动以后，会一直向上漂浮直到遇到父元素的边界或者其他浮动元素。</p></li><li><p>元素浮动以后即完全脱离文档流，这时不会再影响父元素的高度。也就是浮动元素不会撑开父元素。</p></li><li><p>浮动元素<strong>默认会变为块元素</strong>，即使设置display:inline以后其依然是个块元素。</p></li></ul><pre><code class="hljs css"><span class="hljs-selector-class">.s1</span>&#123;    <span class="hljs-comment">/*使span元素浮动*/</span>    <span class="hljs-attribute">float</span>:left;    <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;    <span class="hljs-attribute">background-color</span>:red;&#125;</code></pre><h3 id="高度塌陷问题"><a href="#高度塌陷问题" class="headerlink" title="高度塌陷问题"></a>高度塌陷问题</h3><p>当子元素浮动以后，子元素脱离文档流，不再撑起父元素的高度，引起塌陷，而父元素下的所有元素将会上移，导致页面布局混乱。</p><p>使用<code>clear</code>.</p><p>作用：清除浮动元素对当前元素的影响。</p><ul><li>none：默认值，不清除影响。</li><li>left：清除左侧浮动元素对当前元素带来的影响</li><li>right：清除右侧浮动元素对当前元素带来的影响</li><li>both：清除两侧浮动元素对当前元素带来的影响</li></ul><p>但单纯使用clear会在页面添加一个空白的多余结构，推荐结合after伪类解决高度塌陷问题。</p><p>TIPS：可将要选中的元素添加<code>class=clearfix</code>。</p><pre><code class="hljs css"><span class="hljs-comment">/*</span><span class="hljs-comment">通过after的content来添加一个空白元素，设置为块元素，然后清除浮动。</span><span class="hljs-comment">*/</span><span class="hljs-selector-class">.clearfix</span>：<span class="hljs-selector-tag">after</span>&#123;    <span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-attribute">display</span>:block;    <span class="hljs-attribute">clear</span>:both;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小白文</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON 一些简单知识</title>
    <link href="/JSON/"/>
    <url>/JSON/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：JSON的一些简单知识，源自《JSON必知必会》。</p><a id="more"></a><blockquote><p>参考书籍：《JSON必知必会》</p><p>[美]  Lindsay Bassett 著</p><p>图灵程序设计丛书</p></blockquote><h2 id="什么是JSON"><a href="#什么是JSON" class="headerlink" title="什么是JSON"></a>什么是JSON</h2><ul><li>JSON：JavaScript 对象表示法（JavaScript Object Notation）。</li><li>JSON是一种<strong>数据交换格式</strong>，被许多系统用于交换数据。</li><li>JSON 独立于编程语言，表达数据的方式对通用的编程概念都很友好。</li></ul><h2 id="JSON语法"><a href="#JSON语法" class="headerlink" title="JSON语法"></a>JSON语法</h2><ul><li><p>JSON基于JavaScript对象字面量，即使用了JS的对象字面量及其属性的语法表示：名称 — 值。</p><ul><li>所谓字面量是指对数据值的具体表示，例如<code>x = 5</code>，5就是一个数字字面量。</li></ul></li><li><p>JSON中的<code>名称 — 值</code> 对形式为 <code>&quot;名称&quot; : 值</code>。</p><ul><li><strong>名称始终需要加双引号！</strong></li><li>值可以是字符串、数字、布尔值、null、对象或数组。</li><li><code>名称 — 值</code> 对 也称 <code>属性 — 值</code> 对 或者<code>键—值</code>对。</li><li>值可以是字符串、数字、布尔值、null、数组或者对象。</li></ul></li><li><p>在JSON中，为了获得<strong>最大可移植性</strong>(“以一种双方系统都兼容的方式在平台间传递信息”)，应该尽量避免使用空格或特殊字符（即 a<del>z、0</del>9 除外的其他字符）。</p></li><li><p>构建对象：将<strong>花括号</strong>加在名称 - 值对的两边来使之成为一个对象，多个名称 - 值对使用逗号来分隔。</p></li><li><p>追根溯源，<strong>JSON本身就是对象</strong>。</p></li></ul><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;brand&quot;</span>:<span class="hljs-string">&quot;Crocs&quot;</span>,    <span class="hljs-attr">&quot;color&quot;</span>:<span class="hljs-string">&quot;pink&quot;</span>,    <span class="hljs-attr">&quot;size&quot;</span>:<span class="hljs-number">9</span>,    <span class="hljs-attr">&quot;hasLaces&quot;</span>:<span class="hljs-literal">false</span>&#125;</code></pre><h2 id="JSON的数据类型"><a href="#JSON的数据类型" class="headerlink" title="JSON的数据类型"></a>JSON的数据类型</h2><ul><li><strong>数字</strong>：可以是整数、小数、负数或者指数。</li><li><strong>布尔值</strong>：只能是<code>true</code>或者<code>false</code>。其他形式写法都错误。</li><li><strong>null</strong>：表示没有值，只能使用<code>null</code>，且必须小写。</li><li><strong>字符串</strong>：可由任何Unicode字符构成，必须用双引号包裹。<ul><li>转义字符，使用反斜线来进行转义，例如双引号用<code>\&quot;</code>。</li></ul></li><li><strong>数组</strong>：由值构成的列表或者集合。每个值都可以是字符串、数字、布尔值、对象或数组中的任何一种，数组必须被方括号<code>[] </code>包裹，且值与值之间用逗号隔开。</li><li><strong>对象</strong>：使用逗号分隔的，由名称-值构成的列表或者集合，并且使用花括号<code>&#123;&#125;</code>进行包裹。</li></ul><blockquote><p>数组或者对象是可以<strong>嵌套</strong>的。</p></blockquote><h2 id="JSON一个实例"><a href="#JSON一个实例" class="headerlink" title="JSON一个实例"></a>JSON一个实例</h2><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;person&quot;</span>:&#123;        <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;Lindsay Bassett&quot;</span>,        <span class="hljs-attr">&quot;heightInInches&quot;</span>:<span class="hljs-number">66</span>,        <span class="hljs-attr">&quot;head&quot;</span>:&#123;            <span class="hljs-attr">&quot;hair&quot;</span>:&#123;                <span class="hljs-attr">&quot;color&quot;</span>:<span class="hljs-string">&quot;light blond&quot;</span>,                <span class="hljs-attr">&quot;length&quot;</span>:<span class="hljs-string">&quot;short&quot;</span>,                <span class="hljs-attr">&quot;style&quot;</span>:<span class="hljs-string">&quot;A-line&quot;</span>            &#125;,            <span class="hljs-attr">&quot;eyes&quot;</span>:<span class="hljs-string">&quot;green&quot;</span>        &#125;    &#125;&#125;</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>JSON 这种数据交换格式是可以作为独立的文件存在于文件系统中的。它的文件扩展名：<code>.json</code>。</li><li>JSON 的 MIME 类型是 application/json 。</li></ul><blockquote><p>当你在传递数据时，需要提前告知接收方数据是什么类型，这就会涉及<strong>媒体类型</strong>。媒体类型也有一些你可能听过的其他称呼，如“互联网媒体类型”“内容类型”或“MIME 类型”。它使用“类型 / 子类型”这种格式来表示，比如你可能见过的 text/html 。</p><p>互联网数字分配机构（Internet Assigned Numbers Authority，IANA）维护着一个包含全部媒体类型的列表（<a href="http://www.iana.org/assignments/media-types/media-types.xhtml%EF%BC%89%E3%80%82">http://www.iana.org/assignments/media-types/media-types.xhtml）。</a></p></blockquote><h2 id="JSON-Schema-第四章"><a href="#JSON-Schema-第四章" class="headerlink" title="JSON Schema(第四章)"></a>JSON Schema(第四章)</h2><blockquote><ul><li><p>JSON 验证器负责验证语法错误，JSON Schema 负责提供<strong>一致性检验</strong>。</p></li><li><p>JSON Schema 是数据接收方的第一道防线，也是数据发送方节约时间、<br>保证数据正确的好工具。</p></li></ul><p>JSON Schema 可以解决下列有关一致性验证的问题。</p><ul><li><p>值的数据类型是否正确？<br>可以具体规定一个值是数字、字符串等类型。</p></li><li><p>是否包含所需要的数据？<br>可以具体规定哪些数据是需要的，哪些是不需要的。</p></li><li><p>值的形式是不是我需要的？<br>可以指定范围、最小值和最大值。</p></li></ul></blockquote><h2 id="JSON的一些作用"><a href="#JSON的一些作用" class="headerlink" title="JSON的一些作用"></a>JSON的一些作用</h2><ul><li>作为数据交换格式，用于交换数据。</li><li>作为一种文本格式，可作为JSON文档存储数据，例如：CouchDB是一种使用 JSON 文档存储数据的NoSQL 数据库。</li><li>可将对象序列化为JSON或反序列化。</li><li>可作为配置文件。</li></ul><p>本文只占据这本书的一半的内容，剩余关于JSON的一些应用等内容并为写出，感兴趣可以自行查阅。</p><p>书籍链接：<a href="https://pan.baidu.com/s/1gNeClwP9Is2ohtsuVPdalA">https://pan.baidu.com/s/1gNeClwP9Is2ohtsuVPdalA</a><br>提取码：hpb9 </p>]]></content>
    
    
    <categories>
      
      <category>JSON</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JSON</tag>
      
      <tag>小白文</tag>
      
      <tag>文件下载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenGL在VS2019上搭建环境 —— GLEW、GLFW以及GLUT</title>
    <link href="/opengl-setup/"/>
    <url>/opengl-setup/</url>
    
    <content type="html"><![CDATA[<p>使用VS2019搭建OpenGL运行环境，包括GLEW、GLFW以及GLUT的安装。</p><a id="more"></a><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p>蓝奏云下载链接：<a href="https://colourso.lanzous.com/b05y8x7cf">https://colourso.lanzous.com/b05y8x7cf</a>  密码:fmi7 </p><p>百度云下载链接：<a href="https://pan.baidu.com/s/1OixN8GjM6Igy0JWZQLRc7w">https://pan.baidu.com/s/1OixN8GjM6Igy0JWZQLRc7w</a>  提取码：hb1v</p><p>包含两个压缩包：OpenGL环境依赖包，以及OpenGL_VS2019环境内容。</p><p>OpenGL环境依赖包包含了GLEW、GLFW、GLUT的相关文件。</p><p>OpenGL_VS2019环境内容是一个搭建的参考，在下面的搭建步骤也可以把部分内容直接拿来用。</p><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>创建一个目录，这里叫<code>OpenGLRoot</code>，这里将会存放相关的库，以及VS的项目。</p><p>在这个目录下新建文件夹<code>External Resources</code>，然后将准备好的<code>GLEW</code>、<code>GLFW</code>、<code>GLUT</code>拷贝进这个目录。</p><ul><li>此处安装的是：<code>glew-2.1.0-win32.zip</code>、<code>glfw-3.3.2.bin.WIN32.zip</code>以及<code>glutdlls37beta.zip</code>三个压缩包的文件。</li><li>GLEW、GLFW、GLUT都是上述对应的文件，解压后直接修改文件夹名字为对应的大写字母，然后放进<code>External Resources</code>文件夹下。</li></ul><p><img src="/opengl-setup/GLEW.png"></p><p><img src="/opengl-setup/GLFW.png"></p><p><img src="/opengl-setup/GLUT.png"></p><h2 id="VS配置"><a href="#VS配置" class="headerlink" title="VS配置"></a>VS配置</h2><p>然后打开VS2019，创建一个新的解决方案，这里取名为<code>opengl</code>，存放在<code>OpenGLRoot</code>目录下，添加一个<code>main.cpp</code>文件，这样便于配置C++相关的东西。</p><p>右键项目，点击属性(<strong>快捷键是 Alt + Enter</strong>)，在属性页的最上部选择配置为所有配置，平台选择活动Win32。</p><p>然后选择<code>C/C++</code>，然后选择常规，选择第一项附加包含目录。添加如下三个信息。</p><pre><code class="hljs awk">$(SolutionDir)<span class="hljs-regexp">/../</span>External Resources/GLUT$(SolutionDir)<span class="hljs-regexp">/../</span>External Resources<span class="hljs-regexp">/GLEW/i</span>nclude$(SolutionDir)<span class="hljs-regexp">/../</span>External Resources<span class="hljs-regexp">/GLFW/i</span>nclude</code></pre><ul><li><code>$(SolutionDir)</code>表示解决方案的所在路径，即<code>.sln</code>文件的所在路径。</li><li>添加时一个一个添加，一行添加一个，下面两个添加也是这样。</li></ul><p>然后选择<code>链接器</code>，选择常规，那么多项的中间选择<code>附加库目录</code>，添加如下三个信息。</p><pre><code class="hljs awk">$(SolutionDir)<span class="hljs-regexp">/../</span>External Resources/GLUT$(SolutionDir)<span class="hljs-regexp">/../</span>External Resources<span class="hljs-regexp">/GLEW/</span>lib<span class="hljs-regexp">/Release/</span>Win32$(SolutionDir)<span class="hljs-regexp">/../</span>External Resources<span class="hljs-regexp">/GLFW/</span>lib-vc2019</code></pre><ul><li>GLFW这里的目录最好对应你的VS版本，GLFW好多VS版本都有提供对应的文件。</li></ul><p>然后选择<code>链接器</code>，选择<code>输入</code>，选择附加依赖项，添加如下三个信息。</p><pre><code class="hljs crystal">opengl32.<span class="hljs-keyword">lib</span>glew32s.<span class="hljs-keyword">lib</span>glfw3.<span class="hljs-keyword">lib</span></code></pre><p><img src="/opengl-setup/pp.png"></p><ul><li>图片中有序号，展示了大致顺序。为了方便展示，图中少了链接器配置的两步。</li><li>配置完后，记得先点击<code>应用</code>，再点击<code>确定</code>。</li></ul><p>然后进入<code>OpenGLRoot\opengl</code>路径下，创建两个文件夹<code>Debug</code>和<code>Release</code>。</p><p>注意这两个文件夹是和解决方案<code>.sln</code>同级的哦~</p><p>然后找到三个库文件夹里的<code>glew32.dll</code>和<code>glut32.dll</code>这两个文件，分别拷贝一份到Debug和Release目录之下。</p><p>到此环境配置完成，然后尝试用代码测试环境是否正确。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glut.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;glClear(GL_COLOR_BUFFER_BIT);glRectf(<span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>);glFlush();&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span> </span>&#123;glutInit(&amp;argc, argv);glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);glutInitWindowPosition(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>);glutInitWindowSize(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>);glutCreateWindow(<span class="hljs-string">&quot;第一个OpenGL程序&quot;</span>);glutDisplayFunc(&amp;display);glutMainLoop();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><img src="/opengl-setup/show.png"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p><a href="https://www.cnblogs.com/mjk961/p/9534750.html">01-&gt;OpenGL 实验环境配置（glut）及简单实例</a></p><p>Youtube视频：<a href="https://youtu.be/gCkcP0GcCe0">Modern OpenGL 3.0+ Visual Studio 2017 [SETUP] GLFW and GLEW on Windows</a></p></blockquote><h2 id="保存项目属性表"><a href="#保存项目属性表" class="headerlink" title="保存项目属性表"></a>保存项目属性表</h2><p>做到这里就会有一个疑问，难道我每创建一个项目都要这么配置一遍项目吗？而且同一个解决方案里面的项目都需要重新配置一遍，这谁顶得住。</p><p>百度之后，解决方法是：保存项目属性表，然后引入到新的项目中，就不用这么来回配置了。</p><p>在VS2019的界面里，<strong>视图</strong> –&gt; <strong>其他窗口</strong> –&gt; <strong>属性管理器</strong>。</p><p>然后就会在解决方案右侧出现属性管理器。</p><p><img src="/opengl-setup/props.png"></p><p>通常我们都是Debug Win32模式下，右键右键一个新项目属性表。记得取一个有辨识度的名字，方便之后使用。</p><p>双击新的项目属性表即可打开编辑，然后将上面的操作配置的一切操作再做一遍，即可。当然配置那一栏无法选取，因为这是默认的Debug Win32。</p><p>设置完毕之后在工程路径下找到<code>.props</code>文件，即你的项目属性表，然后可以使用这个项目属性表添加给其他同一解决方案下的其他项目了。</p><p>添加方式：新建一个项目，打开属性管理器，选择Debug|Win32，右键，选择添加现有属性表，添加即可。</p><hr><h2 id="第二种方法——只使用GLUT"><a href="#第二种方法——只使用GLUT" class="headerlink" title="第二种方法——只使用GLUT"></a>第二种方法——只使用GLUT</h2><ol><li>解压<code>glutdlls37beta.zip</code>这个压缩包，包含<code>glut.dll</code>，<code>glut32.dll</code>，<code>glut.lib</code>，<code>glut32.lib</code>，<code>glut.h</code>。</li><li>找到VS2019的安装目录，我的路径为<code>D:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\include</code>，创建一个<code>gl</code>的文件夹，然后将<code>glut.h</code>这个文件放入其中。</li><li>然后找到路径<code>D:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.24.28314\lib\x86</code>，把<code>glut.lib</code>、<code>glut32.lib</code>复制到其中。</li><li>最后把解压到的<code>glut.dll</code>以及<code>glut32.dll</code>复制到路径<code>C:\Windows\System32</code>以及<code>C:\Windows\SysWOW64</code>两个目录下，建议都复制一下。</li><li>最后在VS2019中使用时引入的头文件为<code>#include &lt;gl/glut.h&gt;</code>。</li><li>VS2017同理可用。</li></ol><h2 id="吐槽一下"><a href="#吐槽一下" class="headerlink" title="吐槽一下"></a>吐槽一下</h2><p>环境搭建越费力，后面写代码的可能性越小。</p><p>搭建完环境之后，我就回老家呆了7-8天，回来之后就开始各种狂奔，刷作业，刷网课，刷其他课设，中间又和同学出去玩了几次，结果临近图形学结课，我才发现我压根就没用过这个环境，就是使用了GLUT这种普通的搭建环境，以至于GLEW、GLFW的环境我也没具体测试过，但是参照的油管的教程一步一步走下来的，问题或许不大。</p><p>尴尬~</p>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件下载</tag>
      
      <tag>SOP</tag>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML语法总结</title>
    <link href="/HTML/"/>
    <url>/HTML/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：HTML的语法，基本结构、各种标签、实体、块元素与内联元素、元素属性，以及超链接、图片、列表、表格以及表单的写法。</p><a id="more"></a><hr><p><strong>预警</strong>：本文是我于<font color="red">2020年4月总结的</font> <font color="gree">2018年7月我所学的</font> <font color="blue">2016年的前端课程</font>，简言之可能时效性比较差，可能落后于当今的技术，小心阅读~</p><blockquote><p>前端课程链接：<a href="http://www.atguigu.com/download_detail.shtml?v=63">李立超 —— 尚硅谷_HTML&amp;CSS核心基础</a></p></blockquote><hr><h2 id="HTML的基本结构"><a href="#HTML的基本结构" class="headerlink" title="HTML的基本结构"></a>HTML的基本结构</h2><pre><code class="hljs html"><span class="hljs-meta">&lt;!doctype <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 注释 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>网页标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>            这是一个简单的网页        <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>            简单的段落        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><ul><li><code>&lt;!doctype html&gt;</code>是Html5的文档说明，放在文件的最上方，告诉浏览器网页的版本。</li><li><code>&lt;html&gt;</code>标签是根标签，<strong>一个页面有且只能有一对根标签</strong>，并且几乎一切内容都应该在这对标签之中。根标签中包含两个子标签<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>.</li><li><code>&lt;head&gt;</code>标签头部标签，其内的一切内容都不能在页面中看到。常用来设定一些信息，让浏览器查看，常包含<code>&lt;title&gt;</code>标签。</li><li><code>&lt;meta charset=&quot;utf-8&quot;/&gt;</code>meta用来设置网页的元数据，上述例子表示网页编写采用的字符集是UTF-8.</li><li><code>UTF-8</code>: 万国码，一般网页编写采用的编码。当然也要保证HTML文件本身也是UTF-8格式的。</li><li><code>&lt;title&gt;</code>网页的标题标签，其内容会出现在网页的标题栏上。</li><li><code>&lt;body&gt;</code>网页的主体标签，用于设置网页的主体内容，所有可见的内容都应该存放于<code>&lt;body&gt;</code>中。</li><li><code>&lt;h1&gt;</code> 标题标签，共有6级标签，h1<del>h6，由大到小，常用h1</del>h3.</li><li><code>&lt;p&gt;</code>段落标签，表示内容的一个自然段，默认独占一行。</li><li><code>&lt;!-- 注释 --&gt;</code> HTML的注释格式，可占据多行。</li></ul><h2 id="HTML一些基础知识点"><a href="#HTML一些基础知识点" class="headerlink" title="HTML一些基础知识点"></a>HTML一些基础知识点</h2><ul><li>HTML不区分大小写，<code>&lt;head&gt;</code>与<code>&lt;HEAD&gt;</code>解析效果相同。</li><li>HTML注释不能嵌套。</li><li>HTML标签大致有两种，一种成对出现，例如<code>&lt;html&gt;</code>和<code>&lt;/html&gt;</code>，后面的标签多加一个反斜杠；另一种是自结束标签，即这个标签只写一个即可，例如<code>&lt;br/&gt;</code>。</li><li>HTML标签要尽可能地完整，要么成对标签，要么自结束标签，浏览器会尽最大努力解析网页，尽可能修正网页中不规范或者错误的地方。</li><li>HTML标签可以嵌套，但是不能交叉嵌套，例如：<code>&lt;p&gt; 你好&lt;strong&gt;啊&lt;/p&gt;&lt;/strong&gt;</code>这样就是错误的。</li><li>HTML标签中的可以添加其他的属性，要求属性必须有值，值必须要加引号(单引、双引皆可)。例如：图片标签<code>&lt;img src = &quot;1.png&quot; /&gt;</code></li></ul><h2 id="HTML常用简单标签"><a href="#HTML常用简单标签" class="headerlink" title="HTML常用简单标签"></a>HTML常用简单标签</h2><table><thead><tr><th>标签</th><th>作用</th></tr></thead><tbody><tr><td><code>&lt;center&gt; &lt;center/&gt;</code></td><td>内容居中</td></tr><tr><td><code>&lt;br /&gt;</code></td><td>换行</td></tr><tr><td><code>&lt;hr /&gt;</code></td><td>水平线</td></tr><tr><td><code>&lt;strong&gt; &lt;/strong&gt;</code></td><td>文本加粗</td></tr><tr><td><code>&lt;em&gt; &lt;/em&gt;</code></td><td>文本斜体</td></tr><tr><td><code>&lt;sup&gt; &lt;/sup&gt;</code></td><td>上标</td></tr><tr><td><code>&lt;sub&gt; &lt;/sub&gt;</code></td><td>下标</td></tr><tr><td><code>&lt;ins&gt; &lt;/ins&gt;</code></td><td>文本加上下划线</td></tr><tr><td><code>&lt;del&gt; &lt;/del&gt;</code></td><td>文本加上删除线</td></tr></tbody></table><h2 id="HTML-实体"><a href="#HTML-实体" class="headerlink" title="HTML 实体"></a>HTML 实体</h2><p>在HTML中<code>&lt;</code>与<code>&gt;</code>这样的字符是不能直接表示的，需要使用特殊符号表示，这就是实体。</p><table><thead><tr><th>符号</th><th>实体</th></tr></thead><tbody><tr><td><code>&lt;</code></td><td><code>&amp;lt;</code></td></tr><tr><td><code>&gt;</code></td><td><code>&amp;gt;</code></td></tr><tr><td>空格</td><td><code>&amp;nbsp;</code></td></tr><tr><td>版权符号</td><td><code>&amp;copy;</code></td></tr></tbody></table><h2 id="HTML-块元素与内联元素"><a href="#HTML-块元素与内联元素" class="headerlink" title="HTML 块元素与内联元素"></a>HTML 块元素与内联元素</h2><ul><li>一个<strong>块元素独占一行</strong>，无论它会有多少内容。</li><li>而<strong>内联元素则只占据自身大小的地方</strong>。</li><li>常见的块元素有：<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;li&gt;</code>标签。</li><li><code>div</code>标签主要用来对页面的元素进行布局。</li><li><font color="red"><code>p</code>标签不可以包含其他的块元素，包括其本身。</font></li><li>常见的内联元素有：<code>&lt;a&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;span&gt;</code>。</li><li><code>span</code>标签常用来选择文字，然后为文字设置样式，无任何语义。</li><li><code>a</code>标签中可以包含任意元素，除了它本身。</li><li><font color="red">一般情况下只使用块元素包含内联元素，而不会使用内联元素包含块元素。</font></li></ul><h2 id="HTML-元素属性"><a href="#HTML-元素属性" class="headerlink" title="HTML 元素属性"></a>HTML 元素属性</h2><p>可以给HTML中的元素设置属性，常见的有<code>id</code>属性，<code>class</code>属性，<code>title</code>属性.</p><p>设置属性格式：</p><pre><code class="hljs html">&lt;标签 属性名 = &quot;属性值&quot;&gt;  内容  &lt;/标签&gt;<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span> = <span class="hljs-string">&quot;p2&quot;</span>&gt;</span> Colourso <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span> = <span class="hljs-string">&quot;p2&quot;</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;cd&quot;</span>&gt;</span> Colourso <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span> = <span class="hljs-string">&quot;p2 h2 abc&quot;</span>&gt;</span> CC <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><ul><li>多个属性之间使用空格隔开即可。</li><li>属性必须有值，是以<code>属性名 = &quot;属性值&quot;</code>这样的形式。</li><li>id属性是标签的唯一标识符，同一页面内标签的id<strong>不能重复</strong>。</li><li>class属性允许重复，拥有相同class属性值的元素可以称之为<strong>同一组元素</strong>。</li><li>同一个元素可以设置多个class属性值，使用空格隔开即可。</li><li>title属性可以添加给任何标签，当鼠标移动至该标签时，会显示title的值。</li></ul><h2 id="HTML-超链接"><a href="#HTML-超链接" class="headerlink" title="HTML 超链接"></a>HTML 超链接</h2><p>超链接可以从一个页面跳转到另一个页面。</p><p>用法：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;www.colourso.top&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_self&quot;</span>&gt;</span> Colourso博客 <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><ul><li>href：指向链接跳转的目标地址，可以写相对路径，也可以写完整的地址。<ul><li>当写成<code>href = &quot;#&quot;</code>时，点击链接会自动跳转到页面顶部。</li><li>href也可以写成<code>#</code>加上某一个标签的id的值，例如<code>href = &quot;#id的名字&quot;</code>，这样点击时就会跳转到id的位置处。</li></ul></li><li>target：用来指定打开超链接的位置。<ul><li><code>_self</code>：在当前窗口内打开</li><li><code>_blank</code>：在新的窗口内打开</li></ul></li><li><font color="red">a标签内可以包含任意标签，除了它本身！</font></li></ul><h2 id="HTML-图片"><a href="#HTML-图片" class="headerlink" title="HTML 图片"></a>HTML 图片</h2><p>HTML插入图片使用<code>&lt;img&gt;</code>标签，此标签是一个自结束标签。</p><p>用法：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>= <span class="hljs-string">&quot;1.png&quot;</span> <span class="hljs-attr">alt</span> = <span class="hljs-string">&quot;Colourso&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;20px&quot;</span> <span class="hljs-attr">heught</span>=<span class="hljs-string">&quot;30px&quot;</span>/&gt;</span></code></pre><ul><li>src：设置外部图片的路径，常使用相对路径，即相对当前资源所在目录的位置。</li><li>alt：图片的描述内容，可不写。</li><li>width：修改图片的显示宽度，一般用px(像素)做单位。</li><li>height：修改图片的显示高度<ul><li>注意：如果宽度高度只设置一个的话，另一个会跟随着等比例缩放。</li></ul></li></ul><h2 id="HTML-列表"><a href="#HTML-列表" class="headerlink" title="HTML 列表"></a>HTML 列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>使用<code>&lt;ul&gt; &lt;/ul&gt;</code>来来创建一个无序列表。</p><p>在<code>ul</code>标签内使用<code>&lt;li&gt; &lt;/li&gt;</code>创建一个列表项。</p><p><code>ul</code>属性<code>type</code>来调节列表的符号：disc(实心圆，默认值)、square(方块)、circle(圆圈)。</p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>使用<code>&lt;ol&gt; &lt;/ol&gt;</code>来来创建一个有序列表。</p><p>在<code>ol</code>标签内使用<code>&lt;li&gt; &lt;/li&gt;</code>创建一个列表项。</p><p><code>ol</code>属性<code>type</code>来调节列表的符号：1(数字，默认值)、a/A(小/大写字母)、i/I(小/大写罗马数字)。</p><h3 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h3><p>使用<code>&lt;dl&gt; &lt;/dl&gt;</code>来来创建一个有序列表，其内包含两个子标签<code>dt</code>和<code>dd</code>。</p><p><code>&lt;dt&gt; &lt;/dt&gt;</code>：指被定义的内容</p><p><code>&lt;dd&gt; &lt;/dd&gt;</code>：对定义内容的描述</p><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;circle&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>结构<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>表现<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>行为<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;I&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>结构<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>表现<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>行为<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>鱼香肉丝<span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>萝卜<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>肉丝<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>宫保鸡丁<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>黄焖鸡<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>武松<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>打虎英雄<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>武大郎<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>著名烧饼<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span></code></pre><p>执行结果：</p><p><img src="/HTML/list.png"></p><h2 id="HTML-表格"><a href="#HTML-表格" class="headerlink" title="HTML 表格"></a>HTML 表格</h2><p>使用<code>&lt;table&gt; &lt;/table&gt;</code>来创建表格。</p><p><code>&lt;tr&gt; &lt;/tr&gt;</code>写在<code>table</code>标签中，用来表示表格中的一行，有几个tr就有几行。</p><p><code>&lt;td&gt; &lt;/td&gt;</code>写在<code>tr</code>标签中，用来表示一行中的单元格，有几个td就有几个单元格。</p><p><code>&lt;th&gt; &lt;/th&gt;</code>写在<code>tr</code>标签中，表示表头，用法和td一样，只是其内的文字默认加粗居中。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>序号<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>名字<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Kelly<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Tom<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Bob<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre><ul><li>若<code>table</code>标签中不加属性<code>border</code>，则表格无边框，border表示宽度。</li></ul><p>执行结果：</p><p><img src="/HTML/table.png"></p><h2 id="HTML-表单"><a href="#HTML-表单" class="headerlink" title="HTML 表单"></a>HTML 表单</h2><p>可以使用<code>&lt;form&gt; &lt;/form&gt;</code>标签来创建一个空表单，其内容还需要使用其他标签添加。</p><ul><li><code>form</code>标签常需要设置<code>action</code>属性，表示服务器的地址。</li><li>还需要设置<code>method</code>属性，<code>method=&quot;post&quot;</code>可设置POST或者GET。<ul><li>get方法将表单的输入信息作为查询字符附加在action指定的地址后传送到服务器，会在浏览器地址栏以明文形式显示出来，且对数据的长度有限制。</li><li>post方法将表单中用户的数据进行包装，按照HTTP传输协议中的post方式传送到服务器，且对数据长度没有什么限制，目前大多采用这种方式。</li></ul></li></ul><p>常用<code>&lt;input /&gt;</code>标签来创建各种文本框以及提交按钮。</p><ul><li><code>input</code>标签时自结束标签，且是一个内联元素。</li><li>需要设置<code>name</code>属性，name的值表示<strong>这个表单项提交给服务器的内容的名字</strong>。</li><li><code>input</code>标签可以设置<code>type</code>属性的值，从而形成不同的样式。<ul><li><code>input</code>标签可以设置<code>value</code>属性的值，将会作为文本框的默认值显示。</li><li><code>type = &quot;text&quot;</code>来创建一个文本框。</li><li><code>type = &quot;password&quot;</code>来创建一个密码框，密码默认使用星号代替。</li><li><code>type = &quot;submit&quot;</code>来创建一个提交按钮。</li><li><code>type = &quot;radio&quot;</code>来创建一个单选框，同一组单选框的<code>name</code>属性值相同，且必须指定<code>value</code>值，而属性<code>checked=&quot;checked&quot;</code>则表示默认被选中。</li><li><code>type = &quot;checkbox&quot;</code>来创建多选框，同样使用<code>name</code>属性来分组区分，并且还必须指定<code>value</code>值，而属性<code>checked=&quot;checked&quot;</code>则表示默认被选中。</li></ul></li><li>可使用<code>&lt;select&gt; &lt;/select&gt;</code>来创建下拉列表，要指定<code>name</code>属性。<ul><li>使用<code>&lt;option&gt;&lt;/option&gt;</code>来创建列表项，列表项要指定<code>value</code>属性，属性<code>selected=&quot;selected&quot;</code>则表示默认被选中。</li></ul></li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;www.colourso.top&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span>用户名<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>密码<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>性别<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span>/&gt;</span>大猪蹄子<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">&quot;checked&quot;</span>/&gt;</span>女<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>喜欢的语言<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pro&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;C++&quot;</span>/&gt;</span>C++<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pro&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Java&quot;</span>/&gt;</span>Java<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pro&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Python&quot;</span>/&gt;</span>Python<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pro&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Js&quot;</span>/&gt;</span>Js<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>最擅长的技术<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;best-pro&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dream&quot;</span> <span class="hljs-attr">selected</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span>做白日梦<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dream&quot;</span>&gt;</span>服务器开发<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dream&quot;</span>&gt;</span>客户端开发<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><p>执行效果：</p><p><img src="/HTML/form.png"></p><p>点击体检按钮的浏览器的跳转结果(原谅我的中文路径)</p><ul><li>如果不写<code>method = &quot;post&quot;</code>，数据都是明文，如下形式：</li></ul><pre><code class="hljs sas"><span class="hljs-meta">file</span>:///D:/Code/前端/www.colourso.top?username=Colourso<span class="hljs-variable">&amp;password</span>=123<span class="hljs-variable">&amp;sex</span>=<span class="hljs-name">%E7</span>%94<span class="hljs-name">%B7</span><span class="hljs-variable">&amp;pro</span>=C%2B%2B<span class="hljs-variable">&amp;best</span>-pro=dream</code></pre><ul><li>写上<code>method = &quot;post&quot;</code>，如下：</li></ul><pre><code class="hljs awk">file:<span class="hljs-regexp">//</span><span class="hljs-regexp">/D:/</span>Code<span class="hljs-regexp">/前端/</span>www.colourso.top</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小白文</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面向对象练习（三）—— 继承的简单练习</title>
    <link href="/cpp-opp2-prc3/"/>
    <url>/cpp-opp2-prc3/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：C++面向对象练习：继承。</p><a id="more"></a><hr><blockquote><p>代码全部运行于VS2019</p><p>博客后续会持续更新补充。</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>试定义类TRI (三角形)及其派生类COL (三角柱体)。其中三角形类可以计算三角形的面积和周长;三角柱体类可以计算柱体的体积和表面积。具体要求如下:</p><p>(1) TRI的成员如下:</p><ul><li><p>私有数据成员</p><ul><li>double x,y,z;分别表示三角形三条边的长度</li></ul></li><li><p>公有成员函数</p><ul><li>TRI (double x1,double y1,double z1);构造函数，用x1,y1,z1 分别初始化三角形的三条边。在初始化之前，必须先判断x1、y1、 z1能否构成三角形，如果不能构成三角形，则给出提示并退出程序。判断三条边是否构成三角形的方法:任意两边之和大于第三边。</li><li>virtual double area();虚函数，计算三角形的面积.计算公式为:面积=[s*(s-x)<em>(s-y)</em>(s-z)]^0.5.其中，x、y、z分别为三角形三条边的长度，s= (x+y+z)/2。</li><li>double peri(); 计算三角形的周长。</li></ul></li></ul><p>(2)类COL为类TRI的公有派生类，其成员如下:</p><ul><li>私有数据成员<ul><li>double height;表示三角柱体的高度。</li></ul></li><li>公有成员函数<ul><li>COL (double x1,double y1,double z1,double h);构造函数，用h初始化height，用x1、y1、z1分别初始化基类的成员x、y、z。</li><li>double volume();计算三角柱体的体积。计算公式:体积=底面积X高，其中底面积通过调用基类的成员函数area()计算。</li><li>double area();计算三角柱体的表面积。计算公式:表面积=2X底面积+底面周长X高度，其中底面积和底面周长分别通过调用基类的成员函数area()和prei()计算。</li></ul></li></ul><p>(3)在主函数中，创建一个COL对象co和一个TRI指针*tr，并将tr指向co。通过co调用volume(),计算并输出三角柱体的体积;通过tr调用area(), 计算并输出三角柱体的表面积。</p></blockquote><p>题目来源与参考链接：<a href="https://blog.csdn.net/qq_36426650/article/details/84873569">C++面向对象程序设计50道编程题（第23题）</a></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TRI</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    TRI(<span class="hljs-keyword">double</span> x1, <span class="hljs-keyword">double</span> y1, <span class="hljs-keyword">double</span> z1);    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">peri</span><span class="hljs-params">()</span></span>;          <span class="hljs-comment">//计算周长</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//计算面积</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">double</span> x, y, z;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">COL</span>:</span><span class="hljs-keyword">public</span> TRI&#123;<span class="hljs-keyword">public</span>:    COL(<span class="hljs-keyword">double</span> x1, <span class="hljs-keyword">double</span> y1, <span class="hljs-keyword">double</span> z1, <span class="hljs-keyword">double</span> h);    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">volume</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//计算体积</span>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">//计算面积</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">double</span> height;&#125;;TRI::TRI(<span class="hljs-keyword">double</span> x1, <span class="hljs-keyword">double</span> y1, <span class="hljs-keyword">double</span> z1)&#123;    <span class="hljs-keyword">if</span> (x1 + y1 &lt;= z1)    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;无法构成三角形！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">this</span>-&gt;x = x1;    <span class="hljs-keyword">this</span>-&gt;y = y1;    <span class="hljs-keyword">this</span>-&gt;z = z1;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">TRI::peri</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x+y+z;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">TRI::area</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> s = (x+y+z)/<span class="hljs-number">2</span>;    <span class="hljs-keyword">double</span> areas = <span class="hljs-built_in">sqrt</span>(s*(s-x)*(s-y)*(s-z));    <span class="hljs-keyword">return</span> areas;&#125;COL::COL(<span class="hljs-keyword">double</span> x1, <span class="hljs-keyword">double</span> y1, <span class="hljs-keyword">double</span> z1, <span class="hljs-keyword">double</span> h):TRI(x1, y1, z1)&#123;    <span class="hljs-keyword">this</span>-&gt;height = h;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">COL::volume</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> are = TRI::area();    <span class="hljs-keyword">double</span> vol = are * height;    <span class="hljs-keyword">return</span> vol;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">COL::area</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> are = TRI::area();    <span class="hljs-keyword">double</span> oth = TRI::peri()*height;    are = <span class="hljs-number">2</span> * are + oth;    <span class="hljs-keyword">return</span> are;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> x, y, z, h;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入三角锥的底边三边长和高：&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; h;    <span class="hljs-function">COL <span class="hljs-title">co</span><span class="hljs-params">(x,y,z,h)</span></span>;    TRI* tr = &amp;co;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;三角锥的体积: &quot;</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; co.volume() &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;三角锥的表面积: &quot;</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; tr-&gt;area() &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面向对象（二) —— 继承</title>
    <link href="/cpp-opp2/"/>
    <url>/cpp-opp2/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：C++面向对象之继承，继承实例、覆盖、多继承与虚继承、基类派生类对象兼容性赋值。</p><a id="more"></a><hr><blockquote><p>代码全部运行于VS2019</p><p>为简化考虑，部分源码省略了<code>#include&lt;iostream&gt;</code>以及<code>using namespace std</code>。</p><p>博客后续会持续更新补充。</p></blockquote><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><blockquote><p>类的基本思想是数据抽象( data abstraction) 和封装(encapsulation)。 数据抽象是一种依赖于接口 (interface) 和 实现 (implementation) 分离的编程(以及设计)技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。</p><p>封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。</p><p>面向对象程序设计(object oriented programming)的核心思想是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</p><p>—— 《C++ Primer 第五版》</p></blockquote><h2 id="简单的继承"><a href="#简单的继承" class="headerlink" title="简单的继承"></a>简单的继承</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    Animal() :name(<span class="hljs-string">&quot;&quot;</span>), age(<span class="hljs-number">0</span>), sex(<span class="hljs-literal">true</span>) &#123;&#125;    Animal(<span class="hljs-built_in">string</span> name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">bool</span> sex) :        name(name), age(age), sex(sex) &#123;&#125;    ~Animal() &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;,age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="hljs-string">&quot;, sex: &quot;</span>            &lt;&lt; (sex ? <span class="hljs-string">&quot;male&quot;</span> : <span class="hljs-string">&quot;female&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> message;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">string</span> name;    <span class="hljs-keyword">int</span> age;    <span class="hljs-keyword">bool</span> sex;&#125;;<span class="hljs-comment">//静态变量赋值</span><span class="hljs-built_in">string</span> Animal::message = <span class="hljs-string">&quot;on Earth&quot;</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> :</span><span class="hljs-keyword">public</span> Animal&#123;<span class="hljs-keyword">public</span>:    Cat() :Animal(), lovething(<span class="hljs-string">&quot;&quot;</span>) &#123;&#125;    Cat(<span class="hljs-built_in">string</span> name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">bool</span> sex, <span class="hljs-built_in">string</span> lthing) :        Animal(name, age, sex), lovething(lthing) &#123;&#125;    ~Cat() &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;meow~&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">string</span> lovething;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">Animal <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;Bob&quot;</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">true</span>)</span></span>;    a.showInfo();                   <span class="hljs-comment">//name: Bob,age: 3, sex: male</span>    <span class="hljs-built_in">cout</span> &lt;&lt; a.message &lt;&lt; <span class="hljs-built_in">endl</span>;      <span class="hljs-comment">//on Earth</span>    <span class="hljs-function">Cat <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;kelly&quot;</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">false</span>,<span class="hljs-string">&quot;fish&quot;</span>)</span></span>;      b.showInfo();                   <span class="hljs-comment">//name: kelly,age: 7, sex: female</span>    b.makeSound();                  <span class="hljs-comment">//meow~</span>    <span class="hljs-built_in">cout</span> &lt;&lt; b.message &lt;&lt; <span class="hljs-built_in">endl</span>;      <span class="hljs-comment">//on Earth</span>    a.message = <span class="hljs-string">&quot;Earth&quot;</span>;                <span class="hljs-built_in">cout</span> &lt;&lt; b.message &lt;&lt; <span class="hljs-built_in">endl</span>;      <span class="hljs-comment">//Earth</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>继承是一种将C++的类联系在一起构成一种层级关系。在层次关系的底部的是<strong>基类</strong>(base class)，而其他的类都是直接或者间接地从基类继承而来，这些由继承而得到的类称为<strong>派生类</strong>(derived class)。<strong>基类负责定义在层次关系中所有类都共同拥有的成员，而派生类则额外定义自己特有的成员。</strong></p><p>另外，基类希望它的某些函数派生类各自定义适合自身的版本，此时就会将这些函数声明为<strong>虚函数</strong>(virtual function)。</p><p>例如定义一个基类动物类Animal，定义一个派生类Cat。Animal中包含一些动物拥有的特性，而Cat则是猫这种动物的特性，Cat就是Animal中的一种。是Cat <strong>is</strong> Animal的这种关系。</p><p>可以说Cat继承于Animal，或者说从Animal派生Cat。</p><p>此外也称Animal基类为<strong>父类</strong>，Cat派生类为<strong>子类</strong>。</p><ul><li>继承的形式：派生类后接<code>:</code>，然后接类派生列表，即 <code>继承权限 类名</code>，要继承多个就使用逗号分隔。</li><li>如果基类定义了一个<strong>静态成员</strong>，<strong>则在这个继承体系之中只存在这这个成员的**</strong>唯一实例**。</li><li>在派生类中基类的私有数据成员要使用基类的构造函数来初始化。</li><li><strong>友元不能被继承</strong>。</li></ul><h2 id="派生类对象的内存空间"><a href="#派生类对象的内存空间" class="headerlink" title="派生类对象的内存空间"></a>派生类对象的内存空间</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> a;    <span class="hljs-keyword">int</span> b;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>:</span><span class="hljs-keyword">public</span> A&#123;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> c;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    A a;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(a) &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//8</span>    B b;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(b) &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//12</span>&#125;</code></pre><p>派生类对象之中包含着基类对象，且基类对象存储位置位于派生类对象新增的成员变量之前。就相当于基类对象是头部。</p><p><strong>派生类对象的大小 = 基类对象成员大小 + 派生类对象自己成员变量的大小。</strong></p><h2 id="派生类继承的访问权限"><a href="#派生类继承的访问权限" class="headerlink" title="派生类继承的访问权限"></a>派生类继承的访问权限</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    Animal() :age(<span class="hljs-number">0</span>)&#123;&#125;    Animal(<span class="hljs-keyword">int</span> age) : age(age)&#123;&#125;    ~Animal() &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testPbulicFun</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Public function&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testProtecteFun</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Protected function&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testPrivateFun</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Private function&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-comment">//公有继承</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> :</span><span class="hljs-keyword">public</span> Animal&#123;<span class="hljs-keyword">public</span>:    Cat() :Animal() &#123;&#125;    Cat(<span class="hljs-keyword">int</span> age) :Animal(age) &#123;&#125;    ~Cat() &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testPublicInher</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>-&gt;testPbulicFun();        <span class="hljs-keyword">this</span>-&gt;testProtecteFun();    <span class="hljs-comment">//正确，可在类内访问基类的保护成员</span>        <span class="hljs-comment">//this-&gt;testPrivateFun();   //错误，无法访问基类的私有成员</span>    &#125;&#125;;<span class="hljs-comment">//保护继承</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> :</span><span class="hljs-keyword">protected</span> Animal&#123;<span class="hljs-keyword">public</span>:    Dog() :Animal() &#123;&#125;    Dog(<span class="hljs-keyword">int</span> age):Animal(age) &#123;&#125;    ~Dog() &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testProtecteInher</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>-&gt;testPbulicFun();      <span class="hljs-comment">//正确，可在类内访问基类的共有成员</span>        <span class="hljs-keyword">this</span>-&gt;testProtecteFun();    <span class="hljs-comment">//正确，可在类内访问基类的保护成员</span>        <span class="hljs-comment">//this-&gt;testPrivateFun();   //错误，无法访问基类的私有成员</span>    &#125;&#125;;<span class="hljs-comment">//私有继承</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bull</span> :</span><span class="hljs-keyword">private</span> Animal&#123;<span class="hljs-keyword">public</span>:    Bull() :Animal() &#123;&#125;    Bull(<span class="hljs-keyword">int</span> age) :Animal(age) &#123;&#125;    ~Bull() &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testPrivateInher</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>-&gt;testPbulicFun();      <span class="hljs-comment">//正确，可在类内访问基类的共有成员</span>        <span class="hljs-keyword">this</span>-&gt;testProtecteFun();    <span class="hljs-comment">//正确，可在类内访问基类的保护成员</span>        <span class="hljs-comment">//this-&gt;testPrivateFun();   //错误，无法访问基类的私有成员</span>    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">/*----------------------------基类------------------------------*/</span>    <span class="hljs-function">Animal <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;    a.testPbulicFun();              <span class="hljs-comment">//正确，可以在类外访问类的公有成员</span>    <span class="hljs-comment">//a.testProtecteFun();          //错误，无法在类外访问类的保护成员</span>    <span class="hljs-comment">//a.testPrivateFun();           //错误，无法在类外访问类的私有成员</span>    <span class="hljs-comment">/*-------------------------公有继承类---------------------------*/</span>    <span class="hljs-function">Cat <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;      b.testPublicInher();    b.testPbulicFun();              <span class="hljs-comment">//正确，可以在类外访问基类的公有成员</span>    <span class="hljs-comment">//b.testProtecteFun();          //错误，无法在类外访问基类的保护成员</span>    <span class="hljs-comment">//b.testPrivateFun();           //错误，无法在类外访问基类的私有成员</span>    <span class="hljs-comment">/*-------------------------保护继承类---------------------------*/</span>    <span class="hljs-function">Dog <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;    c.testProtecteInher();    <span class="hljs-comment">//c.testPbulicFun();            //错误，无法在类外访问基类的公有成员</span>    <span class="hljs-comment">//c.testProtecteFun();          //错误，无法在类外访问基类的保护成员</span>    <span class="hljs-comment">//c.testPrivateFun();           //错误，无法在类外访问基类的私有成员</span>    <span class="hljs-comment">/*-------------------------私有继承类---------------------------*/</span>    <span class="hljs-function">Bull <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;    d.testPrivateInher();    <span class="hljs-comment">//d.testPbulicFun();            //错误，无法在类外访问基类的公有成员</span>    <span class="hljs-comment">//d.testProtecteFun();          //错误，无法在类外访问基类的保护成员</span>    <span class="hljs-comment">//d.testPrivateFun();           //错误，无法在类外访问基类的私有成员</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><img src="/cpp-opp2/inher.png"></p><ul><li><p>继承有public、protected和private三种继承方式.</p></li><li><p>只要是基类中的private成员，无论如何继承基类，派生类都无法访问。</p></li><li><p>公有(public)继承，基类的访问权限不变。</p></li><li><p>保护(protected)继承，基类除了private成员，其余访问权限都变成protected。</p></li><li><p>私有(private)继承，基类除了private成员，其余访问权限都变成private。</p></li><li><p>私有的成员一直都是无法访问的，在派生类中想给基类成员赋值需要通过父类构造函数来完成。</p></li></ul><h2 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:Parent()&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Parent()&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">this</span>-&gt;a = <span class="hljs-number">0</span>;&#125;Parent(<span class="hljs-keyword">int</span> a)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Parent(int)&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">this</span>-&gt;a = a;&#125;~Parent()&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;~Parent()&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">private</span>:<span class="hljs-keyword">int</span> a;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>:</span><span class="hljs-keyword">public</span> Parent&#123;<span class="hljs-keyword">public</span>:Child()&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Child()&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">this</span>-&gt;b = <span class="hljs-number">0</span>;&#125;Child(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b):Parent(a)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Child(int,int)&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">this</span>-&gt;b = b;&#125;~Child()&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;~Child()&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">private</span>:<span class="hljs-keyword">int</span> b;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;&#123;Child ch;&#125;&#123;<span class="hljs-function">Child <span class="hljs-title">ch1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;&#125;&#125;</code></pre><p>执行结果</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Parent</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-title">Child</span><span class="hljs-params">()</span></span>~Child()~Parent()<span class="hljs-function"><span class="hljs-title">Parent</span><span class="hljs-params">(int)</span></span><span class="hljs-function"><span class="hljs-title">Child</span><span class="hljs-params">(int,int)</span></span>~Child()~Parent()</code></pre><ul><li>派生类的构造函数在构造对象时一定会调用基类的构造函数。即使是无参构造也会调用父类的构造函数。</li><li>执行构造函数时，会先调用基类的构造函数，父类还有父类就继续向上。</li><li>当需要调用基类的有参构造函数时，需要写在初始化列表的位置！</li><li>析构函数则是先触发派生类的，再触发基类的，辈分由小到大式的触发。</li></ul><h2 id="覆盖-——-派生类成员与基类成员重名"><a href="#覆盖-——-派生类成员与基类成员重名" class="headerlink" title="覆盖 —— 派生类成员与基类成员重名"></a>覆盖 —— 派生类成员与基类成员重名</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:Parent() :a(<span class="hljs-number">0</span>) &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Parent func&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">public</span>:<span class="hljs-keyword">int</span> a;<span class="hljs-comment">//公有权限</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>:</span><span class="hljs-keyword">public</span> Parent&#123;<span class="hljs-keyword">public</span>:Child():a(<span class="hljs-number">0</span>) &#123;&#125;<span class="hljs-comment">//与基类函数同名</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Child func&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myFunc</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;a = <span class="hljs-number">10</span>;Parent::a = <span class="hljs-number">100</span>;func();Parent::func();&#125;<span class="hljs-keyword">private</span>:<span class="hljs-keyword">int</span> a;<span class="hljs-comment">//与基类成员同名</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;Child ch;ch.func();ch.myFunc();&#125;</code></pre><p>执行结果：</p><p>Child func<br>Child func<br>Parent func</p><ul><li>当派生类中的成员与基类成员同名时，这就是<strong>覆盖</strong>。</li><li>当在派生类中访问这一类成员时，默认访问的是派生类自己定义的成员。想要访问基类定义的同名成员时需要加上类名以及作用域符号<code>::</code>来区分。</li><li>基类派生类的同名函数<strong>没有重载关系</strong>。</li></ul><h2 id="多继承与虚继承"><a href="#多继承与虚继承" class="headerlink" title="多继承与虚继承"></a>多继承与虚继承</h2><p>多继承是C++的特性，其他主流语言都没有。</p><p>所谓多继承就是一个类同时继承两个类。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SofaBed</span>:</span><span class="hljs-keyword">public</span> sofa,<span class="hljs-keyword">public</span> bed&#123;&#125;</code></pre><p>但是多继承在特殊情况下会带来一些问题。比如上述例子中的<code>sofa</code>与<code>bed</code>都是继承于同一个基类<code>wood</code>，那基类<code>wood</code>所有的东西比如材质<code>m</code>，派生类<code>sofa</code>与<code>bed</code>都会用这份材质<code>m</code>，那么多继承的<code>sofabed</code>就会有两份<code>m</code>了。</p><p>但是按照逻辑来说，这份材质还只应该出现一次的，于是就有了<strong>虚继承</strong>。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wood</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">int</span> m;Wood() &#123; m = <span class="hljs-number">0</span>; &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sofa</span> :</span><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Wood&#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sit</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;坐&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bed</span> :</span><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Wood&#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;睡觉&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SofaBed</span> :</span><span class="hljs-keyword">public</span> Sofa, <span class="hljs-keyword">public</span> Bed&#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sitSleep</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;坐着睡觉&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;Wood z;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(z) &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//4</span>Sofa a;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(a) &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//8</span>SofaBed b;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(b) &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//12</span>    Desk d;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(d) &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//4</span>    b.m = <span class="hljs-number">2</span>;b.sitSleep();&#125;</code></pre><ul><li>虚拟继承是多重继承中特有的概念，虚拟继承是为了解决多重继承而出现的。</li><li>不建议使用，结构负责，且内存开销比较大。</li><li>此外上面的内存占据大小也没看明白，暂时留个疑问？👍</li></ul><h2 id="子类与父类对象之间的关系–兼容性赋值原则"><a href="#子类与父类对象之间的关系–兼容性赋值原则" class="headerlink" title="子类与父类对象之间的关系–兼容性赋值原则"></a>子类与父类对象之间的关系–兼容性赋值原则</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:Father() &#123; num = <span class="hljs-number">0</span>; &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;hello\n&quot;</span>; &#125;<span class="hljs-keyword">private</span>:<span class="hljs-keyword">int</span> num;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> :</span><span class="hljs-keyword">public</span> Father&#123;<span class="hljs-keyword">public</span>:Son() &#123; d_num = <span class="hljs-number">0</span>; &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">s_info</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;hi\n&quot;</span>; &#125;<span class="hljs-keyword">private</span>:<span class="hljs-keyword">double</span> d_num;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;Son s;<span class="hljs-comment">//1.派生类对象可以当基类对象使用，因为派生类对象拥有基类对象的全部方法。</span>s.info();<span class="hljs-comment">//2.派生类对象可以直接赋值给基类对象</span>Father f;f = s;f.info();<span class="hljs-comment">//3.派生类对象可以直接初始化基类对象</span><span class="hljs-function">Father <span class="hljs-title">f1</span><span class="hljs-params">(s)</span></span>;f1.info();<span class="hljs-comment">//4.基类指针可以直接指向派生类对象</span>Father* f2 = &amp;s;f2-&gt;info();<span class="hljs-comment">//5.基类引用可以直接引用派生类对象</span>Father&amp; f3 = s;f3.info();&#125;</code></pre><p><strong>当继承方式是public继承时：</strong></p><ol><li>子类对象可以当作父类对象使用。</li><li>子类对象可以直接赋值给父类对象。</li><li>子类对象可以直接初始化父类对象</li><li>父类指针可以直接指向子类对象</li><li>父类引用可以直接引用子类对象。</li></ol><blockquote><p>一个原因，根据父类与子类的内存分布决定，父类的结构子类有，而子类的结构父类只有一部分。子类的内存布局可以满足父类指针的所有需求.</p></blockquote><p><strong>而当继承方式是<code>protected</code>或者<code>private</code>时，上述五条规则均不适用！</strong></p><h3 id="基类派生类指针强制转换"><a href="#基类派生类指针强制转换" class="headerlink" title="基类派生类指针强制转换"></a>基类派生类指针强制转换</h3><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;Son s;Father* f_p = &amp;s;<span class="hljs-comment">//public继承方式下，基类指针可以指向派生类对象。</span>f_p-&gt;info();<span class="hljs-comment">//ok</span><span class="hljs-comment">//f_p-&gt;s_info();//error</span><span class="hljs-comment">//这个基类指针只能访问基类里有的成员而不能访问派生类独有的成员</span>Son* s_p = (Son*)f_p;<span class="hljs-comment">//强制类型转换</span>s_p-&gt;info();<span class="hljs-comment">//ok</span>s_p-&gt;s_info();<span class="hljs-comment">//ok</span>Father f;Son* s1 = (Son*)(&amp;f);s1-&gt;info();<span class="hljs-comment">//ok</span>s1-&gt;s_info();<span class="hljs-comment">//ok</span>    <span class="hljs-comment">//留存疑问？？这样的方式对于任意类都可以吗？还是我这个类太简单了？</span>&#125;</code></pre><ul><li>public继承方式下，基类指针可以指向派生类对象，但是该指针只能访问基类里有的方法和成员而不能访问派生类独有的方法和成员。</li></ul><blockquote><p>参考链接：<a href="https://mp.weixin.qq.com/s/Wa9MLte3g7H4E6myAwxhzA">C++ 一篇搞懂继承的常见特性</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面向对象练习（二）—— string类型的简单实现（一）</title>
    <link href="/cpp-opp1-prc2/"/>
    <url>/cpp-opp1-prc2/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：C++面向对象练习：string类型的构造、析构函数实现。</p><a id="more"></a><hr><blockquote><p>代码全部运行于VS2019</p><p>博客后续会持续更新补充。</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>已知 类String的原型为： </p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:  String(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str = <span class="hljs-literal">NULL</span>);<span class="hljs-comment">// 普通构造函数</span>  String(<span class="hljs-keyword">const</span> String &amp;other);    <span class="hljs-comment">// 拷贝构造函数</span>  ~String(<span class="hljs-keyword">void</span>);    <span class="hljs-comment">// 析构函数</span>  String &amp; operate =(<span class="hljs-keyword">const</span> String &amp;other);<span class="hljs-comment">// 赋值函数</span><span class="hljs-keyword">private</span>:  <span class="hljs-keyword">char</span> *m_data;<span class="hljs-comment">// 用于保存字符串</span>&#125;;</code></pre><p>请编写String的上述4个函数。</p></blockquote><pre><code class="hljs c++">String::String(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;默认构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">this</span>-&gt;m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-string">&#x27;\0&#x27;</span>];    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">int</span> length = <span class="hljs-built_in">strlen</span>(str);        <span class="hljs-keyword">this</span>-&gt;m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[length + <span class="hljs-number">1</span>];        strcpy_s(<span class="hljs-keyword">this</span>-&gt;m_data, length+<span class="hljs-number">1</span>, str);    &#125;&#125;String::String(<span class="hljs-keyword">const</span> String&amp; other)&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">int</span> length = <span class="hljs-built_in">strlen</span>(other.m_data);    <span class="hljs-keyword">this</span>-&gt;m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[length + <span class="hljs-number">1</span>];    strcpy_s(<span class="hljs-keyword">this</span>-&gt;m_data, length + <span class="hljs-number">1</span>, other.m_data);&#125;String::~String()&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">delete</span>[] m_data;    m_data = <span class="hljs-literal">nullptr</span>;&#125;String&amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; other)&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;重载=赋值&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) <span class="hljs-comment">//检查自赋值</span>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_data)   <span class="hljs-comment">//释放原有的内存资源</span>        <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;m_data;    <span class="hljs-keyword">int</span> length = <span class="hljs-built_in">strlen</span>(other.m_data);    <span class="hljs-keyword">this</span>-&gt;m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[length + <span class="hljs-number">1</span>];    strcpy_s(<span class="hljs-keyword">this</span>-&gt;m_data, length + <span class="hljs-number">1</span>, other.m_data);    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;</code></pre><p>执行：</p><pre><code class="hljs c++"><span class="hljs-comment">//为了测试额外添加的一个成员函数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">String::print</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_data &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">String <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;    a.print();    <span class="hljs-function">String <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>;    b.print();    String c;    c = a;    c.print();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>执行结果</p><pre><code class="hljs fix"><span class="hljs-attr">默认构造函数</span><span class="hljs-attr">hello</span><span class="hljs-attr">拷贝构造函数</span><span class="hljs-attr">hello</span><span class="hljs-attr">默认构造函数</span><span class="hljs-attr">重载</span>=<span class="hljs-string">赋值</span><span class="hljs-string">hello</span><span class="hljs-string">析构函数</span><span class="hljs-string">析构函数</span><span class="hljs-string">析构函数</span></code></pre><ul><li>当函数参数有默认值的时候，并且函数的声明与定义分开的时候，默认参数只能出现在其中的一个地方。参考链接·：<a href="https://www.cnblogs.com/happybirthdaytoyou/p/10358137.html">C++函数默认参数</a></li><li>使用strlen(const char* str)求得字符串长度是从头截至到<code>\0</code>结束字符，但是不包括<code>\0</code>。</li><li>而在给字符串开辟空间时要注意额外加上<code>\0</code>的空间！</li></ul><blockquote><p>参考链接：</p><p><a href="https://www.cnblogs.com/jwyue0520/archive/2012/12/03/2800160.html">C++笔试题 String类的实现</a></p><p><a href="https://blog.csdn.net/caoshangpa/article/details/51530482">C++笔试题之String类的实现</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面向对象练习（一）—— 各种函数执行顺序</title>
    <link href="/cpp-opp1-prc1/"/>
    <url>/cpp-opp1-prc1/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：C++面向对象练习：构造函数、拷贝构造函数、重载赋值运算符以及析构函数的执行顺序。</p><a id="more"></a><hr><blockquote><p>代码全部运行于VS2019</p><p>博客后续会持续更新补充。</p></blockquote><h2 id="各个函数执行顺序"><a href="#各个函数执行顺序" class="headerlink" title="各个函数执行顺序"></a>各个函数执行顺序</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    Dog()     &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;默认构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    Dog(<span class="hljs-keyword">int</span> age) :age(age)     &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;有参构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    Dog(<span class="hljs-keyword">const</span> Dog&amp; dog) :age(dog.age)     &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    Dog&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Dog&amp; dog)    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;拷贝赋值运算&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;dog)<span class="hljs-comment">//自赋值</span>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;        <span class="hljs-keyword">this</span>-&gt;age = dog.age;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    ~Dog()     &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;析构函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;--  &quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;age &lt;&lt;<span class="hljs-string">&quot;  --&quot;</span>&lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> age;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test0</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;函数test0()开始执行&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    Dog d0;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;函数test0()结束执行&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">(Dog dd)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;函数test1()开始执行&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    dd.show();    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;函数test1()结束执行&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function">Dog <span class="hljs-title">test2</span><span class="hljs-params">(Dog&amp; dd)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;函数test2()开始执行&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    Dog tmp = dd;    tmp.show();    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;函数test2()结束执行&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> tmp;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;主函数main()开始执行&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    test0();    <span class="hljs-function">Dog <span class="hljs-title">d1</span><span class="hljs-params">(<span class="hljs-number">12</span>)</span></span>;    Dog d2 = d1;    Dog d3;    d3 = d1;        test1(d3);    Dog d4;    d4 = test2(d1);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;主函数main()结束执行&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>执行结果如下：</p><ul><li><p>主函数main()开始执行</p></li><li><p>函数test0()开始执行</p></li><li><p>默认构造函数</p></li><li><p>函数test0()结束执行</p></li><li><p>析构函数</p></li><li><p>有参构造函数</p></li><li><p>拷贝构造函数</p></li><li><p>默认构造函数</p></li><li><p>拷贝赋值运算</p></li><li><p>拷贝构造函数</p></li><li><p>函数test1()开始执行</p></li><li><p>–  12  –</p></li><li><p>函数test1()结束执行</p></li><li><p>析构函数</p></li><li><p>默认构造函数</p></li><li><p>函数test2()开始执行</p></li><li><p>拷贝构造函数</p></li><li><p>–  12  –</p></li><li><p>函数test2()结束执行</p></li><li><p><font color="red">拷贝构造函数</font></p></li><li><p><font color="red">析构函数</font></p></li><li><p>拷贝赋值运算</p></li><li><p>主函数main()结束执行</p></li><li><p>析构函数</p></li><li><p>析构函数</p></li><li><p>析构函数</p></li><li><p>析构函数</p></li></ul><p><code>d4 = test2(d1)</code>在函数值返回时注意！</p><pre><code class="hljs c++"><span class="hljs-function">Dog <span class="hljs-title">test3</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;函数test3()开始执行&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-function">Dog <span class="hljs-title">tmp</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;函数test3()结束执行&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> tmp;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;主函数main()开始执行&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    Dog d5 = test3();        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;--------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    test3();    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;主函数main()结束执行&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>结果为：</p><ul><li>主函数main()开始执行</li><li>函数test3()开始执行</li><li>有参构造函数</li><li>函数test3()结束执行</li><li>拷贝构造函数</li><li>析构函数</li><li><font color="red"><code>--------</code></font></li><li>函数test3()开始执行</li><li>有参构造函数</li><li>函数test3()结束执行</li><li>拷贝构造函数</li><li>析构函数</li><li>析构函数</li><li>主函数main()结束执行</li><li>析构函数</li></ul><p><strong>当函数返回一个对象的时候，所作的操作为<code>匿名对象 = return tmp</code>，这样就会执行拷贝构造函数，然后tmp析构。</strong></p><p><strong>而若是函数返回的匿名对象没有值进行接受的话，匿名对象会立刻进行析构。而若是有值进行接受的话，匿名对象就会转正，不会触发任何函数。</strong></p><h2 id="C-面向对象练习"><a href="#C-面向对象练习" class="headerlink" title="C++面向对象练习"></a>C++面向对象练习</h2><blockquote><p>试定义一个处理学生信息的类Student。该类包含学号、成绩和姓名等数据成员( 学号不能相同)以及<br>若干成员函数，另外定义全局函数max),返回n个学生成绩最高者。</p><p>具体要求如下:</p><p>(1)私有数据成员</p><p>int num,score; num存放学号，score 存放成绩</p><p>char name[9]; name 存放学生的姓名</p><p>(2)公有成员函数</p><p>构造函数:将学号、成绩设置为0，姓名设置为空</p><p>void Set(int id,char *na,int sc );为数据成员赋值。</p><p>int get_ score();返 回学生成绩。</p><p>void print();输出学生的学号、姓名和成绩。</p><p>(3) Student max(Student *,int n);全局函数，求得并返回s所指向的n个学生中成绩最高者。</p><p>int check_num(Student str[],int n,int num);检查学号是否已经在str中存在返回1,否则返回0。</p><p>(4)在主函数中完成对该类的测试，主函数中定义一个长度为3的Student类的对象数组s,依次键入学号、成绩、姓名;注意，在输入每-一个学生的信息后，要判断所输入的学号是否已存在，如果存在，则要求重新输入该学生的信息。最后调用全局函数max(,得到成绩最高的学生信息并输出。</p></blockquote><p>参考链接： <a href="https://blog.csdn.net/qq_36426650/article/details/84647167">C++面向对象程序设计50道编程题（第21题）</a></p><pre><code class="hljs c++"><span class="hljs-comment">/*测试环境： VS2019*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    Student();    ~Student();    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">char</span>* na, <span class="hljs-keyword">int</span> sc)</span></span>; <span class="hljs-comment">//为数据成员赋值</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_score</span><span class="hljs-params">()</span></span>;                    <span class="hljs-comment">//返回学生成绩</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_num</span><span class="hljs-params">()</span></span>;                      <span class="hljs-comment">//返回学生学号</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;                       <span class="hljs-comment">//输出学生的学号、姓名、成绩</span><span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> num;        <span class="hljs-comment">//学号</span>    <span class="hljs-keyword">int</span> score;      <span class="hljs-comment">//成绩</span>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">9</span>];   <span class="hljs-comment">//姓名</span>&#125;;<span class="hljs-function">Student <span class="hljs-title">max</span><span class="hljs-params">(Student*, <span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-comment">//求得并返回n个学生中成绩最高的</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">check_num</span><span class="hljs-params">(Student stu[], <span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> num)</span></span>;<span class="hljs-comment">//检查学号是否已经在stu中</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Student stu[<span class="hljs-number">3</span>];    <span class="hljs-keyword">int</span> input_num;    <span class="hljs-keyword">int</span> input_score;    <span class="hljs-keyword">char</span> input_name[<span class="hljs-number">9</span>];    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入学生的学号&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">cin</span> &gt;&gt; input_num;        <span class="hljs-keyword">if</span> (check_num(stu, i, input_num) == <span class="hljs-number">1</span>)        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;已经存在，请重新输入&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">continue</span>;        &#125;                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入学生的成绩&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">cin</span> &gt;&gt; input_score;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入学生的姓名&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">cin</span> &gt;&gt; input_name;        stu[i].Set(input_num, input_name, input_score);        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;信息录入成功&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        i++;        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">break</span>;     &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;学生信息如下：&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)    &#123;        stu[i].print();    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;成绩最高的学生信息如下：&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    max(stu, <span class="hljs-number">3</span>).print();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;Student::Student()&#123;    <span class="hljs-keyword">this</span>-&gt;num = <span class="hljs-number">0</span>;    <span class="hljs-keyword">this</span>-&gt;score = <span class="hljs-number">0</span>;    strcpy_s(<span class="hljs-keyword">this</span>-&gt;name,<span class="hljs-string">&quot;&quot;</span>);&#125;Student::~Student()&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Student::Set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">char</span>* na, <span class="hljs-keyword">int</span> sc)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">this</span>-&gt;num = id;    <span class="hljs-keyword">this</span>-&gt;score = sc;    strcpy_s(<span class="hljs-keyword">this</span>-&gt;name, na);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Student::get_score</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;score;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Student::get_num</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;num;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Student::print</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name &lt;&lt; <span class="hljs-string">&quot;: id:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;num        &lt;&lt; <span class="hljs-string">&quot;, score: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;score &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function">Student <span class="hljs-title">max</span><span class="hljs-params">(Student* stu, <span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> max_score = stu[<span class="hljs-number">0</span>].get_score();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)    &#123;        <span class="hljs-keyword">if</span> (max_score &lt; stu[i].get_score())        &#123;            max_score = stu[i].get_score();            max = i;        &#125;          &#125;    <span class="hljs-keyword">return</span> stu[max];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">check_num</span><span class="hljs-params">(Student stu[], <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> num)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-keyword">if</span> (stu[i].get_num() == num)        &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面向对象（一) —— C++类的基础知识</title>
    <link href="/cpp-opp1/"/>
    <url>/cpp-opp1/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：C++类的基础知识，包括构造函数、初始值列表、拷贝构造函数、重载赋值运算符、深拷贝与浅拷贝、static、const、new以及友元。</p><a id="more"></a><hr><blockquote><p>代码全部运行于VS2019</p><p>为简化考虑，部分源码省略了<code>#include&lt;iostream&gt;</code>以及<code>using namespace std</code>。</p><p>博客后续会持续更新补充。</p></blockquote><h2 id="C-类的demo"><a href="#C-类的demo" class="headerlink" title="C++类的demo"></a>C++类的demo</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Sex</span>&#123;</span>MALE=<span class="hljs-number">0</span>,FEMALE&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    Cat() :name(<span class="hljs-string">&quot;unname&quot;</span>), age(<span class="hljs-number">0</span>),sex(Sex::MALE)&#123;&#125;        Cat(<span class="hljs-built_in">string</span> name, <span class="hljs-keyword">int</span> age, Sex sex) :        name(name), age(age), sex(sex) &#123;&#125;    <span class="hljs-comment">//拷贝构造</span>    Cat(<span class="hljs-keyword">const</span> Cat&amp; other);    <span class="hljs-comment">//拷贝赋值运算符重载</span>    Cat&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Cat&amp; other);    ~Cat() &#123;&#125;    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>;    <span class="hljs-function">Sex <span class="hljs-title">getSex</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">getPetOwner</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrtOwner</span><span class="hljs-params">(<span class="hljs-built_in">string</span> owner)</span></span>;    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">string</span> name;    <span class="hljs-keyword">int</span> age;    Sex sex;    <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> petOwner;&#125;;<span class="hljs-built_in">string</span> Cat::petOwner = <span class="hljs-string">&quot;Colourso&quot;</span>;Cat::Cat(<span class="hljs-keyword">const</span> Cat&amp; other)&#123;    <span class="hljs-keyword">this</span>-&gt;name = other.name;    <span class="hljs-keyword">this</span>-&gt;age = other.age;    <span class="hljs-keyword">this</span>-&gt;sex = other.sex;&#125;Cat&amp; Cat::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Cat&amp; other)&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;other)<span class="hljs-comment">//自赋值</span>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;        <span class="hljs-keyword">this</span>-&gt;name = other.name;    <span class="hljs-keyword">this</span>-&gt;age = other.age;    <span class="hljs-keyword">this</span>-&gt;sex = other.sex;    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">Cat::getName</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;name;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Cat::setName</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">this</span>-&gt;name = str;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Cat::getAge</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;age;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Cat::setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">this</span>-&gt;age = num;&#125;<span class="hljs-function">Sex <span class="hljs-title">Cat::getSex</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;sex;&#125;<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">Cat::getPetOwner</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> petOwner;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Cat::setPrtOwner</span><span class="hljs-params">(<span class="hljs-built_in">string</span> owner)</span></span><span class="hljs-function"></span>&#123;    petOwner = owner;&#125;<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">Cat::toString</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">stringstream</span> ss;    ss &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span>;    ss &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name;    ss &lt;&lt; <span class="hljs-string">&quot;,age: &quot;</span>;    ss &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age;    ss &lt;&lt; <span class="hljs-string">&quot;,sex: &quot;</span>;    ss &lt;&lt; (<span class="hljs-keyword">this</span>-&gt;sex ? <span class="hljs-string">&quot;male&quot;</span> : <span class="hljs-string">&quot;female&quot;</span>);    ss &lt;&lt; <span class="hljs-string">&quot;. Owner: &quot;</span>;    ss &lt;&lt; petOwner;    <span class="hljs-keyword">return</span> ss.str();&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Cat* a = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;Kelly&quot;</span>, <span class="hljs-number">4</span>, Sex::FEMALE);    <span class="hljs-built_in">cout</span> &lt;&lt; a-&gt;toString()&lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-function">Cat <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;Bob&quot;</span>,<span class="hljs-number">3</span>,Sex::MALE)</span></span>;    <span class="hljs-built_in">cout</span> &lt;&lt; b.getName()&lt;&lt;<span class="hljs-string">&quot; love his owner: &quot;</span>&lt;&lt;Cat::getPetOwner()&lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">if</span> (b.getAge() &lt; a-&gt;getAge())        b.setAge(a-&gt;getAge() + <span class="hljs-number">2</span>);    <span class="hljs-built_in">cout</span> &lt;&lt; b.toString() &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">delete</span> a;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr><h2 id="class与struct"><a href="#class与struct" class="headerlink" title="class与struct"></a>class与struct</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    Dog(<span class="hljs-built_in">string</span> name)     &#123;        <span class="hljs-keyword">this</span>-&gt;name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;Dog &quot;</span>&lt;&lt; <span class="hljs-keyword">this</span>-&gt;name &lt;&lt;<span class="hljs-string">&quot; walk.&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">string</span> name;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Cat</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-built_in">string</span> name;    Cat(<span class="hljs-built_in">string</span> name)    &#123;        <span class="hljs-keyword">this</span>-&gt;name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Cat &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name &lt;&lt; <span class="hljs-string">&quot; walk.&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">Dog <span class="hljs-title">wang</span><span class="hljs-params">(<span class="hljs-string">&quot;meow&quot;</span>)</span></span>;    wang.walk();<span class="hljs-comment">//Dog meow walk.</span>    <span class="hljs-function">Cat <span class="hljs-title">hua</span><span class="hljs-params">(<span class="hljs-string">&quot;wang&quot;</span>)</span></span>;    hua.walk();<span class="hljs-comment">//Cat wang walk.</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>如上所示，在C++中，我们可以使用<code>class</code>关键字或者<code>struct</code>关键字进行类的定义。</p><p>两者唯一的区别在于<code>struct</code>与<code>class</code>的默认访问权限不同。</p><ul><li><strong>struct</strong>默认访问权限为public。</li><li><strong>class</strong>默认访问权限为private。</li></ul><h2 id="在类的外部实现类的成员函数——类的分文件编写"><a href="#在类的外部实现类的成员函数——类的分文件编写" class="headerlink" title="在类的外部实现类的成员函数——类的分文件编写"></a>在类的外部实现类的成员函数——类的分文件编写</h2><p><strong>Student.h</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> STUDENT_H__</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STUDENT_H__</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:Student();Student(<span class="hljs-built_in">string</span> name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">bool</span> sex);<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<span class="hljs-keyword">private</span>:<span class="hljs-built_in">string</span> name;<span class="hljs-keyword">int</span> age;<span class="hljs-keyword">bool</span> sex;&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><p><strong>Student.cpp</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Student.h&quot;</span></span>Student::Student()&#123;&#125;Student::Student(<span class="hljs-built_in">string</span> name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">bool</span> sex)&#123;<span class="hljs-keyword">this</span>-&gt;name = name;<span class="hljs-keyword">this</span>-&gt;age = age;<span class="hljs-keyword">this</span>-&gt;sex = sex;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Student::show</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name &lt;&lt; <span class="hljs-string">&quot;: age:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age &lt;&lt; <span class="hljs-string">&quot;, sex:&quot;</span> &lt;&lt; (<span class="hljs-keyword">this</span>-&gt;sex ? <span class="hljs-string">&quot;male&quot;</span> : <span class="hljs-string">&quot;female&quot;</span>);&#125;</code></pre><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">string</span> name;<span class="hljs-keyword">protected</span>:    <span class="hljs-keyword">bool</span> sex;<span class="hljs-keyword">public</span>:    Student()&#123;&#125;    Student(<span class="hljs-built_in">string</span> name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">bool</span> sex)    &#123;        <span class="hljs-keyword">this</span>-&gt;name = name;        <span class="hljs-keyword">this</span>-&gt;age = age;        <span class="hljs-keyword">this</span>-&gt;sex = sex;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowMessage</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name &lt;&lt; <span class="hljs-string">&quot;: age:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age &lt;&lt; <span class="hljs-string">&quot;,sex:&quot;</span> &lt;&lt; (<span class="hljs-keyword">this</span>-&gt;sex ? <span class="hljs-string">&quot;男&quot;</span>:<span class="hljs-string">&quot;女&quot;</span> ) &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> age;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">Student <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-literal">true</span>)</span></span>;    <span class="hljs-built_in">cout</span> &lt;&lt; s.name &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//小明</span>    <span class="hljs-comment">//cout &lt;&lt; s.age &lt;&lt; endl; //错误：不可访问</span>    s.ShowMessage();<span class="hljs-comment">//小明: age:12,sex:男</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>（如上所示的糟糕编码，只是为了展示类内的访问权限的界限是从一个界限开始到下一个界限截至的，例如public到private之间的内容权限都是public，同时一个<strong>访问说明符</strong>可以出现多次。）</p><ul><li><strong>public</strong>：表示公有，类内类外整个程序内都可以被访问。</li><li><strong>private</strong>：表示私有，只有类的成员函数才可以访问，C++ class的默认访问权限是private。</li><li><strong>protected</strong>：表示保护，平时与private无区别，仅在继承时有区别。</li></ul><h2 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">// 默认构造函数</span>    Student() &#123;&#125;    <span class="hljs-comment">//重载带参构造函数</span>    Student(<span class="hljs-built_in">string</span> name)    &#123;        <span class="hljs-keyword">this</span>-&gt;name = name;    &#125;    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">dis</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;name;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">string</span> name;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperStudent</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//默认构造函数</span>    SuperStudent() &#123;&#125;    <span class="hljs-comment">//带参构造函数</span>    SuperStudent(<span class="hljs-keyword">int</span> age)    &#123;        <span class="hljs-keyword">this</span>-&gt;age = age;    &#125;    <span class="hljs-comment">//构造函数初始值列表</span>    SuperStudent(Student stu,<span class="hljs-keyword">int</span> age) :stu(stu),age(age) &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;stu.dis() &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">private</span>:    Student stu;    <span class="hljs-keyword">int</span> age;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">Student <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;小明&quot;</span>)</span></span>;    <span class="hljs-function">SuperStudent <span class="hljs-title">s1</span><span class="hljs-params">(s, <span class="hljs-number">12</span>)</span></span>;    s1.show();<span class="hljs-comment">//小明12</span>    <span class="hljs-function">SuperStudent <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-number">12</span>)</span></span>;    s2.show();<span class="hljs-comment">//12</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>构造函数是用于<strong>初始化类对象的非static数据成员</strong>，无论何时，只要类的对象被创建，那么就会执行构造函数。</p><ul><li>在形式上，构造函数无返回类型，函数名与类名相同，一般声明为public，且构造函数有（可能为空）参数列表与（可能为空）函数体。</li><li>一个类可包含多个构造函数，和其他重载函数类似，不同构造函数必须在参数数量或参数类型上有所不同。</li><li>一个类有自己的<strong>默认构造函数</strong>，默认构造函数无需任何实参。如果存在类内初始值，则默认构造参数使用它来初始化成员，否则将默认初始化成员（赋予对应类型的默认值，eg，string类型的默认值为空串）。</li><li>同时如果我们没有显示定义构造函数，编译器就会隐式的定义一个。（<strong>只有当没有声明任何构造函数时，编译器才会自动生成默认构造函数</strong>）</li><li><strong>一个类最好定义它的默认构造函数</strong>。（如果我们显示定义了一些其他构造函数，那么建议要加上默认构造函数）P236.</li><li>构造函数不能够被声明成const。7.1.2</li></ul><h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//默认构造函数</span>    Student() &#123;&#125;    <span class="hljs-comment">//构造函数初始值列表</span>    Student(<span class="hljs-keyword">char</span> str[], <span class="hljs-keyword">bool</span> sex, <span class="hljs-keyword">int</span> age) :m_sex(sex),m_age(age)    &#123;        <span class="hljs-comment">// m_sex = sex; //错误：表达式必须是可修改的左值</span>        strcpy_s(m_name, str);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="hljs-string">&quot;: sex: &quot;</span> &lt;&lt; (m_sex ? <span class="hljs-string">&quot;male&quot;</span> : <span class="hljs-string">&quot;female&quot;</span>) &lt;&lt; <span class="hljs-string">&quot;, age:&quot;</span> &lt;&lt; m_age &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">char</span> m_name[<span class="hljs-number">20</span>];    <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> m_sex = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">int</span> m_age;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> str[] = <span class="hljs-string">&quot;Bob&quot;</span>;    <span class="hljs-function">Student <span class="hljs-title">s</span><span class="hljs-params">(str, <span class="hljs-literal">true</span>, <span class="hljs-number">12</span>)</span></span>;    s.show();<span class="hljs-comment">//Bob: sex: male, age:12</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li>使用构造函数初始值列表时，<strong>数组应当在构造函数体内进行赋值</strong>，而不能在初始化列表中初始化。</li><li><strong>常量成员或者引用类型以及某种未提供默认构造函数的类类型成员必须要在初始化列表中进行</strong>，在函数体内就会报错！</li><li><strong>建议使用构造函数初始值的习惯</strong>，因为一部分数据成员只能使用这种方式初始化，同时相对于赋值的方式，构造函数初始值列表的效率更高！</li></ul><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//默认构造函数</span>    Foo() &#123;&#125;;    Foo(<span class="hljs-built_in">string</span> str, <span class="hljs-keyword">int</span> num) :str(str), num(num)    &#123; &#125;    <span class="hljs-comment">//拷贝构造函数</span>    Foo(<span class="hljs-keyword">const</span> Foo&amp; foo) :str(foo.str), num(foo.num)    &#123;        times++;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;str &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;num &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; times &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> times;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">string</span> str;    <span class="hljs-keyword">int</span> num;&#125;;<span class="hljs-keyword">int</span> Foo::times = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">Foo <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//直接初始化</span>    f1.show();          <span class="hljs-comment">//hello-10-0</span>    Foo f2 = f1;        <span class="hljs-comment">//拷贝初始化</span>    f2.show();          <span class="hljs-comment">//hello-10-1</span>    <span class="hljs-function">Foo <span class="hljs-title">f3</span><span class="hljs-params">(f1)</span></span>;         <span class="hljs-comment">//拷贝初始化，和上面那种类似</span>    f3.show();          <span class="hljs-comment">//hello-10-2</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li>一般情况下，拷贝构造函数的作用是，将给定对象中的每个非static成员拷贝到正在创建的对象之中。</li><li>拷贝构造函数形式就是<code>Foo(const Foo&amp; foo)</code>，即函数参数为一个const引用类型。</li><li>如果我们没有定义一个拷贝构造函数，那么编译器就会自动为我们定义一个。</li><li>每个成员的类型决定了它如何被拷贝，类的类型成员将会使用它的拷贝构造函数来拷贝，而内置类型的成员将会直接拷贝。至于数组，将会被逐个元素地拷贝。</li><li>但是如何成员中有指针！必须小心的对待！！！</li></ul><h3 id="拷贝初始化发生情况"><a href="#拷贝初始化发生情况" class="headerlink" title="拷贝初始化发生情况"></a>拷贝初始化发生情况</h3><ul><li>拷贝初始化一般发生于用<code>=</code>定义变量时，即<code>Foo f2 = f1</code>这种形式，或者是使用对象初始化的形式，即<code>Foo f3(f1)</code>。</li><li>将一个对象作为<strong>实参传递</strong>给一个非引用类型的形参</li><li>从一个返回类型为非引用类型的函数返回一个对象</li><li>使用花括号列表初始化一个数组中的元素或者聚合类的成员。</li></ul><p>从上述可以看出拷贝构造函数用于初始化非引用类型参数，这一特性导致它的参数必须是引用类型，否则将会无限循环了。</p><h2 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//默认构造函数</span>    Foo() &#123;&#125;;        Foo(<span class="hljs-built_in">string</span> str, <span class="hljs-keyword">int</span> num):str(str),num(num) &#123;&#125;    <span class="hljs-comment">//拷贝赋值，重载等号</span>    Foo&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Foo&amp; foo)    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;other)<span class="hljs-comment">//自赋值</span>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                <span class="hljs-keyword">this</span>-&gt;str = foo.str;        <span class="hljs-keyword">this</span>-&gt;num = foo.num;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        times++;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;str &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;num&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>&lt;&lt;times&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> times;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">string</span> str;    <span class="hljs-keyword">int</span> num;&#125;;<span class="hljs-keyword">int</span> Foo::times = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">Foo <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//直接初始化</span>    f1.show();          <span class="hljs-comment">//hello-10-1</span>    Foo f2;             <span class="hljs-comment">//默认初始化</span>    f2 = f1;            <span class="hljs-comment">//使用拷贝赋值运算符</span>    f2.show();          <span class="hljs-comment">//hello-10-2</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li>一般情况下，拷贝赋值运算符是将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员。</li><li>拷贝赋值运算符实际上就是<strong>重载赋值运算符</strong>。</li><li>重载赋值运算符必须定义成为成员函数。（参看链接：）</li><li>若运算符是成员函数，则运算对象就绑定到了隐式的this参数上，而对于一个二元运算符，右侧运算对象就作为显示的参数传递。</li><li>为了与内置类型保持一致，赋值运算符通常返回一个<strong>指向其左侧运算对象的引用</strong>。</li></ul><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//默认构造函数</span>    Foo() &#123;&#125;;        Foo(<span class="hljs-built_in">string</span> str, <span class="hljs-keyword">int</span> num):str(str),num(num) &#123;&#125;    ~Foo()     &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;函数析构了&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">string</span> str;    <span class="hljs-keyword">int</span> num;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">Foo <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//直接初始化</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//执行结果：函数析构了</span></code></pre><ul><li>作用：析构函数释放掉对象使用的资源，并且销毁对象的非static数据成员。</li><li>析构函数形式上是<code>~类名()</code>，波浪线与类名组成的，无返回值，不接受参数，故析构函数不能够重载，——一个类的析构函数唯一。</li><li>如果不显示写出析构函数，那么编译器会自动添加一个默认的构造函数。</li><li>析构时，成员的销毁完全依赖于成员的类型，对应类型执行对应的析构函数，而内置类型则没有析构函数，故销毁内置类型成员不需要做什么。</li><li>而隐式的销毁一个内置指针类型的成员时，不会delete它所指向的对象。</li></ul><h3 id="什么时候调用析构函数"><a href="#什么时候调用析构函数" class="headerlink" title="什么时候调用析构函数"></a>什么时候调用析构函数</h3><ul><li>变量在离开其作用域时被销毁</li><li>对象被销毁时，其成员被销毁的时候</li><li>容器（标准库容器或者数组）被销毁时，其元素被销毁的时候</li><li>对于动态分配的对象，执行它的指针被delete运算符执行时</li><li>对于临时对象，创建它的完整表达式结束时被销毁。</li></ul><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    Student();    ~Student();<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> age;    <span class="hljs-keyword">char</span>* name;&#125;;Student::Student()&#123;    <span class="hljs-keyword">this</span>-&gt;name = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>(<span class="hljs-number">20</span>);    <span class="hljs-keyword">this</span>-&gt;age = <span class="hljs-number">0</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Student()&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;Student::~Student()&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;~Student()&quot;</span> &lt;&lt;(<span class="hljs-keyword">int</span>)name&lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">delete</span> name;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Ok&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    name = <span class="hljs-literal">nullptr</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    &#123;<span class="hljs-comment">// 花括号让s1和s2变成局部对象，方便测试</span>        Student s1;        Student s2 = s1;    &#125;<span class="hljs-comment">//花括号结束，对象析构</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>执行结果为引发异常，触发断点。</p><pre><code class="hljs less"><span class="hljs-selector-tag">Student</span>()~<span class="hljs-selector-tag">Student</span>()<span class="hljs-selector-tag">17464200</span><span class="hljs-selector-tag">OK</span>~<span class="hljs-selector-tag">Student</span>()<span class="hljs-selector-tag">17464200</span></code></pre><p>当对一个对象进行拷贝的时候，编译器会自动调用<code>拷贝构造函数</code>。而默认的拷贝构造函数就是简单的将原对象的成员一一赋值给新对象。这就是所谓的<strong>浅拷贝</strong>。</p><p>对于指针这种类型来说，原拷贝构造函数的动作就像<code>char * a = new char(20)</code>，然后<code>char* b = a</code>，也就是说a与b两个指针指向了同一块内存区域。当对象被析构的时候，同一块内存区域就被<code>delete</code>了两次，因而触发异常。</p><p>而这种情况，一般是默认拷贝构造函数无法避免的。</p><p>因此对于类的成员含有指针的情况，一定要显示的写出拷贝构造函数，并且特殊针对指针类型进行处理，这就是<strong>深拷贝</strong>。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    Student();    ~Student();    Student(<span class="hljs-keyword">const</span> Student&amp; other);<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> age;    <span class="hljs-keyword">char</span>* name;&#125;;Student::Student()&#123;    <span class="hljs-keyword">this</span>-&gt;name = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>(<span class="hljs-number">20</span>);    <span class="hljs-keyword">this</span>-&gt;age = <span class="hljs-number">0</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Student()&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;Student::Student(<span class="hljs-keyword">const</span> Student&amp; other)&#123;    <span class="hljs-keyword">this</span>-&gt;age = other.age;    <span class="hljs-keyword">this</span>-&gt;name = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>(<span class="hljs-number">20</span>);    <span class="hljs-built_in">memcpy</span>(<span class="hljs-keyword">this</span>-&gt;name,other.name,<span class="hljs-built_in">strlen</span>(other.name));&#125;Student::~Student()&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;~Student()&quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)name &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">delete</span> name;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Ok&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    name = <span class="hljs-literal">nullptr</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    &#123;<span class="hljs-comment">// 花括号让s1和s2变成局部对象，方便测试</span>        Student s1;        Student s2 = s1;    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>执行结果：</p><pre><code class="hljs less"><span class="hljs-selector-tag">Student</span>()~<span class="hljs-selector-tag">Student</span>()<span class="hljs-selector-tag">17149496</span><span class="hljs-selector-tag">Ok</span>~<span class="hljs-selector-tag">Student</span>()<span class="hljs-selector-tag">17149832</span><span class="hljs-selector-tag">Ok</span><span class="hljs-selector-tag">hello</span></code></pre><blockquote><p>参考链接：<a href="https://blog.csdn.net/caoshangpa/article/details/79226270">C++面试题之浅拷贝和深拷贝的区别</a></p><p>总结：<strong>浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针</strong>。<br>再说几句：<br>当对象中存在指针成员时，除了在复制对象时需要考虑自定义拷贝构造函数，还应该考虑以下两种情形：<br>1.当函数的参数为对象时，实参传递给形参的实际上是实参的一个拷贝对象，系统自动通过拷贝构造函数实现；<br>2.当函数的返回值为一个对象时，该对象实际上是函数内对象的一个拷贝，用于返回函数调用处。<br>3.浅拷贝带来问题的本质在于析构函数释放多次堆内存，使用std::shared_ptr，可以完美解决这个问题。</p></blockquote><blockquote><p>知乎大佬Milo Yip的回答：<a href="https://www.zhihu.com/question/36370072/answer/68086634">如何理解 C++ 中的深拷贝和浅拷贝？ - Milo Yip的回答</a></p><p>事实上，所谓的浅拷贝和深拷贝各自代表不同的意义，各有所需。关键是要区分值语意(value semantics)和引用语意(reference semantics)。</p><p>对于值语意的对象，在x= y完成复制之后，y的状态改变不能影响到x,这特性称为独立性(independence)。使用深拷贝的方式可以完全复制一个独立于原来的对象。C++提供的(模板)大部分都是值语意的，如stad::basic string、 std:.vector 等。</p><p>有些对象会引用相同的对象，举个游戏中的例子。通常多个模型可以引用同一个材质，复制模型时并不会深度复制新一份材质。 如果需要改变个别模型的材质里的参数，才会手动把该模型的材质复制，独立于其他模型的材质。</p></blockquote><h2 id="static修饰的类成员"><a href="#static修饰的类成员" class="headerlink" title="static修饰的类成员"></a>static修饰的类成员</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    Student() :age(<span class="hljs-number">0</span>) &#123;&#125;    Student(<span class="hljs-keyword">int</span> age) :age(age) &#123;&#125;    ~Student() &#123;&#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> conut;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getConut</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> conut;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> age;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> nums;&#125;;<span class="hljs-keyword">int</span> Student::conut = <span class="hljs-number">12</span>;<span class="hljs-keyword">int</span> Student::nums = <span class="hljs-number">10</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Student s;    <span class="hljs-built_in">cout</span> &lt;&lt; s.conut &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; Student::getConut() &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//cout &lt;&lt; s.nums &lt;&lt; endl;//错误，无法访问private成员</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ol><li>static修饰类中成员，表示<strong>类的共享数据</strong>。</li><li>static不属于某一个对象。而是此类所有的成员都公有的。</li><li>创建一个对象所开辟的空间中不包括静态成员的空间。静态成员的空间是在所有对象之外单独去开辟的。静态成员开辟的空间存放于<strong>静态区</strong>。</li><li>静态数据成员是<strong>在开始运行时被分配空间</strong>，到程序结束时才释放空间。</li><li>静态成员可以初始化，但是只能够在类外初始化。也不能够用参数列表对其初始化。</li><li>静态数据成员既可以通过对象名（a.C）或者类名（A::C）来引用。</li><li>static修饰的成员仍然遵循public，private，protected访问准则。</li><li>静态成员函数的意义不在于信息共享，而在于管理静态数据成员，完成封装。</li><li>静态成员函数只能访问静态数据成员，因为静态成员函数属于类所有而非对象所有，没有this指针。</li><li>静态数据成员不占据类的大小。</li></ol><blockquote><p>参考链接：<a href="https://www.cnblogs.com/fuqia/p/8888938.html">C++ static类成员，static类成员函数</a></p></blockquote><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>this指针是隐含的变量，表示当前对象。实际就是指向了对象的地址。</p><p>在类的成员函数，非static函数内，this隐含在其中。</p><ul><li>在平常情况下，this指针指向的普通成员变量的值可以改变，说明this指针不是<code>const Class *</code>，但是this指针不能做<code>++</code>操作，说明this指针是一个常指针，即<code>Class * const</code>。</li><li>而如果在成员函数的末尾加上const，则表示this指针变成了<code>const Class * const</code>这样。</li><li>静态成员函数没有this指针</li></ul><h3 id="成员函数返回对象本身"><a href="#成员函数返回对象本身" class="headerlink" title="成员函数返回对象本身"></a>成员函数返回对象本身</h3><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    Example() :a(<span class="hljs-number">10</span>) &#123;&#125;    ~Example() &#123;&#125;        <span class="hljs-function">Example&amp; <span class="hljs-title">copy</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Example&amp; other)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>-&gt;a = other.a;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;<span class="hljs-comment">//注意函数返回值为引用。</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> a;&#125;;</code></pre><h2 id="const修饰的类成员"><a href="#const修饰的类成员" class="headerlink" title="const修饰的类成员"></a>const修饰的类成员</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    Example() :i_nom_n(<span class="hljs-number">11</span>) &#123;&#125;    ~Example() &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">this</span>-&gt;i_nom_n += <span class="hljs-number">100</span>;        <span class="hljs-built_in">cout</span> &lt;&lt; i_con_n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i_nom_n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i_sta_n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i_con_sta_n &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showInfo2</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//this-&gt;i_nom_n++;//错误，表达式必须是可修改的左值</span>        <span class="hljs-built_in">cout</span> &lt;&lt; i_con_n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i_nom_n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i_sta_n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i_con_sta_n &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i_con_n = <span class="hljs-number">10</span>;<span class="hljs-comment">//可在此处赋值或者初始值列表进行初始化</span>    <span class="hljs-keyword">int</span> i_nom_n;<span class="hljs-comment">//可在此处赋值，为默认值</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i_sta_n;<span class="hljs-comment">//必须在类外初始化</span>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i_con_sta_n;<span class="hljs-comment">//可在此处赋值或者类外初始化</span>&#125;;<span class="hljs-keyword">int</span> Example::i_sta_n = <span class="hljs-number">12</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Example::i_con_sta_n = <span class="hljs-number">13</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Example ex;    ex.showInfo2();    ex.showInfo();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li>const类常量只能在声明时就初始化或者使用构造函数初始值列表进行初始化。</li><li>而static const修饰的成员变量则可以在声明时初始化，或者在类外进行初始化。</li><li>类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。</li><li>本质上，const指针修饰的是被隐藏的this指针所指向的内存空间，修饰的是this指针。</li><li>在成员函数的末尾加上const，则表示this指针变成了<code>const Class * const</code>这样。</li></ul><blockquote><p>参考链接：<a href="https://www.cnblogs.com/cthon/p/9178701.html">C++之const类成员变量，const成员函数</a></p><p><a href="https://blog.csdn.net/buknow/article/details/80275191">C++普通变量、C++静态成员变量、C++成员常量、C++静态成员常量的初始化方法</a></p></blockquote><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    A() :a(<span class="hljs-number">0</span>), b(<span class="hljs-number">0</span>) &#123;&#125;    A(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) :a(a), b(b) &#123;&#125;    ~A() &#123;&#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> a;    <span class="hljs-keyword">int</span> b;    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">friendfun</span><span class="hljs-params">(A an, B bn)</span></span>;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    B() :c(<span class="hljs-number">0</span>) &#123;&#125;    B(<span class="hljs-keyword">int</span> c) :c(c) &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">(A an)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; an.a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; an.b &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;c&lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> c;    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">friendfun</span><span class="hljs-params">(A an, B bn)</span></span>;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">friendfun</span><span class="hljs-params">(A an,B bn)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; an.a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; an.b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; bn.c &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">A <span class="hljs-title">an</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;    <span class="hljs-function">B <span class="hljs-title">bn</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;    bn.info(an);    friendfun(an,bn);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li>当类实现了数据的封装和隐藏的时候，又是需要一些函数频繁访问类的数据成员，但它又不是此类的一部分，此时可以将这些函数定义为友元。</li><li>友元将无视权限，同时友元也不受所在private、public或者protected区域的影响，一般将友元放在类的末尾部分。</li><li>友元的作用是提高程序运行效率，缺点是破坏了类的封装和隐藏性。</li><li>友元不能被继承，友元不具有传递性，友元关系是单向的。</li></ul><h2 id="创建对象实例的方式（new与不new）"><a href="#创建对象实例的方式（new与不new）" class="headerlink" title="创建对象实例的方式（new与不new）"></a>创建对象实例的方式（new与不new）</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:    A() :a(<span class="hljs-number">0</span>), b(<span class="hljs-number">0</span>) &#123;&#125;    A(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) :a(a), b(b) &#123;&#125;    ~A()&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> a;    <span class="hljs-keyword">int</span> b;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">A <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)</span></span>;    a1.showInfo();              <span class="hljs-comment">//5 5</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(a1) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">//8</span>    A* a2 = <span class="hljs-keyword">new</span> A(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);    a2-&gt;showInfo();             <span class="hljs-comment">//5 5</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(a2) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">//4</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(*a2) &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//8</span>    <span class="hljs-keyword">delete</span> a2;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>C++创建对象实例有两种方式：</p><ol><li><code>ClassName obj(param);</code></li><li><code>ClassName * obj = new ClassName(param);</code></li></ol><p>这两种方式还是有较大的区别。</p><ol><li><code>ClassName obj(param);</code>这种方式创建的对象，内存是分配到<strong>栈</strong>中的。由编译器默认调用构造与析构函数。</li><li><code>ClassName * obj = new ClassName(param);</code>，这种方式创建的对象位于堆上，new返回的是一个对象指针，这个指针指向一个对象的地址。</li><li>new会自动触发构造函数，使用new创建的对象，最后要<strong>手动使用</strong>delete，delete会自动触发析构函数。</li><li>new创建的对象需要使用<code>-&gt;</code>来调用对应的成员。</li></ol><blockquote><p>参考链接：<a href="http://blog.sina.com.cn/s/blog_586b6c050100dhjg.html">C++创建对象的两种方法</a></p><p><a href="https://www.cnblogs.com/MarkKobs-blog/p/11642431.html">C++用new与不用new创建对象的区别</a></p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="成员初始化的顺序"><a href="#成员初始化的顺序" class="headerlink" title="成员初始化的顺序"></a>成员初始化的顺序</h3><ul><li>成员初始化的顺序与他们在类定义中的出现顺序一致</li><li>构造函数初始值列表的顺序不影响被初始化的顺序。</li><li>建议是尽可能避免使用类的某些成员去初始化其他成员。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++引用与指针</title>
    <link href="/c-reference&amp;point/"/>
    <url>/c-reference&amp;point/</url>
    
    <content type="html"><![CDATA[<p>引用与指针</p><a id="more"></a><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>大部分时候，当我们使用引用时，使用的是左值引用，lvalue reference，C++11 中新增了一种引用，右值引用，rvalue reference ，主要用于内置类。</p></blockquote><p>引用是为对象起了另外一个名字，<strong>引用类型</strong> 引用 <strong>另外一种类型</strong>。通过将声明符写成&amp;d的形式来定义引用类型。</p><pre><code class="hljs C++"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">1024</span>;<span class="hljs-keyword">int</span> &amp;refVal = ival; <span class="hljs-comment">//refVal 指向ival，实际上refVal就是ival的另一个名字</span><span class="hljs-keyword">int</span> &amp;refVal2;<span class="hljs-comment">// error,引用必须被初始化！</span></code></pre><p>一般在初始化的时候，初始值会被拷贝到新建的对象之中。</p><p>然而在定义引用中，程序是把引用和它的初始值**绑定(bind)**在一起，而非拷贝。</p><p>一旦初始化完成，引用将和它的初始值对象一直绑定在一起。<strong>因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</strong></p><p>此外：<strong>因为引用本身不是一个对象，所以不能定义引用的引用</strong>。</p><pre><code class="hljs c++">refVal = <span class="hljs-number">2</span>;<span class="hljs-comment">//对引用的操作实际上就是对对象本身的操作。</span><span class="hljs-keyword">int</span> &amp;refVal3 = refVal;<span class="hljs-comment">//将refVal3绑定到了refVal绑定的对象上。</span><span class="hljs-keyword">int</span> &amp;refVal4 = <span class="hljs-number">10</span>;<span class="hljs-comment">//error,引用类型的初始值必须是一个对象</span></code></pre><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针是<strong>指向</strong>另外一种类型的复合类型。</p><h3 id="指针的定义"><a href="#指针的定义" class="headerlink" title="指针的定义"></a>指针的定义</h3><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *ip1;<span class="hljs-comment">//指向Int型对象的指针</span><span class="hljs-keyword">double</span> *dp1;</code></pre><h3 id="获取对象的地址"><a href="#获取对象的地址" class="headerlink" title="获取对象的地址"></a>获取对象的地址</h3><p>指针是存放某个对象的地址，获取对象的地址需要使用<code>取地址符 &amp;</code>  。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">42</span>;<span class="hljs-keyword">int</span> *p = &amp;ival;<span class="hljs-comment">//p是指向ival的指针</span></code></pre><h3 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h3><p>指针的值也就是地址，应当属于下列四种状态之一。</p><ul><li>指向一个对象</li><li>指向紧邻对象所占空间的下一个位置</li><li>空指针，即指针没有指向任何一个对象‘</li><li>无效指针，除上述情况之外的其他值</li></ul><p>试图拷贝或者说是以其他方式访问无效指针的值都将会引发错误，访问无效指针的后果无法预计。</p><h3 id="使用指针访问对象"><a href="#使用指针访问对象" class="headerlink" title="使用指针访问对象"></a>使用指针访问对象</h3><p>如果指针指向了一个对象，那么可以使用 <code>解引用符 * </code> 来访问对象。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">24</span>;<span class="hljs-keyword">int</span> *p = &amp;ival;<span class="hljs-built_in">cout</span> &lt;&lt; *p;*p = <span class="hljs-number">0</span>;</code></pre><h3 id="’-amp-‘-和-‘-’-的多重含义"><a href="#’-amp-‘-和-‘-’-的多重含义" class="headerlink" title="’&amp;‘ 和 ‘*’  的多重含义"></a>’&amp;‘ 和 ‘*’  的多重含义</h3><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<span class="hljs-keyword">int</span> &amp;r = i;<span class="hljs-comment">//&amp;紧随类型名出现，是声明的一部分，r是一个引用</span><span class="hljs-keyword">int</span> *p;<span class="hljs-comment">//*紧随类型名出现，是声明的一部分，p是一个指针</span>p = &amp;i;<span class="hljs-comment">//&amp;出现在表达式之中，是一个取地址符</span>*p = i;<span class="hljs-comment">//*出现在表达式之中，是一个解引用符</span><span class="hljs-keyword">int</span> &amp;r2 = *p;<span class="hljs-comment">//&amp;是声明的一部分，而*是解引用符</span></code></pre><h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><p>空指针 null pointer，不指向任何对象。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p1 = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//等价于int *p1 = 0</span><span class="hljs-keyword">int</span> *p2 = <span class="hljs-number">0</span>;<span class="hljs-comment">//直接将p2初始化为字面常量0</span><span class="hljs-comment">//需要先 #include cstdlib</span><span class="hljs-keyword">int</span> *p3 = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//等价于int *p3 = 0</span></code></pre><p>得到空指针最直接的办法就是使用字面值nullptr来初始化指针，这是C++11 新标准引入的方法。nullptr是特殊类型的字面值，它可以被转换成任意其他的指针类型。</p><h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h3><p>待续……</p><h2 id="指针与引用的异同点"><a href="#指针与引用的异同点" class="headerlink" title="指针与引用的异同点"></a>指针与引用的异同点</h2><p>指针和引用类似，实现了对其他对象的间接访问。</p><p>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。</p><p>引用必须在定义时赋值(或者说是绑定)，而指针无须在定义时进行赋值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</p><hr><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><pre><code class="hljs c++"><span class="hljs-keyword">char</span> *p1 = <span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-keyword">char</span> p2[] = <span class="hljs-string">&quot;abc&quot;</span>;</code></pre><p>上述两者不同，对p1来说，不能修改p1指向的内存，即它是类似 <code>char const *p1</code> ，p1是指向文字常量区的指针变量。</p><p>p2呢，可以改变数组元素，因为它的实际上是将”abc”拷贝到数组p2之中。</p><pre><code class="hljs c++"><span class="hljs-keyword">char</span> p3[<span class="hljs-number">100</span>];p3 = <span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-comment">//这样是错误的，数组名是一个常量</span><span class="hljs-built_in">strcpy</span>(p3,<span class="hljs-string">&quot;abc&quot;</span>);</code></pre><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a,b,c;<span class="hljs-keyword">int</span> *p[] = &#123;&amp;a,&amp;b,&amp;c&#125;;<span class="hljs-comment">// p是指针数组，他是数组，每个元素都是指针 int*，指向int</span><span class="hljs-keyword">char</span> a,b,c;<span class="hljs-keyword">char</span> *p[] = &#123;&amp;a,&amp;b,&amp;c&#125;;<span class="hljs-comment">//这种不常用</span><span class="hljs-keyword">char</span> *p2[] = &#123;<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;mike&quot;</span>&#125;;<span class="hljs-comment">//这种常用</span><span class="hljs-comment">//p2是指针数组，是数组，每个元素都是指针char *，保存了三个字符串的首元素地址</span>p2[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;hello&quot;</span>;</code></pre><pre><code class="hljs c++"><span class="hljs-keyword">char</span> *p2[] = &#123;<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;mike&quot;</span>&#125;;<span class="hljs-keyword">char</span> **p2 = &#123;<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;mike&quot;</span>&#125;; <span class="hljs-comment">//err错误</span><span class="hljs-comment">//p2是char**类型，它要指向char *类型</span><span class="hljs-keyword">char</span> *tmp;<span class="hljs-keyword">char</span> **p = &amp;tmp;<span class="hljs-keyword">char</span> *str[] = &#123;<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;mike&quot;</span>&#125;;<span class="hljs-comment">//str首元素是char*类型</span><span class="hljs-comment">//&amp;str[0]代表首元素的地址，str等价于&amp;str[0],类型是char *</span><span class="hljs-keyword">char</span> **p3 = str;<span class="hljs-comment">//等价于char **p3 = &amp;str[0];</span><span class="hljs-comment">//故函数参数：fun(str),定义时 是void fun(char **p)</span><span class="hljs-comment">// 如果char *str[] 作为函数参数，可以改为char **str;</span><span class="hljs-comment">//下面三者等价，编译器都当作char **p处理</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **p)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *p[])</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *p[<span class="hljs-number">100</span>])</span></span></code></pre>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python常用序列结构——列表、元组、字符串、字典和集合</title>
    <link href="/python-sequence/"/>
    <url>/python-sequence/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：Python常用序列结构总结。</p><a id="more"></a><p><img src="/python-sequence/main.png"></p><p>图片来源见图中水印。</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="列表的主要特征"><a href="#列表的主要特征" class="headerlink" title="列表的主要特征"></a>列表的主要特征</h3><ol><li>在形式上，列表的所有元素都存放在一对中括号<code>[]</code>中，相邻元素使用逗号分隔。</li><li>可以将数字、字符串、列表、元组等任何数据类型的内容放入列表之中。</li><li>同一个列表的元素类型可以是不同的，非常的灵活。</li></ol><h3 id="创建与删除列表"><a href="#创建与删除列表" class="headerlink" title="创建与删除列表"></a>创建与删除列表</h3><pre><code class="hljs python"><span class="hljs-comment"># 1. 创建空列表</span>empty_list = []empty_list1 = <span class="hljs-built_in">list</span>()<span class="hljs-comment"># 2. 创建含有内容的列表</span>num_list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]print(num_list) <span class="hljs-comment">#[1, 2, 3, 4, 5]</span>my_list = [<span class="hljs-string">&#x27;21&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,[<span class="hljs-string">&#x27;qq&#x27;</span>,<span class="hljs-string">&#x27;wechat&#x27;</span>]]print(my_list)  <span class="hljs-comment">#[&#x27;21&#x27;, 1, 2, 3, 4, 5, [&#x27;qq&#x27;, &#x27;wechat&#x27;]]</span>range_list = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">2</span>))print(range_list) <span class="hljs-comment">#[10, 12, 14, 16, 18]</span>char_list = <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;道阻且长行将则至&#x27;</span>)print(char_list) <span class="hljs-comment">#[&#x27;道&#x27;, &#x27;阻&#x27;, &#x27;且&#x27;, &#x27;长&#x27;, &#x27;行&#x27;, &#x27;将&#x27;, &#x27;则&#x27;, &#x27;至&#x27;]</span><span class="hljs-comment"># 3. 使用列表生成式创建列表</span>char_list = <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;道阻且长行将则至&#x27;</span>)new_char_list = [item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> char_list]print(new_char_list) <span class="hljs-comment">#[&#x27;道&#x27;, &#x27;阻&#x27;, &#x27;且&#x27;, &#x27;长&#x27;, &#x27;行&#x27;, &#x27;将&#x27;, &#x27;则&#x27;, &#x27;至&#x27;]</span>num_list = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)]print(num_list)      <span class="hljs-comment">#[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><span class="hljs-comment"># 3. 删除列表</span><span class="hljs-keyword">del</span> char_list</code></pre><h3 id="访问列表元素"><a href="#访问列表元素" class="headerlink" title="访问列表元素"></a>访问列表元素</h3><pre><code class="hljs python">char_list = <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;道阻且长行将则至&#x27;</span>)<span class="hljs-comment"># 1. 通过下标访问</span>print(char_list[<span class="hljs-number">1</span>])     <span class="hljs-comment">#阻</span>print(char_list[-<span class="hljs-number">1</span>])    <span class="hljs-comment">#至</span><span class="hljs-comment"># 负数也可做为索引，从右向左，从-1开始作为索引</span><span class="hljs-comment"># 2. 切片操作</span>print(char_list[<span class="hljs-number">0</span>:<span class="hljs-number">7</span>:<span class="hljs-number">2</span>]) <span class="hljs-comment">#[&#x27;道&#x27;, &#x27;且&#x27;, &#x27;行&#x27;, &#x27;则&#x27;]</span><span class="hljs-comment"># 3. 遍历列表</span><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> char_list:    print(item)<span class="hljs-keyword">for</span> index,item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(char_list):    print(index,item) <span class="hljs-comment">#同时输出索引值和元素内容</span></code></pre><h3 id="增加、修改与删除列表元素"><a href="#增加、修改与删除列表元素" class="headerlink" title="增加、修改与删除列表元素"></a>增加、修改与删除列表元素</h3><pre><code class="hljs python">char_list = <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;道阻且长行将则至&#x27;</span>)<span class="hljs-comment"># 1. insert()向指定位置插入元素</span>char_list.insert(<span class="hljs-built_in">len</span>(char_list),<span class="hljs-string">&#x27;加&#x27;</span>)print(char_list) <span class="hljs-comment">#[&#x27;道&#x27;, &#x27;阻&#x27;, &#x27;且&#x27;, &#x27;长&#x27;, &#x27;行&#x27;, &#x27;将&#x27;, &#x27;则&#x27;, &#x27;至&#x27;, &#x27;加&#x27;]</span><span class="hljs-comment"># 2. append()向末尾添加元素</span>char_list.append(<span class="hljs-string">&#x27;油&#x27;</span>)print(char_list) <span class="hljs-comment">#[&#x27;道&#x27;, &#x27;阻&#x27;, &#x27;且&#x27;, &#x27;长&#x27;, &#x27;行&#x27;, &#x27;将&#x27;, &#x27;则&#x27;, &#x27;至&#x27;, &#x27;加&#x27;, &#x27;油&#x27;]</span><span class="hljs-comment"># 3. extend()将一个列表的内容加入另一个列表</span>new_char_list = [<span class="hljs-string">&#x27;吧&#x27;</span>]char_list.extend(new_char_list)print(char_list) <span class="hljs-comment">#[&#x27;道&#x27;, &#x27;阻&#x27;, &#x27;且&#x27;, &#x27;长&#x27;, &#x27;行&#x27;, &#x27;将&#x27;, &#x27;则&#x27;, &#x27;至&#x27;, &#x27;加&#x27;, &#x27;油&#x27;, &#x27;吧&#x27;]</span><span class="hljs-comment"># 4. 修改元素，通过索引直接重新赋值</span>char_list[-<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;减&#x27;</span>print(char_list) <span class="hljs-comment">#[&#x27;道&#x27;, &#x27;阻&#x27;, &#x27;且&#x27;, &#x27;长&#x27;, &#x27;行&#x27;, &#x27;将&#x27;, &#x27;则&#x27;, &#x27;至&#x27;, &#x27;减&#x27;, &#x27;油&#x27;, &#x27;吧&#x27;]</span><span class="hljs-comment"># 5. 删除元素，根据索引删除</span><span class="hljs-keyword">del</span> char_list[-<span class="hljs-number">1</span>]print(char_list) <span class="hljs-comment">#[&#x27;道&#x27;, &#x27;阻&#x27;, &#x27;且&#x27;, &#x27;长&#x27;, &#x27;行&#x27;, &#x27;将&#x27;, &#x27;则&#x27;, &#x27;至&#x27;, &#x27;减&#x27;, &#x27;油&#x27;]</span><span class="hljs-comment"># 6. 删除元素，根据元素值删除，使用remove()方法</span>del_value = <span class="hljs-string">&#x27;油&#x27;</span><span class="hljs-keyword">if</span> del_value <span class="hljs-keyword">in</span> char_list:    char_list.remove(del_value)print(char_list) <span class="hljs-comment">#[&#x27;道&#x27;, &#x27;阻&#x27;, &#x27;且&#x27;, &#x27;长&#x27;, &#x27;行&#x27;, &#x27;将&#x27;, &#x27;则&#x27;, &#x27;至&#x27;, &#x27;减&#x27;]</span></code></pre><ul><li><code>append()</code>的效率要高于<code>insert()</code>方法</li><li>使用<code>remove()</code>方法前最好判断要删除的元素是否存在</li></ul><h3 id="统计元素次数、获取元素索引"><a href="#统计元素次数、获取元素索引" class="headerlink" title="统计元素次数、获取元素索引"></a>统计元素次数、获取元素索引</h3><pre><code class="hljs python">char_list = <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;道阻且长行将则至&#x27;</span>)<span class="hljs-comment"># 1. 使用count()方法获取元素在列表中的出现次数</span>num = char_list.count(<span class="hljs-string">&#x27;且&#x27;</span>)print(num) <span class="hljs-comment"># 1</span><span class="hljs-comment"># 2. 获取指定元素首次出现的下标</span>position = char_list.index(<span class="hljs-string">&#x27;将&#x27;</span>)print(position) <span class="hljs-comment"># 5</span></code></pre><h3 id="对列表进行排序"><a href="#对列表进行排序" class="headerlink" title="对列表进行排序"></a>对列表进行排序</h3><pre><code class="hljs python"><span class="hljs-comment"># 1. 使用列表的sort()进行排序</span>num_list = [<span class="hljs-number">14</span>, <span class="hljs-number">51</span>, <span class="hljs-number">19</span>, <span class="hljs-number">35</span>, <span class="hljs-number">16</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>, <span class="hljs-number">60</span>, <span class="hljs-number">90</span>, <span class="hljs-number">77</span>]print(num_list) <span class="hljs-comment">#[14, 51, 19, 35, 16, 13, 15, 60, 90, 77]</span>num_list.sort()print(num_list) <span class="hljs-comment">#[13, 14, 15, 16, 19, 35, 51, 60, 77, 90]</span>num_list.sort(reverse=<span class="hljs-literal">True</span>)print(num_list) <span class="hljs-comment">#[90, 77, 60, 51, 35, 19, 16, 15, 14, 13]</span><span class="hljs-comment"># 2. 使用内置sorted()函数排序</span>num_list = [<span class="hljs-number">14</span>, <span class="hljs-number">51</span>, <span class="hljs-number">19</span>, <span class="hljs-number">35</span>, <span class="hljs-number">16</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>, <span class="hljs-number">60</span>, <span class="hljs-number">90</span>, <span class="hljs-number">77</span>]print(num_list) <span class="hljs-comment">#[14, 51, 19, 35, 16, 13, 15, 60, 90, 77]</span>num_as = <span class="hljs-built_in">sorted</span>(num_list)print(num_list) <span class="hljs-comment">#[14, 51, 19, 35, 16, 13, 15, 60, 90, 77]</span>print(num_as)   <span class="hljs-comment">#[13, 14, 15, 16, 19, 35, 51, 60, 77, 90]</span>num_des = <span class="hljs-built_in">sorted</span>(num_list,reverse=<span class="hljs-literal">True</span>)print(num_list) <span class="hljs-comment">#[14, 51, 19, 35, 16, 13, 15, 60, 90, 77]</span>print(num_des)  <span class="hljs-comment">#[90, 77, 60, 51, 35, 19, 16, 15, 14, 13]</span></code></pre><ul><li><code>sort()</code>函数会改变原先列表的元素顺序。</li><li><code>sort()</code>函数默认从小到大排序，指定<code>reverse=True</code>就可以逆序排序</li><li><code>sorted()</code>函数用法和<code>sort()</code>基本相同，不过<code>sorted()</code>函数默认不会改变原来的列表。</li></ul><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><h3 id="元组的主要特征"><a href="#元组的主要特征" class="headerlink" title="元组的主要特征"></a>元组的主要特征</h3><ol><li>在形式上，元组使用小括号<code>()</code>括起来，元素使用逗号分开。</li><li>元组可以按照特定顺序存放一组元素，但<strong>元组是不可变序列</strong>，元素不能修改。</li><li>同一个元组的元素可以是不同的数据类型。</li><li>元组比列表的访问以及处理速度都要快。</li></ol><h3 id="创建删除元组"><a href="#创建删除元组" class="headerlink" title="创建删除元组"></a>创建删除元组</h3><pre><code class="hljs python"><span class="hljs-comment"># 1. 创建空元组</span>empty_tuple = ()empty_tuple = <span class="hljs-built_in">tuple</span>()<span class="hljs-comment"># 2. 使用()创建元组</span>num_tuple = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)print(num_tuple) <span class="hljs-comment">#(1, 2, 3, 4, 5)</span>untitle = (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2&#x27;</span>,num_tuple)print((untitle)) <span class="hljs-comment">#(1, &#x27;2&#x27;, (1, 2, 3, 4, 5))</span>my_str = (<span class="hljs-string">&#x27;hello&#x27;</span>)print(<span class="hljs-built_in">type</span>(my_str)) <span class="hljs-comment">#&lt;class &#x27;str&#x27;&gt;</span>my_str_tuple = (<span class="hljs-string">&#x27;hello&#x27;</span>,) <span class="hljs-comment"># 多加一个逗号来创建元组</span>print(my_str_tuple) <span class="hljs-comment">#(&#x27;hello&#x27;,)</span>print(<span class="hljs-built_in">type</span>(my_str_tuple)) <span class="hljs-comment">#&lt;class &#x27;tuple&#x27;&gt;</span><span class="hljs-comment"># 3. 使用tuple()创建元组</span>num_tuple = <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>))print(num_tuple) <span class="hljs-comment">#(1, 2, 3, 4, 5, 6, 7, 8, 9)</span>str_tuple = <span class="hljs-built_in">tuple</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)print(str_tuple) <span class="hljs-comment">#(&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;)</span><span class="hljs-comment"># 4. 使用元组生成式创建元组</span><span class="hljs-keyword">import</span> randommy_num_tuple = (random.randint(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>))print(my_num_tuple) <span class="hljs-comment">#&lt;generator object &lt;genexpr&gt; at 0x00000221286B7748&gt;</span>                    <span class="hljs-comment"># 使用元组生成式产生的是一个生成器对象，还需要额外转换</span>my_num_tuple = <span class="hljs-built_in">tuple</span>(my_num_tuple)print(my_num_tuple) <span class="hljs-comment">#(96, 93, 60, 22, 78, 59, 43, 32, 85, 40)</span><span class="hljs-comment"># 5. 删除元组</span><span class="hljs-keyword">del</span> str_tuple</code></pre><h3 id="访问元组元素"><a href="#访问元组元素" class="headerlink" title="访问元组元素"></a>访问元组元素</h3><pre><code class="hljs python">num_tuple = (<span class="hljs-number">96</span>, <span class="hljs-number">93</span>, <span class="hljs-number">60</span>, <span class="hljs-number">22</span>, <span class="hljs-number">78</span>, <span class="hljs-number">59</span>, <span class="hljs-number">43</span>, <span class="hljs-number">32</span>, <span class="hljs-number">85</span>, <span class="hljs-number">40</span>)<span class="hljs-comment"># 1. 通过下标访问元组元素</span>print(num_tuple[<span class="hljs-number">0</span>])     <span class="hljs-comment">#96</span>print(num_tuple[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])   <span class="hljs-comment">#(96, 93, 60, 22)</span><span class="hljs-comment"># 2. for循环遍历</span><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> num_tuple:    print(item)</code></pre><h3 id="元组连接组合"><a href="#元组连接组合" class="headerlink" title="元组连接组合"></a>元组连接组合</h3><pre><code class="hljs python"><span class="hljs-comment"># 元组内的元素不能修改</span>num_tuple = (<span class="hljs-number">96</span>, <span class="hljs-number">93</span>, <span class="hljs-number">60</span>, <span class="hljs-number">22</span>, <span class="hljs-number">78</span>, <span class="hljs-number">59</span>, <span class="hljs-number">43</span>, <span class="hljs-number">32</span>, <span class="hljs-number">85</span>, <span class="hljs-number">40</span>)<span class="hljs-comment"># num_tuple[-1] = 22 #TypeError: &#x27;tuple&#x27; object does not support item assignment</span>my_num_tuple = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<span class="hljs-comment"># 元组连接时要求连接的内容必须的元组</span>num_tuple += my_num_tupleprint(num_tuple) <span class="hljs-comment">#(96, 93, 60, 22, 78, 59, 43, 32, 85, 40, 1, 2)</span></code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串的特征"><a href="#字符串的特征" class="headerlink" title="字符串的特征"></a>字符串的特征</h3><ol><li>字符串是不可变的序列，不能修改内容。</li><li>Python中的字符串可以使用单引号、双引号以及三个单引号的形式括起来。</li><li>Python字符串也支持转义符<code>\</code>。</li></ol><h3 id="字符串的表示"><a href="#字符串的表示" class="headerlink" title="字符串的表示"></a>字符串的表示</h3><pre><code class="hljs python">my_str0 = <span class="hljs-string">&#x27;hello&#x27;</span>my_str1 = <span class="hljs-string">&quot;123&quot;</span>my_str2 = <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">12fsdfg</span><span class="hljs-string">  &#x27;&#x27;&#x27;</span></code></pre><h3 id="字符串的操作符：-、-、in"><a href="#字符串的操作符：-、-、in" class="headerlink" title="字符串的操作符：+、*、in"></a>字符串的操作符：+、*、in</h3><pre><code class="hljs python">mystr = <span class="hljs-string">&#x27;hello&#x27;</span>mystr1 = <span class="hljs-string">&#x27;world&#x27;</span>print(mystr + <span class="hljs-string">&#x27; &#x27;</span> + mystr1) <span class="hljs-comment">#hello world</span><span class="hljs-comment"># 字符串不允许直接和其他类型进行拼接</span>print(mystr1 * <span class="hljs-number">3</span>) <span class="hljs-comment">#worldworldworld</span>print(<span class="hljs-string">&#x27;lo&#x27;</span> <span class="hljs-keyword">in</span> mystr) <span class="hljs-comment">#True</span><span class="hljs-comment"># in 是查看是否是字符串的子串</span></code></pre><h3 id="字符串的索引和切片"><a href="#字符串的索引和切片" class="headerlink" title="字符串的索引和切片"></a>字符串的索引和切片</h3><pre><code class="hljs python">mystr = <span class="hljs-string">&#x27;bullet&#x27;</span>print(mystr[<span class="hljs-number">2</span>]) <span class="hljs-comment">#l</span>print(mystr[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(mystr):<span class="hljs-number">2</span>]) <span class="hljs-comment">#ble</span></code></pre><h3 id="字符串的基本函数"><a href="#字符串的基本函数" class="headerlink" title="字符串的基本函数"></a>字符串的基本函数</h3><pre><code class="hljs python">print(<span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;一二三456&#x27;</span>)) <span class="hljs-comment">#6</span>print(<span class="hljs-built_in">str</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])) <span class="hljs-comment">#[1, 2]</span>print(<span class="hljs-built_in">hex</span>(<span class="hljs-number">125</span>)) <span class="hljs-comment">#0x7d</span>print(<span class="hljs-built_in">oct</span>(<span class="hljs-number">125</span>)) <span class="hljs-comment">#0o175</span>print(<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)) <span class="hljs-comment">#97</span>print(<span class="hljs-built_in">chr</span>(<span class="hljs-number">97</span>)) <span class="hljs-comment">#a</span></code></pre><ul><li><code>len(s) </code> 返回字符串s长度</li><li><code>str(x)</code> 将任意类型转换成对应的字符串形式</li><li><code>hex(x)</code> 将整数转成十六进制字符串</li><li><code>oct(x)</code> 将整数x转成八进制字符串</li><li><code>ord(x)</code> 返回字符x的Unicode编码</li><li><code>chr(x)</code> 返回Unicode编码x对应的字符</li></ul><h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><p><img src="/python-sequence/str-function.png"></p><ul><li>str.find(sub)：检索str中是否存在子串sub，若不存在则返回-1，存在则返回首次出现时的索引。</li><li>str.startswith(prefix)：检查字符串是否是以prefix开头，是返回True，否则返回False</li><li>str.endswith(suffix)：检查字符串是否是以suffix结尾，是返回True，否则返回False</li></ul><h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p><img src="/python-sequence/format1.png"></p><p><img src="/python-sequence/format2.png"></p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>Python中的字典相当于Java或者C++中的Map。</p><p>Python中的字典与列表一样都是可变序列，但不同于列表，字典是无序的，它保存的内容都是以“键值对”的形式存放的。</p><h3 id="字典的主要特征"><a href="#字典的主要特征" class="headerlink" title="字典的主要特征"></a>字典的主要特征</h3><ol><li>字典通过键(key)来读取，但不能通过索引来读取。</li><li>字典是任意对象的无序集合，随机排列。</li><li>字典是可变的，可以任意嵌套，它的值(value)可以是其他列表或者字典。</li><li>字典的键(key)必须唯一且不可变，即可使用字符串、元组作为键但是不能使用列表、集合字典等其他可变值做为键。</li></ol><h3 id="字典的创建与删除"><a href="#字典的创建与删除" class="headerlink" title="字典的创建与删除"></a>字典的创建与删除</h3><pre><code class="hljs python"><span class="hljs-comment"># 1. 使用&#123;&#125;方式创建</span>mydict0 = &#123;&#125; <span class="hljs-comment"># 空字典</span>mydict1 = &#123;<span class="hljs-string">&quot;qq&quot;</span>:<span class="hljs-string">&quot;110110110&quot;</span>,<span class="hljs-string">&quot;wechat&quot;</span>:<span class="hljs-string">&quot;hagsjhfaj&quot;</span>&#125; <span class="hljs-comment">#使用键值对形式创建</span><span class="hljs-comment"># 2. 使用dict()创建</span>mydict2 = <span class="hljs-built_in">dict</span>() <span class="hljs-comment">#空字典</span>mydict3 = <span class="hljs-built_in">dict</span>(qq = <span class="hljs-string">&quot;110110110&quot;</span>,wechat = <span class="hljs-string">&quot;hagsjhfaj&quot;</span>)list1 = [<span class="hljs-string">&#x27;qq&#x27;</span>,<span class="hljs-string">&#x27;wechat&#x27;</span>]list2 = [<span class="hljs-string">&#x27;110110110&#x27;</span>,<span class="hljs-string">&#x27;hagsjhfaj&#x27;</span>]mydict4 = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(list1,list2)) <span class="hljs-comment"># 使用zip()函数将两列表对应位置的元素组合成元组返回成zip对象</span><span class="hljs-comment"># 3. 字典推导式</span><span class="hljs-keyword">import</span> randommydict5 = &#123;i:random.randint(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)&#125;print(mydict5) <span class="hljs-comment"># &#123;1: 70, 2: 100, 3: 63, 4: 52&#125;</span><span class="hljs-comment"># 4. 删除</span>mydict5.clear() <span class="hljs-comment"># 清楚字典中的全部元素</span><span class="hljs-keyword">del</span> mydict <span class="hljs-comment">#彻底删除字典</span></code></pre><h3 id="访问字典元素"><a href="#访问字典元素" class="headerlink" title="访问字典元素"></a>访问字典元素</h3><pre><code class="hljs python"><span class="hljs-comment"># 1. 遍历字典元素</span>mydict = <span class="hljs-built_in">dict</span>(qq = <span class="hljs-string">&quot;110110110&quot;</span>,wechat = <span class="hljs-string">&quot;hagsjhfaj&quot;</span>)<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> mydict.items():    print(item)         <span class="hljs-comment"># (&#x27;qq&#x27;, &#x27;110110110&#x27;)</span>    print(<span class="hljs-built_in">type</span>(item))   <span class="hljs-comment"># &lt;class &#x27;tuple&#x27;&gt;</span><span class="hljs-comment"># 分别获取具体的每个键与值</span><span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> mydict.items():    print(key,<span class="hljs-string">&#x27;:&#x27;</span>,value)<span class="hljs-comment"># 单独获取全部的key，value同理</span><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> mydict.keys():    print(key)    <span class="hljs-comment"># 2. 通过键获得指定的值</span>mydict = <span class="hljs-built_in">dict</span>(qq = <span class="hljs-string">&quot;110110110&quot;</span>,wechat = <span class="hljs-string">&quot;hagsjhfaj&quot;</span>)print(mydict[<span class="hljs-string">&#x27;qq&#x27;</span>]) <span class="hljs-comment">#类似列表下标的方式</span><span class="hljs-comment"># 3. 使用get()方法获得指定键的值</span>mydict.get(<span class="hljs-string">&#x27;qq&#x27;</span>) <span class="hljs-comment"># 110110110</span><span class="hljs-comment"># 针对于get(key[,default])如果指定的key不存在，返回默认值，若默认值为空，则默认返回None</span>mydict.get(<span class="hljs-string">&#x27;weibo&#x27;</span>,<span class="hljs-string">&#x27;不存在&#x27;</span>) <span class="hljs-comment"># 不存在</span></code></pre><h3 id="添加、修改与删除字典元素"><a href="#添加、修改与删除字典元素" class="headerlink" title="添加、修改与删除字典元素"></a>添加、修改与删除字典元素</h3><pre><code class="hljs python"><span class="hljs-comment"># 添加与修改</span>mydict = <span class="hljs-built_in">dict</span>(qq = <span class="hljs-string">&quot;110110110&quot;</span>,wechat = <span class="hljs-string">&quot;hagsjhfaj&quot;</span>)mydict[<span class="hljs-string">&#x27;weibo&#x27;</span>] = <span class="hljs-string">&#x27;shello&#x27;</span> <span class="hljs-comment">#添加一个元素，若键值存在，则变成修改元素</span>print(mydict) <span class="hljs-comment"># &#123;&#x27;qq&#x27;: &#x27;110110110&#x27;, &#x27;wechat&#x27;: &#x27;hagsjhfaj&#x27;, &#x27;weibo&#x27;: &#x27;shello&#x27;&#125;</span>mydict[<span class="hljs-string">&#x27;weibo&#x27;</span>] = <span class="hljs-string">&#x27;nhello&#x27;</span> <span class="hljs-comment">#修改元素</span>print(mydict) <span class="hljs-comment"># &#123;&#x27;qq&#x27;: &#x27;110110110&#x27;, &#x27;wechat&#x27;: &#x27;hagsjhfaj&#x27;, &#x27;weibo&#x27;: &#x27;nhello&#x27;&#125;</span><span class="hljs-comment"># 删除</span>mydict.pop(<span class="hljs-string">&#x27;qq&#x27;</span>) <span class="hljs-comment">#删除指定键的元素，并返回键对应的value值</span><span class="hljs-keyword">del</span> mydict[<span class="hljs-string">&#x27;qq&#x27;</span>] <span class="hljs-comment">#删除指定键的元素</span></code></pre><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Python中的集合用于保存不重复的元素。</p><p>集合有可变集合set与不可变集合frozenset两种，这里主要介绍set。</p><h3 id="set的主要特征"><a href="#set的主要特征" class="headerlink" title="set的主要特征"></a>set的主要特征</h3><ol><li>set集合是无序可变序列，随机排列</li><li>形式上，集合中的所有元素都放在一对大括号之中<code>&#123; &#125;</code> </li><li>集合的特性是元素唯一，常用于去重操作。</li></ol><h3 id="set集合的创建"><a href="#set集合的创建" class="headerlink" title="set集合的创建"></a>set集合的创建</h3><pre><code class="hljs python"><span class="hljs-comment"># 1. 使用&#123;&#125;创建，元素可以是Python支持的任意数据类型</span>myset = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>&#125;print(<span class="hljs-built_in">type</span>(myset)) <span class="hljs-comment">#&lt;class &#x27;set&#x27;&gt;</span>print(myset) <span class="hljs-comment">#&#123;1, 2, 3, 4&#125; set会自动去重的</span><span class="hljs-comment"># 2. 使用set()函数创建</span>myset1 = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;此爱隔山海，山海皆可平&#x27;</span>)print(myset1) <span class="hljs-comment">#&#123;&#x27;隔&#x27;, &#x27;皆&#x27;, &#x27;爱&#x27;, &#x27;山&#x27;, &#x27;海&#x27;, &#x27;平&#x27;, &#x27;可&#x27;, &#x27;，&#x27;, &#x27;此&#x27;&#125;</span>myset2 = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])print(myset2) <span class="hljs-comment">#&#123;1, 2, 3, 4, 5, 6&#125;</span></code></pre><ul><li>当创建空集合的时候只能使用set()函数，直接使用<code>&#123;&#125;</code>创建的是空字典。</li><li><code>set()</code>函数可以将列表、元组、字符串、range对象等可迭代对象转换为集合，并且自动去重。</li></ul><h3 id="set集合元素的访问"><a href="#set集合元素的访问" class="headerlink" title="set集合元素的访问"></a>set集合元素的访问</h3><p>由于set集合是无序可变序列，不能使用类似列表下标的方式访问元素，最好的方法是将set集合转成list再访问。</p><h3 id="set集合的添加、删除与合并"><a href="#set集合的添加、删除与合并" class="headerlink" title="set集合的添加、删除与合并"></a>set集合的添加、删除与合并</h3><pre><code class="hljs python"><span class="hljs-comment"># 1. 添加元素</span>myset = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])myset.add(<span class="hljs-string">&#x27;7&#x27;</span>)print(myset) <span class="hljs-comment">#&#123;1, 2, 3, 4, 5, 6, &#x27;7&#x27;&#125;</span>list1 = [<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] <span class="hljs-comment">#添加列表元组之类的元素会出错 </span>myset.add(list1) <span class="hljs-comment">#TypeError: unhashable type: &#x27;list&#x27;</span><span class="hljs-comment"># 2. 删除元素</span><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;7&#x27;</span> <span class="hljs-keyword">in</span> myset:myset.remove(<span class="hljs-string">&#x27;7&#x27;</span>)print(myset) <span class="hljs-comment">#&#123;1, 2, 3, 4, 5, 6&#125;</span>print(myset.pop())  <span class="hljs-comment"># 1</span>print(myset)        <span class="hljs-comment"># &#123;2, 3, 4, 5, 6&#125;</span><span class="hljs-keyword">del</span> mysetprint(myset)        <span class="hljs-comment"># NameError: name &#x27;myset&#x27; is not defined</span><span class="hljs-comment"># 3. 合并集合</span>myset1 = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])myset2 = <span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;hi&#x27;</span>])myset1.update(myset2)print(myset1) <span class="hljs-comment">#&#123;1, 2, 3, 4, 5, 6, &#x27;hi&#x27;, &#x27;hello&#x27;&#125;</span></code></pre><ul><li>set的<code>add()</code>方法添加元素时只能使用字符串、数字、布尔类型，不能使用列表、元组等可迭代对象。</li><li>移除指定元素时最好使用<code>in</code>查看元素是否在集合之中。</li></ul><h3 id="set集合常用的交、并和差集的运算"><a href="#set集合常用的交、并和差集的运算" class="headerlink" title="set集合常用的交、并和差集的运算"></a>set集合常用的交、并和差集的运算</h3><pre><code class="hljs python">pf = <span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;邓肯&#x27;</span>,<span class="hljs-string">&#x27;加内特&#x27;</span>,<span class="hljs-string">&#x27;马龙&#x27;</span>])print(<span class="hljs-string">&#x27;大前锋位置的球员有&#x27;</span>,pf)cf = <span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;邓肯&#x27;</span>,<span class="hljs-string">&#x27;奥尼尔&#x27;</span>,<span class="hljs-string">&#x27;姚明&#x27;</span>])print(<span class="hljs-string">&#x27;中锋位置的球员有&#x27;</span>,cf)print(<span class="hljs-string">&#x27;交集运算&#x27;</span>,pf &amp; cf) <span class="hljs-comment">#交集运算 &#123;&#x27;邓肯&#x27;&#125;</span>print(<span class="hljs-string">&#x27;并集运算&#x27;</span>,pf | cf) <span class="hljs-comment">#并集运算 &#123;&#x27;奥尼尔&#x27;, &#x27;加内特&#x27;, &#x27;邓肯&#x27;, &#x27;姚明&#x27;, &#x27;马龙&#x27;&#125;</span>print(<span class="hljs-string">&#x27;差集运算&#x27;</span>,pf - cf) <span class="hljs-comment">#差集运算 &#123;&#x27;马龙&#x27;, &#x27;加内特&#x27;&#125;</span></code></pre><h2 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h2><h3 id="将list中全部的字符串转成数字"><a href="#将list中全部的字符串转成数字" class="headerlink" title="将list中全部的字符串转成数字"></a>将list中全部的字符串转成数字</h3><pre><code class="hljs python">list1 = [<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>]print(list1) <span class="hljs-comment">#[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span>list1 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,list1))print(list1) <span class="hljs-comment">#[1, 2, 3, 4]</span></code></pre><h3 id="list转成字符串"><a href="#list转成字符串" class="headerlink" title="list转成字符串"></a>list转成字符串</h3><pre><code class="hljs python">list1 = [<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>]str1 = <span class="hljs-built_in">str</span>(list1)print(str1) <span class="hljs-comment">#[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span>print(<span class="hljs-string">&quot;&quot;</span>.join(list1)) <span class="hljs-comment">#1234</span></code></pre><blockquote><p>参考资料： <a href="https://blog.csdn.net/zhouheng2018/article/details/79822192">Python字符串</a></p><p><a href="https://blog.csdn.net/zhouheng2018/article/details/79977968">Python序列结构（数据结构）</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小白文</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python小项目 —— 企业编码生成系统</title>
    <link href="/python-pollcode/"/>
    <url>/python-pollcode/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：Python控制台项目，比较简单。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《Python项目开发案例集锦》是我在20年疫情期间发现的一本书，介绍了好多个小项目，以及整本书的源码和可执行程序。之前简单学过一点Python的语法之后，再也没有用过Python了，正巧用这里面的代码练练手。</p><p>这个项目：企业编码生成器，是一个控制台项目，接收用户的命令生成指定格式的编码或者防伪码，存储到对应文件之中，此外还有生成条形码以及二维码的功能。</p><p>这个项目实际上用到的东西包括列表、集合、随机数的生成、文件目录的操作以及常规流程控制的掌握，总体来说没有什么难度，二维码以及条形码模块使用的方式也非常的简单。</p><h2 id="项目功能及演示"><a href="#项目功能及演示" class="headerlink" title="项目功能及演示"></a>项目功能及演示</h2><p>1.<strong>生成6位数字防伪编码</strong> （213563型）：模拟手机上的6位数字验证码。</p><p>2.<strong>生成9位系列产品数字防伪编码</strong>(879-335439型)：前3位表示产品类型，后六位代表同一类型的随机编号。</p><p>3.<strong>生成25位混合产品序列号</strong>(B2R12-N7TE8-9IET2-FE35O-DW2K4型)：模拟Windows激活的序列号。</p><p>4.<strong>生成含数据分析功能的防伪编码</strong>(5A61M053D)：包含三个字母编码，字母编码有着相对位置的要求，第一个字母代表地区，第二个字母代表产品颜色。第三个字母代表产品批次。</p><p>5.<strong>智能批量生成带数据分析功能的防伪码</strong>：对4功能的扩充，需要先编辑<code>plcode.mri</code>文件，然后会根据文件批量生成。</p><p>6.<strong>后续补加生成防伪码</strong>：对4、5功能生成的编码文件的扩充。</p><p>7.<strong>EAN-13条形码批量生成</strong>：生成超市常用的EAN-13条形码，生成的条形码图片保存在文件夹<code>ean13code</code></p><p>8.<strong>二维码批量输出</strong>：生成常见的二维码，生成的二维码图片保存在文件夹<code>qrcode</code></p><p>部分结果展示：</p><img src="/python-pollcode/result.png" style="zoom:80%;"><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>下面的代码并未完全仿照原书的代码，对比原书的代码，我的代码删掉了许多无用的变量，删掉了tkinter模块，因为这个模块弹出的图形界面太卡了。再然后是每个功能生成编码的时候都使用set集合进行去重，会和原先的代码有很大差别。</p><p><img src="/python-pollcode/project.png"></p><center>项目的结构</center>## 代码<pre><code class="hljs python"><span class="hljs-keyword">import</span> os,random,time<span class="hljs-keyword">import</span> qrcode <span class="hljs-comment"># 二维码模块</span><span class="hljs-keyword">from</span> pystrich.ean13 <span class="hljs-keyword">import</span> EAN13Encoder <span class="hljs-comment">#条形码模块</span><span class="hljs-comment"># 初始化数据</span>number = <span class="hljs-string">&quot;1234567890&quot;</span>letter = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&quot;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mainmenu</span>():</span>    <span class="hljs-string">&#x27;&#x27;&#x27;企业编码管理系统主菜单&#x27;&#x27;&#x27;</span>    print(<span class="hljs-string">&quot;&quot;&quot;\033[1;35m</span><span class="hljs-string">      ****************************************************************</span><span class="hljs-string">                            企业编码生成系统</span><span class="hljs-string">      ****************************************************************</span><span class="hljs-string">          1.生成6位数字防伪编码 （213563型）</span><span class="hljs-string">          2.生成9位系列产品数字防伪编码(879-335439型)</span><span class="hljs-string">          3.生成25位混合产品序列号(B2R12-N7TE8-9IET2-FE35O-DW2K4型)</span><span class="hljs-string"></span><span class="hljs-string">          4.生成含数据分析功能的防伪编码(5A61M053D)</span><span class="hljs-string">          5.智能批量生成带数据分析功能的防伪码</span><span class="hljs-string">          6.后续补加生成防伪码</span><span class="hljs-string"></span><span class="hljs-string">          7.EAN-13条形码批量生成</span><span class="hljs-string">          8.二维码批量输出          </span><span class="hljs-string">          0.退出系统</span><span class="hljs-string">      ================================================================</span><span class="hljs-string">      说明：通过数字键选择菜单</span><span class="hljs-string">      ================================================================</span><span class="hljs-string">    \033[0m&quot;&quot;&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">input_validation</span>(<span class="hljs-params">insel</span>):</span>    <span class="hljs-string">&#x27;&#x27;&#x27;判断在主菜单的输入是否非法&#x27;&#x27;&#x27;</span>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">str</span>.isdigit(insel):  <span class="hljs-comment"># 验证是否是数字</span>        insel = <span class="hljs-built_in">int</span>(insel)  <span class="hljs-comment"># 这里需要将insel转成数字!</span>        <span class="hljs-keyword">return</span> insel    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">&quot;输入非法，请重新输入&quot;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mkdir</span>(<span class="hljs-params">path</span>):</span>    <span class="hljs-string">&#x27;&#x27;&#x27;创建文件夹&#x27;&#x27;&#x27;</span>    isexists = os.path.exists(path)    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isexists:        os.mkdir(path)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">openfile</span>(<span class="hljs-params">filename</span>):</span>    <span class="hljs-string">&#x27;&#x27;&#x27;读取文本文件&#x27;&#x27;&#x27;</span>    f = <span class="hljs-built_in">open</span>(filename)    fllist = f.read()    f.close()    <span class="hljs-keyword">return</span> fllist<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inputbox</span>(<span class="hljs-params">showstr, showorder, length</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    输入验证判断</span><span class="hljs-string">    :param showstr: 输入提示文字</span><span class="hljs-string">    :param showorder: 输入内容的类型,1.数字，不限位数，2.字母，3.数字且有位数要求</span><span class="hljs-string">    :param length: 输入内容的长度</span><span class="hljs-string">    :return:</span><span class="hljs-string">    &quot;&quot;&quot;</span>    instr = <span class="hljs-built_in">input</span>(showstr)    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(instr) != <span class="hljs-number">0</span>:        <span class="hljs-keyword">if</span> showorder == <span class="hljs-number">1</span>:            <span class="hljs-keyword">if</span> <span class="hljs-built_in">str</span>.isdigit(instr):  <span class="hljs-comment"># 验证是否是数字</span>                <span class="hljs-keyword">if</span> instr == <span class="hljs-number">0</span>:                    print(<span class="hljs-string">&quot;输入为0，请重新输入！&quot;</span>)                    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">return</span> instr            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 如果输入不是数字</span>                print(<span class="hljs-string">&quot;输入非法，请重新输入！&quot;</span>)                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>        <span class="hljs-keyword">if</span> showorder == <span class="hljs-number">2</span>:            <span class="hljs-keyword">if</span> <span class="hljs-built_in">str</span>.isalpha(instr):  <span class="hljs-comment"># 验证输入的内容是否是字母</span>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(instr) != length:  <span class="hljs-comment"># 输入位数不符</span>                    print(<span class="hljs-string">&quot;必须输入&quot;</span> + <span class="hljs-built_in">str</span>(length) + <span class="hljs-string">&quot;个字母，请重新输入！&quot;</span>)                    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">return</span> instr        <span class="hljs-keyword">if</span> showorder == <span class="hljs-number">3</span>:            <span class="hljs-keyword">if</span> <span class="hljs-built_in">str</span>.isdigit(instr):  <span class="hljs-comment"># 验证是否是数字</span>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(instr) != length:                    print(<span class="hljs-string">&quot;必须输入&quot;</span> + <span class="hljs-built_in">str</span>(length) + <span class="hljs-string">&quot;个数字，请重新输入！&quot;</span>)                    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">return</span> instr            <span class="hljs-keyword">else</span>:                print(<span class="hljs-string">&quot;输入非法，请重新输入！&quot;</span>)                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">&quot;输入为空，请重新输入！&quot;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wfile</span>(<span class="hljs-params">sstr, sfile, typeis, smsg, datapath</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    编码输出显示，同时保存文件</span><span class="hljs-string">    :param sstr: 生成的防伪码</span><span class="hljs-string">    :param sfile: 保存防伪码的文件名</span><span class="hljs-string">    :param typeis: 是否显示输出完成的防伪码，&quot;&quot;时显示提示框，&quot;no&quot;时不显示</span><span class="hljs-string">    :param smsg: 提示框显示的提示内容</span><span class="hljs-string">    :param datapath: 保存防伪码的路径</span><span class="hljs-string">    &quot;&quot;&quot;</span>    mkdir(datapath)    datafile = datapath + <span class="hljs-string">&#x27;\\&#x27;</span> + sfile  <span class="hljs-comment"># 设置保存防伪码的文件路径</span>    file = <span class="hljs-built_in">open</span>(datafile, <span class="hljs-string">&#x27;w&#x27;</span>)          <span class="hljs-comment"># 打开保存防伪码文件，不存在则创建,存在则会将其覆盖掉</span>    wrlist = <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>(sstr))         <span class="hljs-comment"># 将防伪码信息赋值给</span>    pdata = <span class="hljs-string">&quot;&quot;</span>                          <span class="hljs-comment"># 清空变量，pdata存储屏幕输出的防伪码信息</span>    wdata = <span class="hljs-string">&quot;&quot;</span>                          <span class="hljs-comment"># 清空变量，wdata存储保存到文本文件的防伪码信息</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(wrlist)):        wdata = <span class="hljs-built_in">str</span>(wrlist[i].replace(<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>))    <span class="hljs-comment"># 去掉字符的中括号</span>        wdata = wdata.replace(<span class="hljs-string">&#x27;&quot;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)             <span class="hljs-comment"># 去掉字符串中的引号</span>        file.write(<span class="hljs-built_in">str</span>(wdata))        pdata = pdata + wdata    file.close()    <span class="hljs-keyword">if</span> typeis != <span class="hljs-string">&quot;no&quot;</span>:        print(pdata)  <span class="hljs-comment"># 输出生成的防伪码信息</span>    print(smsg + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(wrlist)) + <span class="hljs-string">&quot;\n防伪码文件存放位置&quot;</span> + datafile)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">replace_strIndex</span>(<span class="hljs-params">string, char, index</span>):</span>    <span class="hljs-string">&#x27;&#x27;&#x27;将字符串中指定位置的字符进行替换&#x27;&#x27;&#x27;</span>    string = <span class="hljs-built_in">list</span>(string)       <span class="hljs-comment"># python str是不可变量，转换成列表</span>    string[index] = char    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(string)      <span class="hljs-comment"># return str(string) list转str的错误操作</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scode1</span>(<span class="hljs-params">schoice</span>):</span>    <span class="hljs-string">&#x27;&#x27;&#x27;生成6位数字防伪编码 （213563型）&#x27;&#x27;&#x27;</span>    incount = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入您要生成验证码的数量:\33[0m&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">while</span> <span class="hljs-built_in">int</span>(incount) == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 若输入为0则重新输入</span>        incount = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入您要生成验证码的数量:\33[0m&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)    coding_set = <span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 在创建空集合的时候，只能使用set()而不能使用&#123;&#125;，&#123;&#125;会创建成字典</span>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(coding_set) != <span class="hljs-built_in">int</span>(incount):        coding = <span class="hljs-string">&quot;&quot;</span>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):            coding = coding + random.choice(number)  <span class="hljs-comment"># 产生随机数因子</span>        coding = coding + <span class="hljs-string">&quot;\n&quot;</span>        coding_set.add(coding)  <span class="hljs-comment"># 将单条防伪码添加到保存批量验证码的变量中</span>    wfile(coding_set, <span class="hljs-string">&quot;scode&quot;</span> + <span class="hljs-built_in">str</span>(schoice) + <span class="hljs-string">&quot;.txt&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;已生成6位防伪码共计：&quot;</span>, <span class="hljs-string">&quot;codepath&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scode2</span>(<span class="hljs-params">schoice</span>):</span>    <span class="hljs-string">&#x27;&#x27;&#x27;生成9位数字系列产品防伪编码&#x27;&#x27;&#x27;</span>    beginNum = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入系列产品的数字起始号码（3位）:\33[0m&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)    <span class="hljs-keyword">while</span> <span class="hljs-built_in">int</span>(beginNum) == <span class="hljs-number">0</span>:        beginNum = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入系列产品的数字起始号码（3位）:\33[0m&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)    beginNum = <span class="hljs-built_in">int</span>(beginNum)    kindNum = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入产品系列的数量:\33[0m&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">while</span> <span class="hljs-built_in">int</span>(kindNum) == <span class="hljs-number">0</span>:        kindNum = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入产品系列的数量:\33[0m&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)    kindNum = <span class="hljs-built_in">int</span>(kindNum)    aloneNum = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入要生成的每个系列产品的防伪码数量:\33[0m&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">while</span> <span class="hljs-built_in">int</span>(aloneNum) == <span class="hljs-number">0</span>:        aloneNum = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入要生成的每个系列产品的防伪码数量:\33[0m&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)    aloneNum = <span class="hljs-built_in">int</span>(aloneNum)    coding_set = <span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 在创建空集合</span>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(kindNum):        beginNum = beginNum + <span class="hljs-number">1</span>  <span class="hljs-comment"># 更新前缀</span>        litter_coding_set = <span class="hljs-built_in">set</span>()        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(litter_coding_set) != aloneNum:            coding = <span class="hljs-built_in">str</span>(beginNum)  <span class="hljs-comment"># 每一次循环都重置coding</span>            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):                coding = coding + random.choice(number)            coding = coding + <span class="hljs-string">&quot;\n&quot;</span>            litter_coding_set.add(coding)        coding_set.update(litter_coding_set)    wfile(coding_set, <span class="hljs-string">&quot;scode&quot;</span> + <span class="hljs-built_in">str</span>(schoice) + <span class="hljs-string">&quot;.txt&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;已生成9位系列产品防伪码共计：&quot;</span>, <span class="hljs-string">&quot;codepath&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scode3</span>(<span class="hljs-params">schoice</span>):</span>    <span class="hljs-string">&#x27;&#x27;&#x27;生成25位混合产品序列号&#x27;&#x27;&#x27;</span>    incountNum = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入要生成的25位混合产品序列号数量:\33[0m&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">while</span> <span class="hljs-built_in">int</span>(incountNum) == <span class="hljs-number">0</span>:        incountNum = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入要生成的25位混合产品序列号数量:\33[0m&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)    incountNum = <span class="hljs-built_in">int</span>(incountNum)    coding_set = <span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 在创建空集合</span>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(coding_set) != incountNum:        randstrtmp = <span class="hljs-string">&quot;&quot;</span>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):            coding = <span class="hljs-string">&quot;&quot;</span>            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):                coding = coding + random.choice(letter)            <span class="hljs-keyword">if</span> k == <span class="hljs-number">4</span>:                coding = coding + <span class="hljs-string">&quot;\n&quot;</span>            <span class="hljs-keyword">else</span>:                coding = coding + <span class="hljs-string">&quot;-&quot;</span>            randstrtmp = randstrtmp + coding        coding_set.add(randstrtmp)    wfile(coding_set, <span class="hljs-string">&quot;scode&quot;</span> + <span class="hljs-built_in">str</span>(schoice) + <span class="hljs-string">&quot;.txt&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;已生成25位混合产品序列号共计：&quot;</span>, <span class="hljs-string">&quot;codepath&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scode4</span>(<span class="hljs-params">schoice</span>):</span>    <span class="hljs-string">&#x27;&#x27;&#x27;生成含数据分析功能的防伪编码</span><span class="hljs-string">    主要由3位字母和6位数字组成，并且字母位置随机，但是首字母对应不同地区，</span><span class="hljs-string">    次字母对应产品颜色，最后的字母对应产品批次</span><span class="hljs-string">    &#x27;&#x27;&#x27;</span>    inLetter = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入数据分析编号的三位字母:\33[0m&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> inLetter.isalpha() <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(inLetter) != <span class="hljs-number">3</span>:        inLetter = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入数据分析编号的三位字母:\33[0m&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)    incountNum = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入要生成的带数据分析功能的防伪码数量:\33[0m&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">while</span> <span class="hljs-built_in">int</span>(incountNum) == <span class="hljs-number">0</span>:        incountNum = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入要生成的带数据分析功能的防伪码数量:\33[0m&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)    incountNum = <span class="hljs-built_in">int</span>(incountNum)    coding_set = <span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 在创建空集合</span>    let = [inLetter[j].upper() <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(coding_set) != incountNum:        indexNum = <span class="hljs-string">&quot;012345678&quot;</span>                  <span class="hljs-comment"># 数字索引，不需要9</span>        ranIndex = random.sample(indexNum, <span class="hljs-number">3</span>)   <span class="hljs-comment"># sample函数的作用是从number中获取三个不重复的值，将结果作为list返回</span>        ranIndex = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, ranIndex))        ranIndex = <span class="hljs-built_in">sorted</span>(ranIndex)             <span class="hljs-comment"># 对结果进行排序</span>        myNum = <span class="hljs-string">&quot;&quot;</span>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):            myNum = myNum + random.choice(number)        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):            myNum = replace_strIndex(myNum, let[n], ranIndex[n])        myNum = myNum + <span class="hljs-string">&quot;\n&quot;</span>        coding_set.add(myNum)    wfile(coding_set, <span class="hljs-string">&quot;scode&quot;</span> + <span class="hljs-built_in">str</span>(schoice) + <span class="hljs-string">&quot;.txt&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;已生成9位含数据分析功能的防伪编码共计：&quot;</span>, <span class="hljs-string">&quot;codepath&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scode5</span>(<span class="hljs-params">schoice</span>):</span>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">    智能批量生成带数据分析功能的防伪码</span><span class="hljs-string">    利用文件批量生成数据</span><span class="hljs-string">    &#x27;&#x27;&#x27;</span>    file_path = <span class="hljs-string">&quot;plcode.mri&quot;</span>            <span class="hljs-comment"># 设置默认打开的文件名称</span>    codelist = openfile(file_path)      <span class="hljs-comment"># 读取从文件选择对话框中选择的文件</span>    codelist = codelist.split(<span class="hljs-string">&quot;\n&quot;</span>)     <span class="hljs-comment"># 把读取的内容以回车分割，饭会分割后的列表</span>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> codelist:        codea = item.split(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 将每一行按照“,”分割，逗号前的存储为防伪码标准信息</span>        codeb = item.split(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 将每一行按照“,”分割，逗号后的存储为防伪码生成数量</span>        coding_set = <span class="hljs-built_in">set</span>()          <span class="hljs-comment"># 在创建空集合</span>        let = [codea[j].upper() <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(codea))] <span class="hljs-comment"># 将字母转成大写</span>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(coding_set) != <span class="hljs-built_in">int</span>(codeb):            indexNumber = <span class="hljs-string">&quot;012345678&quot;</span>            ranIndex = random.sample(indexNumber, <span class="hljs-number">3</span>)  <span class="hljs-comment"># 随机取三个不重复的数</span>            ranIndex = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, ranIndex))       <span class="hljs-comment"># 将ranIndex转成数字</span>            ranIndex = <span class="hljs-built_in">sorted</span>(ranIndex)            myNum = <span class="hljs-string">&quot;&quot;</span>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):                myNum = myNum + random.choice(number)            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):                myNum = replace_strIndex(myNum, let[m], ranIndex[m])            myNum = myNum + <span class="hljs-string">&quot;\n&quot;</span>            coding_set.add(myNum)        wfile(coding_set, codea + <span class="hljs-string">&quot;scode&quot;</span> + <span class="hljs-built_in">str</span>(schoice) + <span class="hljs-string">&quot;.txt&quot;</span>, <span class="hljs-string">&quot;no&quot;</span>, <span class="hljs-string">&quot;已生成9位含数据分析功能的防伪编码共计：&quot;</span>, <span class="hljs-string">&quot;codepath&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scode6</span>(<span class="hljs-params">schoice</span>):</span>    <span class="hljs-string">&#x27;&#x27;&#x27;后续补加生成防伪码&#x27;&#x27;&#x27;</span>    print(<span class="hljs-string">&quot;\033[1;32m     本功能只针对于功能5的数据文件做添加操作！:\33[0m&quot;</span>)    file_name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要补加防伪码的文件名称：&quot;</span>)    file_path = <span class="hljs-string">r&quot;./codepath/&quot;</span> + file_name    fileData = openfile(file_path)          <span class="hljs-comment"># 获取文件数据</span>    fileData_list = fileData.split(<span class="hljs-string">&quot;\n&quot;</span>)    <span class="hljs-comment"># 将文件数据转成List</span>    fileData_list.pop()                     <span class="hljs-comment"># 文件读取的最后一行为空格，删除</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(fileData_list)):        fileData_list[i] = fileData_list[i] + <span class="hljs-string">&quot;\n&quot;</span>    print(<span class="hljs-string">&quot;之前生成的防伪码数量共计：&quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(fileData_list)) + <span class="hljs-string">&quot;个&quot;</span>)    fileData_set = <span class="hljs-built_in">set</span>(fileData_list)       <span class="hljs-comment"># 将list转成set,保证元素不重复</span>    incountNum = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入要补加的带数据分析功能的防伪码数量:\33[0m&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">while</span> <span class="hljs-built_in">int</span>(incountNum) == <span class="hljs-number">0</span>:        incountNum = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入要补加的带数据分析功能的防伪码数量:\33[0m&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)    incountNum = <span class="hljs-built_in">int</span>(incountNum)    let = [file_name[j].upper() <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]    <span class="hljs-comment"># 获取三个字母</span>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(fileData_set) - <span class="hljs-built_in">len</span>(fileData_list) != incountNum:        indexNumber = <span class="hljs-string">&quot;012345678&quot;</span>        ranIndex = random.sample(indexNumber, <span class="hljs-number">3</span>)    <span class="hljs-comment"># 随机取三个不重复的数</span>        ranIndex = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, ranIndex))         <span class="hljs-comment"># 将ranIndex转成数字</span>        ranIndex = <span class="hljs-built_in">sorted</span>(ranIndex)        myNum = <span class="hljs-string">&quot;&quot;</span>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):            myNum = myNum + random.choice(number)        <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):            myNum = replace_strIndex(myNum, let[m], ranIndex[m])        myNum = myNum + <span class="hljs-string">&quot;\n&quot;</span>        fileData_set.add(myNum)    print(<span class="hljs-string">&quot;已经新生成的防伪码数量共计：&quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(fileData_set) - <span class="hljs-built_in">len</span>(fileData_list)) + <span class="hljs-string">&quot;个&quot;</span>)    wfile(fileData_set, file_name[:<span class="hljs-number">3</span>] + <span class="hljs-string">&quot;scode&quot;</span> + <span class="hljs-built_in">str</span>(schoice) + <span class="hljs-string">&quot;.txt&quot;</span>, <span class="hljs-string">&quot;no&quot;</span>, <span class="hljs-string">&quot;已生成9位含数据分析功能的防伪编码共计：&quot;</span>, <span class="hljs-string">&quot;codepath&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scode7</span>(<span class="hljs-params">schoice</span>):</span>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">    实现条形码的输出</span><span class="hljs-string">    EAN-13是一种常见的条形码，多用于超市和零售市场</span><span class="hljs-string">    EAN-13： European Article Number，共计13位</span><span class="hljs-string">    前3位为国家码(中国大陆是690-695)，4-7位为企业码，8-12位为商品码，第13位是校验位</span><span class="hljs-string">    校验位的计算：</span><span class="hljs-string">    1、前12位的偶数位相加</span><span class="hljs-string">    2、前12位的奇数位相加</span><span class="hljs-string">    3、将偶数位的和的三倍与奇数位的和相加</span><span class="hljs-string">    4、取出得到的和的个位</span><span class="hljs-string">    5、由10减去这个个位数，再将得到的结果取个位即可</span><span class="hljs-string">    &#x27;&#x27;&#x27;</span>    nationId = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入EAN-13的国家码（3位）:\33[0m&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)    <span class="hljs-keyword">while</span> <span class="hljs-built_in">int</span>(nationId) == <span class="hljs-number">0</span>:        nationId = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入EAN-13的国家码（3位）:\33[0m&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)    compId = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入EAN-13的企业码（4位）:\33[0m&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)    <span class="hljs-keyword">while</span> <span class="hljs-built_in">int</span>(compId) == <span class="hljs-number">0</span>:        compId = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入EAN-13的企业码（4位）:\33[0m&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)    codeNum = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入要生成的条形码的数量 :\33[0m&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">while</span> <span class="hljs-built_in">int</span>(codeNum) == <span class="hljs-number">0</span>:        codeNum = (<span class="hljs-string">&quot;\033[1;32m     请输入要生成的条形码的数量 :\33[0m&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)    codeNum = <span class="hljs-built_in">int</span>(codeNum)    codeNum_set = <span class="hljs-built_in">set</span>()    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(codeNum_set) != codeNum:        sellId  = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># 商品码</span>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):            sellId = sellId + random.choice(number)        sellId = nationId + compId + sellId <span class="hljs-comment"># 商品码前缀添加国家码与企业码</span>        <span class="hljs-comment"># 生成校验码</span>        oushu = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">11</span>,<span class="hljs-number">2</span>):            oushu = oushu + <span class="hljs-built_in">int</span>(sellId[k])        jishu = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">2</span>):            jishu = jishu + <span class="hljs-built_in">int</span>(sellId[k])        jiaoyan = (<span class="hljs-number">10</span> - (oushu*<span class="hljs-number">3</span> + jishu)%<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>        sellId = sellId + <span class="hljs-built_in">str</span>(jiaoyan)        codeNum_set.add(sellId)    <span class="hljs-comment"># 生成激活码，并且保存</span>    wfile(codeNum_set, <span class="hljs-string">&quot;scode&quot;</span> + <span class="hljs-built_in">str</span>(schoice) + <span class="hljs-string">&quot;.txt&quot;</span>, <span class="hljs-string">&quot;no&quot;</span>, <span class="hljs-string">&quot;已生成EAN-13条形码共计：&quot;</span>, <span class="hljs-string">&quot;codepath&quot;</span>)    codeNum_list = <span class="hljs-built_in">list</span>(codeNum_set)    mkdir(<span class="hljs-string">&quot;ean13code&quot;</span>)    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(codeNum):        encoder = EAN13Encoder(codeNum_list[index])        encoder.save(<span class="hljs-string">&quot;ean13code\\&quot;</span>+codeNum_list[index]+<span class="hljs-string">&quot;.png&quot;</span>)    print(<span class="hljs-string">&quot;ean-13的全部条形码保存在&quot;</span>+<span class="hljs-string">&quot;ean13code文件夹下&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scode8</span>(<span class="hljs-params">schoice</span>):</span>    codeNum = inputbox(<span class="hljs-string">&quot;\033[1;32m     请输入要生成的12位数字二维码的数量 :\33[0m&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">while</span> <span class="hljs-built_in">int</span>(codeNum) == <span class="hljs-number">0</span>:        codeNum = (<span class="hljs-string">&quot;\033[1;32m     请输入要生成的条形码的数量 :\33[0m&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)    codeNum = <span class="hljs-built_in">int</span>(codeNum)    codeNum_set = <span class="hljs-built_in">set</span>()    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(codeNum_set) != codeNum:        qrRanCode = <span class="hljs-string">&quot;&quot;</span>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">12</span>):            qrRanCode = qrRanCode + random.choice(number)        codeNum_set.add(qrRanCode)    wfile(codeNum_set, <span class="hljs-string">&quot;scode&quot;</span> + <span class="hljs-built_in">str</span>(schoice) + <span class="hljs-string">&quot;.txt&quot;</span>, <span class="hljs-string">&quot;no&quot;</span>, <span class="hljs-string">&quot;已生成12位数字二维码共计：&quot;</span>, <span class="hljs-string">&quot;codepath&quot;</span>)    mkdir(<span class="hljs-string">&quot;qrcode&quot;</span>)    codeNum_list = <span class="hljs-built_in">list</span>(codeNum_set)    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(codeNum_list)):        encoder = qrcode.make(codeNum_list[j])        encoder.save(<span class="hljs-string">&quot;qrcode\\&quot;</span>+codeNum_list[j]+<span class="hljs-string">&quot;.png&quot;</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mainpro</span>():</span>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">    通过循环控制用户对程序功能的选择</span><span class="hljs-string">    &#x27;&#x27;&#x27;</span>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        mainmenu()   <span class="hljs-comment"># 调入程序主界面菜单</span>        choice = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;\033[1;32m     请输入您要操作的菜单选项:\33[0m&quot;</span>)      <span class="hljs-comment"># 键盘输入需要操作的选项</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(choice) != <span class="hljs-number">0</span>:            choice = input_validation(choice) <span class="hljs-comment"># 验证输入是否为数字</span>            <span class="hljs-keyword">if</span> choice == <span class="hljs-number">1</span>:                scode1(choice)            <span class="hljs-keyword">if</span> choice == <span class="hljs-number">2</span>:                scode2(choice)            <span class="hljs-keyword">if</span> choice == <span class="hljs-number">3</span>:                scode3(choice)            <span class="hljs-keyword">if</span> choice == <span class="hljs-number">4</span>:                scode4(choice)            <span class="hljs-keyword">if</span> choice == <span class="hljs-number">5</span>:                scode5(choice)            <span class="hljs-keyword">if</span> choice == <span class="hljs-number">6</span>:                scode6(choice)            <span class="hljs-keyword">if</span> choice == <span class="hljs-number">7</span>:                scode7(choice)            <span class="hljs-keyword">if</span> choice == <span class="hljs-number">8</span>:                scode8(choice)            <span class="hljs-keyword">if</span> choice == <span class="hljs-number">0</span>:                print(<span class="hljs-string">&quot;正在退出系统!!&quot;</span>)                <span class="hljs-keyword">break</span>        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">&quot;\033[1;31;40m    输入非法，请重新输入！！\033[0m&quot;</span>)            time.sleep(<span class="hljs-number">2</span>)<span class="hljs-comment"># 程序的执行</span>mainpro()</code></pre><h2 id="相关知识总结"><a href="#相关知识总结" class="headerlink" title="相关知识总结"></a>相关知识总结</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><pre><code class="hljs python">let = []<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>): <span class="hljs-comment">#都转成大写字母</span>let[j] = inLetter[j].upper()  <span class="hljs-comment"># 错误写法！数组越界</span>    <span class="hljs-comment">#########正确的写法#############</span><span class="hljs-comment"># 法1：列表生成式</span>let = [inLetter[j].upper() <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]<span class="hljs-comment"># 法2：append方法</span>let = []<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):    let.append(inLetter[j].upper())</code></pre><p>列表中的每个元素都是字母，转换成数字</p><pre><code class="hljs python">indexNum = <span class="hljs-string">&quot;012345678&quot;</span>  <span class="hljs-comment"># 数字索引，不需要9</span>ranIndex = random.sample(indexNum, <span class="hljs-number">3</span>)  <span class="hljs-comment"># sample函数的作用是从number中获取三个不重复的值，将结果作为list返回</span>ranIndex = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, ranIndex))</code></pre><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>替换字符串指定位置的字母</p><pre><code class="hljs python"><span class="hljs-comment"># 函数：将字符串中指定位置的字符进行替换</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">replace_strIndex</span>(<span class="hljs-params">string,char,index</span>):</span>    string = <span class="hljs-built_in">list</span>(string) <span class="hljs-comment">#python str是不可变量，转换成列表</span>    string[index] = char    <span class="hljs-comment">#return str(string) list转str的错误操作</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(string)</code></pre><p>list转str的方式</p><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;</span>.join(string)</code></pre><h3 id="random的用法"><a href="#random的用法" class="headerlink" title="random的用法"></a>random的用法</h3><pre><code class="hljs python">random.choice(seq) <span class="hljs-comment">#返回列表、元组、字符串中的任意一项</span>random.sample(indexNum, <span class="hljs-number">3</span>) <span class="hljs-comment"># sample函数的作用是从number中获取三个不重复的值，将结果作为list返回</span></code></pre><h3 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h3><p>使用set集合来确保无重复。但是set集合顺序不固定，不能使用索引的方式访问元素</p><pre><code class="hljs python">mylet_set = &#123;<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>&#125; <span class="hljs-comment">#set初始化方式一，但不能使用空的&#123;&#125;进行初始化，这样初始化生成的是字典</span>mynum_set = <span class="hljs-built_in">set</span>() <span class="hljs-comment">#set初始化方式二，可生成一个空的set</span>mynum_set.add() <span class="hljs-comment">#增加元素</span>mynum_set.pop() <span class="hljs-comment">#随机删除一个元素</span>mynum_set.update(mylet_set) <span class="hljs-comment">#将两个集合合并在一起</span><span class="hljs-comment"># list --&gt; set</span>mynum_list = <span class="hljs-built_in">list</span>(mynum_set)</code></pre><h2 id="吐槽一下"><a href="#吐槽一下" class="headerlink" title="吐槽一下"></a>吐槽一下</h2><p>《Python项目开发案例集锦》这本书关于这个项目的教程……，书中代码有错误的部分，与提供的源代码不匹配；关于编码不能重复的问题，前几个功能它一直都没考虑过编码重复的这个问题，到功能6的时候开始考虑了，这个真是有点随意。还有给变量起名的确不是一件容易的事情，命名真是一塌糊涂。</p><h2 id="代码的可执行文件获取以及书籍下载"><a href="#代码的可执行文件获取以及书籍下载" class="headerlink" title="代码的可执行文件获取以及书籍下载"></a>代码的可执行文件获取以及书籍下载</h2><p>代码的可执行文件：<a href="https://pan.baidu.com/s/1YWwPQVp9CYvrGyy31CUPpw">https://pan.baidu.com/s/1YWwPQVp9CYvrGyy31CUPpw</a>  提取码：kv7v</p><p>《Python项目开发案例集锦》书籍及源码下载：<a href="https://pan.baidu.com/s/154xVwvRV1E5U476iY_EJXw">https://pan.baidu.com/s/154xVwvRV1E5U476iY_EJXw</a><br>提取码：wc8x</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件下载</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次在Win+Ubuntu双平台编译软件Aseprite</title>
    <link href="/compile-aseprite/"/>
    <url>/compile-aseprite/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：skia，ninja，事件查看器，进程浏览器，dos2unix，以及Aseprite软件分享。</p><p> 绝大多数情况下你并不孤单，你踩过的坑里尽是前人的脚印。</p><a id="more"></a><hr><p>偶然发现了aseprite这个像素画软件，看到有在steam售卖，但是软件全是开源的，自行编译就可以使用，于是访问了它的github想尝试编译出两个平台的软件。前前后后折腾了好几天，最终Windows编译成功，Ubuntu编译失败，想记录一下在编译过程中接触到的一些东西。</p><h2 id="编译Aseprite需要使用的环境工具"><a href="#编译Aseprite需要使用的环境工具" class="headerlink" title="编译Aseprite需要使用的环境工具"></a>编译Aseprite需要使用的环境工具</h2><ul><li><strong>CMake</strong>： CMake是一个跨平台的安装（编译）工具 </li><li><strong>Ninja</strong>： Ninja 是Google的一名程序员推出的注重速度的构建工具，一般在Unix/Linux上的程序通过make/makefile来构建编译，而Ninja通过将编译任务并行组织，大大提高了构建速度。 </li><li><strong>Skia</strong>： Skia 是一个 Google 开源的 C++ 二维图形库，提供各种常用的API，并可在多种软硬件平台上运行。 </li></ul><h2 id="Windows编译Aseprite"><a href="#Windows编译Aseprite" class="headerlink" title="Windows编译Aseprite"></a>Windows编译Aseprite</h2><p> 在Windows平台编译主要是参考了这个视频：<a href="https://www.bilibili.com/video/av69832640/">https://www.bilibili.com/video/av69832640/</a> </p><p>UP主很贴心的做了一份教程并且分享了文档。</p><blockquote><p>1.前往<a href="https://visualstudio.microsoft.com/zh-hans/vs/%E4%B8%8B%E8%BD%BDVisual">https://visualstudio.microsoft.com/zh-hans/vs/下载Visual</a> Studio Community<br>2.勾选“使用C++的桌面开发”并以默认目录安装Visual Studio<br>3.前往<a href="https://cmake.org/download/%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85CMake">https://cmake.org/download/下载安装CMake</a><br>4.检查环境变量设置，删除MinGW相关环境变量（若存在）<br>5.前往<a href="https://github.com/ninja-build/ninja/releases%E4%B8%8B%E8%BD%BDNinja-win%EF%BC%8C%E8%A7%A3%E5%8E%8B%E6%94%BE%E5%85%A5CMake%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95/bin">https://github.com/ninja-build/ninja/releases下载Ninja-win，解压放入CMake安装目录\bin</a><br>6.前往<a href="https://pan.baidu.com/s/1FoEA_Oep00MrGFn6j6yStQ%E4%B8%8B%E8%BD%BDskia%E4%BE%9D%E8%B5%96%E5%8C%85%EF%BC%8C%E5%B9%B6%E8%A7%A3%E5%8E%8B%E5%88%B0%E4%BB%BB%E6%84%8F%E7%9B%AE%E5%BD%95">https://pan.baidu.com/s/1FoEA_Oep00MrGFn6j6yStQ下载skia依赖包，并解压到任意目录</a><br>7.前往<a href="https://github.com/aseprite/aseprite/releases%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%89%88Aseprite%E6%BA%90%E7%A0%81%EF%BC%8C%E5%B9%B6%E8%A7%A3%E5%8E%8B%E5%88%B0%E4%BB%BB%E6%84%8F%E7%9B%AE%E5%BD%95">https://github.com/aseprite/aseprite/releases下载最新版Aseprite源码，并解压到任意目录</a><br>8.打开命令提示符CMD，执行：</p><pre><code class="hljs bash">call <span class="hljs-string">&quot;Visual Studio的路径\2019\Community\Common7\Tools\VsDevCmd.bat&quot;</span> -arch=x64<span class="hljs-built_in">cd</span> /d <span class="hljs-string">&quot;aseprite源码路径&quot;</span>mkdir build<span class="hljs-built_in">cd</span> buildcmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DLAF_OS_BACKEND=skia -DSKIA_DIR=<span class="hljs-string">&quot;skia路径&quot;</span> -DSKIA_OUT_DIR=<span class="hljs-string">&quot;skia路径\out\Release&quot;</span> -G Ninja ..ninja aseprite</code></pre><p><strong>注意上面的各种路径都是要替换成为你的实际的路径，而且最好不要有中文。</strong></p></blockquote><p>UP主很贴心的分享了skia的依赖包，于是编译就变得很简单，跟着教程做一遍就可以成功。</p><h2 id="分享Windows版本的Aseprite"><a href="#分享Windows版本的Aseprite" class="headerlink" title="分享Windows版本的Aseprite"></a>分享Windows版本的Aseprite</h2><p>我本想着编译完成之后，保留一份一直使用下去，于是换了另一台电脑尝试使用这个软件，但是报错说缺少两个dll文件，于是我就上百度下载了这两个文件，结果依旧是报错<strong>0xc0150002</strong>，无法打开。</p><p>然后我就开始百度查找问题的解决方案了，最终找到了一些教程：</p><h3 id="windows事件查看器"><a href="#windows事件查看器" class="headerlink" title="windows事件查看器"></a>windows事件查看器</h3><p>使用windows的搜索搜事件查看器，进入之后，点击“Windows日志”  –&gt;  “应用程序”然后就可以看到关于Windows应用程序的事件和信息了，找错误的信息就可以看到错误的具体原因是什么了。</p><p><img src="/compile-aseprite/win-event-viewer.png"></p><blockquote><p> 参考链接：<a href="https://blog.csdn.net/znlangel/article/details/85341730">无法正常启动，错误0xc0150002</a></p></blockquote><p>虽然找到了错误的原因，但是百度不到问题的解决方案，于是我怀疑是网上下载的dll和我原先电脑的dll不一样，于是使用了<a href="https://www.voidtools.com/zh-cn/">Everything</a>来查找缺少的dll存在于我电脑的哪里，结果缺少的两个dll在我的电脑里都有6、7个，我该怎么知道我编译的这个程序到底是使用的哪里的dll呢？</p><h3 id="Windows-Process-Explorer进程浏览器"><a href="#Windows-Process-Explorer进程浏览器" class="headerlink" title="Windows Process Explorer进程浏览器"></a>Windows Process Explorer进程浏览器</h3><p>一番搜索之后找到了一个工具，可以查看一个正在运行的程序使用的dll。这个程序叫做Process Explorer，这是它的下载网站：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer">https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer</a></p><p>在它的主界面，点击 View –&gt;  Lower Pane View ，然后勾选DLLs，然后还要点击勾选 View –&gt;  Show Lower Pane 。这样就可以看到一个运行的程序的使用的dll了。</p><p><img src="/compile-aseprite/Process-Explorer.png"></p><p>然后去dll对应的路径中把这个软件需要用到的dll都拷贝的与那个软件exe同级的目录下。亲测成功使用。</p><hr><p>分享一下我编译出的软件，以及我找到的简体中文插件以及主题插件。</p><p>Windows Aseprite v1.3 链接:<a href="https://pan.baidu.com/s/1L9gyzMpqIZnJv_-0Pu2N7g">https://pan.baidu.com/s/1L9gyzMpqIZnJv_-0Pu2N7g</a> </p><p>提取码:7u9f</p><hr><h2 id="Ubuntu编译软件"><a href="#Ubuntu编译软件" class="headerlink" title="Ubuntu编译软件"></a>Ubuntu编译软件</h2><p>ubuntu编译着实是让头大不已，没有搜到任何的教程，参照官方的install.md的说明，配置skia配置到绝望。</p><blockquote><p>简单吐槽一下：</p><p>首先skia只能通过git工具下载，其次那个网站国内无法访问，开始找了半天的ubuntu可以使用的vpn，最后无果，于是乎决定用windows下载skia，结果git工具没有走梯子的代理，无法下载，最后解决完这个问题后终于下载了下来。但是事情远远没有那么简单，windows的文本不同于Linux的文本，换行格式不一样，linux运行总是报错，将格式转完之后，开始编译，发现官方文档安装的有一步还需要联网，但是ubuntu没找到可以翻墙的方法，多番尝试无果之后，放弃了。前前后后花了四天时间，最终还是编译失败。很纳闷为什么我这平常的网络甚至连github都不能访问了。</p></blockquote><h3 id="windows下git工具走梯子代理"><a href="#windows下git工具走梯子代理" class="headerlink" title="windows下git工具走梯子代理"></a>windows下git工具走梯子代理</h3><p>现象，连着梯子发现可以打开这个网站，但是使用git工具下载时总是连接超时，原因可能是<strong>终端没有走代理</strong>。</p><pre><code class="hljs bash">git config --global http.proxy <span class="hljs-string">&quot;localhost:1080&quot;</span></code></pre><p>在git的命令行里使用上述命令，注意1080是我电脑上梯子使用的端口，使用时记得改成梯子对应的端口号。</p><blockquote><p>参考链接：<a href="https://www.cnblogs.com/zheng-chuang/p/11261713.html">git clone https://chromium.googlesource.com/失败</a></p></blockquote><h3 id="文本在Windows与Linux中行结尾标志不同"><a href="#文本在Windows与Linux中行结尾标志不同" class="headerlink" title="文本在Windows与Linux中行结尾标志不同"></a>文本在Windows与Linux中行结尾标志不同</h3><p>在Windows中使用连续的<code>\r</code>和<code>\n</code>两个字符来换行，而Linux中仅使用<code>\n</code>进行换行，<code>\r</code>被认为是回车。</p><p>所以当我把在Windows上git下载的东西拷贝到Ubuntu上之后，执行的时候会出现类似这种错误：<code>/usr/bin/env: bash \r :No such file or directory</code>。</p><h3 id="dos2unix-——-Windows与Linux文件转换"><a href="#dos2unix-——-Windows与Linux文件转换" class="headerlink" title="dos2unix —— Windows与Linux文件转换"></a>dos2unix —— Windows与Linux文件转换</h3><p>安装：</p><pre><code class="hljs bash">sudo apt-get install dos2unix</code></pre><p>然后进行批量转换</p><pre><code class="hljs bash">find . -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">exec</span> dos2unix  &#123;&#125; \;// 点号（.）表示当前目录，f表示文本格式，&#123;&#125;与dos2unix间有空格，<span class="hljs-string">&quot;\ &quot;</span>和<span class="hljs-string">&quot;;&quot;</span>之间不能空格。</code></pre><blockquote><p>参考链接：</p><p><a href="https://blog.csdn.net/NiYintang/article/details/86124338?utm_source=app">Linux异常解决：/usr/bin/env python\r no such file or directory</a> </p><p><a href="https://blog.csdn.net/renlonggg/article/details/52944915?utm_source=app">批量执行dos2unix,unix2dos</a></p></blockquote><h3 id="skia"><a href="#skia" class="headerlink" title="skia"></a>skia</h3><p>吐槽一下，太难安装了，不过也接触到了一些东西，比如gn命令，还有这里面用的python2</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多看官方的文档，主要按照官方的安装文档来进行操作。</p><p>然后就是面对问题的心态：多搜索思考，不要浮躁。虽然没有编译成功，不过印证了之前看过的一句话：绝大多数情况下你并不孤单，你踩过的坑里尽是前人的脚印。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件下载</tag>
      
      <tag>SOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下安装QT5</title>
    <link href="/qt5setupInLinux/"/>
    <url>/qt5setupInLinux/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：Ubuntu下安装QT5，QT5项目编译时可能缺少libGL库。</p><a id="more"></a><blockquote><p>相关版本：</p><p>gcc version 7.4.0 (Ubuntu 7.4.0-1ubuntu1~18.04.1)</p><p>QT 5.11.1</p></blockquote><h2 id="Ubuntu下安装QT5"><a href="#Ubuntu下安装QT5" class="headerlink" title="Ubuntu下安装QT5"></a>Ubuntu下安装QT5</h2><p>在官网下载安装包：<a href="http://download.qt.io/archive/qt/5.11/5.11.1/">http://download.qt.io/archive/qt/5.11/5.11.1/</a> </p><p>下载<code>qt-opensource-linux-x64-5.11.1.run</code> 及后缀为 <code>.run</code> 的版本。</p><p>下载后更改这个文件的执行权限 <code>chmod a+x qt-opensource-linux-x64-5.11.1.run</code></p><p>然后在 <code>/opt/</code> 这个目录下创建一个文件夹<code>qt</code>. 这是我决定的安装目录。</p><p>之后在终端运行安装包 <code>./qt-opensource-linux-x64-5.11.1.run</code></p><p>弹出的界面就像windows安装Qt的界面一样，安装过程也基本类似。注意将安装路径指定到之前创建好的目录。</p><p>然后选择组建的时候：Tools是必选的，而Qt5.11.1 里把<code>Desktop gcc 64-bit</code> 选择上，其他看需求。</p><p>安装完成之后，默认会帮我们启动Qt creator。</p><p><strong>注意</strong>：我在2020-02-27日安装QT的时候，必须需要QT账号了，无法跳过，必须注册一个。</p><h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><p>跟着几篇文章盲目做的，不知道到底对结果有没有影响。</p><blockquote><p>ubuntu中的环境变量配置文件一般为/etc/profile, 所以修改该文件：<code>sudo vim /etc/profile</code><br>打开文件之后在文件的最后加入两行：(顺带复习以下vim怎么用)<br> export PATH=”/opt/qt/Tools/QtCreator/bin:$PATH”<br> export PATH=”/opt/qt/5.11.1/gcc_64/bin:$PATH”<br> 注：/opt/qt是我的Qt的安装路径</p></blockquote><blockquote><p>参考链接：<a href="https://blog.csdn.net/new_delete_/article/details/82948347">ubuntu18.04 安装qt5.11.1及环境配置</a></p></blockquote><h2 id="Qt-Linux-Hello-World"><a href="#Qt-Linux-Hello-World" class="headerlink" title="Qt Linux Hello World"></a>Qt Linux Hello World</h2><p>打开Qt create，创建一个默认的项目，即<code>Qt Widgets Application</code>，选择好项目的存储路径以及工程名，然后下一步，在<code>Kits</code> 那个页面，如果安装的时候勾选了<code>Desktop gcc 64-bit</code>，就会有一个默认的<code>桌面(Desktop)</code>，如果没有貌似就需要自行配置了。之后一直点next，默认会创建一个含有空窗口的项目。</p><p>点击左下角的运行按钮，观察结果。</p><p><img src="/qt5setupInLinux/err.png"></p><p>我在这里碰到了两个问题。第一个：<code>cannot find -IGL</code>，说明没有安装 <code>libGL库</code> 。在终端执行</p><p><code>sudo apt-get install libgl1-mesa-dev</code> </p><p>来进行安装。</p><blockquote><p> 参考链接：<a href="https://blog.csdn.net/m0_37688984/article/details/80216123">在Ubuntu下搭建Qt开发环境和Qt creator</a></p></blockquote><p>第二个问题：<code>Circular all &lt;- first dependency dropped</code>。原因竟然是因为我的工程名是<code>first</code>，而Qt使用了first这个单词作为生成的Makefile文件的内置项，导致make在处理Makefile时产生依赖错误。</p><p>有点苦笑不得。</p><blockquote><p> 参考链接：<a href="https://www.cnblogs.com/csuftzzk/archive/2013/07/18/3198154.html">Linux平台Qt creator报错：Circular all &lt;- first dependency dropped</a></p></blockquote><h2 id="最尴尬的事情"><a href="#最尴尬的事情" class="headerlink" title="最尴尬的事情"></a>最尴尬的事情</h2><p>安装完Qt Creator并测试完样例之后，就关掉了它，然后惊喜的发现，Ubuntu的软件列表里，竟然没有 Qt Creator 的图标！那我怎么打开这个软件？？？</p><p>返回到安装目录 <code>/opt/qt</code>中去找 Qt Creator ，最终在<code>/opt/qt/Tools/QtCreator/bin/</code>路径下找到了，然后做一个软链接放到桌面上，这样打开就容易一些。</p><pre><code class="hljs bash">ln -s /opt/qt/Tools/QtCreator/bin/qtcreator /home/colourso/桌面/QtCreators</code></pre><p><code>QtCreators</code> 是我的软链接的名称，可以随便起名。</p><p>PS：参考链接都放在文中了，文末就不放了。祈愿 2019-nCoV 新型冠状病毒早日被解决，武汉加油！</p><h2 id="QT的卸载"><a href="#QT的卸载" class="headerlink" title="QT的卸载"></a>QT的卸载</h2><p>找到你原来安装目录。进入找到 <code>MaintenanceTool</code> ，执行之后就可以找到卸载选项，卸载即可。</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>SOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu安装腾讯QQ for Linux</title>
    <link href="/linux-qq/"/>
    <url>/linux-qq/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：腾讯QQ for Linux尝试</p><a id="more"></a><blockquote><p>相关版本：</p><p>gcc version 7.4.0 (Ubuntu 7.4.0-1ubuntu1~18.04.1)</p></blockquote><h2 id="Linux版QQ"><a href="#Linux版QQ" class="headerlink" title="Linux版QQ"></a>Linux版QQ</h2><p>2019年10月24日，程序员节日那天，腾讯发布了QQ Linux版本。</p><p>网站链接：<a href="https://im.qq.com/linuxqq/index.html">https://im.qq.com/linuxqq/index.html</a></p><p>官网介绍说是支持x64（x86_64、amd64）、arm64（aarch64）、mips64（mips64el）三种架构，每种架构支持Debian系、红帽系、Arch Linux系、其它发行版中的一种或几种（未来可能继续扩充）。</p><p>各种详细的信息官网都有介绍。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先查看自己机器的架构，在终端中输入命令 <code>uname -a</code> 来查看，我的这台电脑信息：</p><pre><code class="hljs apache"><span class="hljs-attribute">Linux</span> colourso-Legion <span class="hljs-number">4</span>.<span class="hljs-number">18</span>.<span class="hljs-number">0</span>-<span class="hljs-number">15</span>-generic #<span class="hljs-number">16</span>~<span class="hljs-number">18</span>.<span class="hljs-number">04</span>.<span class="hljs-number">1</span>-Ubuntu SMP Thu Feb <span class="hljs-number">7</span> <span class="hljs-number">14</span>:<span class="hljs-number">06</span>:<span class="hljs-number">04</span> UTC <span class="hljs-number">2019</span> x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> GNU/Linux</code></pre><p>所以我是x64架构中的。</p><p>确定好自己的架构，然后下载对应的程序包，因为我的linux是Ubuntu，所以我选用deb的包。在浏览器里点击下载即可。</p><p>安装之前要确定自己的设备安装有 gtk2.0 ，因为Linux QQ需要依赖它。Ubuntu下使用终端命令<code>sudo apt install libgtk2.0-0</code> 进行查看或者安装。</p><p>下载好之后，点击程序进行安装，或者是使用终端命令 <code>sudo dpkg -i linuxqq_2.0.0-b1-1024_amd64.deb</code></p><p><img src="/linux-qq/setup.png"></p><p>安装完成，然后在自己的软件列表里找到“腾讯QQ”点击打开即可。</p><blockquote><p>参考链接及其他版本安装方式：<a href="https://im.qq.com/linuxqq/download.html">https://im.qq.com/linuxqq/download.html</a></p></blockquote><h2 id="使用感受"><a href="#使用感受" class="headerlink" title="使用感受"></a>使用感受</h2><ul><li>只能使用手机QQ扫码登陆。</li><li>界面有点复古，比较简单，倒是支持简单的换肤。</li><li>主界面只能显示头像、个签、搜索框、会话列表、好友列表、群聊列表以及设置按钮。</li><li>消息提醒不明显，未屏蔽的群聊以及个人消息都是头像闪动提醒，屏蔽的群聊消息以左上角出现小红点标示提醒。</li><li>聊天页面支持发送表情、图片、文件以及截图，必备功能都有。</li><li>群聊不能看群文件等、也不能查看群主是谁。</li><li>隔一段时间会掉线，需要点击左下角的企鹅图标重新上线。</li><li>不支持给我的设备发送文件或消息。</li></ul><p><img src="/linux-qq/screencasts.png"></p><p>除此之外还有wineQQ，百度搜索一下就有相关的文章，比较好用。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>SOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下安装Lua5.3以及LuaRocks(Lua包管理)</title>
    <link href="/luaforlinux/"/>
    <url>/luaforlinux/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：Ubuntu下安装Lua5.3以及LuaRocks(Lua包管理)，以及安装Luasocket库。</p><a id="more"></a><blockquote><p>相关版本：</p><p>gcc version 7.4.0 (Ubuntu 7.4.0-1ubuntu1~18.04.1)</p><p>Lua 5.3.5</p><p>LuaRocks 3.3.0</p></blockquote><p>先吐槽一下，在Windows上安装Lua的相关包以及包管理工具一堆一堆的问题，搜到的大部分文章都是相互复制，对解决问题没什么帮助，关键是在CSDN里阅读量还高。。。其次就是CSDN大部分文章都是关于Lua在linux上的安装以及其他的扩展，安装起来比较快。</p><h2 id="Linux下-Ubuntu-安装lua"><a href="#Linux下-Ubuntu-安装lua" class="headerlink" title="Linux下(Ubuntu)安装lua"></a>Linux下(Ubuntu)安装lua</h2><p>打开终端(Ctrl+Alt+T).输入命令下载lua的包。<code>wget http://www.lua.org/ftp/lua-5.3.5.tar.gz</code></p><p>或者是直接去lua的官网下载：(<a href="http://www.lua.org/download.html)[http://www.lua.org/download.html]">http://www.lua.org/download.html)[http://www.lua.org/download.html]</a></p><p>之后解压压缩包： <code>tar -zxvf lua-5.3.5.tar.gz</code></p><p>进入解压之后的目录： <code>cd lua-5.3.5/</code></p><p>然后输入：<code>make linux</code></p><blockquote><p>有可能会报出错误：<br>lua.c:82:10: fatal error: readline/readline.h: 没有那个文件或目录<br>#include &lt;readline/readline.h&gt;<br>         ^~~~~~~~~~~~~~~~~~~~~</p></blockquote><p>如果是因为缺少<code>readline</code>的话，执行下述命令来安装这个文件: <code>sudo apt-get install libreadline7 libreadline-dev</code>。输入密码即可安装成功。</p><p>之后再次进行 <code>make linux</code></p><p>最后执行 <code>sudo make install</code></p><p>这样lua就安装成功了。</p><p>在终端输入<code>lua</code>，即可进入lua的命令行下，即 <code>Lua 5.3.5  Copyright (C) 1994-2018 Lua.org, PUC-Rio</code>.</p><blockquote><p>参考链接：<a href="https://blog.csdn.net/lvqingyao520/article/details/83573093">Linux 安装Lua</a></p></blockquote><h2 id="Linux下-Ubuntu-安装LuaRocks"><a href="#Linux下-Ubuntu-安装LuaRocks" class="headerlink" title="Linux下(Ubuntu)安装LuaRocks"></a>Linux下(Ubuntu)安装LuaRocks</h2><p>LuaRocks是Lua的包管理工具。官网：<a href="https://luarocks.org/">https://luarocks.org/</a></p><p>在Linux下安装比较简单，在Windows下折腾了好久，安装成功却不能使用。</p><p>LuaRocks的官网里就有安装说明，稍微修改以下就可以安装了，如下：</p><pre><code><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> wget https://luarocks.org/releases/luarocks-3.3.0.tar.gz</span><span class="hljs-meta">$</span><span class="bash"> tar zxpf luarocks-3.3.0.tar.gz</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> luarocks-3.3.0</span><span class="hljs-meta">$</span><span class="bash"> ./configure --prefix=/usr/<span class="hljs-built_in">local</span>/luarocks &amp;&amp; make &amp;&amp; sudo make install</span><span class="hljs-meta">$</span><span class="bash"> sudo luarocks install luasocket</span><span class="hljs-meta">$</span><span class="bash"> lua</span>Lua 5.3.5 Copyright (C) 1994-2018 Lua.org, PUC-Rio<span class="hljs-meta">&gt;</span><span class="bash"> require <span class="hljs-string">&quot;socket&quot;</span></span></code></pre></code></pre><p>照常来一遍操作基本没有问题。</p><p>安装完之后，在终端输入 <code>luarocks</code> 来查看是否安装成功。安装成功会打印一大堆luarocks的命令行的选项与功能。</p><h3 id="LuaRocks使用示例"><a href="#LuaRocks使用示例" class="headerlink" title="LuaRocks使用示例"></a>LuaRocks使用示例</h3><p>安装luasocket：<code>sudo luarocks install luasocket</code></p><p>安装luafilesystem：<code>sudo luarocks install luafilesystem</code></p><p>安装完成之后可以使用 <code>luarocks list</code> 来查看已经安装的lua模块。</p><p>或者进入lua的命令行，尝试使用 <code>require(&quot;socket&quot;)</code>。未报错说明安装成功。</p><blockquote><p>参考链接：</p><p><a href="https://blog.csdn.net/hp_cpp/article/details/87643911">ubuntu上安装luarocks，并添加LuaFileSystem</a></p><p><a href="https://www.linuxidc.com/Linux/2014-01/95501.htm">Linux 安装 (luarocks(lua的模块管理工具)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>SOP</tag>
      
      <tag>Lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lua快速入门 —— 协同程序</title>
    <link href="/lua-5/"/>
    <url>/lua-5/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：协同程序提供了一种协作式的多线程。每个协同程序都等于是一个线程。一对yield-resume可以将执行权在不同线程间切换。然而与常规多线程不同，协程是非抢先式的。</p><a id="more"></a><blockquote><p>参照书籍：<strong>《Lua程序设计（第二版）》</strong></p><p>Lua版本：<strong>Lua 5.3.5</strong></p></blockquote><h2 id="协同程序"><a href="#协同程序" class="headerlink" title="协同程序"></a>协同程序</h2><ul><li><p>Lua将所有关于协同程序的函数放在了一个名叫”<strong>coroutine</strong>“的table中。</p></li><li><p>create函数用于创建一个协同程序，只有一个参数，为一个函数。最终返回一个thread类型的值。</p>  <pre><code class="hljs lua">&gt; co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">print</span><span class="hljs-string">&quot;hi&quot;</span> <span class="hljs-keyword">end</span>)&gt; <span class="hljs-built_in">print</span>(co)thread: <span class="hljs-number">000000000078</span>eba8</code></pre></li><li><p>一个协同程序有四种状态：<strong>挂起(suspended)、运行(running)、死亡(dead)和正常(normal)</strong>.创建一个协同程序后它将储于挂起状态，可以使用status函数来检查协同程序的状态。</p>  <pre><code class="hljs lua">&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">status</span>(co))suspended</code></pre></li><li><p>使用resume函数来启动执行协同程序，并将其状态从<strong>挂起 –&gt; 运行</strong></p>  <pre><code class="hljs lua">&gt; <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co)hi<span class="hljs-literal">true</span>&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">status</span>(co))dead&gt; <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co)<span class="hljs-literal">false</span>   cannot <span class="hljs-built_in">resume</span> dead <span class="hljs-built_in">coroutine</span>&gt;</code></pre></li><li><p>使用yield函数来让一个运行中的协同程序挂起。</p>  <pre><code class="hljs lua">co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">10</span> <span class="hljs-keyword">do</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;co&quot;</span>,i) <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">yield</span>() <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>)&gt; <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co)co      <span class="hljs-number">1</span><span class="hljs-literal">true</span>&gt; <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co)co      <span class="hljs-number">2</span><span class="hljs-literal">true</span>&gt; <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co)co      <span class="hljs-number">3</span><span class="hljs-literal">true</span>&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">status</span>(co))suspended&gt;</code></pre><blockquote><p><strong>从协程的角度来看，所有在它挂起时发生的活动都发生在yield调用中。当恢复协同程序的执行时，对于yield的调用才最终返回。然后协同程序继续它的执行，直到下个yield调用或执行的结束。</strong></p></blockquote></li><li><p><strong>正常状态</strong>：当协程A唤醒了另一个协程B时，协程A就处于一个特殊状态，既不是挂起状态(A无法继续执行)也不是运行状态(B在运行)。</p></li><li><p>Lua协同程序的机制：通过一对resume-yield来交换数据。在第一次调用resume时，并没有对应的yield在等待它，因此传<strong>递给resume的额外参数都将视为协同程序主函数的参数。</strong></p>  <pre><code class="hljs lua">&gt; co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a,b,c)</span></span>&gt;&gt; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;co&quot;</span>,a,b,c)&gt;&gt; <span class="hljs-keyword">end</span>)&gt; <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)co      <span class="hljs-number">1</span>       <span class="hljs-number">2</span>       <span class="hljs-number">3</span><span class="hljs-literal">true</span>&gt;</code></pre><p>  数据由yield传给resume。true表明调用成功，true之后的部分，即是yield的参数.</p>  <pre><code class="hljs lua">co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a,b)</span></span>  <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">yield</span>(a+b,a-b)<span class="hljs-keyword">end</span>)&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co,<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))<span class="hljs-literal">true</span>    <span class="hljs-number">30</span>      <span class="hljs-number">10</span></code></pre><p>  相应地，resume的参数，会被传递给yield。 </p>  <pre><code class="hljs lua">co  = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;co&quot;</span>,  <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">yield</span>())<span class="hljs-keyword">end</span>)<span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co)<span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)   <span class="hljs-comment">--&gt; co  4 5</span></code></pre><p>  最后一个，协同代码结束时的返回值，也会传给resume：</p>  <pre><code class="hljs lua">co  = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span>  <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>, <span class="hljs-number">7</span><span class="hljs-keyword">end</span>)<span class="hljs-built_in">print</span>(<span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co))   <span class="hljs-comment">--&gt;  true 6 7</span></code></pre></li><li><p>Lua的协同称为<strong>不对称协同</strong>（asymmetric coroutines），指“挂起一个正在执行的协同函数”与“使一个被挂起的协同再次执行的函数”是不同的，有些语言提供对称协同（symmetric coroutines），即使用同一个函数负责“执行与挂起间的状态切换”.</p><blockquote><p>与对称的协同和不对称协同的区别不同的是，协同与产生器的区别更大。产生器相对比较简单，他不能完成真正的协同所能完成的一些任务。我们熟练使用不对称的协同之后，可以利用不对称的协同实现比较优越的对称协同。</p></blockquote></li></ul><h2 id="协程实例-生产者消费者"><a href="#协程实例-生产者消费者" class="headerlink" title="协程实例-生产者消费者"></a>协程实例-生产者消费者</h2><p>生产者消费者涉及两个函数，一个负责不断的产生值，另一个负责不断地消费值。</p><pre><code class="hljs lua"><span class="hljs-comment">-- 两个函数大致的样子</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span></span>    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span>        <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>() <span class="hljs-comment">--产生新的值</span>        send(x) <span class="hljs-comment">-- 发送给消费者</span>    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span></span>    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span>        <span class="hljs-keyword">local</span> x = receive() <span class="hljs-comment">--从生产者接受值</span>        <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>(x,<span class="hljs-string">&quot;\n&quot;</span>)  <span class="hljs-comment">-- 消费新的值</span>    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span></code></pre><p>这里的问题在于如何将send与receive匹配起来，这是一个典型的**“谁具有主循环”(who-has-the-main-loop)**的问题。由于生产者与消费者都处于活动状态，他们各自具有一个主循环，并且都将对方视为一个可调用的服务。</p><p><strong>而协调程序被称为是一种匹配生产者与消费者的理想工具，因为调用者与被调用者之间的resume-yield关系会不断颠倒。当一个协同调用yield时，并不会进入一个新的函数，取而代之的是返回一个未决的resume的调用。相似的，调用resume时也不会开始一个新的函数而是返回yield的调用。这种性质正是我们所需要的，与使得send-receive协同工作的方式是一致的。receive唤醒生产者生产新值，send把产生的值送给消费者消费。</strong></p><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span></span>    <span class="hljs-keyword">local</span> <span class="hljs-built_in">status</span>,value = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(producer)    <span class="hljs-keyword">return</span> value<span class="hljs-keyword">end</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">send</span><span class="hljs-params">(x)</span></span>    <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">yield</span>(x)<span class="hljs-keyword">end</span><span class="hljs-comment">-- 因此生产者现在一定是一个协同程序</span>producer = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span>    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span>            <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()  <span class="hljs-comment">--产生新值</span>            send(x)        <span class="hljs-keyword">end</span>    <span class="hljs-keyword">end</span>)</code></pre><p>在这种设计中，程序通过调用消费者来启动。当消费者需要一个新值时，它唤醒生产者。生产者返回一个新值后停止运行，并等待消费者的再次唤醒。这种设计称之为——“消费者驱动”。</p><h3 id="过滤器filter"><a href="#过滤器filter" class="headerlink" title="过滤器filter"></a>过滤器filter</h3><p>扩展上面的设计，实现过滤器</p><p>过滤器是一种位于生产者与消费者之间的处理功能，可用于对数据的一些变换。过滤器既是一个消费者又是一个生产者，它唤醒一个生产者促使其产生新的值，然后又将变换后的值传递给消费者。</p><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">receive</span><span class="hljs-params">(prod)</span></span>    <span class="hljs-keyword">local</span> <span class="hljs-built_in">status</span>,value = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(prod)    <span class="hljs-keyword">return</span> value<span class="hljs-keyword">end</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">send</span><span class="hljs-params">(x)</span></span>    <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">yield</span>(x)<span class="hljs-keyword">end</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span></span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>        <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span>            <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()            send(x)         <span class="hljs-keyword">end</span>       <span class="hljs-keyword">end</span>)<span class="hljs-keyword">end</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span><span class="hljs-params">(prod)</span></span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>        <span class="hljs-keyword">for</span> line=<span class="hljs-number">1</span>,<span class="hljs-built_in">math</span>.<span class="hljs-built_in">huge</span> <span class="hljs-keyword">do</span>                <span class="hljs-keyword">local</span> x = receiver(prod)                x = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;%5d %s&quot;</span>,line,x)                send(x)        <span class="hljs-keyword">end</span>     <span class="hljs-keyword">end</span>)<span class="hljs-keyword">end</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">consumer</span><span class="hljs-params">(prod)</span></span>   <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span>        <span class="hljs-keyword">local</span> x = receive(prod)  <span class="hljs-comment">--获取新值</span>        <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>(x,<span class="hljs-string">&quot;\n&quot;</span>)  <span class="hljs-comment">--消费新值</span>    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-comment">-- 运行代码</span>p = producer()f = filter(p)consumer(f)<span class="hljs-comment">--或者 sonsumer(filter(producer()))</span><span class="hljs-comment">-- 不过貌似无法运行</span></code></pre><p>可能很自然的想到<strong>UNIX的管道（pipe）</strong>，<strong>协同是一种非抢占式的多线程</strong>。管道的方式下，每一个任务在独立的进程中运行，而协同方式下，每个任务运行在独立的协同代码中。管道在读（consumer）与写（producer）之间提供了一个缓冲，因此两者相关的的速度没有什么限制，在上下文管道中这是非常重要的，因为在进程间的切换代价是很高的。协同模式下，任务间的切换代价较小，与函数调用相当，因此读写可以很好的协同处理。</p><h2 id="用协同程序实现迭代器"><a href="#用协同程序实现迭代器" class="headerlink" title="用协同程序实现迭代器"></a>用协同程序实现迭代器</h2><p>我们可以将循环的迭代器看作生产者-消费者模式的特殊的例子。迭代函数产生值给循环体消费。所以可以使用协同来实现迭代器。<strong>协同的一个关键特征是它可以不断颠倒调用者与被调用者之间的关系</strong>，这样我们毫无顾虑的使用它实现一个迭代器，而不用保存迭代函数返回的状态。</p><pre><code class="hljs lua"><span class="hljs-comment">-- 打印一个数组元素的所有的排列</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">permgen</span><span class="hljs-params">(a,n)</span></span>    n = n <span class="hljs-keyword">or</span> #a <span class="hljs-comment">--默认n为a的大小</span>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> <span class="hljs-keyword">then</span>        printResult(a)    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,n <span class="hljs-keyword">do</span>            a[n],a[i] = a[i],a[n] <span class="hljs-comment">--将第i个元素放到数组末尾</span>            permgen(a,n<span class="hljs-number">-1</span>)  <span class="hljs-comment">-- 生成其余元素的排列</span>            a[n],a[i] = a[i],a[n] <span class="hljs-comment">-- 恢复第i个元素</span>        <span class="hljs-keyword">end</span>    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printResult</span><span class="hljs-params">(a)</span></span>    <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,#a <span class="hljs-keyword">do</span>        <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>(a[i],<span class="hljs-string">&quot; &quot;</span>)    <span class="hljs-keyword">end</span>    <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;\n&quot;</span>)<span class="hljs-keyword">end</span><span class="hljs-comment">-- 调用</span>permgen(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;) <span class="hljs-comment">--只传一个参数也可以，函数中会对第二个参数进行默认赋值操作</span><span class="hljs-comment">--[[</span><span class="hljs-comment">2 3 4 1</span><span class="hljs-comment">3 2 4 1</span><span class="hljs-comment">3 4 2 1</span><span class="hljs-comment">4 3 2 1</span><span class="hljs-comment">2 4 3 1</span><span class="hljs-comment">4 2 3 1</span><span class="hljs-comment">4 3 1 2</span><span class="hljs-comment">3 4 1 2</span><span class="hljs-comment">3 1 4 2</span><span class="hljs-comment">1 3 4 2</span><span class="hljs-comment">4 1 3 2</span><span class="hljs-comment">1 4 3 2</span><span class="hljs-comment">2 4 1 3</span><span class="hljs-comment">4 2 1 3</span><span class="hljs-comment">4 1 2 3</span><span class="hljs-comment">1 4 2 3</span><span class="hljs-comment">2 1 4 3</span><span class="hljs-comment">1 2 4 3</span><span class="hljs-comment">2 3 1 4</span><span class="hljs-comment">3 2 1 4</span><span class="hljs-comment">3 1 2 4</span><span class="hljs-comment">1 3 2 4</span><span class="hljs-comment">2 1 3 4</span><span class="hljs-comment">1 2 3 4</span><span class="hljs-comment">--]]</span></code></pre><p>转化为迭代器</p><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">permgen</span><span class="hljs-params">(a,n)</span></span>    n = n <span class="hljs-keyword">or</span> #a    <span class="hljs-keyword">if</span> n&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">then</span>        <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">yield</span>(a)    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,n <span class="hljs-keyword">do</span>            a[n],a[i] = a[i],a[n] <span class="hljs-comment">--将第i个元素放到数组末尾</span>            permgen(a,n<span class="hljs-number">-1</span>)  <span class="hljs-comment">-- 生成其余元素的排列</span>            a[n],a[i] = a[i],a[n] <span class="hljs-comment">-- 恢复第i个元素</span>        <span class="hljs-keyword">end</span>    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-comment">--定义一个工厂函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">permutations</span><span class="hljs-params">(a)</span></span>    <span class="hljs-keyword">local</span> co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> permgen(a) <span class="hljs-keyword">end</span>)    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">--迭代器</span>        <span class="hljs-keyword">local</span> code,res = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co)        <span class="hljs-keyword">return</span> res    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-comment">-- for循环中便利</span><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> permutations(&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>&#125;) <span class="hljs-keyword">do</span>    printResult(p)<span class="hljs-keyword">end</span></code></pre><p>permutations函数使用了lua中常用的模式：<strong>将一个对协同的resume的调用封装在一个函数内部</strong>，这种方式在非常常见，所以专门为此专门提供了一个函数<code>coroutine.wrap</code>。与create相同的是，wrap创建一个协同程序；不同的是wrap不返回协同本身，而是返回一个函数，当这个函数被调用时将resume协同。wrap中resume协同的时候不会返回错误代码作为第一个返回结果，一旦有错误发生，将抛出错误。</p><pre><code class="hljs lua"><span class="hljs-comment">-- 使用wrap来重写permutations</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">permutations</span><span class="hljs-params">(a)</span></span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">wrap</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span> permgen(a) <span class="hljs-keyword">end</span>)<span class="hljs-keyword">end</span></code></pre><p>一般情况下，coroutine.wrap比coroutine.create使用起来简单直观，前者更确切的提供了我们所需要的：一个可以resume协同的函数，然而缺少灵活性，没有办法知道wrap所创建的协同的状态，也没有办法检查错误的发生。</p><h2 id="非抢占式的多线程-non-preemptive"><a href="#非抢占式的多线程-non-preemptive" class="headerlink" title="非抢占式的多线程(non-preemptive)"></a>非抢占式的多线程(non-preemptive)</h2><p>对于非抢占式的多线程来说，只要有一个线程调用了阻塞(blocking)的操作，整个程序在该操作完成前，都会停下来。但对于大部分程序来说，这是无法接受的。</p><pre><code class="hljs lua"><span class="hljs-comment">--未完</span>相关模块一直无法安装以及使用</code></pre>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lua快速入门 —— 练习</title>
    <link href="/lua-6/"/>
    <url>/lua-6/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：</p><a id="more"></a><blockquote><p>参照书籍：<strong>《Lua程序设计（第二版）》</strong></p><p>Lua版本：<strong>Lua 5.3.5</strong></p></blockquote><h2 id="马尔科夫链算法-——-markov-chain"><a href="#马尔科夫链算法-——-markov-chain" class="headerlink" title="马尔科夫链算法 —— markov chain"></a>马尔科夫链算法 —— markov chain</h2><p>该算法根据原始文本中n个单词的序列来确定后面的单词，从而生成随机的文本。本例中将n=2.</p><p>– the more we try the more we do<br>statetab = { [“\n \n”] = {“the”},<br>    [“\n the”] = {“more”},<br>    [“the more”] = {“we”,”we”},<br>    [“more we”] = {“try”,”do”},<br>    [“we try”] = {“the”},<br>    [“try the”] = {“more”},<br>    [“we do”] = {“\n”},<br>}</p><pre><code class="hljs lua"><span class="hljs-comment">--将两个单词以空格连接 编码形成一个前缀</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prefix</span><span class="hljs-params">(w1,w2)</span></span><span class="hljs-keyword">return</span> w1 .. <span class="hljs-string">&quot; &quot;</span> .. w2<span class="hljs-keyword">end</span><span class="hljs-keyword">local</span> statetab = &#123;&#125;<span class="hljs-comment">-- 向table中的某个前缀列表插入一个新单词</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insert</span><span class="hljs-params">(index,value)</span></span>   <span class="hljs-keyword">local</span> list = statetab[index]     <span class="hljs-keyword">if</span> list == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span>        statetab[index] = &#123;value&#125;    <span class="hljs-keyword">else</span>        list[#list + <span class="hljs-number">1</span>] = value    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">allwords</span><span class="hljs-params">()</span></span>    <span class="hljs-keyword">local</span> line = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()  <span class="hljs-comment">--当前行</span>    <span class="hljs-keyword">local</span> pos = <span class="hljs-number">1</span> <span class="hljs-comment">--行中的当前位置</span>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>  <span class="hljs-comment">-- 迭代器函数</span>        <span class="hljs-keyword">while</span> line <span class="hljs-keyword">do</span>  <span class="hljs-comment">--只要还有行就一直循环</span>            <span class="hljs-keyword">local</span> s,e = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">find</span>(line,<span class="hljs-string">&quot;%w+&quot;</span>,pos)            <span class="hljs-keyword">if</span> s <span class="hljs-keyword">then</span>  <span class="hljs-comment">--找到下一个单词吗？</span>                pos = e+<span class="hljs-number">1</span>  <span class="hljs-comment">--更新下一个位置</span>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>.<span class="hljs-built_in">sub</span>(line,s,e) <span class="hljs-comment">--返回该单词</span>            <span class="hljs-keyword">else</span>                line = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>() <span class="hljs-comment">-- 没有找到单词，尝试下一行</span>                pos = <span class="hljs-number">1</span> <span class="hljs-comment">--从行首位置从新开始</span>            <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <span class="hljs-comment">--所有行都遍历完</span>    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-comment">---------主程序------------- </span><span class="hljs-keyword">local</span> N = <span class="hljs-number">2</span><span class="hljs-keyword">local</span> MAXGEN = <span class="hljs-number">10000</span><span class="hljs-keyword">local</span> NOWORD = <span class="hljs-string">&quot;\n&quot;</span><span class="hljs-comment">-- 构建table</span><span class="hljs-keyword">local</span> w1,w2 = NOWORD,NOWORD<span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> allwords() <span class="hljs-keyword">do</span>    <span class="hljs-built_in">insert</span>(prefix(w1,w2),w)    w1 = w2    w2 = w<span class="hljs-keyword">end</span><span class="hljs-built_in">insert</span>(prefix(w1,w2),NOWORD)<span class="hljs-comment">--生成文本</span>w1 = NOWORDw2 = NOWORD <span class="hljs-comment">--重新初始化</span><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,MAXGEN <span class="hljs-keyword">do</span>   <span class="hljs-keyword">local</span> list = statetab[prefix(w1,w2)]     <span class="hljs-comment">--从列表中选择一个随机项</span>    <span class="hljs-keyword">local</span> r = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">random</span>(#list)    <span class="hljs-keyword">local</span> nextword = list[r]    <span class="hljs-keyword">if</span> nextword == NOWORD <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span>    <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>(nextword,<span class="hljs-string">&quot; &quot;</span>)    w1 = w2    w2 = nextword <span class="hljs-keyword">end</span></code></pre><p>emmmm，测试结果一般，在命令行里输入内容最后想要结束的时候记得使用<code>Ctrl+Z</code>来结束。</p><hr><h2 id="输出“Hello-World-”"><a href="#输出“Hello-World-”" class="headerlink" title="输出“Hello,World!”"></a>输出“Hello,World!”</h2><pre><code class="hljs lua"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Hello,World!&quot;</span></code></pre><p>当函数参数仅为一个并且是字符串或者表的构造式的时候，有没有括号都无所谓</p><h2 id="实现两数相加"><a href="#实现两数相加" class="headerlink" title="实现两数相加"></a>实现两数相加</h2><p>获取用户输入的两个数字，并使两数相加，结果输出到屏幕上。</p><pre><code class="hljs lua"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Please enter a number:&quot;</span>num1 = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>(<span class="hljs-string">&quot;*number&quot;</span>)<span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Please enter a number again:&quot;</span>num2 = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>(<span class="hljs-string">&quot;*number&quot;</span>)sums = num1 + num2<span class="hljs-built_in">print</span>(num1..<span class="hljs-string">&quot; + &quot;</span>..num2..<span class="hljs-string">&quot; = &quot;</span>..sums)</code></pre><h2 id="求商及余数"><a href="#求商及余数" class="headerlink" title="求商及余数"></a>求商及余数</h2><p>获取用户输入的两个整数，计算结果输出到屏幕上。</p><p>Lua的number类型式双精度的浮点数，而且正常的运算结果是个浮点数。</p><p>可以使用Lua的math库里的<code>math.modf(x)</code> ——  返回 <code>x</code> 的整数部分和小数部分。 第二个结果一定是浮点数。 </p><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-number">5</span>/<span class="hljs-number">3</span>)  <span class="hljs-comment">--1.6666666666667</span><span class="hljs-built_in">print</span>(<span class="hljs-number">5</span>%<span class="hljs-number">3</span>)  <span class="hljs-comment">--2</span><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Please enter a number:&quot;</span>num1 = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>(<span class="hljs-string">&quot;*number&quot;</span>)<span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Please enter a number again:&quot;</span>num2 = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>(<span class="hljs-string">&quot;*number&quot;</span>)shang,flots = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">modf</span>(num1/num2) <span class="hljs-comment">-- shang 是运算的整数部分，flots是运算得到的小数部分</span>yushu = num1 - shang * num2<span class="hljs-built_in">print</span>(num1..<span class="hljs-string">&quot; / &quot;</span>..num2..<span class="hljs-string">&quot; = &quot;</span>..shang..<span class="hljs-string">&quot; 余数为 &quot;</span>..yushu)</code></pre><h2 id="判断元音还是辅音"><a href="#判断元音还是辅音" class="headerlink" title="判断元音还是辅音"></a>判断元音还是辅音</h2><p><code>#</code>是长度操作符，可以获取table或者字符串的长度。</p><p>还有Lua中的table的下标是从数字1开始的。</p><pre><code class="hljs lua"><span class="hljs-keyword">local</span> vowel = &#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;i&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;u&quot;</span>&#125; <span class="hljs-comment">--元音</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">judgeVowel</span><span class="hljs-params">(str)</span></span>   <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,#vowel <span class="hljs-keyword">do</span>   <span class="hljs-keyword">if</span> str == vowel[i] <span class="hljs-keyword">then</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        <span class="hljs-keyword">end</span>   <span class="hljs-keyword">end</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><span class="hljs-keyword">end</span><span class="hljs-keyword">local</span> j = <span class="hljs-number">1</span><span class="hljs-keyword">while</span> j &lt; <span class="hljs-number">5</span> <span class="hljs-keyword">do</span>    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Please enter a character:&quot;</span>strs = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()    <span class="hljs-keyword">if</span> #strs == <span class="hljs-number">1</span> <span class="hljs-keyword">then</span>        <span class="hljs-keyword">if</span> judgeVowel(strs) <span class="hljs-keyword">then</span>            <span class="hljs-built_in">print</span>(strs .. <span class="hljs-string">&quot; is a vowel&quot;</span>)        <span class="hljs-keyword">else</span>             <span class="hljs-built_in">print</span>(strs .. <span class="hljs-string">&quot; is a consonant&quot;</span>)        <span class="hljs-keyword">end</span>    <span class="hljs-keyword">else</span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Please enter a character!!!&quot;</span>)    <span class="hljs-keyword">end</span>    j = j+<span class="hljs-number">1</span><span class="hljs-keyword">end</span></code></pre><h2 id="判断闰年"><a href="#判断闰年" class="headerlink" title="判断闰年"></a>判断闰年</h2><p>闰年是能够被4整除但不能被100整除的年份。</p><pre><code class="hljs lua"><span class="hljs-keyword">local</span> j = <span class="hljs-number">1</span><span class="hljs-keyword">while</span> j &lt; <span class="hljs-number">5</span> <span class="hljs-keyword">do</span>   <span class="hljs-built_in">print</span><span class="hljs-string">&quot;Please enter a years&quot;</span>   years = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>(<span class="hljs-string">&quot;*number&quot;</span>)   num1,num2 = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">modf</span>(years/<span class="hljs-number">4</span>)   num3,num4 = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">modf</span>(years/<span class="hljs-number">100</span>)   <span class="hljs-keyword">if</span> num2 == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> num4 ~= <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>       <span class="hljs-built_in">print</span>(years..<span class="hljs-string">&quot; is a leap year&quot;</span>)      <span class="hljs-keyword">else</span>        <span class="hljs-built_in">print</span>(years..<span class="hljs-string">&quot; not is a leap year&quot;</span>)   <span class="hljs-keyword">end</span>   j = j+<span class="hljs-number">1</span><span class="hljs-keyword">end</span></code></pre><h2 id="求两数的最大公约数和最小公倍数"><a href="#求两数的最大公约数和最小公倍数" class="headerlink" title="求两数的最大公约数和最小公倍数"></a>求两数的最大公约数和最小公倍数</h2><pre><code class="hljs lua"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Please enter a number:&quot;</span>num1 = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>(<span class="hljs-string">&quot;*number&quot;</span>)<span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Please enter a number again:&quot;</span>num2 = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>(<span class="hljs-string">&quot;*number&quot;</span>)hcf = num1temp = num2<span class="hljs-keyword">while</span> hcf ~= temp <span class="hljs-keyword">do</span>    <span class="hljs-keyword">if</span> hcf &gt; temp <span class="hljs-keyword">then</span>        hcf = hcf - temp    <span class="hljs-keyword">else</span>        temp = temp - hcf    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>lcm = num1*num2/hcf<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The greatest common divisor is &quot;</span>..hcf)<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The minimum common multiple is &quot;</span>..lcm)</code></pre>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lua快速入门 —— 编译执行与错误</title>
    <link href="/lua-4/"/>
    <url>/lua-4/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：</p><a id="more"></a><blockquote><p>参照书籍：<strong>《Lua程序设计（第二版）》</strong></p><p>Lua版本：<strong>Lua 5.3.5</strong></p></blockquote><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>Lua是一种解释型语言，但Lua允许在运行源代码前，先将源代码预编译为一种中间形式。</p><blockquote><p>区别解释型语言的主要特征并不在于是否能编译它们，而是在于编译器是否是语言运行时库的一部分，即<strong>是否有能力(并轻易地)执行动态生成的代码</strong>。</p></blockquote><p>Lua中的 <code>dofile函数</code>，用于运行Lua代码块</p><pre><code class="hljs lua"><span class="hljs-comment">-- 在Lua的命令行中 执行下述语句可以得到结果</span><span class="hljs-built_in">dofile</span>(<span class="hljs-string">&quot;D:\\Code\\Lua\\new.lua&quot;</span>)</code></pre><p>但是实际上，<code>loadfile函数</code>才是做了真正核心的工作。loadfile从一个文件加载Lua代码块，但它并不运行代码块，而是只编译代码，然后将编译结果作为一个函数返回。</p><pre><code class="hljs lua"><span class="hljs-comment">-- 在Lua的命令行中</span>f = <span class="hljs-built_in">loadfile</span>(<span class="hljs-string">&quot;D:\\Code\\Lua\\new.lua&quot;</span>)f() <span class="hljs-comment">-- 执行代码</span></code></pre><p>与dofile不同的还有loadfile不会引发错误，它只是返回错误值并不处理错误。</p><pre><code class="hljs lua"><span class="hljs-comment">-- 一般dofile可以这样来定义</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dofile</span><span class="hljs-params">(filename)</span></span>    <span class="hljs-keyword">local</span> f = <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">loadfile</span>(filename))    <span class="hljs-keyword">return</span> f()<span class="hljs-keyword">end</span></code></pre><p>上述代码中，如果loadfile失败，那么assert就会引发一个错误。</p><p>dofile在一次调用中做完了所有的事，而loadfile更加的灵活，比如需要多次运行一个文件，只需要多次使用loadfile的返回结果就可以了。</p><p>除此之外还有一个类似的loadstring函数，用于去执行外部代码。不过 <strong>loadstring在lua5.2中已经被弃用了</strong> 。</p><h2 id="动态链接机制"><a href="#动态链接机制" class="headerlink" title="动态链接机制"></a>动态链接机制</h2><p>Lua通常不会包含任何无法通过ANSI C来实现的机制，但是动态链接有些意外，因为ANSI C标准没有动态链接。</p><p>可以将动态链接视为其他机制的母机制，只要拥有它，就可以动态加载任何其他不在Lua中的机制了。</p><blockquote><p>要检测某一平台是否支持动态链接机制，只需要在Lua命令行中运行<code>print(package.loadlib(&quot;a&quot;,&quot;b&quot;))</code> ，然后观察执行结果，如果报告不存在指定文件，就说明该平台具有动态链接机制。否则会有错误消息提示或未安装此机制。</p></blockquote><p>Lua提供了所有的动态连接的功能都在一个叫<code>package.loadlib</code>的函数内。这个函数有两个参数:动态库的完整路径和一个函数名称。所以典型的调用的例子如下：</p><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-built_in">path</span> = <span class="hljs-string">&quot;/usr/local/lua/lib/libluasocket.so&quot;</span><span class="hljs-keyword">local</span> f = <span class="hljs-built_in">loadlib</span>(<span class="hljs-built_in">path</span>, <span class="hljs-string">&quot;luaopen_socket&quot;</span>)</code></pre><p>loadlib函数加载指定的库并且连接到Lua，然而它并不打开库（也就是说没有调用初始化函数），反之他返回初始化函数作为Lua的一个函数，这样我们就可以直接在Lua中调用他。如果加载动态库或者查找初始化函数时出错，loadlib将返回nil和错误信息。</p><p>通常使用require来加载C程序库，这个函数会搜索指定的库，然后用loadlib来加载库，并返回初始化函数。这个初始化函数应将库中提供的函数注册到Lua中，就好像一段Lua代码定义了其他的函数一样。</p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>Lua经常作为扩展语言嵌入在别的应用中，所以不能当错误发生时简单的崩溃或者退出。相反，当错误发生时Lua结束当前的chunk并返回到应用中。</p><p>Lua提供了内建的<code>assert函数</code>来处理错误</p><pre><code class="hljs lua"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;please enter a number&quot;</span>n = <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>(<span class="hljs-string">&quot;*number&quot;</span>),<span class="hljs-string">&quot;invalid input&quot;</span>)<span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;You enter the num is &quot;</span>..n)<span class="hljs-comment">--[[</span><span class="hljs-comment">&gt; dofile(&quot;D:\\Code\\Lua\\new.lua&quot;)</span><span class="hljs-comment">please enter a number</span><span class="hljs-comment">a</span><span class="hljs-comment">D:\Code\Lua\new.lua:261: invalid input</span><span class="hljs-comment">stack traceback:</span><span class="hljs-comment">        [C]: in function &#x27;assert&#x27;</span><span class="hljs-comment">        D:\Code\Lu\new126.lua:261: in main chunk</span><span class="hljs-comment">        [C]: in function &#x27;dofile&#x27;</span><span class="hljs-comment">        stdin:1: in main chunk</span><span class="hljs-comment">        [C]: in ?</span><span class="hljs-comment">&gt; nil</span><span class="hljs-comment">--]]</span></code></pre><p>assert函数检查其第一个参数是否为true，若为true，则简单的返回该参数，否则(即false或者nil)就会引发一个错误。它的第二个参数是一个可选的信息字符串，当第一个参数为false时，assert会以第二个参数为错误信息抛出。</p><blockquote><p>另：assert总会先处理两个参数(即如果参数需要计算就会进行计算)，然后才调用函数。</p></blockquote><p>当一个函数遭遇了一种未预期的状况（即异常时），它可以采取两种基本的行为：<strong>返回错误代码(通常时nil)**或者</strong>引发一个错误(调用error)**。</p><p>在这两种选择之间并没有固定的法则，通常的原则是：<strong>易于避免的异常应引发一个错误，否则应返回错误代码。</strong></p><blockquote><p><strong>对于程序逻辑上能够避免的异常，以抛出错误的方式处理之，否则返回错误代码。</strong>——《Lua程序设计第一版》</p></blockquote><h2 id="Lua进行错误处理"><a href="#Lua进行错误处理" class="headerlink" title="Lua进行错误处理"></a>Lua进行错误处理</h2><p>如果想要处理错误，必须使用函数pcall来包装需要执行的代码。</p><p>第一步：将这段代码封装在一个函数内</p><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">()</span></span>    ...    <span class="hljs-keyword">if</span> unexpected_condition <span class="hljs-keyword">then</span> <span class="hljs-built_in">error</span>() <span class="hljs-keyword">end</span>    ...    <span class="hljs-built_in">print</span>(a[i])   <span class="hljs-comment">-- potential error: `a&#x27; may not be a table</span>    ...<span class="hljs-keyword">end</span></code></pre><p>第二步：使用pcall调用这个函数</p><pre><code class="hljs lua"><span class="hljs-keyword">if</span> <span class="hljs-built_in">pcall</span>(foo) <span class="hljs-keyword">then</span>    <span class="hljs-comment">-- no errors while running `foo&#x27;    </span>    ...<span class="hljs-keyword">else</span>    <span class="hljs-comment">-- `foo&#x27; raised an error: take appropriate actions</span>    ...<span class="hljs-keyword">end</span></code></pre><p>当然也可以用匿名函数的方式调用pcall：</p><pre><code class="hljs lua"><span class="hljs-keyword">if</span> <span class="hljs-built_in">pcall</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span> &lt;代码&gt; ) <span class="hljs-keyword">then</span>        &lt;常规代码&gt;<span class="hljs-keyword">else</span>        &lt;错误代码处理&gt;<span class="hljs-keyword">end</span></code></pre><p>pcall函数会以一种“保护模式(protected mode)”来调用它得第一个参数，因此pcall可以捕获函数执行中的错误。如果没有发生错误，那么pcall会返回true以及函数调用的返回值，否则返回false以及错误消息。</p><p>错误信息不一定仅为字符串（下面的例子是一个table），传递给error的任何信息都会被pcall返回：</p><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-built_in">status</span>, err = <span class="hljs-built_in">pcall</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span> <span class="hljs-built_in">error</span>(&#123;code=<span class="hljs-number">121</span>&#125;) <span class="hljs-keyword">end</span>)<span class="hljs-built_in">print</span>(err.code) <span class="hljs-comment">--&gt;  121</span><span class="hljs-comment">-- 但是在本地的命令行无法运行…… 使用文件的方式可以使用</span></code></pre><p>这种机制提供了强大的能力，足以应付Lua中的各种异常和错误情况。我们通过error抛出异常，然后通过pcall捕获之，而错误消息则可以标识出错误的类型或内容。</p><h2 id="错误消息"><a href="#错误消息" class="headerlink" title="错误消息"></a>错误消息</h2><p>通常情况下我们使用字符串来描述错误信息，如果遇到内部错误（比如对一个非table的值使用索引下标访问）Lua将自己产生错误信息，否则Lua使用传递给<strong>error函数</strong>的参数作为错误信息。</p><p>而error函数还有第二个附加参数level，来指明是调用层级中的哪一层的error()函数来报告当前错误。</p><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">(num)</span></span>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(num) ~= <span class="hljs-string">&quot;number&quot;</span> <span class="hljs-keyword">then</span>    <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;number expected&quot;</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">-- 让error报告错误发生在第二级(自己的函数是第一级)</span>        <span class="hljs-comment">-- 好吧，没搞懂 书 P71</span>  <span class="hljs-keyword">end</span>  <span class="hljs-built_in">print</span>(str.<span class="hljs-number">.123</span>)<span class="hljs-keyword">end</span>n = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()foo(n)<span class="hljs-comment">--[[</span><span class="hljs-comment">&gt; dofile(&quot;D:\\Code\\Lua\\new126.lua&quot;)</span><span class="hljs-comment">asds（人为输入的值）</span><span class="hljs-comment">D:\Code\Lua\new126.lua:307: number expected （错误给出了文件名、行号、以及自定义的错误信息）</span><span class="hljs-comment">stack traceback:</span><span class="hljs-comment">        [C]: in function &#x27;error&#x27;</span><span class="hljs-comment">        D:\Code\Lua\new126.lua:301: in function &#x27;foo&#x27;</span><span class="hljs-comment">        D:\Code\Lua\new126.lua:307: in main chunk</span><span class="hljs-comment">        [C]: in function &#x27;dofile&#x27;</span><span class="hljs-comment">        stdin:1: in main chunk</span><span class="hljs-comment">        [C]: in ?</span><span class="hljs-comment">&gt;</span><span class="hljs-comment">--]]</span></code></pre><h2 id="追溯（traceback）"><a href="#追溯（traceback）" class="headerlink" title="追溯（traceback）"></a>追溯（traceback）</h2><p>当错误发生的时候，我们常常希望了解详细的信息，而不仅是错误发生的位置。若能了解到“错误发生时的栈信息”就好了，但<strong>pcall返回错误信息时，已经释放了保存错误发生情况的栈信息。</strong></p><p>因此，若想得到tracebacks，我们必须在pcall返回以前获取。Lua提供了<code>xpcall</code>来实现这个功能，<strong>xpcall接受两个参数：调用函数、错误处理函数</strong>。当错误发生时，Lua会在栈释放以前调用错误处理函数，因此可以使用debug库收集错误相关信息。有两个常用的debug处理函数：debug.debug和debug.traceback，前者给出Lua的提示符，你可以自己动手察看错误发生时的情况；后者通过traceback创建更多的错误信息，也是控制台解释器用来构建错误信息的函数。你可以在任何时候调用debug.traceback获取当前运行的traceback信息：</p><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">debug</span>.<span class="hljs-built_in">traceback</span>())</code></pre><p>else …</p>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lua快速入门 —— 迭代器与泛型for</title>
    <link href="/lua-3/"/>
    <url>/lua-3/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：Lua的函数的基本形式、如何调用以及函数的多重返回值、变长参数、具名实参。此外还有Lua中函数的地位，即函数是类似于数字那样的第一类值，还有匿名函数、闭包、局部函数以及尾调用函数。</p><a id="more"></a><blockquote><p>参照书籍：<strong>《Lua程序设计（第二版）》</strong></p><p>Lua版本：<strong>Lua 5.3.5</strong></p></blockquote><h2 id="迭代器与closure"><a href="#迭代器与closure" class="headerlink" title="迭代器与closure"></a>迭代器与closure</h2><p>迭代器：一种可以遍历一种集合中所有元素的机制。</p><p>在Lua中，通常将迭代器表示为函数，每调用一次函数，就会返回集合中“下一个”元素。</p><blockquote><p>迭代器需要保留上一次成功调用的状态和下一次成功调用的状态，也就是他知道来自于哪里和将要前往哪里。</p><p>闭包提供的机制可以很容易实现这个任务。记住：闭包是一个内部函数，它可以访问一个或者多个外部函数的外部局部变量。<strong>每次闭包的成功调用后这些外部局部变量都保存他们的值（状态）</strong>。当然如果要创建一个闭包必须要创建其外部局部变量。所以一个典型的闭包的结构包含两个函数：一个是闭包自己；另一个是工厂（创建闭包的函数）。</p></blockquote><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">values</span><span class="hljs-params">(t)</span></span>    <span class="hljs-keyword">local</span> i = <span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span>        i = i+<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> t[i]    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span></code></pre><p>上述函数中，values就是一个工厂，每当调用这个工厂时，它就会常见一个新的closure(即迭代器本身)。这个closure将它的状态保存在其外部变量t和i中。每当调用这个迭代器时，它就从列表t中返回下一个值。直到最后一个元素返回后，迭代器就会返回nil，一次表示迭代器的结束。</p><pre><code class="hljs lua">t = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>&#125;iter = values(t)   <span class="hljs-comment">-- 创建迭代器</span><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span>    <span class="hljs-keyword">local</span> element = iter()  <span class="hljs-comment">--调用迭代器</span>    <span class="hljs-keyword">if</span> element == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span>        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">end</span>    <span class="hljs-built_in">print</span>(element)<span class="hljs-keyword">end</span></code></pre><p>使用<strong>泛型for</strong>会更加简单，它正是为这种迭代设计的。</p><pre><code class="hljs lua">t = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>&#125;<span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> values(t) <span class="hljs-keyword">do</span>    <span class="hljs-built_in">print</span>(element)<span class="hljs-keyword">end</span></code></pre><p><strong>对比于while循环，泛型for为一次迭代循环做了所有的薄记工作。它在内部保存了迭代器函数，因此不再需要iter变量(while循环中的)。它在每次循环时调用迭代器，并在迭代器返回nil时结束循环。</strong></p><blockquote><p>通常情况下，迭代器函数都难写易用。🙃</p></blockquote><h2 id="泛型for的语义"><a href="#泛型for的语义" class="headerlink" title="泛型for的语义"></a>泛型for的语义</h2><p>前面我们看到的迭代器有一个缺点：每次调用都需要创建一个闭包，大多数情况下这种做法都没什么问题，然而在有些情况下创建闭包的代价是不能忍受的。在这些情况下我们可以使用泛型for本身来保存迭代的状态。</p><p>泛型for在循环过程内部保存了迭代器函数。实际上它保存了3个值：一个迭代器函数、一个恒定状态和一个控制变量。</p><pre><code class="hljs lua"><span class="hljs-comment">--泛型for的语法</span><span class="hljs-keyword">for</span> &lt;var-list&gt; <span class="hljs-keyword">in</span> &lt;<span class="hljs-built_in">exp</span>-list&gt; <span class="hljs-keyword">do</span>    &lt;body&gt;<span class="hljs-keyword">end</span></code></pre><ul><li><code>&lt;var-list&gt;</code>是以一个或多个逗号分隔的变量名列表</li><li><code>&lt;exp-list&gt;</code>是以一个或多个逗号分隔的表达式列表，通常情况下exp-list只有一个值：迭代工厂的调用。</li></ul><p>变量列表的第一个元素称为“控制变量”，当其变为nil时，循环结束。</p><h3 id="泛型for的执行过程"><a href="#泛型for的执行过程" class="headerlink" title="泛型for的执行过程"></a>泛型for的执行过程</h3><p>首先，初始化，计算in后面表达式的值，表达式应该返回范性for需要的三个值：迭代函数、状态常量、控制变量的初值；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用nil补足，多出部分会被忽略。</p><p>第二，将状态常量和控制变量作为参数调用迭代函数（注意：对于for结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。</p><p>第三，for将迭代函数返回的值赋给变量列表。</p><p>第四，如果返回的第一个值为nil循环结束，否则执行循环体。</p><p>第五，回到第二步再次调用迭代函数。</p><blockquote><p>类似于一个do…while循环</p></blockquote><h2 id="无状态的迭代器"><a href="#无状态的迭代器" class="headerlink" title="无状态的迭代器"></a>无状态的迭代器</h2><p>无状态的迭代器是指<strong>不保留任何状态</strong>的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。</p><p>每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。这种无状态迭代器的典型的简单的例子是ipairs，他遍历数组的每一个元素。</p><pre><code class="hljs lua">a = &#123;<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>&#125;<span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(a) <span class="hljs-keyword">do</span>    <span class="hljs-built_in">print</span>(i, v)<span class="hljs-keyword">end</span></code></pre><p>迭代的状态包括被遍历的表（循环过程中不会改变的状态常量）和当前的索引下标（控制变量），ipairs和迭代函数都很简单，我们在Lua中可以这样实现：</p><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iter</span> <span class="hljs-params">(a, i)</span></span>    i = i + <span class="hljs-number">1</span>    <span class="hljs-keyword">local</span> v = a[i]    <span class="hljs-keyword">if</span> v <span class="hljs-keyword">then</span>        <span class="hljs-keyword">return</span> i, v    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ipairs</span> <span class="hljs-params">(a)</span></span>    <span class="hljs-keyword">return</span> iter, a, <span class="hljs-number">0</span><span class="hljs-keyword">end</span></code></pre><p>当Lua调用ipairs(a)开始循环时，他获取三个值：迭代函数iter、状态常量a、控制变量初始值0；然后Lua调用iter(a,0)返回1,a[1]（除非a[1]=nil）；第二次迭代调用iter(a,1)返回2,a[2]……直到第一个非nil元素。</p><p>Lua库中实现的pairs是一个用next实现的原始方法：</p><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pairs</span> <span class="hljs-params">(t)</span></span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">next</span>, t, <span class="hljs-literal">nil</span><span class="hljs-keyword">end</span></code></pre><p>还可以不使用ipairs直接使用next</p><pre><code class="hljs lua"><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">next</span>, t <span class="hljs-keyword">do</span>    ...<span class="hljs-keyword">end</span></code></pre><p>记住：<strong>Lua会自动将for循环中返回结果会被调整为三个</strong>，所以Lua获取next、t、nil；确切地说当他调用pairs时获取。</p><h2 id="具有复杂状态的迭代器"><a href="#具有复杂状态的迭代器" class="headerlink" title="具有复杂状态的迭代器"></a>具有复杂状态的迭代器</h2><p>很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制信息，但泛型for却只提供一个恒定状态和一个控制变量用于状态的保存。</p><p>一个最简单的解决办法就是使用closure。🙃(还没想到)</p><p>另一个办法是将迭代器所需的所有状态打包为一个table，保存在恒定状态之中。然后迭代器就可以通过这个table就可以保存任意多的数据。此外for还可以在循环过程中改变这些数据。(所谓的恒定是指恒定状态总是那个table)。因为这种情况下可以将所有的信息存放在table内，所以迭代函数通常不需要第二个参数。</p><pre><code class="hljs lua"><span class="hljs-comment">-- 便利当前输入文件中的所有单词</span><span class="hljs-keyword">local</span> iterator       <span class="hljs-comment">-- to be defined later</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">allwords</span><span class="hljs-params">()</span></span>    <span class="hljs-keyword">local</span> state = &#123;line = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>(), pos = <span class="hljs-number">1</span>&#125;    <span class="hljs-keyword">return</span> iterator, state<span class="hljs-keyword">end</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iterator</span> <span class="hljs-params">(state)</span></span>    <span class="hljs-keyword">while</span> state.line <span class="hljs-keyword">do</span>      <span class="hljs-comment">-- repeat while there are lines</span>       <span class="hljs-comment">-- search for next word</span>       <span class="hljs-keyword">local</span> s, e = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">find</span>(state.line, <span class="hljs-string">&quot;%w+&quot;</span>, state.pos)       <span class="hljs-keyword">if</span> s <span class="hljs-keyword">then</span>     <span class="hljs-comment">-- found a word?</span>           <span class="hljs-comment">-- update next position (after this word)</span>           state.pos = e + <span class="hljs-number">1</span>           <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>.<span class="hljs-built_in">sub</span>(state.line, s, e)       <span class="hljs-keyword">else</span>   <span class="hljs-comment">-- word not found</span>           state.line = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()   <span class="hljs-comment">-- try next line...</span>           state.pos = <span class="hljs-number">1</span>     <span class="hljs-comment">-- ... from first position</span>       <span class="hljs-keyword">end</span>    <span class="hljs-keyword">end</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>        <span class="hljs-comment">-- no more lines: end loop</span><span class="hljs-keyword">end</span></code></pre><p>我们应该<strong>尽可能的写无状态的迭代器</strong>，因为这样循环的时候由for来保存状态，不需要创建对象花费的代价小；如果不能用无状态的迭代器实现，应<strong>尽可能使用闭包</strong>；尽可能不要使用table这种方式，因为创建闭包的代价要比创建table小，另外Lua处理闭包要比处理table速度快些。后面我们还将看到另一种使用协同来创建迭代器的方式，这种方式功能更强但更复杂。</p><h2 id="真正的迭代器"><a href="#真正的迭代器" class="headerlink" title="真正的迭代器"></a>真正的迭代器</h2>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lua快速入门 —— 函数</title>
    <link href="/lua-2/"/>
    <url>/lua-2/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：Lua的函数的基本形式、如何调用以及函数的多重返回值、变长参数、具名实参。此外还有Lua中函数的地位，即函数是类似于数字那样的第一类值，还有匿名函数、闭包、局部函数以及尾调用函数。</p><a id="more"></a><blockquote><p>参照书籍：<strong>《Lua程序设计（第二版）》</strong></p><p>Lua版本：<strong>Lua 5.3.5</strong></p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Lua中的函数是第一类值，可以像变量那样被赋给其他的变量、被存储到表中、作为函数参数或者是函数的返回值，即实际上函数就像一个变量一样，函数是“匿名的”，函数名只不过是指向了那个函数而已。Lua中的函数可以有多个返回值，Lua可以接受非固定数量的参数，同时调用Lua函数时，可以指定参数以实参。此外Lua支持匿名函数，闭包，Lua中的函数尾调用类似于goto语句，可以避免栈操作。</p><hr><p>在Lua中函数是一种对语句或者表达式进行抽象的主要机制。</p><h2 id="函数的基本形式"><a href="#函数的基本形式" class="headerlink" title="函数的基本形式"></a>函数的基本形式</h2><pre><code class="hljs lua"><span class="hljs-comment">-- 函数实现语法规则：</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func_name</span><span class="hljs-params">(argument-list)</span></span> <span class="hljs-comment">-- 函数名(参数)</span>    statements-list; <span class="hljs-comment">-- 函数体</span><span class="hljs-keyword">end</span></code></pre><pre><code class="hljs lua"><span class="hljs-comment">-- 实例</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func_name</span><span class="hljs-params">()</span></span>   <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-comment">-- 见下面的说明</span><span class="hljs-keyword">end</span>func_name() <span class="hljs-comment">-- 函数的调用</span><span class="hljs-comment">-- 计算从1加到n的和</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adds</span><span class="hljs-params">(n)</span></span>  <span class="hljs-keyword">local</span> sum = <span class="hljs-number">0</span>  <span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>,n <span class="hljs-keyword">do</span>    sum = sum + i  <span class="hljs-keyword">end</span>  <span class="hljs-keyword">return</span> sum<span class="hljs-keyword">end</span><span class="hljs-built_in">print</span>(adds(<span class="hljs-number">4</span>)) <span class="hljs-comment">-- 10</span></code></pre><h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><p>同其他语言类似，<code>函数名+（参数）</code> 若参数列表为空也需要加上括号()。</p><p>例外：<strong>当函数有且只有一个参数，并且该参数是<font color="red">字符串</font>或者<font color="red">表构造式</font>时，()可有可无。</strong></p><pre><code class="hljs lua"><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Hello World&quot;</span>      &lt;<span class="hljs-comment">--&gt;      print(&quot;Hello World&quot;)</span><span class="hljs-built_in">dofile</span> <span class="hljs-string">&#x27;a.lua&#x27;</span>           &lt;<span class="hljs-comment">--&gt;       dofile (&#x27;a.lua&#x27;)</span><span class="hljs-built_in">print</span> <span class="hljs-string">[[a multi-line     &lt;--&gt;       print([[a multi-line</span><span class="hljs-string"></span><span class="hljs-string">           message]]                          message]]</span>)f&#123;x=<span class="hljs-number">10</span>, y=<span class="hljs-number">20</span>&#125;            &lt;<span class="hljs-comment">--&gt;       f(&#123;x=10, y=20&#125;)</span><span class="hljs-built_in">type</span>&#123;&#125;                   &lt;<span class="hljs-comment">--&gt;       type(&#123;&#125;)</span></code></pre><p>以及面向对象式的调用函数:</p><pre><code class="hljs lua">o:foo(x)  &lt;<span class="hljs-comment">--&gt; o.foo(o,x)</span></code></pre><p>此外，<strong>Lua程序既可以使用以Lua编写的程序，也可以调用C语言或者宿主程序使用的其他语言编写的程序</strong>。</p><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>若实参多于形参，则舍弃多余的实参，若实参不足，则多余的形参初始化为nil。</p><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(a, b)</span></span> <span class="hljs-keyword">return</span> a <span class="hljs-keyword">or</span> b <span class="hljs-keyword">end</span>CALL              PARAMETERSf(<span class="hljs-number">3</span>)              a=<span class="hljs-number">3</span>, b=<span class="hljs-literal">nil</span>f(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)           a=<span class="hljs-number">3</span>, b=<span class="hljs-number">4</span>f(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)        a=<span class="hljs-number">3</span>, b=<span class="hljs-number">4</span>   (<span class="hljs-number">5</span> is discarded)</code></pre><p>用处：用于默认参数的应用。</p><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incCount</span><span class="hljs-params">(n)</span></span>    n = n <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>    count = count + n<span class="hljs-keyword">end</span></code></pre><p>上述函数使用1作为默认参数，若直接调用IncCount()函数而不传递参数时，count值增加1。因为不传递参数则n被初始化为nil，而 <code>nil or 1</code> 返回值为1，故最终初始化为1.</p><h2 id="多重返回值"><a href="#多重返回值" class="headerlink" title="多重返回值"></a>多重返回值</h2><p>Lua与众不同的特征：<strong>允许函数返回多个结果</strong>。</p><pre><code class="hljs lua"><span class="hljs-comment">--例如 string.find() 返回匹配串的开始和结束的下标，如果不存在返回nil</span>s,e = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;hello Lua users&quot;</span>,<span class="hljs-string">&quot;Lua&quot;</span>)<span class="hljs-built_in">print</span>(s,e)  <span class="hljs-comment">--&gt; 7  9</span></code></pre><pre><code class="hljs lua"><span class="hljs-comment">-- 取得一个table中最大的值和该值最大的下标</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maximum</span><span class="hljs-params">(a)</span></span>  <span class="hljs-keyword">local</span> mi = <span class="hljs-number">1</span> <span class="hljs-comment">-- max value index</span>  <span class="hljs-keyword">local</span> m = a[mi] <span class="hljs-comment">-- max value</span>  <span class="hljs-keyword">for</span> i,val <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(a) <span class="hljs-keyword">do</span>    <span class="hljs-keyword">if</span> val &gt; m <span class="hljs-keyword">then</span>      mi = i      m = val    <span class="hljs-keyword">end</span>  <span class="hljs-keyword">end</span>  <span class="hljs-keyword">return</span> m,mi<span class="hljs-keyword">end</span><span class="hljs-built_in">print</span>(maximum(&#123;<span class="hljs-number">23</span>,<span class="hljs-number">56</span>,<span class="hljs-number">48</span>,<span class="hljs-number">10</span>&#125;)) <span class="hljs-comment">--&gt; 56  2</span></code></pre><h3 id="Lua的多重返回值使用"><a href="#Lua的多重返回值使用" class="headerlink" title="Lua的多重返回值使用"></a>Lua的多重返回值使用</h3><p>Lua会调整一个函数的返回值来适应不同的情况。</p><ol><li>若函数作为单独的语句时，Lua会丢弃函数的返回值。</li><li>若函数作为表达式的一部分来调用时，Lua只会保留函数的第一个返回值。</li><li>若函数调用是一系列表达式中的最后一个元素时，此时才能获得所有的返回值。</li><li>当函数调用作为另一个函数调用的最后一个实参时，这个函数的全部返回值都会作为实参传递给第二个参数，比如print函数</li><li>若函数调用存在于table构造式之中时，且该函数调用是作为最后一个元素时，获取全部结果，否则其他位置只产生一个结果。</li><li>return语句，例如<code>return maximum(&#123;23,56,48,10&#125;)</code>将返回函数的全部返回值。</li><li>将函数调用单独放在一对圆括号之中，将会只返回一个结果，所以return语句也不要随意加括号。</li></ol><pre><code class="hljs lua">x,y = maximum(&#123;<span class="hljs-number">23</span>,<span class="hljs-number">56</span>,<span class="hljs-number">48</span>,<span class="hljs-number">10</span>&#125;) <span class="hljs-comment">--&gt; 56  2</span>x = maximum(&#123;<span class="hljs-number">23</span>,<span class="hljs-number">56</span>,<span class="hljs-number">48</span>,<span class="hljs-number">10</span>&#125;)  <span class="hljs-comment">--&gt; 56</span><span class="hljs-comment">-- 情况3 获取所有的返回值</span>x,y,z = <span class="hljs-number">100</span>,maximum(&#123;<span class="hljs-number">23</span>,<span class="hljs-number">56</span>,<span class="hljs-number">48</span>,<span class="hljs-number">10</span>&#125;)  <span class="hljs-comment">--&gt;100 56 2</span><span class="hljs-comment">-- 情况2 只产生一个值</span>x,y = maximum(&#123;<span class="hljs-number">23</span>,<span class="hljs-number">56</span>,<span class="hljs-number">48</span>,<span class="hljs-number">10</span>&#125;),<span class="hljs-number">100</span>  <span class="hljs-comment">--&gt; 56 100</span><span class="hljs-comment">-- 情况4</span><span class="hljs-built_in">print</span>(maximum(&#123;<span class="hljs-number">23</span>,<span class="hljs-number">56</span>,<span class="hljs-number">48</span>,<span class="hljs-number">10</span>&#125;)) <span class="hljs-comment">--&gt; 56  2</span><span class="hljs-comment">-- 情况2</span><span class="hljs-built_in">print</span>(maximum(&#123;<span class="hljs-number">23</span>,<span class="hljs-number">56</span>,<span class="hljs-number">48</span>,<span class="hljs-number">10</span>&#125;)..<span class="hljs-string">&quot;hello&quot;</span>)  <span class="hljs-comment">--&gt;56hello</span><span class="hljs-comment">-- 情况5</span>t = &#123;maximum(&#123;<span class="hljs-number">23</span>,<span class="hljs-number">56</span>,<span class="hljs-number">48</span>,<span class="hljs-number">10</span>&#125;)&#125;<span class="hljs-built_in">print</span>(t[<span class="hljs-number">1</span>])  <span class="hljs-comment">--&gt; 56</span><span class="hljs-built_in">print</span>(t[<span class="hljs-number">2</span>])  <span class="hljs-comment">--&gt; 2</span>t1 = &#123;maximum(&#123;<span class="hljs-number">23</span>,<span class="hljs-number">56</span>,<span class="hljs-number">48</span>,<span class="hljs-number">10</span>&#125;),<span class="hljs-number">100</span>&#125;<span class="hljs-built_in">print</span>(t1[<span class="hljs-number">1</span>])  <span class="hljs-comment">--&gt; 56</span><span class="hljs-built_in">print</span>(t1[<span class="hljs-number">2</span>])  <span class="hljs-comment">--&gt; 100</span><span class="hljs-comment">-- 情况6</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>  <span class="hljs-keyword">return</span> maximum(&#123;<span class="hljs-number">23</span>,<span class="hljs-number">56</span>,<span class="hljs-number">48</span>,<span class="hljs-number">10</span>&#125;)<span class="hljs-keyword">end</span><span class="hljs-built_in">print</span>(a())  <span class="hljs-comment">--&gt; 56   2</span><span class="hljs-comment">-- 情况7</span><span class="hljs-built_in">print</span>((a()))  <span class="hljs-comment">--&gt; 56</span></code></pre><h3 id="特殊函数-unpack"><a href="#特殊函数-unpack" class="headerlink" title="特殊函数 unpack"></a>特殊函数 unpack</h3><p>unpack接收一个数组作为参数，并从下标1开始返回该数组的所有元素。</p><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">unpack</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;))  <span class="hljs-comment">--&gt; 1  2  3</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">unpack</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;)  <span class="hljs-comment">--&gt; 1  2   3</span><span class="hljs-comment">-- 当函数有且只有一个参数，并且该参数是字符串或者表构造式时，()可有可无。</span>x,y = <span class="hljs-built_in">unpack</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;  <span class="hljs-comment">--&gt; 1  2</span></code></pre><p>unpack的一项重要用途体现在泛型调用机制中。泛型调用机制可以动态地以任何实参来调用任何函数。</p><blockquote><p>举例来说ANSI C中无法编写泛型调用的代码。最多是声明一个能接受变长参数的函数(stdarg.h)，或者使用一个函数指针来调用不同的函数。并且在C语言中，无法在同一函数调用中传入动态数量的参数，也就是说，在每次调用不同的函数时必须传入固定数量的参数，并且每个参数都具有确定的类型。</p></blockquote><p>在Lua中，如果你想调用任意函数f，而所有的参数都在数组a中，可以：<code>f(unpack(a))</code></p><pre><code class="hljs lua">f = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">find</span>a = &#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;ll&quot;</span>&#125;<span class="hljs-built_in">print</span>(f(<span class="hljs-built_in">unpack</span>(a)))      <span class="hljs-comment">--&gt; 3  4</span></code></pre><p>预定义的unpack函数是用C语言实现的，我们也可以用Lua来完成：</p><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unpack</span><span class="hljs-params">(t, i)</span></span>    i = i <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>    <span class="hljs-keyword">if</span> t[i] <span class="hljs-keyword">then</span>       <span class="hljs-keyword">return</span> t[i], <span class="hljs-built_in">unpack</span>(t, i + <span class="hljs-number">1</span>)    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span></code></pre><h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2><p>在函数的实现中，括号里的参数列表使用三个点 (…) 来表示该函数可以接受不同数量的实参。</p><p>而当函数内要调用变长参数时，仍然需要直接使用三个点 (…) 。</p><pre><code class="hljs lua"><span class="hljs-comment">-- 计算所有参数的总和</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">(...)</span></span>  <span class="hljs-keyword">local</span> sum = <span class="hljs-number">0</span>  <span class="hljs-built_in">print</span>(...)  <span class="hljs-comment">--直接使用可变参数</span>  <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>&#123;...&#125; <span class="hljs-keyword">do</span>    sum = sum + v  <span class="hljs-keyword">end</span>  <span class="hljs-keyword">return</span> sum<span class="hljs-keyword">end</span><span class="hljs-built_in">print</span>(add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>))  <span class="hljs-comment">--&gt;15</span></code></pre><ul><li>若函数还有固定参数，固定参数必须放在可变参数之前。</li><li>若函数还有固定参数，则实际传参时优先匹配固定参数，多余参数全部被赋予可变参数</li><li>通常一个函数在遍历其变长参数时只需要使用表达式<code>...</code>，然而在某些特殊情况下，变长参数可能会包含一些故意传入的 <code>nil</code> ，那么此时需要用函数select来访问变长参数了。</li><li><strong>对 <code>...</code> 的操作是Lua5.1之后的版本支持的，Lua5.0版本提供了隐含变量<code>arg</code>来接受所有的变长参数。</strong> ——《Lua程序设计第二版 P41》</li></ul><h3 id="特殊情况时使用select访问变长参数"><a href="#特殊情况时使用select访问变长参数" class="headerlink" title="特殊情况时使用select访问变长参数"></a>特殊情况时使用select访问变长参数</h3><p>调用select函数需要传入一个固定实参selector(选择开关)和一系列变长参数。</p><ul><li>若selector为数字n，那么<u>select函数就会返回它的第n个可变实参</u>(实际上，下面的代码测试为从第i个开始的参数，select(1,…) 实际返回的是多个返回值)</li><li>否则selector只能为字符串”#”，这样select会返回变长参数的总数。</li><li><code>select(&quot;#&quot;, ...)</code> 会返回所有变长参数的总数，其中包括nil。</li></ul><pre><code class="hljs lua"><span class="hljs-comment">-- 计算所有参数的总和</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">(...)</span></span>  <span class="hljs-keyword">local</span> sum = <span class="hljs-number">0</span>      <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-built_in">select</span>(<span class="hljs-string">&quot;#&quot;</span>, ...) <span class="hljs-keyword">do</span>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">select</span>(i,...))  <span class="hljs-keyword">end</span>    <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>&#123;...&#125; <span class="hljs-keyword">do</span>    sum = sum + v  <span class="hljs-keyword">end</span>  <span class="hljs-keyword">return</span> sum<span class="hljs-keyword">end</span><span class="hljs-built_in">print</span>(add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>))  <span class="hljs-comment">--&gt;15</span></code></pre><h2 id="具名实参"><a href="#具名实参" class="headerlink" title="具名实参"></a>具名实参</h2><p>顾名思义，就是使用函数时，通过指定形参的名称来给形参赋值。</p><p>但是Lua不能像其他语言那样直接使用类似<code>rename(old=&quot;temp.lua&quot;,  new=&quot;temp1.lua&quot;)</code>这样的方式，Lua可以通过将所有的参数放在一个表中，把表作为函数的唯一参数来实现。</p><pre><code class="hljs lua"><span class="hljs-built_in">rename</span>&#123;old=<span class="hljs-string">&quot;temp.lua&quot;</span>, new=<span class="hljs-string">&quot;temp1.lua&quot;</span>&#125;</code></pre><p>然后根据这个想法可以重新定义rename</p><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rename</span> <span class="hljs-params">(arg)</span></span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">os</span>.<span class="hljs-built_in">rename</span>(<span class="hljs-built_in">arg</span>.old, <span class="hljs-built_in">arg</span>.new)<span class="hljs-keyword">end</span></code></pre><p>当函数的参数很多的时候，这种函数参数的传递方式很方便的。例如GUI库中创建窗体的函数有很多参数并且大部分参数是可选的，可以用下面这种方式：</p><pre><code class="hljs lua">w = Window &#123;    x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>, width=<span class="hljs-number">300</span>, height=<span class="hljs-number">200</span>,    title = <span class="hljs-string">&quot;Lua&quot;</span>, background=<span class="hljs-string">&quot;blue&quot;</span>,    border = <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Window</span> <span class="hljs-params">(options)</span></span>    <span class="hljs-comment">-- check mandatory options</span>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(options.title) ~= <span class="hljs-string">&quot;string&quot;</span> <span class="hljs-keyword">then</span>       <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;no title&quot;</span>)    <span class="hljs-keyword">elseif</span> <span class="hljs-built_in">type</span>(options.width) ~= <span class="hljs-string">&quot;number&quot;</span> <span class="hljs-keyword">then</span>       <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;no width&quot;</span>)    <span class="hljs-keyword">elseif</span> <span class="hljs-built_in">type</span>(options.height) ~= <span class="hljs-string">&quot;number&quot;</span> <span class="hljs-keyword">then</span>       <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;no height&quot;</span>)    <span class="hljs-keyword">end</span>    <span class="hljs-comment">-- everything else is optional</span>    _Window(options.title,       options.x <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>,          <span class="hljs-comment">-- default value</span>       options.y <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>,          <span class="hljs-comment">-- default value</span>       options.width, options.height,       options.background <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;white&quot;</span>,  <span class="hljs-comment">-- default</span>       options.border           <span class="hljs-comment">-- default is false (nil)</span>    )<span class="hljs-keyword">end</span></code></pre><hr><h2 id="进阶：函数是第一类值"><a href="#进阶：函数是第一类值" class="headerlink" title="进阶：函数是第一类值"></a>进阶：函数是第一类值</h2><p>Lua中的函数是带有词法定界（lexical scoping）的<strong>第一类值</strong>（first-class values）。</p><p><strong>第一类值指：在Lua中函数和其他值（数值、字符串）一样，函数可以被存放在变量中，也可以存放在表中，可以作为函数的参数，还可以作为函数的返回值。</strong></p><p>词法定界指：嵌套的函数可以访问他外部函数中的变量。这一特性给Lua提供了强大的编程能力。</p><p>在Lua中，”函数和所有其它的值一样都是匿名的“，当我们在说某个函数时，比如print，实际上是在讨论拥有了一个函数的变量而已，print也可以被赋值。</p><pre><code class="hljs lua">b = <span class="hljs-built_in">print</span>b(<span class="hljs-string">&quot;123&quot;</span>)a = &#123;p = <span class="hljs-built_in">print</span>&#125;a.p(<span class="hljs-string">&quot;Hello World&quot;</span>)   <span class="hljs-comment">--&gt; Hello World</span><span class="hljs-built_in">print</span> = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span>  <span class="hljs-comment">-- `print&#x27;被赋值为正弦函数</span>a.p(<span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>))     <span class="hljs-comment">--&gt; 0.841470</span><span class="hljs-built_in">sin</span> = a.p         <span class="hljs-comment">-- `sin&#x27; now refers to the print function</span><span class="hljs-built_in">sin</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)       <span class="hljs-comment">--&gt; 10   20</span></code></pre><p>所以函数就像一个变量一样，是可以由表达式创建的，我们在本篇博客开头看见的函数创建方式实际类似于“语法糖”。</p><pre><code class="hljs lua"><span class="hljs-comment">-- function foo(x) return 2*x end</span>foo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x)</span></span> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x <span class="hljs-keyword">end</span> <span class="hljs-comment">-- 创建一个变量，赋值为函数</span><span class="hljs-built_in">print</span>(foo(<span class="hljs-number">1</span>)) <span class="hljs-comment">--&gt; 2</span></code></pre><p>这样创建的函数实际就像是创建了一个匿名函数，然后再将匿名函数赋予了一个变量。</p><p>由于Lua是第一类值，所以不仅可以将其存储在全局变量中，还可以存储在局部变量中甚至table的字段中。</p><h3 id="函数可以存储到table字段中"><a href="#函数可以存储到table字段中" class="headerlink" title="函数可以存储到table字段中"></a>函数可以存储到table字段中</h3><p>有部分Lua库将函数存储在table字段中，例如：io.read，math.sin。</p><blockquote><p>复习前面接触到的table的语法糖：a = {} a.x就是a[“x”]。即以字符串x为索引。</p></blockquote><pre><code class="hljs lua"><span class="hljs-comment">-- 方式一</span>Lib = &#123;&#125;Lib.foo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x,y)</span></span> <span class="hljs-keyword">return</span> x+y <span class="hljs-keyword">end</span>Lib.goo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x,y)</span></span> <span class="hljs-keyword">return</span> x-y <span class="hljs-keyword">end</span><span class="hljs-built_in">print</span>(Lib.foo(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))  <span class="hljs-comment">--&gt; 5</span><span class="hljs-comment">-- 方式二</span>Lib = &#123;foo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x,y)</span></span> <span class="hljs-keyword">return</span> x+y <span class="hljs-keyword">end</span>goo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x,y)</span></span> <span class="hljs-keyword">return</span> x-y <span class="hljs-keyword">end</span>&#125;<span class="hljs-comment">-- 方式三</span>Lib = &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Lib.foo</span> <span class="hljs-params">(x,y)</span></span> <span class="hljs-keyword">return</span> x+y <span class="hljs-keyword">end</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Lib.goo</span> <span class="hljs-params">(x,y)</span></span> <span class="hljs-keyword">return</span> x+y <span class="hljs-keyword">end</span></code></pre><h2 id="匿名函数的应用"><a href="#匿名函数的应用" class="headerlink" title="匿名函数的应用"></a>匿名函数的应用</h2><p>table标准库提供一个排序函数，接受一个表作为输入参数并且排序表中的元素。这个函数必须能够对不同类型的值（字符串或者数值）按升序或者降序进行排序。Lua不是尽可能多地提供参数来满足这些情况的需要，而是接受一个排序函数作为参数（类似C++的函数对象），排序函数接受两个排序元素作为输入参数，并且返回两者的大小关系，例如：</p><pre><code class="hljs lua">network = &#123;    &#123;name = <span class="hljs-string">&quot;grauna&quot;</span>,    IP = <span class="hljs-string">&quot;210.26.30.34&quot;</span>&#125;,    &#123;name = <span class="hljs-string">&quot;arraial&quot;</span>,   IP = <span class="hljs-string">&quot;210.26.30.23&quot;</span>&#125;,    &#123;name = <span class="hljs-string">&quot;lua&quot;</span>,       IP = <span class="hljs-string">&quot;210.26.23.12&quot;</span>&#125;,    &#123;name = <span class="hljs-string">&quot;derain&quot;</span>,    IP = <span class="hljs-string">&quot;210.26.23.20&quot;</span>&#125;,&#125;<span class="hljs-built_in">table</span>.<span class="hljs-built_in">sort</span>(network, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a,b)</span></span> <span class="hljs-keyword">return</span> (a.name &gt; b.name) <span class="hljs-keyword">end</span>)<span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(network) <span class="hljs-keyword">do</span>  <span class="hljs-built_in">print</span>(v.name , v.IP)<span class="hljs-keyword">end</span><span class="hljs-comment">--[[</span><span class="hljs-comment">lua210.26.23.12</span><span class="hljs-comment">grauna210.26.30.34</span><span class="hljs-comment">derain210.26.23.20</span><span class="hljs-comment">arraial210.26.30.23</span><span class="hljs-comment">--]]</span></code></pre><h2 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包 closure"></a>闭包 closure</h2><p><strong>词法域</strong>：若将一个函数写在另一个函数内，那么这个位于内部的函数便可以访问外部函数中的局部变量，这项特征称之为“词法域”。</p><p><strong>closure</strong>：<font color="red">简单的讲，一个closure就是一个函数加上该函数所需访问的所有的“<strong>非局部的变量</strong>”。</font></p><h3 id="非局部的变量"><a href="#非局部的变量" class="headerlink" title="非局部的变量"></a>非局部的变量</h3><pre><code class="hljs lua">name = &#123;<span class="hljs-string">&quot;Peter&quot;</span>,<span class="hljs-string">&quot;Paul&quot;</span>,<span class="hljs-string">&quot;Mary&quot;</span>&#125;grades = &#123;Peter = <span class="hljs-number">8</span>,Paul = <span class="hljs-number">7</span>,Mary = <span class="hljs-number">10</span>&#125;<span class="hljs-built_in">table</span>.<span class="hljs-built_in">sort</span>(name, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n1,n2)</span></span>    <span class="hljs-keyword">return</span> grades[n1] &gt; grades[n2]  <span class="hljs-comment">-- 比较年级</span>    <span class="hljs-keyword">end</span>)<span class="hljs-comment">-- 改写代码，封装函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortbygrade</span><span class="hljs-params">(names,grades)</span></span>   <span class="hljs-built_in">table</span>.<span class="hljs-built_in">sort</span>(names,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n1,n2)</span></span>    <span class="hljs-keyword">return</span> grades[n1] &gt; grades[n2]        <span class="hljs-keyword">end</span>) <span class="hljs-keyword">end</span></code></pre><p>对于<code>sortbygrade()</code>函数来说，传递给<code>sort</code>的匿名函数可以去访问参数<code>grades</code>，而<code>grades</code>是外部函数<code>sortbygrade()</code>的<strong>局部变量</strong>。但对于匿名函数来说，grades既不是全局变量，也不是局部变量，而是将其称为一个<strong>非局部的变量</strong>(non-local variable 或 <strong>upvalue</strong>)。</p><h3 id="closure"><a href="#closure" class="headerlink" title="closure"></a>closure</h3><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newCounter</span><span class="hljs-params">()</span></span>  <span class="hljs-keyword">local</span> i = <span class="hljs-number">0</span>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>    i = i + <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> i  <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>c1 = newCounter()<span class="hljs-built_in">print</span>(c1())  <span class="hljs-comment">--》 1</span><span class="hljs-built_in">print</span>(c1())  <span class="hljs-comment">--》 2</span>c2 = newCounter()<span class="hljs-built_in">print</span>(c2())  <span class="hljs-comment">--》 1</span></code></pre><p>在这里c1和c2是同一个函数创建的两个不同的closure，他们各自之间拥有局部变量i的独立实例。</p><blockquote><p>闭包的内容对应于《Lua程序设计第二版 P47-50》</p></blockquote><pre><code class="hljs lua"><span class="hljs-comment">-- 计算y = a*x + b</span><span class="hljs-comment">--普通函数写法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span><span class="hljs-params">(a,b,x)</span></span>    <span class="hljs-keyword">return</span> a*x+b<span class="hljs-keyword">end</span><span class="hljs-comment">--闭包的写法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span><span class="hljs-params">(a,b)</span></span>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span>        <span class="hljs-keyword">return</span> a*x+b    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-comment">--这样对于计算ab固定的一阶函数的时候，比较方便</span>y1 = func1(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)ends = y1(<span class="hljs-number">5</span>)  <span class="hljs-comment">--&gt; 13</span>ends = y1(<span class="hljs-number">4</span>)  <span class="hljs-comment">--&gt; 11</span></code></pre><blockquote><p>from Colourso&gt; </p><p>Lua的闭包和Python的闭包有些相似，上面的这个例子就是我接触Python闭包时的例子，Python闭包网址： <a href="http://www.colourso.top/Python/">http://www.colourso.top/Python/</a> </p></blockquote><h3 id="closure的用途举例：创建一个安全环境"><a href="#closure的用途举例：创建一个安全环境" class="headerlink" title="closure的用途举例：创建一个安全环境"></a>closure的用途举例：创建一个安全环境</h3><p><strong>把原始版本的函数放在一个局部变量里，然后这个函数被访问的唯一方法就是通过新版本的函数。</strong></p><p>例如：当我们运行一段不信任的代码（比如我们运行网络服务器上获取的代码）时安全的环境是需要的，比如我们可以使用闭包重定义io库的open函数来限制程序打开的文件。</p><pre><code class="hljs lua"><span class="hljs-keyword">do</span>    <span class="hljs-keyword">local</span> oldOpen = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>    <span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(filename, mode)</span></span>       <span class="hljs-keyword">if</span> access_OK(filename, mode) <span class="hljs-keyword">then</span>           <span class="hljs-keyword">return</span> oldOpen(filename, mode)       <span class="hljs-keyword">else</span>           <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;access denied&quot;</span>       <span class="hljs-keyword">end</span>    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span></code></pre><h2 id="非全局的函数"><a href="#非全局的函数" class="headerlink" title="非全局的函数"></a>非全局的函数</h2><p>将一个函数存储到一个局部变量中，即得到了一个“局部函数”，这个函数只能在某个特定的作用域中使用。</p><pre><code class="hljs lua"><span class="hljs-keyword">local</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span> <span class="hljs-keyword">return</span> x <span class="hljs-keyword">end</span><span class="hljs-comment">--Lua的语法糖</span><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(x)</span></span>    <span class="hljs-keyword">return</span> x<span class="hljs-keyword">end</span></code></pre><h3 id="局部递归函数注意事项"><a href="#局部递归函数注意事项" class="headerlink" title="局部递归函数注意事项"></a>局部递归函数注意事项</h3><pre><code class="hljs lua"><span class="hljs-comment">-- 错误</span><span class="hljs-keyword">local</span> fact = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span></span>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    <span class="hljs-keyword">else</span>       <span class="hljs-keyword">return</span> n*fact(n<span class="hljs-number">-1</span>)   <span class="hljs-comment">-- 错误</span>    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-comment">-- 上面这种方式导致Lua编译时遇到fact(n-1)并不知道他是局部函数fact，Lua会去查找是否有这样的全局函数fact。为了解决这个问题我们必须在定义函数以前先声明：</span><span class="hljs-keyword">local</span> factfact = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span></span>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    <span class="hljs-keyword">else</span>       <span class="hljs-keyword">return</span> n*fact(n<span class="hljs-number">-1</span>)    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-comment">-- 这样在fact内部fact(n-1)调用是一个局部函数调用，运行时fact就可以获取正确的值了</span></code></pre><h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p>当函数最后一个动作是调用另外一个函数时，我们称这种调用尾调用。例如：</p><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(x)</span></span>    <span class="hljs-keyword">return</span> g(x)  <span class="hljs-comment">-- g的调用就是尾调用</span><span class="hljs-keyword">end</span></code></pre><p>上面例子中f调用g后不会再做任何事情，这种情况下当被调用函数g结束时程序不需要返回到调用者f；所以<strong>尾调用之后程序不需要在栈中保留关于调用者的任何信息</strong>。一些编译器比如Lua解释器利用这种特性在处理尾调用时<strong>不使用额外的栈</strong>，我们称这种语言支持正确的尾调用。</p><p>由于尾调用不需要使用栈空间，那么<strong>尾调用递归的层次可以无限制的</strong>。</p><pre><code class="hljs lua"><span class="hljs-comment">-- 这个函数无论n为何值都不会导致栈溢出</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">(n)</span></span>    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> foo(n<span class="hljs-number">-1</span>) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span></code></pre><h3 id="正确的尾调用"><a href="#正确的尾调用" class="headerlink" title="正确的尾调用"></a>正确的尾调用</h3><p>形如：<code>return func(args)</code> 这样的调用形式才是真正的尾调用。</p><pre><code class="hljs lua"><span class="hljs-keyword">return</span> x[i].foo(x[j] + a*b,i+j) <span class="hljs-comment">--正确的尾调用</span><span class="hljs-comment">-- 以下都不是正确的尾调用，因为执行完g(x)后还需要额外做运算</span><span class="hljs-keyword">return</span> g(x)+<span class="hljs-number">1</span><span class="hljs-keyword">return</span> x <span class="hljs-keyword">or</span> g(x)<span class="hljs-keyword">return</span> (g(x))  <span class="hljs-comment">-- ()作用是把返回结果调整为一个值</span></code></pre><h3 id="尾调用的应用-——-编写状态机-state-machine"><a href="#尾调用的应用-——-编写状态机-state-machine" class="headerlink" title="尾调用的应用 —— 编写状态机(state machine)"></a>尾调用的应用 —— 编写状态机(state machine)</h3><blockquote><p>状态机的应用要求函数记住每一个状态，改变状态只需要goto(or call)一个特定的函数。我们考虑一个迷宫游戏作为例子：迷宫有很多个房间，每个房间有东西南北四个门，每一步输入一个移动的方向，如果该方向存在即到达该方向对应的房间，否则程序打印警告信息。目标是：从开始的房间到达目的房间。</p><p>这个迷宫游戏是典型的状态机，每个当前的房间是一个状态。我们可以对每个房间写一个函数实现这个迷宫游戏，我们使用尾调用从一个房间移动到另外一个房间。一个四个房间的迷宫代码如下：</p><p>我们可以调用room1()开始这个游戏。</p><p>如果没有正确的尾调用，每次移动都要创建一个栈，多次移动后可能导致栈溢出。但正确的尾调用可以无限制的尾调用，因为每次尾调用只是一个goto到另外一个函数并不是传统的函数调用。</p></blockquote><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">room1</span> <span class="hljs-params">()</span></span>    <span class="hljs-keyword">local</span> move = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()    <span class="hljs-keyword">if</span> move == <span class="hljs-string">&quot;south&quot;</span> <span class="hljs-keyword">then</span>      <span class="hljs-keyword">return</span> room3()    <span class="hljs-keyword">elseif</span> move == <span class="hljs-string">&quot;east&quot;</span> <span class="hljs-keyword">then</span>       <span class="hljs-keyword">return</span> room2()    <span class="hljs-keyword">else</span>       <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;invalid move&quot;</span>)      <span class="hljs-keyword">return</span> room1()   <span class="hljs-comment">-- stay in the same room</span>    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">room2</span> <span class="hljs-params">()</span></span>    <span class="hljs-keyword">local</span> move = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()    <span class="hljs-keyword">if</span> move == <span class="hljs-string">&quot;south&quot;</span> <span class="hljs-keyword">then</span>       <span class="hljs-keyword">return</span> room4()    <span class="hljs-keyword">elseif</span> move == <span class="hljs-string">&quot;west&quot;</span> <span class="hljs-keyword">then</span>       <span class="hljs-keyword">return</span> room1()    <span class="hljs-keyword">else</span>       <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;invalid move&quot;</span>)       <span class="hljs-keyword">return</span> room2()    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">room3</span> <span class="hljs-params">()</span></span>    <span class="hljs-keyword">local</span> move = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()    <span class="hljs-keyword">if</span> move == <span class="hljs-string">&quot;north&quot;</span> <span class="hljs-keyword">then</span>       <span class="hljs-keyword">return</span> room1()    <span class="hljs-keyword">elseif</span> move == <span class="hljs-string">&quot;east&quot;</span> <span class="hljs-keyword">then</span>       <span class="hljs-keyword">return</span> room4()    <span class="hljs-keyword">else</span>       <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;invalid move&quot;</span>)       <span class="hljs-keyword">return</span> room3()    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">room4</span> <span class="hljs-params">()</span></span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;congratilations!&quot;</span>)<span class="hljs-keyword">end</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>世界上没有什么东西比一颗碎掉的心更完整了</title>
    <link href="/%E4%B8%96%E7%95%8C%E4%B8%8A%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%E6%AF%94%E4%B8%80%E9%A2%97%E7%A2%8E%E6%8E%89%E7%9A%84%E5%BF%83%E6%9B%B4%E5%AE%8C%E6%95%B4%E4%BA%86/"/>
    <url>/%E4%B8%96%E7%95%8C%E4%B8%8A%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%E6%AF%94%E4%B8%80%E9%A2%97%E7%A2%8E%E6%8E%89%E7%9A%84%E5%BF%83%E6%9B%B4%E5%AE%8C%E6%95%B4%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来源：微信公众号：<a href="https://mp.weixin.qq.com/s/IiuQhQGwsyZlQy8-PuxtVA">秦朔朋友圈——世界上没有什么东西比一颗碎掉的心更完整了</a></p><p>作者： 忆湄 </p><p>时间：2019.11.17</p></blockquote><a id="more"></a><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p><strong>金钱是一种好东西，不是因为它能买到你想要的任何东西，而是它能让真相暴露地更快。</strong></p><p>和一群人玩过一个真心话游戏——<strong>假设你已经有足够多的钱，而你的余生只能选择做一件事，你会做什么？</strong></p><p>说真的，这类直击人心的问题很适合现代人定期“务虚”，毕竟在焦虑的时代里厮杀惯了，不被逼到某一处，就不知道自己是谁。</p><p><strong>习惯，可是伟大的消音器。</strong></p><p>有人说想专注于修行，有人说想专注于某一个爱好，有人想帮助从小就不被理解的孩子们绽放他们的人生，而有人只想体验生活。</p><p><strong>最有意思的是一位女生，她有定期更新自己遗书的习惯，对人生走向已经反复考量，洞察清澈。</strong>而其他人不会那样“以死为始”，倒退着走进生活，但有一点，他们提到所有余生要做的事，都和眼前正在做的事情无关。<strong>在现实世界里，他们专注的是创业、赚钱，是创造神话，是最大化自己的影响力。</strong></p><p>现实世界里他们是长在金字塔尖的人物，正因如此，世界的嘈杂阻隔了他们的真情实感。自己如果不和一个更强大的东西碰撞，然后反弹回来，你不知道自己是谁。<strong>同样，自己如果不能有底气（比如足够的财富）冲破人为制造的流行那种沉重的覆盖，就无法分清何为欲望，何为理想。</strong></p><p><strong>这大概是“自动”帮自己跃升阶层的好处。</strong></p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>另一个观察到的有意思的现象，是身边的中产往往更向往上流社会的做派，比如要奢华的房产，无死角的旅行，足够气派的孩子生日派对……</p><p>大都市的中产有一种在都市阶层里寻找自身位置的习惯性焦虑，他们从小到大就是好学生，迷恋秩序和等级，因此这种世俗的精致是他们找到用来确信自己已经到达某个层级的途径，仿佛如此就能把他们离真正的顶层社会拉近一点。</p><p>但真正的大佬往往不拘小节，可能就一身不起眼的打扮，套一件皱巴巴的衣服，坐地铁、坐经济舱，没那么讲究。</p><p>早期金钱带来的满足感迅速地产生抗药性，再从中生出虚妄来，成为人生幸福函数里最不起眼的自变量。</p><p>他们发现，金钱既不能确保他们身体健康，家庭幸福，也不能保证他们创业成功，永远不上“老赖”的名单。</p><p><strong>换句话说，这个世界上能用钱买到的，都不贵。</strong>而所有生活（如衣食住行）的粗糙与人活在这个世上的本质是无关的，真正能让你跟这个世界产生瓜葛的是热爱、愿力、心志、认知这样的东西，而表面的精致不过是暂时的体面，它单薄到连人内心的一个窟窿都无法粉饰。</p><p>什么意思呢，穷加剧了人的窘迫，越想得到无尽的财富，举手投足就越会被金钱牢牢掌控；而富有则成就了坦荡，认知到了另一层面，世俗的精致就会掉色。<strong>如果你仅仅从金钱的角度看这世界，那你根本就没看到这世界。</strong></p><p><strong>这大概是金钱和地位最好的作用了。</strong></p><p>你在没有它们时，总会夸大得到它们的好处。但当你一旦拥有，它们的庙堂性便迅速削减，你对世界的认识也不再聚焦于你的周身了，开始往远方去，人类的动物性和神性仿佛在此处简单而隐秘地做了一场交接。</p><p>就像我们不会想到身上最坚硬的牙齿会最先消失，而最柔软的嘴唇却能陪伴我们到死。你曾以为世间最“有用”的东西最后都褪色消失，而那些飘渺的自我实现与精神渴望却成了人最要紧的不动产。</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p><strong>当然，以上所谈的关于生活中的“位移”，也能顺顺当当用到职场里。</strong></p><p>阿里有一套管理中层管理者的做法，就是让中层能“向上看两级”和“向下看两级”。这是职场的“位移”。</p><p>“向上看两级”就是当你想问题时，把自己拔高到上级，以及上级的上级的位子来思考。“自动”帮自己职位跃迁的好处，其实是把自己的眼光、胸襟、支配资源、责任担当都统统加了<strong>杠杆</strong>，这样一来，个人原本的能力也就能迅速迭代升级了。稻盛和夫讲过一句话，如果你不肯抛弃“工作是别人要我做的”这种不恰当的想法，就无法从工作的“苦难”里解脱出来。</p><p>培养企业家的湖畔大学，喜欢做跨界融合。比如他们想请顶尖的医生讲手术前的心理建设，请将军讲作战部署，请足球教练讲球员布局，请武术家、艺术家讲他们如何取得成就，又如何经历痛苦选择，那些商业课程是选修，而这些非商业化的课程却是必修。</p><p>因为每个人固有的成功生意经只能让他们安稳度过眼前，但其他优秀体系里大量思考的汇集带来的复杂的世界和更陌生的经验，才有可能让他们不被“降维打击”。<strong>系统观不够用了，这时还需要世界观，需要历史观。</strong></p><p>许多职业里，往往是越往上走，人越谦卑。年轻艺术家总妄想当出奇制胜的 “创造家”，但真正智慧的艺术大家却认为——<strong>艺术，其实是“一种本分而又沉着的劳动”。</strong></p><p>罗丹曾说过，独创性不在于生造出一些悖于常理的新词，而在于巧妙使用旧词。旧词足以表达一切了，旧词对天才来说已经足够。</p><p>同样，好的学者最忌讳“成见”，欢迎任何对自我观点的反驳，包容不同的反馈。而当眼睛的尺幅够宽，一辈子的输赢或成功与否都不是重要的，不过是提升心志的不同手段而已。</p><p>李开复在历劫重生后曾说，<strong>经历的灾难多了，人就学得会客观了。</strong>人从挫折中学到的东西，远比成功里学到的多。<strong>这是段位的“位移”。</strong></p><p>所有这些“位移”都会让你原本不假思索的世界整个在周身弹开，被撞得粉碎，为自己的无知殉葬。</p><p><strong>世界上什么东西最完整？**</strong>我最喜欢的一个答案*<em>是*</em>，世界上没有什么东西比一颗碎掉的心更完整了。**</p><p>当你真正理解跃迁阶层、职位、段位背后的意义和负重，你才会真切感知到自己是谁，你会更了解生活的本质，工作的本质，人生的本质。但同时伴随的，便是之前价值体系的坍塌。谁都没那么好，谁都不那么容易，厚重的浮云从眼前散去，自傲狂妄的开始谦卑，耿耿于怀的开始放下。</p><p><strong>碎掉的是一轮轮的价值观，而完整的是人性。</strong>用一颗沧桑的心来换更清澈剔透的人性，大概是眼界和阅历还给人类的，最美好的东西。</p>]]></content>
    
    
    <categories>
      
      <category>转载</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>黄金手铐</title>
    <link href="/%E9%BB%84%E9%87%91%E6%89%8B%E9%93%90/"/>
    <url>/%E9%BB%84%E9%87%91%E6%89%8B%E9%93%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来源：微信公众号：<a href="https://mp.weixin.qq.com/s/cB8TXd4aPVFpTGMs6YlbnQ">秦朔朋友圈——黄金手铐</a></p><p>作者： 忆湄 </p><p>时间：2019.09.15</p></blockquote><a id="more"></a><p><strong>造富时代烘烤出来的任何馅饼都不是百分百完美，“黄金手铐”就是其中一个。</strong></p><p>许多局中人袒露过心声——因为手持多少多少股票他不得不待在目前的公司，因为多想创业而放弃了多少多少期权。这些激励虽是黄金，也是手铐。前者的瞻前顾后或许会让二流公司反而出了一流创业人才，而后者的义无反顾，倒是会给一个成功跑出来的创业者锦上添花。</p><p>另一种“黄金手铐”呢，则是反过来，规矩行事小步慢跑的公司反倒活得长久，而怀揣侥幸心理跨过法律的边界去掘金的，结果带上了真手铐，戴志康案和一轮轮行业洗牌就是典型。</p><p><strong>这些边界虽是手铐，也是黄金。</strong>虽然人成熟的标志就是知道这辈子不可能什么都要，但在结局还没显山露水之前，总有那么些时刻，贪婪会打败理想，把他们引入岔路。</p><p>黄金手铐，短短四个字，一头是奖赏，一头是负累，拼在一起，简直说出了生活的真相。</p><p>但这点真相，也曾把很多人蒙在鼓里。早个十年，或许我也不会面不改色地打下这段话。</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>当年我在金融危机时进入金融行业，那时真是羡慕前几年入行的前辈，他们构建了整个行业的巅峰，能亲自出演纸醉金迷的戏码，而我们只能见证废墟。那是我第一次感受到“命运”的存在感，再牛逼闪闪的人都无法对时代的起落免疫。但后来发觉，往往被某一个时代厚爱得太厉害的人，就会有入过模子的感觉，越被某一种职业模式定性，时代巨变时刻就越难切换和落地，或者说心理上也不愿意落地，成为下一次时代转型时沉重的负累。</p><p>就像那一批78年出生，初入职场正好赶上中国第一代互联网公司崛起，被大佬亲自带过的，定过型的那一代幸运儿一样，虽然这批人辈出后来的职业经理人和创业者，但他们的痛苦也来源于这种“幸运”。要超越自己，要再次成长，就必须彻底否定过去的自己，相信我，人居高位时还真没多少人有这种勇气。<strong>所以你会发现英雄的出没总是一阵阵的。</strong></p><p>这里丝毫没有幸灾乐祸的意思，因为这让我看清了“命运”更扎实的存在感。人生就像俄罗斯方块，失败的隐患是早就埋下的，获得的成功还会消失。</p><p>33岁开始以写小说为生的日本作家村上春树曾说过，自己是易胖体质，但他的妻子怎么吃也胖不起来。他觉得人生真是不公平啊，为什么一些人不费吹灰之力得到的东西，另一些人要付出很多才能换来？不过，他立马就化解了这点郁闷——<strong>那些轻轻松松就保持苗条的人，反而不会像他这样重视饮食和运动，或许老化得更快。**</strong>什么才是公平，还得从长计议。**</p><p>是的，什么才是公平呢。稍有一点阅历的人，就会明白捷径里会隐藏陷阱，好事背后必有隐忧。<strong>所以看年轻人抒情很有意思，斩钉截铁，非黑即白。</strong>但一旦上了年纪，话就会堵在嘴边，说不出来。<strong>罗素说人的情绪起落是与他对事实的感知成反比的，你对事实了解得越少，就越容易动感情。</strong></p><p>当你眼睁睁看着“黄金”变成“手铐”，做人，大概就是扑灭羡慕嫉妒恨的过程。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>同时扑灭的，还有脆弱和浮躁。反人性的自律、坚持、忍耐、宽容，这些看起来像手铐一般的东西，反而会在人生马拉松里轻易地把人划分阵营。</p><p>教育小孩子有个很重要的点是“延迟满足”，动物性最明显的小时候，不睡觉的理由是因为睡觉太无聊了。而如今的年轻人，习惯沉浸在精彩虚幻的手机世界里，一旦脱离wifi就觉得没事可做，一个不断地把你的注意力往外拉扯的东西，本质上会让你变得越来越笨。现代人接受了太多信息，却没时间停下来好好思考，无法沉淀智慧；<strong>而古代人呢，要花好多时间获取如今只要手指动动就来的知识，但他们明显更有智慧。去翻哪一本古代经典，薄薄一本都能揭示人间大道，让人惊叹。</strong></p><p>没有人不想扒着快乐和精彩不让它走，但我们在成长的过程中会渐渐明白，生命的巅峰都是短暂的，快乐不会整年出没，平淡和孤独是生命的本质。这点灰扑扑的真相，虽然让我们少了点幻想的乐趣，但也少了无端的情绪波动。小时候被困扰的事，如今还是会被困扰，但是我们慢慢习得了一种能力<strong>：**</strong>不是说真的能解决它，而是开始能够在漫长的时间里忍耐它、对抗它、与它花时间周旋也不会原地爆炸**<strong>。静心和耐受，足以抵抗任何辛苦和复杂。人最容易被反复折腾的，其实不是问题本身，而是自己那颗不够清明和淡定的心。</strong></p><p>高手都是长期主义者，或者说看透了生命本质的人，也必须是长期主义者。小时候看铁棒磨针、水滴石穿还有佛教里用勺子舀干大海的故事，都觉好笑，哪会有人这么傻呢，后来才慢慢体会到那是一种教你能面对漫长一生最关键的能力。芒格总结过好搭档巴菲特成功的原因——巴菲特简直就是学习机器，如果拿着计时器观察他，你会发现他醒着的时候有一半时间是在看书。而亚马逊的贝佐斯20多年的股东信都会一如既往地动情写下“It remains Day 1”，吹牛是简单的，外人描述起成功也是简单的，好像荒地上突然就建起了摩天大楼。只有自己知道，在一次次遭遇暗礁和低谷，还能跨越内心的层峦叠嶂把初心紧紧抓住的，才是最后把人和人划出天堑的原因。</p><p>到最后，你可能都不会愿意去拿长期的忍耐、坚持和自律的“痛苦”去换一些瞬时得到的快乐和轻松了，因为那些在长期看来对人生并无价值，“手铐”才是“黄金”呢。这是人逐渐成熟的注脚。</p><p>写这篇文章的时候我又重温了一遍写《哈利波特》的J.K.罗琳在哈佛的演讲，她讲失败的好处，不说教，很实在，她说“失败代表了摒除不必要的事物，我不再自我欺骗、干脆忠于自我，投注所有心力完成唯一重要的工作。要是我以前在其他地方成功了，那么我也许永远不会有这样的决心，投身于这个我自信真正属于我的领域。我重获自由了。”</p><p>所以你就不难理解，为什么在《哈利·波特》风靡全球后，她会以罗伯特·加尔布雷斯为化名，写出了《布谷鸟的呼唤》，结果是再一次震惊出版界。罗琳解释说：“我本想让这个秘密藏得更久，因为能当罗伯特·加尔布雷斯对我是一种释放。”</p><p>写到这里，我只想复述一遍村上的话：<strong>什么才是公平，还得从长计议。</strong></p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>要如何判断是黄金还是手铐，这本身也不会有答案。生活本来就是一个矛盾体，不同的时代、时期、环境和人本身的成长，都会加剧这种矛盾。就像你去看金庸先生如雷贯耳的14部武侠小说，第一部歌颂反清复明的英雄人物，主张革命起义，到了最后一部又回到了明清易主时代，但开始主张妥协和生存，歌颂一个猥琐鄙俗的投降派小家伙。<strong>从强调“正邪分明”，到“亦正亦邪”，再到“无所谓正邪”，他自己历史观和价值观也在变化，他也有一大堆矛盾。</strong></p><p>我常常被人说心态好，大约是经历多了当初为之欣喜若狂或者忿忿不平的事情，几年后发现长出了一副完全陌生的五官的桥段，所以对着“黄金手铐”四个字，都能唠叨出一篇千字文吧。</p><p>但我写这些的本意是，既然“黄金”也会像手心里的雪，哈口气就化掉，而“手铐”也会让你忍耐到拨云见日、运气守恒的那一天，既然生活的真相就是把奖赏和负累揉捏在一起扔给你的，那真正重要的不是去在意此时此刻你所处的位置，而是要耐下性子去挖掘能为你的一生提供源源不断能量的那股源泉。</p><p>那才是你与世界最本质的链接。</p>]]></content>
    
    
    <categories>
      
      <category>转载</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统课程设计 -- 磁盘管理</title>
    <link href="/os-lab-4/"/>
    <url>/os-lab-4/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：操作系统课程设计 —— 磁盘管理的实现，包含Java与C++，均采用面向对象的思想，包含代码。</p><a id="more"></a><h2 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h2><p>本次课程设计的任务是虚拟实现部分操作系统的典型算法，加深对操作系统运行机制的掌握和理解。任务具体要求：</p><p>在Winidows/Linux/iOS/Android平台下（平台任选一个），以<strong>面向对象思想</strong>实现下面功能：</p><h3 id="1、磁盘管理"><a href="#1、磁盘管理" class="headerlink" title="1、磁盘管理"></a>1、磁盘管理</h3><p>建立一个4KB大小的文件模拟磁盘，按逻辑将其划分为1024块，每块大小4B。其中900块用于存放普通数据，124块用于存储兑换数据。存储管理需要支持：</p><p>（1）数据组织：对需要存放的文件数据加以组织管理，可以采用连续组织方式、显式连接（FAT）方式、单级索引组织方式、二级索引组织方式、混合索引方式（每组要求不同，具体见“课程设计分组”部分，下同）。</p><p>（2）空闲块管理：能够查询并返回当前剩余的空闲块，对空闲块管理可以采用位示图法、空闲盘块表法、空闲盘块连法、成组连接法。</p><p>（3）兑换区管理：能够写入、读出兑换区数据。</p><h3 id="2、目录管理"><a href="#2、目录管理" class="headerlink" title="2、目录管理"></a>2、目录管理</h3><p>  为写入模拟磁盘的数据文件建立目录，目录可以是单级文件目录、双级文件目录、树形结构目录。在目录中选择某个文件可以将其数据读入模拟内存。目录中包含文件名、文件所有者、创建时间、文件结构、在磁盘中存放的地址等信息。目录管理需要支持：</p><p>（1）新建目录：在目录中新建空目录</p><p>（2）删除目录：删除空目录</p><p>（3）为文件建立目录项：一个文件被创建后，为该文件创建目录项，并将文件相关信息写入目录中。</p><p>（4）删除文件：删除目录中某个文件，删除其在磁盘中的数据，并删除目录项。如果被删除文件已经读入内存应该阻止删除，完成基本的文件保护。</p><h3 id="3、内存管理"><a href="#3、内存管理" class="headerlink" title="3、内存管理"></a>3、内存管理</h3><p>  申请一块64字节的内存空间模拟内存，按逻辑划分为16块，每块4B。将目录中选中的文件读入内存，显示文件中信息。内存可以同时显示多个文件信息，每个文件固定分配4个内存块，如果4个内存块不能显示文件全部信息，采用页面置换策略，将已显示完的页换出内存，可以选择的置换策略有，全局置换、局部置换、FIFO、LRU。内存管理需要支持：</p><p>（1）分配内存块：为线程分配内存块，每个线程默认分配4块。</p><p>（2）回收内存：线程结束后回收其内存。</p><p>（3）空闲内存块管理：为进入内存的数据寻找空闲内存块。没有空闲内存时，应给出提示。</p><p>（4）块时间管理：提供数据块进入模拟内存的时间、访问时间的记录和查询功能，为页面置换算法提供支持，当某个内存块被选中时，更新其访问时间。</p><h3 id="4、线程管理"><a href="#4、线程管理" class="headerlink" title="4、线程管理"></a>4、线程管理</h3><p>   本虚拟系统以线程为基本运行单位，线程本身采用编程语言提供的线程机制，不模拟。系统主要包括的线程有：</p><p>（1）数据生成线程：该线程负责生成外存数据，给定数据大小（按字节计算）、数据信息（英文字母）、存储目录、文件名后，该线程调用磁盘管理中空闲磁盘管理功能，申请所需大小的外存块，如果盘块不够给出提示。按照要求的数据组织方式，将数据存入磁盘块（按块分配磁盘），并调用目录管理功能为其在目录中建立目录项，更改空闲盘块信息。</p><p>（2）删除数据线程：该线程调用删除目录管理中文件删除功能删除数据（内存中文件不能删除）。并回收外存空间，更新空闲盘块信息。</p><p>（3）执行线程：选择目录中的文件，执行线程将文件数据从外存调入内存，为此，首先需要调用内存管理的空闲空间管理功能，为该进程申请4块空闲内存，如果没有足够内存则给出提示，然后根据目录中文件存储信息将文件数据从外存读入内存，此间如果4块内存不够存放文件信息，需要进行换页（选择的换页策略见分组要求），欢出的页面存放到磁盘兑换区。允许同时运行多个执行线程。文件数据在内存块的分布通过线程的页表（模拟）进行记录。</p><p>（4）线程互斥：对于64B的内存，线程需要互斥访问，避免产生死锁。不能访问内存的线程阻塞，等待被唤醒。</p><h3 id="5、用户接口"><a href="#5、用户接口" class="headerlink" title="5、用户接口"></a>5、用户接口</h3><p>  对内存块、外存块、目录信息进行可视化显示，并能够动态刷新。文件调入内存过程、以及换页过程在块与块之间加入延时，以便观察。</p><p>  对于实现以上功能，可以采用任何熟悉的编程语言，不做具体要求。</p><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><p>由于我主要负责磁盘管理部分，所以只写了磁盘管理部分的代码。</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><p>DiskBlock.java – 定义单独的一块磁盘块，即磁盘的最小结构。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> FileDiskDir;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiskBlock</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> blockNum;<span class="hljs-comment">//块号</span>    <span class="hljs-keyword">private</span> String blockData;<span class="hljs-comment">//块内数据</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DiskBlock</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DiskBlock</span><span class="hljs-params">(<span class="hljs-keyword">int</span> blockNum, String blockData)</span> </span>&#123;        <span class="hljs-keyword">this</span>.blockNum = blockNum;        <span class="hljs-keyword">this</span>.blockData = blockData;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBlockNum</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> blockNum;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBlockNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> blockNum)</span> </span>&#123;        <span class="hljs-keyword">this</span>.blockNum = blockNum;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getBlockData</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> blockData;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBlockData</span><span class="hljs-params">(String blockData)</span> </span>&#123;        <span class="hljs-keyword">this</span>.blockData = blockData;    &#125;&#125;</code></pre><p>DiskManage.java – 磁盘管理。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> FileDiskDir;<span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiskManage</span> </span>&#123;    <span class="hljs-keyword">private</span> Map&lt;String, MixIndex&gt; FileMixIndexMap = <span class="hljs-keyword">new</span> HashMap&lt;String, MixIndex&gt;();<span class="hljs-comment">//建立文件名和索引表的映射</span>    <span class="hljs-keyword">private</span> DiskBlock[] MyDisk = <span class="hljs-keyword">new</span> DiskBlock[<span class="hljs-number">1024</span>];<span class="hljs-comment">//1024个磁盘块</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] MyDiskState = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">1024</span>];<span class="hljs-comment">//位示图,false表示未被使用，true表示被使用</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> freeDiskDataBlock;<span class="hljs-comment">//数据区中空闲的磁盘块数</span>    <span class="hljs-keyword">private</span> String diskTxtData;<span class="hljs-comment">//磁盘txt的全部数据</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DiskManage instance = <span class="hljs-keyword">new</span> DiskManage();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DiskManage</span><span class="hljs-params">()</span> </span>&#123;        freeDiskDataBlock = <span class="hljs-number">900</span>;        serializeToDisktxt();        diskTxtData = readDataFromDiskTxt();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DiskManage <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> instance;    &#125;    <span class="hljs-comment">//初始化文件DiskTxt</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serializeToDisktxt</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//将disk文件存满1024*4个#.</span>            File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;src/file/disk.txt&quot;</span>);            <span class="hljs-keyword">byte</span> data[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4096</span>];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4096</span>;i++)&#123;                data[i] = <span class="hljs-string">&#x27;#&#x27;</span>;            &#125;            <span class="hljs-comment">// 创建基于文件的输出流</span>            FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(f);            <span class="hljs-comment">// 把数据写入到输出流</span>            fos.write(data);            <span class="hljs-comment">// 关闭输出流</span>            fos.close();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            <span class="hljs-comment">// TODO Auto-generated catch block</span>            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">//从DiskTxt读取磁盘所有的内容，存储为string</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">readDataFromDiskTxt</span><span class="hljs-params">()</span></span>&#123;        String data = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//将disk文件存满1024*4个#.</span>            File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;src/file/disk.txt&quot;</span>);            FileReader reader = <span class="hljs-keyword">new</span> FileReader(f);            BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(reader);            String lines;            <span class="hljs-keyword">while</span>((lines = br.readLine() )!= <span class="hljs-keyword">null</span>)&#123;                data += lines;            &#125;            <span class="hljs-comment">// 关闭输出流</span>            br.close();            reader.close();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            <span class="hljs-comment">// TODO Auto-generated catch block</span>            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> data;    &#125;    <span class="hljs-comment">//将全部数据写回磁盘文件</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeDataToDiskTxt</span><span class="hljs-params">(String data)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;src/file/disk.txt&quot;</span>);            f.createNewFile();<span class="hljs-comment">//创建新文件,有同名的文件的话直接覆盖</span>            FileWriter writer = <span class="hljs-keyword">new</span> FileWriter(f);            BufferedWriter out = <span class="hljs-keyword">new</span> BufferedWriter(writer);            out.write(data);            out.flush();<span class="hljs-comment">//将缓存区内容压入文件</span>            out.close();            writer.close();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFreeDiskDataBlock</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> freeDiskDataBlock;    &#125;    <span class="hljs-comment">//写数据到磁盘块</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteDataToBlock</span><span class="hljs-params">(<span class="hljs-keyword">int</span> blockNum,String data)</span></span>&#123;        MyDisk[blockNum] = <span class="hljs-keyword">new</span> DiskBlock();        MyDisk[blockNum].setBlockData(data);        MyDiskState[blockNum] = <span class="hljs-keyword">true</span>;        freeDiskDataBlock -= <span class="hljs-number">1</span>;        <span class="hljs-comment">//diskTxtData更新</span>        diskTxtData = readDataFromDiskTxt();        <span class="hljs-comment">//使用stringbuffer来替换</span>        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(diskTxtData);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;            sb.setCharAt(blockNum*<span class="hljs-number">4</span> + i,data.charAt(i));        &#125;        <span class="hljs-comment">//</span>        writeDataToDiskTxt(sb.toString());    &#125;    <span class="hljs-comment">//从磁盘块读数据</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">ReadDataFromBlock</span><span class="hljs-params">(<span class="hljs-keyword">int</span> blockNum)</span></span>&#123;        <span class="hljs-keyword">return</span> MyDisk[blockNum].getBlockData();    &#125;    <span class="hljs-comment">//删除数据</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DeleteDataInBlock</span><span class="hljs-params">(<span class="hljs-keyword">int</span> blockNum)</span></span>&#123;        MyDiskState[blockNum] = <span class="hljs-keyword">false</span>;        freeDiskDataBlock += <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">//创建文件保留数据到磁盘</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> MixIndex <span class="hljs-title">SaveFileDataToDisk</span><span class="hljs-params">(String fileName,<span class="hljs-keyword">int</span> size,String data)</span></span>&#123;        <span class="hljs-comment">//创建文件的索引表</span>        MixIndex fileMixIndexTable = <span class="hljs-keyword">new</span> MixIndex();        <span class="hljs-comment">//创建一个当前正在使用的索引表</span>        MixIndex nowMixIndexTable = fileMixIndexTable;        <span class="hljs-comment">//从位示图中寻找空闲的块,并且赋值</span>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-comment">//定义一个索引表里的index,同时表示字符串的读取位置</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">900</span>;i++) &#123;            <span class="hljs-keyword">if</span>(MyDiskState[i] == <span class="hljs-keyword">false</span>)&#123;                <span class="hljs-keyword">if</span>(index &lt; size)&#123;                    <span class="hljs-keyword">if</span>(index / <span class="hljs-number">9</span> == <span class="hljs-number">0</span> &amp;&amp; index % <span class="hljs-number">9</span> == <span class="hljs-number">0</span> )&#123;                        <span class="hljs-comment">//创建文件的新一级索引表</span>                        MixIndex newfileMixIndexTable = <span class="hljs-keyword">new</span> MixIndex();                        nowMixIndexTable.setIndirectIndex(newfileMixIndexTable);                        nowMixIndexTable = newfileMixIndexTable;                    &#125;                    nowMixIndexTable.setDirectIndexByIndex(index%<span class="hljs-number">9</span>,i);                    <span class="hljs-comment">//位示图更新</span>                    MyDiskState[i] = <span class="hljs-keyword">true</span>;                    <span class="hljs-comment">//写入对应磁盘块的数据</span>                    WriteDataToBlock(i,data.substring(index*<span class="hljs-number">4</span>,index*<span class="hljs-number">4</span>+<span class="hljs-number">4</span>));<span class="hljs-comment">//截取[index*4,index*4+4)这一部分</span>                    index++;                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-comment">//添加到FileMixIndexMap</span>        FileMixIndexMap.put(fileName,fileMixIndexTable);<span class="hljs-comment">//是否可以？</span>        <span class="hljs-keyword">return</span> fileMixIndexTable;    &#125;    <span class="hljs-comment">//读取文件在磁盘上的数据</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">ReadFileDataInDisk</span><span class="hljs-params">(String fileName,<span class="hljs-keyword">int</span> size)</span></span>&#123;        MixIndex fileMixIndexTable = FileMixIndexMap.get(fileName);        String data = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-comment">//计算次数</span>        <span class="hljs-keyword">int</span> times = size / <span class="hljs-number">9</span>;        <span class="hljs-keyword">int</span> lasttimes = size % <span class="hljs-number">9</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt; times;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;j++)&#123;                data += ReadDataFromBlock(fileMixIndexTable.getDirectIndex(j));            &#125;            fileMixIndexTable = fileMixIndexTable.getIndirectIndex();        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;lasttimes;i++)&#123;            data += ReadDataFromBlock(fileMixIndexTable.getDirectIndex(i));        &#125;        <span class="hljs-keyword">return</span> data;    &#125;&#125;</code></pre><p>main.java – 测试代码</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> FileDiskDir.DiskManage;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);        DiskManage disk = <span class="hljs-keyword">new</span> DiskManage();        String data = <span class="hljs-string">&quot;1234567812345678123456781234567812345678123456781234567812345678&quot;</span>;        disk.SaveFileDataToDisk(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">16</span>,data);        System.out.println(disk.ReadFileDataInDisk(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">16</span>));    &#125;&#125;</code></pre><h3 id="java代码大致思路"><a href="#java代码大致思路" class="headerlink" title="java代码大致思路"></a>java代码大致思路</h3><ul><li>采用了普通的一维数组来表示位示图，用于记录磁盘块的状态。</li><li>MyDisk[1024] 来表示磁盘。存取操作都对这个数组进行。</li><li>Map&lt;String, MixIndex&gt; FileMixIndexMap 用来记录文件名与文件所存储的混合索引表的映射。</li><li>文件的读取操作都是之后加入的，用于同步磁盘的情况。</li><li>实际上的存储数据会有一定的bug（存储数据的第一部分，即索引表的第一部分读取时会出现问题）。</li></ul><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h3><p>common_data.h – 公共数据的结构体定义头文件</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">/*----------定义磁盘块-------------*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DiskBlock</span> &#123;</span><span class="hljs-keyword">int</span> BlockNum;<span class="hljs-comment">//定义块号</span><span class="hljs-built_in">string</span> data;<span class="hljs-comment">//数据</span>&#125;;<span class="hljs-comment">/*----------定义索引表的结构-------------*/</span><span class="hljs-comment">//直接索引</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DireIndexTable</span> &#123;</span><span class="hljs-keyword">int</span> addr_1[<span class="hljs-number">10</span>];&#125;;<span class="hljs-comment">//一级间接索引</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IndireIndexTable</span> &#123;</span>DireIndexTable addr_2[<span class="hljs-number">10</span>];&#125;;<span class="hljs-comment">//混合索引</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MixIndexTable</span> &#123;</span><span class="hljs-keyword">int</span> addr_1[<span class="hljs-number">10</span>];<span class="hljs-comment">//10个直接索引，直接存储盘块号</span>DireIndexTable addr_2[<span class="hljs-number">10</span>];<span class="hljs-comment">//10个一级索引，每个一级索引存储了10个直接索引</span>IndireIndexTable addr_3[<span class="hljs-number">10</span>];<span class="hljs-comment">//10个二级索引</span>&#125;;</code></pre><p>DiskManage.h  –  磁盘管理类的定义头文件</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;common_data.h&quot;</span></span><span class="hljs-comment">/*----------磁盘管理类-------------*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiskManage</span>&#123;</span><span class="hljs-keyword">public</span>:DiskBlock MyDisk[<span class="hljs-number">1024</span>];<span class="hljs-comment">//磁盘，有1024个块</span><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, MixIndexTable*&gt; MyMixIndexTable;<span class="hljs-comment">//文件名与混合索引表的映射</span><span class="hljs-keyword">int</span> BitMap[<span class="hljs-number">32</span>][<span class="hljs-number">32</span>];<span class="hljs-comment">//位示图 32 * 32，0表示未被使用，1表示已经使用</span><span class="hljs-keyword">int</span> FreeDataBlockNum;<span class="hljs-comment">//空闲数据区的块数</span><span class="hljs-keyword">int</span> FreeSwapBlockNum;<span class="hljs-comment">//空闲交换区的块数</span><span class="hljs-keyword">public</span>:DiskManage();~DiskManage();<span class="hljs-comment">/*----------单例模式创建实例-------------*/</span><span class="hljs-function"><span class="hljs-keyword">static</span> DiskManage *<span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/*----------磁盘操作的最微操作-------------*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WriteDataToBlock</span><span class="hljs-params">(<span class="hljs-keyword">int</span> blockNum, <span class="hljs-built_in">string</span> data)</span></span>;<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">ReadDataFromBlock</span><span class="hljs-params">(<span class="hljs-keyword">int</span> blockNum)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DeleteDataInBlock</span><span class="hljs-params">(<span class="hljs-keyword">int</span> blockNum)</span></span>;<span class="hljs-comment">/*----------保存文件数据到磁盘，返回混合索引表-------------*/</span><span class="hljs-function">MixIndexTable* <span class="hljs-title">SaveFileDataToDisk</span><span class="hljs-params">(<span class="hljs-built_in">string</span> fileName, <span class="hljs-keyword">int</span> size, <span class="hljs-built_in">string</span> data)</span></span>;<span class="hljs-comment">/*----------保存内存数据到交换区，返回块号-------------*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SaveMmToSwap</span><span class="hljs-params">(<span class="hljs-built_in">string</span> data)</span></span>;<span class="hljs-comment">/*----------读取文件数据-------------*/</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">ReadFileDataFromDisk</span><span class="hljs-params">(<span class="hljs-built_in">string</span> fileName, <span class="hljs-keyword">int</span> size)</span></span>;<span class="hljs-comment">/*----------打印磁盘数据-------------*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintMyDisk</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintBitMap</span><span class="hljs-params">()</span></span>;&#125;;</code></pre><p>DiskManage.cpp  – 磁盘管理类的实现文件</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;DiskManage.h&quot;</span></span>DiskManage::DiskManage()&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1024</span>; i++) &#123;MyDisk[i].BlockNum = i;MyDisk[i].data = <span class="hljs-string">&quot;####&quot;</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">32</span>; j++) &#123;BitMap[i][j] = <span class="hljs-number">0</span>;&#125;&#125;FreeDataBlockNum = <span class="hljs-number">900</span>;FreeSwapBlockNum = <span class="hljs-number">124</span>;&#125;DiskManage::~DiskManage()&#123;&#125;<span class="hljs-function">DiskManage * <span class="hljs-title">DiskManage::getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">static</span> DiskManage * instance;<span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>) &#123;instance = <span class="hljs-keyword">new</span> DiskManage();&#125;<span class="hljs-keyword">return</span> instance;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DiskManage::WriteDataToBlock</span><span class="hljs-params">(<span class="hljs-keyword">int</span> blockNum, <span class="hljs-built_in">string</span> data)</span></span>&#123;MyDisk[blockNum].data = data;<span class="hljs-comment">//修改位示图</span><span class="hljs-keyword">int</span> i = blockNum / <span class="hljs-number">32</span>;<span class="hljs-keyword">int</span> j = blockNum % <span class="hljs-number">32</span>;BitMap[i][j] = <span class="hljs-number">1</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 900/32 =28 余4</span><span class="hljs-comment"> * 所以第一块swap坐标是cacheBlock【28】【4】</span><span class="hljs-comment"> * 第29行第五个</span><span class="hljs-comment"> */</span><span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">28</span> &amp;&amp; j &gt;= <span class="hljs-number">4</span> ) &#123;FreeSwapBlockNum -= <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span> &#123;FreeDataBlockNum -= <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">DiskManage::ReadDataFromBlock</span><span class="hljs-params">(<span class="hljs-keyword">int</span> blockNum)</span></span>&#123;<span class="hljs-keyword">return</span> MyDisk[blockNum].data;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DiskManage::DeleteDataInBlock</span><span class="hljs-params">(<span class="hljs-keyword">int</span> blockNum)</span></span>&#123;MyDisk[blockNum].data = <span class="hljs-string">&quot;####&quot;</span>;<span class="hljs-comment">//修改位示图</span><span class="hljs-keyword">int</span> i = blockNum / <span class="hljs-number">32</span>;<span class="hljs-keyword">int</span> j = blockNum % <span class="hljs-number">32</span>;BitMap[i][j] = <span class="hljs-number">0</span>;<span class="hljs-comment">//修改空闲块数</span><span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">28</span> &amp;&amp; j &gt;= <span class="hljs-number">4</span>) &#123;FreeSwapBlockNum += <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span> &#123;FreeDataBlockNum += <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function">MixIndexTable * <span class="hljs-title">DiskManage::SaveFileDataToDisk</span><span class="hljs-params">(<span class="hljs-built_in">string</span> fileName, <span class="hljs-keyword">int</span> size, <span class="hljs-built_in">string</span> data)</span></span>&#123;MixIndexTable *mit = <span class="hljs-keyword">new</span> MixIndexTable;<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-comment">//从位示图寻找空闲的块</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> blockNum = <span class="hljs-number">0</span>; blockNum &lt; <span class="hljs-number">900</span>; blockNum++) &#123;<span class="hljs-keyword">if</span> (BitMap[blockNum / <span class="hljs-number">32</span>][blockNum % <span class="hljs-number">32</span>] == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span> (index &lt; size) &#123;<span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">10</span>) &#123;mit-&gt;addr_1[index] = blockNum;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">10</span> &amp;&amp; index &lt; <span class="hljs-number">110</span>) &#123;mit-&gt;addr_2[(index - <span class="hljs-number">10</span>) / <span class="hljs-number">10</span>].addr_1[(index - <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>] = blockNum;&#125;<span class="hljs-keyword">else</span> &#123;mit-&gt;addr_3[(index - <span class="hljs-number">110</span>) / <span class="hljs-number">100</span>].addr_2[((index - <span class="hljs-number">110</span>) % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>].addr_1[((index - <span class="hljs-number">110</span>) % <span class="hljs-number">100</span>) % <span class="hljs-number">10</span>];&#125;<span class="hljs-comment">//位示图更新</span>BitMap[blockNum / <span class="hljs-number">32</span>][blockNum % <span class="hljs-number">32</span>] == <span class="hljs-number">1</span>;<span class="hljs-comment">//写入对应的数据</span>WriteDataToBlock(blockNum, data.substr(index*<span class="hljs-number">4</span>,<span class="hljs-number">4</span>));index++;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-comment">//加入文件名与混合索引表的映射</span>MyMixIndexTable.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,MixIndexTable*&gt;::value_type(fileName,mit));<span class="hljs-keyword">return</span> mit;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DiskManage::SaveMmToSwap</span><span class="hljs-params">(<span class="hljs-built_in">string</span> data)</span></span>&#123;<span class="hljs-keyword">int</span> blockNum = <span class="hljs-number">900</span>;<span class="hljs-comment">//从位示图寻找空闲的块</span><span class="hljs-keyword">for</span> (blockNum = <span class="hljs-number">900</span>; blockNum &lt; <span class="hljs-number">1024</span>; blockNum++) &#123;<span class="hljs-keyword">if</span> (BitMap[blockNum / <span class="hljs-number">32</span>][blockNum % <span class="hljs-number">32</span>] == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//位示图更新</span>BitMap[blockNum / <span class="hljs-number">32</span>][blockNum % <span class="hljs-number">32</span>] == <span class="hljs-number">1</span>;<span class="hljs-comment">//写入对应的数据</span>WriteDataToBlock(blockNum, data);<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">return</span> blockNum;&#125;<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">DiskManage::ReadFileDataFromDisk</span><span class="hljs-params">(<span class="hljs-built_in">string</span> fileName, <span class="hljs-keyword">int</span> size)</span></span>&#123;MixIndexTable *mit = MyMixIndexTable.find(fileName)-&gt;second;<span class="hljs-built_in">string</span> data = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">10</span>) &#123;data.append(ReadDataFromBlock(mit-&gt;addr_1[i]));&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">10</span> &amp;&amp; i &lt; <span class="hljs-number">110</span>) &#123;data.append(ReadDataFromBlock(mit-&gt;addr_2[(i - <span class="hljs-number">10</span>) / <span class="hljs-number">10</span>].addr_1[(i - <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>]));&#125;<span class="hljs-keyword">else</span> &#123;data.append(ReadDataFromBlock(mit-&gt;addr_3[(i - <span class="hljs-number">110</span>) / <span class="hljs-number">100</span>].addr_2[((i - <span class="hljs-number">110</span>) % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>].addr_1[((i - <span class="hljs-number">110</span>) % <span class="hljs-number">100</span>) % <span class="hljs-number">10</span>]));&#125;&#125;<span class="hljs-keyword">return</span> data;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DiskManage::PrintMyDisk</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1024</span>; i++) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; MyDisk[i<span class="hljs-number">-1</span>].data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-keyword">if</span> (i % <span class="hljs-number">16</span> == <span class="hljs-number">0</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DiskManage::PrintBitMap</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">32</span>; j++) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; BitMap[i][j<span class="hljs-number">-1</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-keyword">if</span> (j % <span class="hljs-number">16</span> == <span class="hljs-number">0</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;&#125;</code></pre><p>mian.cpp  –  测试文件</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;DiskManage.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;打印磁盘&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;DiskManage::getInstance()-&gt;PrintMyDisk();<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;打印位示图&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;DiskManage::getInstance()-&gt;PrintBitMap();<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\t\t----模拟创建文件----&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;文件数据内容：1234xxzz5678ccvv9999oooo0x0xcccc1234xxzz5678ccvv9999oooo0x0xcccc&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">string</span> data = <span class="hljs-string">&quot;1234xxzz5678ccvv9999oooo0x0xcccc1234xxzz5678ccvv9999oooo0x0xcccc&quot;</span>;DiskManage::getInstance()-&gt;SaveFileDataToDisk(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">16</span>,data);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\t\t----创建文件完成----&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;打印磁盘&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;DiskManage::getInstance()-&gt;PrintMyDisk();<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;打印位示图&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;DiskManage::getInstance()-&gt;PrintBitMap();<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\t\t----模拟数据写入交换区----&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;文件数据内容：cccc&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;data = <span class="hljs-string">&quot;cccc&quot;</span>;DiskManage::getInstance()-&gt;SaveMmToSwap(data);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\t\t----数据写入交换区完成----&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;打印磁盘&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;DiskManage::getInstance()-&gt;PrintMyDisk();<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;打印位示图&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;DiskManage::getInstance()-&gt;PrintBitMap();_getch();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="C-代码思路"><a href="#C-代码思路" class="headerlink" title="C++代码思路"></a>C++代码思路</h3><p>第一遍是用Java写的，当时思路还不够清晰明确，混合索引定义也有问题，而且代码还有BUG，而且出于整个组的代码合并的考虑，改写成了C++。并且重新建立了结构体，以及混合索引表的结构。</p><ul><li>混合索引表有三部分，第一部分是10个直接索引，直接指向存储数据的磁盘块号，这样能表示大小占10个块的数据；第二部分是10个间接索引，每个间接索引都指向了10个直接索引，实际上就是二维数组，这样能表示大小占100个块的数据；第三部分是10个二级索引，每个索引都指向了10个一级间接索引，而每个一级间接索引都能够指向10直接索引，实际上就是三维数组，这样就能够表示1000个块的数据。这样一个混合索引表最多能存储1110个块的数据，足够满足本次课设的要求。</li><li>位示图采用了 32*32的二维数组来表示，然后块号到位示图位置的映需要通过简单的计算映射。</li><li>建立了文件名与混合索引表的映射  –  map&lt;string, MixIndexTable*&gt; MyMixIndexTable;这样就能根据文件名来找到文件对应的混合索引表了。</li><li>磁盘的构造函数里初始化了磁盘的数据，全部为“####”，且设置了数据区与交换区的块数。</li><li>分配外存采用了首次适应算法，即分配磁盘时永远从第一块磁盘开始进行搜索。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次课程设计做的比较心累，一方面时语言的不熟悉，一方面是对任务的要求不够清楚，比较模糊，最后是小组分工写代码，但要求代码合并到一起，没有统一的接口设置，代码写的非常混乱。</p><p>对比其他的大佬组，有大佬亲自定义了全部的框架与函数，只要求其他人实现函数就行，有的大佬写了图形界面，还有的大佬甚至用了安卓和数据库，我等菜鸡太卑微了~</p><h2 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h2><p>本次代码里有java实现的代码，以及小组最终去展示的C++代码。线程管理的那一部分完全没有做。</p><p>链接：<a href="https://pan.baidu.com/s/1uFze_G3Dp337vlfYhJFb9A">https://pan.baidu.com/s/1uFze_G3Dp337vlfYhJFb9A</a><br>提取码：37ef</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>文件下载</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理课程设计 —— MIPS32五级流水之addi指令的实现</title>
    <link href="/cpudesign/"/>
    <url>/cpudesign/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：</p><a id="more"></a><h2 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h2><p><strong>MIPS32五级流水设计并实现指令ADDI rt, rs, immediate</strong>。</p><p>参考书籍：《自己动手写CPU》</p><p>编程语言：Verilog</p><p>主要软件：Xilinx-Vivado-2018</p><h2 id="五级流水"><a href="#五级流水" class="headerlink" title="五级流水"></a>五级流水</h2><p><img src="/cpudesign/wujiliushui.png"></p><p>五级流水分为这五个阶段：<strong>取指、译码、执行、访存和回写</strong>。</p><p>在取指阶段，由pc给出指令的地址，从指令寄存器中取出指令送至译码阶段。在译码阶段分析指令，给出源操作数所在的寄存器地址、目的操作数所在的寄存器地址，同时扩展立即数，分析运算类型等。在执行阶段，ALU根据运算类型以及源操作数、立即操作数算出最终结果，传递给访存阶段和回写阶段，最终回写至寄存器。  </p><h2 id="addi指令"><a href="#addi指令" class="headerlink" title="addi指令"></a>addi指令</h2><p><img src="/cpudesign/addi.png"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>由于完全没接触过Verilog以及Vivado，所以刚开始拿到课设题目的时候比较头大，最后仿照了《自己动手写CPU》的第四章ori指令的实现，根据这一章的讲解，理解了五级流水的工作原理以及实现，最后根据第七章的源代码完成了本次课程设计。</p><ul><li><p>指令寄存器是使用文件代替的，所以可以把准备好的16进制指令写在文件里。</p><p><img src="/cpudesign/zhiling.png"></p></li></ul><p>上图中，第一条指令是ori指令，给第一个寄存器赋值。后面的9条指令都是addi指令，分别进行不同加法的操作，最后将结果写回到寄存器。</p><ul><li><p>最后的仿真结果</p><p><img src="/cpudesign/addiwujiliushui.png"></p><p>​    针对于指令0x20850002，这条指令的意思是四号寄存器的值加上0x000000002之后将结果放入5号寄存器。在取指阶段，取得那一条指令，即if_inst保存那一条指令，在下一个时钟传送给id模块进行译码操作，译码操作主要是确定参与运算的两个操作数以及运算的类型、子类型等信息，如上图所示，id_reg1_o为4号寄存器的值，id_reg2_o为立即数的值，aluop_o为子类型，表示为addi运算，alusel_o为运算类型，表示算术运算。</p><p>​    在执行阶段，ex模块根据id模块传递的信息计算出最终的结果，输出计算结果wdata_o和要写入的寄存器地址wd_o。在访存阶段，MEM模块最终输出要写入寄存器的值wdata_o和要写入的寄存器地址wd_o，并把这些信息传递给MEM/WB模块。最后在MEM/WB模块进行回写，写入到目的寄存器即5号寄存器。最终完成一条指令的全部运行过程。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>《自己动手写CPU》这本书真的是写的太清晰易懂了，而且还能找到全书的代码，导入项目之后就可以直接用了，非常的方便。各个模块功能明确，架构清晰，真的是太强了。</p><p>不过Vivado这个软件20G，真的太大了，而且刚开始建立项目碰到了好多坑……，网上的一些教程也并不详细，不过也算摸索过来了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.mxdon.com/">Mxdon</a> - <a href="http://www.mxdon.com/2019/08/17/%E5%8E%9F%E5%A7%8BopenMIPS%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4ori%E6%8C%87%E4%BB%A4%E7%BB%93%E6%9E%84/#more">原始openMIPS五级流水ori指令结构</a></p><h2 id="工程下载"><a href="#工程下载" class="headerlink" title="工程下载"></a>工程下载</h2><p>链接：<a href="https://pan.baidu.com/s/1zwtzVfggJXmfziulgNZDqw">https://pan.baidu.com/s/1zwtzVfggJXmfziulgNZDqw</a><br>提取码：btdr </p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
      <tag>文件下载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“21天教你学会C++”</title>
    <link href="/tenyears/"/>
    <url>/tenyears/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：<strong>陈皓</strong></p><p>来源： <a href="https://coolshell.cn/">https://coolshell.cn/</a> </p></blockquote><a id="more"></a><p>下面是一个《Teach Yourself C++ in 21 Days》的流程图，请各位程序员同仁认真领会。如果有必要，你可以查看这个图书以作参照：<a href="http://www.china-pub.com/27043">http://www.china-pub.com/27043</a></p><p><img src="/tenyears/Teach_Youself_CPP_21days.jpg" alt="Teach Youself C++ 21 Days"></p><p>看完上面这个图片，我在想，我学习C++有12年了，好像C++也没有学得特别懂，看到STL和泛型，还是很头大。不过，我应该去考虑研究量子物理和生物化学，这样，我才能重返98年杀掉还在大学的我，然后达到21天搞定C++的目标。另外，得要特别提醒刚刚开始学习C++的朋友，第21天的时候，小心被人杀害。呵呵。</p><p>当然，上面只是一个恶搞此类图片，学习一门技术，需要你很长的时间，正如图片中的第三图和第四图所示，你需要用十年的时间去不断在尝试，并在错误中总结经验教训，以及在项目开发中通过与别人相互沟通互相学习来历练自己。你才能算得上是真正学会。</p><p>这里有篇文章叫《<a href="http://norvig.com/21-days.html"><strong>Teach Yourself Programming in Ten Years</strong></a>》，网上有人翻译了一下，不过原文已被更新了，我把网上的译文转载并更新如下：</p><center>用十年来学编程 Peter Norvig</center><h4 id="为什么每个人都急不可耐？"><a href="#为什么每个人都急不可耐？" class="headerlink" title="为什么每个人都急不可耐？"></a>为什么每个人都急不可耐？</h4><p>走进任何一家书店，你会看见《Teach Yourself Java in 7 Days》（7天Java无师自通）的旁边是一长排看不到尽头的类似书籍，它们要教会你Visual Basic、Windows、Internet等等，而只需要几天甚至几小时。我在<a href="http://www.amazon.com/">Amazon.com</a>上进行了如下<a href="http://www.amazon.com/exec/obidos/tg/browse/-/468558/104-5938873-6579160">搜索</a>：</p><p>[pubdate: after 1992 and title: days and (title: learn or title: teach yourself)](<a href="http://www.amazon.com/exec/obidos/search-handle-url/ix=books&amp;rank=%2Bfeaturedrank&amp;fqp=power%01pubdate%3A">http://www.amazon.com/exec/obidos/search-handle-url/ix=books&amp;rank=%2Bfeaturedrank&amp;fqp=powerpubdate%3A</a> after 1992 and title%3A days and (title%3A learn or title%3A teach yourself)&amp;sz=25&amp;pg=1/ref=s_b_np)(出版日期：1992年后 and 书名：天 and （书名：学会 or 书名：无师自通）)</p><p>我一共得到了248个搜索结果。前面的78个是计算机书籍（第79个是《<a href="http://www.amazon.com/exec/obidos/ASIN/0781802245/">Learn Bengali in 30 days</a>》，30天学会孟加拉语）。我把关键词“days”换成“[hours](<a href="http://www.amazon.com/exec/obidos/search-handle-url/ix=books&amp;rank=%2Bfeaturedrank&amp;fqp=power%01pubdate%3A">http://www.amazon.com/exec/obidos/search-handle-url/ix=books&amp;rank=%2Bfeaturedrank&amp;fqp=powerpubdate%3A</a> after 1992 and title%3A hours and (title%3A learn or title%3A teach yourself)&amp;sz=25&amp;pg=3/ref=s_b_np)”，得到了非常相似的结果：这次有253本书，头77本是计算机书籍，第78本是《<a href="http://www.amazon.com/exec/obidos/ASIN/0028638999/">Teach Yourself Grammar and Style in 24 Hours</a>》（24小时学会文法和文体）。头200本书中，有96%是计算机书籍。</p><p>结论是，要么是人们非常急于学会计算机，要么就是不知道为什么计算机惊人地简单，比任何东西都容易学会。没有一本书是要在几天里教会人们欣赏贝多芬或者量子物理学，甚至怎样给狗打扮。在《*<a href="http://www.ccs.neu.edu/home/matthias/HtDP2e/index.html">How to Design Programs</a><em>》这本书里说“</em>Bad programming is easy. Idiots can learn it in 21 days, even if they are dummies.”* （坏的程序是很容易的，就算他们是笨蛋白痴都可以在21天内学会。）</p><p>让我们来分析一下像《<a href="http://www.amazon.com/Learn-C-Three-Days-Rachele/dp/1556227078">Learn C++ in Three Days</a>》（3天学会C++）这样的题目到底是什么意思：</p><ul><li><strong>学会</strong>：在3天时间里，你不够时间写一些有意义的程序，并从它们的失败与成功中学习。你不够时间跟一些有经验的程序员一起工作，你不会知道在C++那样的环境中是什么滋味。简而言之，没有足够的时间让你学到很多东西。所以这些书谈论的只是表面上的精通，而非深入的理解。如Alexander Pope（英国诗人、作家，1688-1744）所言，<strong>一知半解是危险的（a little learning is a dangerous thing）</strong></li><li><strong>C++**：在3天时间里你可以学会C++的语法（如果你已经会一门类似的语言），但你无法学到多少如何运用这些语法。简而言之，如果你是，比如说一个Basic程序员，你可以学会用C++语法写出Basic风格的程序，但你学不到C++真正的优点（和缺点）。那关键在哪里？Alan Perlis（ACM第一任主席，图灵奖得主，1922-1990）曾经说过：“</strong>如果一门语言不能影响你对编程的想法，那它就不值得去学**”。另一种观点是，有时候你不得不学一点C++（更可能是javascript和Flash Flex之类）的皮毛，因为你需要接触现有的工具，用来完成特定的任务。但此时你不是在学习如何编程，你是在学习如何完成任务。</li><li><strong>3天</strong>：不幸的是，这是不够的，正如下一节所言。</li></ul><h4 id="10年学编程"><a href="#10年学编程" class="headerlink" title="10年学编程"></a>10年学编程</h4><p>一些研究者（<a href="http://www.amazon.com/exec/obidos/ASIN/034531509X/">Bloom (1985)</a>, <a href="http://norvig.com/21-days.html#bh">Bryan &amp; Harter (1899)</a>, <a href="http://www.amazon.com/exec/obidos/ASIN/0805803092">Hayes (1989)</a>, <a href="http://norvig.com/21-days.html#sc">Simmon &amp; Chase (1973)</a>）的研究表明，在许多领域，都需要大约10 年时间才能培养出专业技能，包括国际象棋、作曲、绘画、钢琴、游泳、网球，以及神经心理学和拓扑学的研究。似乎并不存在真正的捷径：即使是莫扎特，他4 岁就显露出音乐天才，在他写出世界级的音乐之前仍然用了超过13年时间。再看另一种音乐类型的披头士，他们似乎是在1964年的Ed Sullivan节目中突然冒头的。但其实他们从1957年就开始表演了，即使他们很早就显示出了巨大的吸引力，他们第一次真正的成功——Sgt. Peppers——也要到1967年才发行。<a href="http://www.amazon.com/Outliers-Story-Success-Malcolm-Gladwell/dp/0316017922">Malcolm Gladwell</a> 研究报告称，把在伯林音乐学院学生一个班的学生按水平分成高中低，然后问他们对音乐练习花了多少工夫：</p><blockquote><p>在这三个小组中的每一个人基本上都是从相同的时间开始练习的（在五岁的时候）。在开始的几年里，每个人都是每周练习2-3个小时。但是在八岁的时候，练习的强度开始显现差异。在这个班中水平最牛的人开始比别人练习得更多——在九岁的时候每周练习6个小时，十二岁的时候，每周8个小时，十四岁的时候每周16个小时，并在成长过程中练习得越来越多，到20岁的时候，其每周练习可超过30个小时。到了20岁，这些优秀者在其生命中练习音乐总共超过 10,000 小时。与之对比，其它人只平均有8,000小时，而未来只能留校当老师的人仅仅是4,000 小时。</p></blockquote><p>所以，这也许需要10,000 小时，并不是十年，但这是一个magic number。Samuel Johnson（英国诗人）认为10 年还是不够的：“<strong>任何领域的卓越成就都只能通过一生的努力来获得；稍低一点的代价也换不来。</strong>”（Excellence in any department can be attained only by the labor of a lifetime; it is not to be purchased at a lesser price.） 乔叟（Chaucer，英国诗人，1340-1400）也抱怨说：“<strong>生命如此短暂，掌握技艺却要如此长久。</strong>”（the lyf so short, the craft so long to lerne.）</p><p>下面是我在编程这个行当里获得成功的处方：</p><ul><li>对编程感兴趣，因为乐趣而去编程。确定始终都能保持足够的乐趣，以致你能够将10年时间投入其中。</li><li>跟其他程序员交谈；阅读其他程序。这比任何书籍或训练课程都更重要。</li><li>编程。最好的学习是<a href="http://www.engines4ed.org/hyperbook/nodes/NODE-120-pg.html">从实践中学习</a>。用更加技术性的语言来讲，“个体在特定领域最高水平的表现不是作为长期的经验的结果而自动获得的，但即使是非常富有经验的个体也可以通过刻意的努力而提高其表现水平。”（<a href="http://www2.umassd.edu/swpi/DesignInCS/expertise.html">p. 366</a>），而且“最有效的学习要求为特定个体制定适当难度的任务，有意义的反馈，以及重复及改正错误的机会。”（p. 20-21）《<a href="http://www.amazon.com/exec/obidos/ASIN/0521357349">Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life</a>》（在实践中认知：心智、数学和日常生活的文化）是关于这个观点的一本有趣的参考书。</li><li>如果你愿意，在大学里花上4年时间（或者再花几年读研究生）。这能让你获得一些工作的入门资格，还能让你对此领域有更深入的理解，但如果你不喜欢进学校，（作出一点牺牲）你在工作中也同样能获得类似的经验。在任何情况下，单从书本上学习都是不够的。“计算机科学的教育不会让任何人成为内行的程序员，正如研究画笔和颜料不会让任何人成为内行的画家”, Eric Raymond，《The New Hacker’s Dictionary》（新黑客字典）的作者如是说。我曾经雇用过的最优秀的程序员之一仅有高中学历；但他创造出了许多伟大的软件（<a href="http://www.xemacs.org/">XEmacs</a>, <a href="http://www.mozilla.org/">Mozilla</a>），甚至有讨论他本人的<a href="http://groups.google.com/groups?q=alt.fan.jwz&meta=site=groups">新闻组</a>，而且股票期权让他达到我无法企及的<a href="http://en.wikipedia.org/wiki/DNA_Lounge">富有程度</a>（译注：指Jamie Zawinski，Xemacs和Netscape的作者）。</li><li>跟别的程序员一起完成项目。在一些项目中成为最好的程序员；在其他一些项目中当最差的一个。当你是最好的程序员时，你要测试自己领导项目的能力，并通过你的洞见鼓舞其他人。当你是最差的时候，你学习高手们在做些什么，以及他们不喜欢做什么（因为他们让你帮他们做那些事）。</li><li>接手别的程序员完成项目。用心理解别人编写的程序。看看在没有最初的程序员在场的时候理解和修改程序需要些什么。想一想怎样设计你的程序才能让别人接手维护你的程序时更容易一些。</li><li>学会至少半打编程语言。包括一门支持类抽象（class abstraction）的语言（如Java或C++），一门支持函数抽象（functional abstraction）的语言（如Lisp或ML），一门支持句法抽象（syntactic abstraction）的语言（如Lisp），一门支持说明性规约（declarative specification）的语言（如Prolog或C++模版），一门支持协程（coroutine）的语言（如Icon或Scheme），以及一门支持并行处理（parallelism）的语言（如Sisal）。</li><li>记住在“计算机科学”这个词组里包含“计算机”这个词。了解你的计算机执行一条指令要多长时间，从内存中取一个word要多长时间（包括缓存命中和未命中的情况），从磁盘上读取连续的数据要多长时间，定位到磁盘上的新位置又要多长时间。（<a href="http://norvig.com/21-days.html#answers">答案在这里</a>）</li><li>尝试参与到一项语言标准化工作中。可以是ANSI C++委员会，也可以是决定自己团队的编码风格到底采用2个空格的缩进还是4个。不论是哪一种，你都可以学到在这门语言中到底人们喜欢些什么，他们有多喜欢，甚至有可能稍微了解为什么他们会有这样的感觉。</li><li>拥有尽快从语言标准化工作中抽身的良好判断力。</li></ul><p>抱着这些想法，我很怀疑从书上到底能学到多少东西。在我第一个孩子出生前，我读完了所有“怎样……”的书，却仍然感到自己是个茫无头绪的新手。30个月后，我第二个孩子出生的时候，我重新拿起那些书来复习了吗？不。相反，我依靠我自己的经验，结果比专家写的几千页东西更有用更靠得住。</p><p>Fred Brooks在他的短文《<a href="http://en.wikipedia.org/wiki/No_Silver_Bullet">No Silver Bullets</a>》（没有银弹）中确立了如何发现杰出的软件设计者的三步规划：</p><ul><li>尽早系统地识别出最好的设计者群体。</li><li>指派一个事业上的导师负责有潜质的对象的发展，小心地帮他保持职业生涯的履历。</li><li>让成长中的设计师们有机会互相影响，互相激励。</li></ul><p>这实际上是假定了有些人本身就具有成为杰出设计师的必要潜质；要做的只是引导他们前进。<a href="http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html">Alan Perlis</a>说得更简洁：“每个人都可以被教授如何雕塑；而对米开朗基罗来说，能教给他的倒是怎样能够不去雕塑。杰出的程序员也一样”。</p><p>所以尽管去买那些Java书；你很可能会从中找到些用处。但你的生活，或者你作为程序员的真正的专业技术，并不会因此在24小时、24天甚至24个月内发生真正的变化。</p>]]></content>
    
    
    <categories>
      
      <category>转载</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理相关知识</title>
    <link href="/ComputerOrganization-0/"/>
    <url>/ComputerOrganization-0/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：计算机组成相关知识，计算机系统的组成、系统抽象层图、ISA的介绍与MIPS。</p><a id="more"></a><h2 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h2><p><img src="/ComputerOrganization-0/ComputerOrganization-0%5Ccomsys.png"></p><h2 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h2><p><img src="/ComputerOrganization-0/ComputerOrganization-0%5Ccomceng.png"></p><h2 id="计算机系统抽象层的转换"><a href="#计算机系统抽象层的转换" class="headerlink" title="计算机系统抽象层的转换"></a>计算机系统抽象层的转换</h2><p><img src="/ComputerOrganization-0/ComputerOrganization-0%5Ccomchouxiang.png"></p><p>程序执行结果不仅取决于算法、程序的编写。而且取决于语言处理系统、操作系统、ISA、微体系结构。</p><h2 id="计算机系统的不同用户"><a href="#计算机系统的不同用户" class="headerlink" title="计算机系统的不同用户"></a>计算机系统的不同用户</h2><ul><li>最终用户工作在由应用程序提供的最上面的抽象层</li><li>系统管理员工作在由操作系统提供的抽象层</li><li>应用程序员工作在由语言处理系统（主要有编译器和汇编器）的抽象层</li><li>语言处理系统建立在操作系统之上</li><li>系统程序员（实现系统软件）工作在ISA层次，必须对ISA非常了解</li><li>编译器和汇编器的目标程序由机器级代码组成</li><li>操作系统通过指令直接对硬件进行编程控制</li><li>ISA处于软件和硬件的交界面（接口）</li></ul><p><img src="/ComputerOrganization-0/ComputerOrganization-0%5Cbutong.png"></p><p>ISA是对硬件的抽象，所有软件功能都建立在ISA之上。</p><h3 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h3><p>处理器最主要的功能是负责解释和执行指令，假设处理器A与B支持的指令不同，为处理器A编写的程序不能直接在处理器B上使用，需要重新编写，然后再次编译、汇编后才可使用，减低了软件的移植性，且极为不便。</p><p>IBM为了让自己的一系列计算机能使用相同的软件，免去重复编写软件的痛苦，在它的System/360计算机中引入了指令集架构（ISA：Instruction Set Architecture）的概念。</p><p><strong>将编程所需要了解的硬件信息从硬件系统中抽象出来</strong>，这样软件人员就可以面向ISA进行编程，开发出来的软件不经过修改就可以应用在符合该ISA的所有计算机上。</p><p>ISA用来描述编程时用到的抽象机器，而非这种机器的具体实现，<strong>从软件人员的角度来看，ISA包括一套指令集和一些寄存器，知道它们就可以编写程序了</strong>。</p><p>ISA —— Instruction Set Architecture  指令集体系结构</p><ul><li><p>ISA指Instruction Set Architecture，即指令集体系结构</p></li><li><p>ISA是一种规约（Specification），它规定了如何使用硬件</p></li><li><p>可执行的指令的集合，包括指令格式、操作种类以及每种操作</p></li></ul><p>对应的操作数的相应规定；</p><ul><li>指令可以接受的操作数的类型；</li><li>操作数所能存放的寄存器组的结构，包括每个寄存器的名称、</li></ul><p>编号、长度和用途；</p><ul><li> 操作数所能存放的存储空间的大小和编址方式；</li><li>操作数在存储空间存放时按照大端还是小端方式存放；</li><li>指令获取操作数的方式，即寻址方式；</li><li>指令执行过程的控制方式，包括程序计数器、条件码定义等。</li></ul><h3 id="ISA和计算机组成（微结构）之间的关系"><a href="#ISA和计算机组成（微结构）之间的关系" class="headerlink" title="ISA和计算机组成（微结构）之间的关系"></a>ISA和计算机组成（微结构）之间的关系</h3><p><img src="/ComputerOrganization-0/ComputerOrganization-0%5Cguanxi.png"></p><h2 id="架构与指令集"><a href="#架构与指令集" class="headerlink" title="架构与指令集"></a>架构与指令集</h2><h3 id="MIPS指令集架构"><a href="#MIPS指令集架构" class="headerlink" title="MIPS指令集架构"></a>MIPS指令集架构</h3><p>目前并没有一种统一的ISA为各个处理器厂商所接受，而是存在多种ISA，就像这个世界存在多种语言一样，但是主要的语言只有几种：汉语、英语、法语、俄语等。主要的ISA也只有几种：x86、ARM、SPARC、POWER、MIPS，除了x86是CISC ISA外，其余都是RISC ISA。</p><p>MIPS的含义是无内锁流水线微处理器（Microprocessor without Interlocked Piped Stages），是上世纪80年代诞生的RISC CPU的重要代表，其设计者John Hennessy时任斯坦福大学的教授。</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统实验（三）—— 请求调页存储管理方式的模拟</title>
    <link href="/os-lab-3/"/>
    <url>/os-lab-3/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：OPT、LRU、FIFO算法的实现</p><a id="more"></a><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>（1）假设每个页面中可存放10条指令，分配给一作业的内存块数为4。</p><p>（2）用C语言模拟一作业的执行过程。该作业共有320条指令，即它的地址空间为32页，目前它的所有页都还未调入内存。在模拟过程中，如果所访问的指令已经在内存中，则显示其物理地址，并转下一条指令。如果所访问的指令还未装入内存，则发生缺页，此时需记录缺页的次数，并将相应页调入内存。如果4个内存块中均已装入该作业，则需进行页面置换。最后显示其物理地址，并转下一条指令。在所有320条指令执行完毕后，请计算并显示作业运行过程中发生的缺页率。</p><p>（3）置换算法：请分别考虑OPT、FIFO和LRU算法。</p><p>（4）作业中指令的访问次序按下述原则生成：</p><p>50%的指令是顺序执行的。<br>25%的指令是均匀分布在前地址部分。<br>25%的指令时均匀分布在后地址部分。</p><p>具体的实施办法是：<br>①    在[0，319]之间随机选取一条起始执行指令，其序号为m；<br>②    顺序执行下一条指令，即序号为m+1的指令；<br>③    通过随机数，跳转到前地址部分[0，m-1]中的某条指令处，其序号为m1；<br>④    顺序执行下一条指令，即序号为m1+1的指令；<br>⑤    通过随机数，跳转到后地址部分[m1+2，319]中的某条指令处，其序号为m2；<br>⑥    顺序执行下一条指令，即序号为m2+1的指令；<br>⑦    重复跳转到前地址部分、顺序执行、跳转到后地址部分、顺序执行的过程，直至执行320条指令。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><pre><code class="hljs applescript">FIFO算法是如果可用内存满了，优先替换掉在内存中存在时间最长的页面对应的就是一个队列，容量为<span class="hljs-number">4</span>，先进先出如果队列的容量没有满检查是否在队列中，如果在，无操作如果不在，直接加入尾部队列，<span class="hljs-built_in">count</span>+<span class="hljs-number">1</span>如果队列容量满了检查是否在队列中，如果在，无操作如果不在，首部出队列，尾部进队列，<span class="hljs-built_in">count</span>+<span class="hljs-number">1</span>LRU算法 —— 最近最久未使用，即淘汰掉最近一段时间内没被使用的块即在一个队列里，如果没被使用就在队列中，如果被使用了就取出加入到队尾如果队列的容量没有满检查是否在队列中，如果在，取出这一块，加入到队列尾部如果不在，直接加入尾部队列，<span class="hljs-built_in">count</span>+<span class="hljs-number">1</span>如果队列容量满了检查是否在队列中，如果在，取出这一块，加入到队列尾部如果不在，首部出队列，尾部进队列，<span class="hljs-built_in">count</span>+<span class="hljs-number">1</span>OPT算法 —— 最佳适应算法向后搜索待执行的队列，比较当前内存中哪条指令最后被执行如果内存未满检查是否在内存之中，在的话，无操作不在的话，加入内存之中，<span class="hljs-built_in">count</span>+<span class="hljs-number">1</span>如果内存满了检查是否在内存之中，在的话，无操作不在的话，向后搜索待执行的指令，查找在内存之中的指令哪一条最晚被执行或者永不被执行，替换掉，<span class="hljs-built_in">count</span>+<span class="hljs-number">1</span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;                                                                                                                                   <span class="hljs-comment">//Memory</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Memory;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FindMemoryById</span><span class="hljs-params">(Memory MyMemory[<span class="hljs-number">4</span>],<span class="hljs-keyword">int</span> memoryNum,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= memoryNum<span class="hljs-number">-1</span>; i++)&#123;<span class="hljs-keyword">if</span> (MyMemory[i] == id)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetIndexById</span><span class="hljs-params">(Memory MyMemory[<span class="hljs-number">4</span>], <span class="hljs-keyword">int</span> memoryNum, <span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= memoryNum - <span class="hljs-number">1</span>; i++)&#123;<span class="hljs-keyword">if</span> (MyMemory[i] == id)&#123;<span class="hljs-keyword">return</span> i;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(Memory MyMemory[<span class="hljs-number">4</span>], <span class="hljs-keyword">int</span> memoryNum)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= memoryNum - <span class="hljs-number">1</span>; i++)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; MyMemory[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetFirstLargeIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[<span class="hljs-number">4</span>])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> maxNum = arr[<span class="hljs-number">0</span>];<span class="hljs-keyword">int</span> maxNumIndex = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; j++)&#123;<span class="hljs-keyword">if</span> (maxNum &lt; arr[j])&#123;maxNum = arr[j];maxNumIndex = j;&#125;&#125;<span class="hljs-keyword">return</span> maxNumIndex;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetLastIndexOrdList</span><span class="hljs-params">(Memory MyMemory[<span class="hljs-number">4</span>], <span class="hljs-keyword">int</span> orderList[<span class="hljs-number">320</span>], <span class="hljs-keyword">int</span> index)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> LastIndex[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">999</span>,<span class="hljs-number">999</span>,<span class="hljs-number">999</span>,<span class="hljs-number">999</span>&#125;;<span class="hljs-keyword">int</span> LastIndexNum = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=index;i&lt;<span class="hljs-number">320</span>;i++)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)&#123;<span class="hljs-keyword">if</span> (MyMemory[j] == orderList[i])&#123;<span class="hljs-keyword">if</span> (LastIndex[j] == <span class="hljs-number">999</span>)&#123;LastIndex[j] = i;LastIndexNum++;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-keyword">if</span> (LastIndexNum == <span class="hljs-number">4</span>) <span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">return</span> GetFirstLargeIndex(LastIndex);&#125;<span class="hljs-comment">//FIFO算法</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIFO</span><span class="hljs-params">(<span class="hljs-keyword">int</span> orderList[<span class="hljs-number">320</span>])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//计算缺页次数</span>Memory MyMemory[<span class="hljs-number">4</span>];<span class="hljs-keyword">int</span> memoryNum = <span class="hljs-number">0</span>;<span class="hljs-comment">//内存已经占用的数量</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">320</span>; i++)&#123;<span class="hljs-keyword">if</span> (memoryNum &lt; <span class="hljs-number">4</span>)<span class="hljs-comment">//如果内存未满</span>&#123;<span class="hljs-keyword">if</span> (!FindMemoryById(MyMemory,memoryNum,orderList[i]))&#123;<span class="hljs-comment">//不在内存中</span>MyMemory[memoryNum] = orderList[i];memoryNum++;count++;&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (!FindMemoryById(MyMemory, memoryNum, orderList[i]))&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)&#123;MyMemory[j] = MyMemory[j + <span class="hljs-number">1</span>];&#125;MyMemory[<span class="hljs-number">3</span>] = orderList[i];count++;&#125;&#125;<span class="hljs-comment">//Print(MyMemory,memoryNum);</span>&#125;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;FIFO算法的缺页率为：&quot;</span> &lt;&lt; <span class="hljs-keyword">double</span>(count) / <span class="hljs-number">320</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//LRU算法</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LRU</span><span class="hljs-params">(<span class="hljs-keyword">int</span> orderList[<span class="hljs-number">320</span>])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//计算缺页次数</span>Memory MyMemory[<span class="hljs-number">4</span>];<span class="hljs-keyword">int</span> memoryNum = <span class="hljs-number">0</span>;<span class="hljs-comment">//内存已经占用的数量</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">320</span>; i++)&#123;<span class="hljs-keyword">if</span> (memoryNum &lt; <span class="hljs-number">4</span>)<span class="hljs-comment">//如果内存未满</span>&#123;<span class="hljs-keyword">if</span> (FindMemoryById(MyMemory, memoryNum, orderList[i]))&#123;<span class="hljs-comment">//在内存中</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = GetIndexById(MyMemory, memoryNum, orderList[i]); j &lt; memoryNum - <span class="hljs-number">1</span>; j++)&#123;MyMemory[j] = MyMemory[j + <span class="hljs-number">1</span>];&#125;MyMemory[memoryNum<span class="hljs-number">-1</span>] = orderList[i];&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//不在内存中</span>MyMemory[memoryNum] = orderList[i];memoryNum++;count++;&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (FindMemoryById(MyMemory, memoryNum, orderList[i]))&#123;<span class="hljs-comment">//在内存中</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = GetIndexById(MyMemory, memoryNum, orderList[i]); j &lt; <span class="hljs-number">3</span>; j++)&#123;MyMemory[j] = MyMemory[j + <span class="hljs-number">1</span>];&#125;MyMemory[<span class="hljs-number">3</span>] = orderList[i];&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//不在内存中</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)&#123;MyMemory[j] = MyMemory[j + <span class="hljs-number">1</span>];&#125;MyMemory[<span class="hljs-number">3</span>] = orderList[i];count++;&#125;&#125;<span class="hljs-comment">//Print(MyMemory, memoryNum);</span>&#125;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;LRU算法的缺页率为：&quot;</span> &lt;&lt; <span class="hljs-keyword">double</span>(count) / <span class="hljs-number">320</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//OPT算法</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OPT</span><span class="hljs-params">(<span class="hljs-keyword">int</span> orderList[<span class="hljs-number">320</span>])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//计算缺页次数</span>Memory MyMemory[<span class="hljs-number">4</span>];<span class="hljs-keyword">int</span> memoryNum = <span class="hljs-number">0</span>;<span class="hljs-comment">//内存已经占用的数量</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">320</span>; i++)&#123;<span class="hljs-keyword">if</span> (memoryNum &lt; <span class="hljs-number">4</span>)<span class="hljs-comment">//如果内存未满</span>&#123;<span class="hljs-keyword">if</span> (!FindMemoryById(MyMemory, memoryNum, orderList[i]))&#123;<span class="hljs-comment">//不在内存中</span>MyMemory[memoryNum] = orderList[i];memoryNum++;count++;&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (!FindMemoryById(MyMemory, memoryNum, orderList[i]))&#123;<span class="hljs-comment">//不在内存中</span><span class="hljs-keyword">int</span> index = GetLastIndexOrdList(MyMemory,orderList,i+<span class="hljs-number">1</span>);MyMemory[index] = orderList[i];count++;&#125;&#125;<span class="hljs-comment">//Print(MyMemory,memoryNum);</span>&#125;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;OPT算法的缺页率为：&quot;</span> &lt;&lt; <span class="hljs-keyword">double</span>(count) / <span class="hljs-number">320</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125; <span class="hljs-comment">//产生随机数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">generateRandom</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//产生一个随机数，位于[begin,end]之间</span><span class="hljs-keyword">int</span> ranNum = rand() % (end - begin + <span class="hljs-number">1</span>) + begin;<span class="hljs-keyword">return</span> ranNum;&#125;<span class="hljs-comment">//产生随机数列表</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generateRandomList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> orderList[<span class="hljs-number">320</span>])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//①在[0，319]之间随机选取一条起始执行指令，其序号为m；</span><span class="hljs-comment">//②顺序执行下一条指令，即序号为m + 1的指令；</span><span class="hljs-comment">//③通过随机数，跳转到前地址部分[0，m - 1]中的某条指令处，其序号为m1；</span><span class="hljs-comment">//④顺序执行下一条指令，即序号为m1 + 1的指令；</span><span class="hljs-comment">//⑤通过随机数，跳转到后地址部分[m1 + 2，319]中的某条指令处，其序号为m2；</span><span class="hljs-comment">//⑥顺序执行下一条指令，即序号为m2 + 1的指令；</span><span class="hljs-comment">//⑦重复跳转到前地址部分、顺序执行、跳转到后地址部分、顺序执行的过程，直至执行320条指令。</span>srand((<span class="hljs-keyword">unsigned</span>)time(<span class="hljs-literal">NULL</span>));orderList[<span class="hljs-number">0</span>] = generateRandom(<span class="hljs-number">0</span>, <span class="hljs-number">319</span>);orderList[<span class="hljs-number">1</span>] = orderList[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">320</span>; )&#123;i++;orderList[i] = generateRandom(<span class="hljs-number">0</span>, orderList[i - <span class="hljs-number">2</span>] - <span class="hljs-number">1</span>);i++;orderList[i] = orderList[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;i++;orderList[i] = generateRandom(orderList[i - <span class="hljs-number">2</span>] + <span class="hljs-number">2</span>, <span class="hljs-number">319</span>);i++;orderList[i] = orderList[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printRandomList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> orderList[<span class="hljs-number">320</span>])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">320</span>; i++)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; orderList[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-keyword">if</span> ((i + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;<span class="hljs-comment">//指令序列转化为页面序列</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OrderList2PageList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> orderList[<span class="hljs-number">320</span>])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">320</span>; i++)&#123;orderList[i] = orderList[i] / <span class="hljs-number">10</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//指令序列</span><span class="hljs-keyword">int</span> orderList[<span class="hljs-number">320</span>];generateRandomList(orderList);printRandomList(orderList);OrderList2PageList(orderList);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;FIFO(orderList);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;LRU(orderList);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;OPT(orderList);_getch();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/os-lab-3/result.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理 —— 编译程序相关概念</title>
    <link href="/compile-1/"/>
    <url>/compile-1/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：编译阶段的前端与后端、编译程序包含的内容以及编译程序与解释程序的区别。</p><a id="more"></a><h2 id="编译阶段划分为前端和后端"><a href="#编译阶段划分为前端和后端" class="headerlink" title="编译阶段划分为前端和后端"></a>编译阶段划分为前端和后端</h2><p> 编译程序的<strong>前端</strong>：它由这样一些阶段组成：这些阶段的工作主要依赖于源语言而与目标机无关。通常前端包括词法分析、语法分析、语义分析和中间代码生成这些阶段，某些优化工作也可在前端做，也包括与前端每个阶段相关的出错处理工作和符号表管理等工作。</p><p><strong>后端</strong>：指那些依赖于目标机而一般不依赖源语言，只与中间代码有关的那些阶段，即目标代码生成，以及相关出错处理和符号表操作。</p><h2 id="一个典型的编译程序"><a href="#一个典型的编译程序" class="headerlink" title="一个典型的编译程序"></a>一个典型的编译程序</h2><p>一个典型的编译程序通常包含 8 个组成部分，它们是<strong>词法分析程序</strong>、<strong>语法分析程序</strong>、<strong>语义分析程序</strong>、<strong>中间代码生成程序</strong>、<strong>中间代码优化程序</strong>、<strong>目标代码生成程序</strong>、<strong>表格管理程序</strong>和<strong>错误处理程序</strong>。</p><p>其各部分的主要功能简述如下。</p><p>词法分析程序：输人源程序，拼单词、检查单词和分析单词，输出单词的机内表达形式。</p><p>语法分析程序：检查源程序中存在的形式语法错误，输出错误处理信息</p><p>语义分析程序：进行语义检查和分析语义信息，并把分析的结果保存到各类语义信息表中。</p><p>中间代码生成程序：按照语义规则，将语法分析程序分析出的语法单位转换成一定形式的中间语言代码，如三元式或四元式。</p><p>中间代码优化程序：为了产生高质量的目标代码，对中间代码进行等价变换处理。</p><p>目标代码生成程序：将优化后中间代码程序转换成目标代码程序。</p><p>表格管理程序：负责建立、填写和查找等一系列表格工作。</p><p>错误处理程序：处理和校正源程序中存在的词法、语法和语义错误。当编译程序发现源程序中的错误时，错误处理程序负责报告出错的位置和错误性质等信息，同时对发现的错误进行适当的校正（修复），目的是使编译程序能够继续向下进行分析和处理。</p><h2 id="编译程序和解释程序的区别"><a href="#编译程序和解释程序的区别" class="headerlink" title="编译程序和解释程序的区别"></a>编译程序和解释程序的区别</h2><p>翻译程序是指将<strong>用某种语言编写的程序转换成另一种语言形式的程序</strong>的程序，如编译程序和汇编程序等。</p><p>广义上讲，编译程序和解释程序都属于翻译程序，但它们的翻译方式不同</p><p>解释程序是<strong>边翻译（解释）边执行</strong>，<strong>不产生目标代码</strong>，输出源程序的运行结果。</p><p>编译程序只负责把源程序翻译成<strong>目标程序</strong>，输出与源程序等价的目标程序，而目标程序的执行任务由操作系统来完成，即<strong>只翻译不执行</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基础问题汇总</title>
    <link href="/cpp-basepro/"/>
    <url>/cpp-basepro/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：C++基础问题汇总</p><a id="more"></a><h2 id="数组作为函数返回值"><a href="#数组作为函数返回值" class="headerlink" title="数组作为函数返回值"></a>数组作为函数返回值</h2><p>当数组作为函数返回值时，返回值类型写成<code>数组类型 *</code>，这种形如指针式的写法，函数内的return语句只写函数名。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> * <span class="hljs-title">getSomeNum</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> nums[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;    <span class="hljs-keyword">return</span> nums;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络—— 题目总结</title>
    <link href="/network-chapter-all/"/>
    <url>/network-chapter-all/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：计算机网络中网络层的基本概念以及应用.</p><a id="more"></a><blockquote><p>参照书籍：</p><p><strong>《计算机网络(第七版)》——谢希仁编著</strong></p><p><strong>《图解TCP/IP》第五版</strong></p></blockquote><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ol><li>以太网中数据包是以广播的形式发送的。</li><li>浏览器与Web服务器之间使用的协议是HTTP</li><li>PDU —— Protocol Data Unit 协议数据单元</li><li>对IP数据报的<strong>重组</strong>发生在<strong>目的主机</strong>上。</li><li>能证明计算机网络中传送的报文的真实性的技术是<strong>数字签名</strong></li><li>防火墙可以将未经授权的用户阻挡在<strong>内部网络</strong>之中。</li><li>为了保障网络安全，防止外部网络对内部网络的侵犯，通常在内部网络与外部网络之间设置防火墙。</li><li>防火墙负责管理风险区域和内部网络之间的访问。</li><li>公钥密码体制之中，<strong>解密密钥</strong>是需要用户保密的。</li><li>多媒体信息的特点：信息量往往很大、对时延有较高要求、可以传递音频和视频。</li><li>为了实现域名解析，客户机必须知道互联网上任意一台域名服务器的IP地址。</li><li>在广播或者多播中，运输层通常使用的协议是UDP。</li><li>CIDR技术的作用：把小的网络汇聚成大的超网。</li><li><strong>计算机网络最本质的活动室分布在不同地理位置的主机之间的进程通信</strong>。</li><li><strong>无线局域网</strong>中为实现传输媒体共享而采用的协议：<strong>CSMA/CA</strong></li><li>属于网络连接设备的有：集线器、中继器、交换机和路由器。</li><li>决定局域网特性的主要技术因素有：网络拓扑、传输媒体和信道访问协议。</li><li>计算机网络协议的要素包括：语法、语义和同步。</li><li>集线器工作在物理层</li><li>海明码具有检错和纠错功能</li><li>同一个VLAN中的两台主机可以跨越多台交换机(不能跨越路由器)</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统实验（二）—— 使用动态分区分配方式的模拟</title>
    <link href="/os-lab-2/"/>
    <url>/os-lab-2/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：<strong>首次适应算法</strong>和<strong>最佳适应算法</strong>的动态分区分配。</p><a id="more"></a><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>用C语言分别实现采用首次适应算法和最佳适应算法的动态分区分配过程alloc( )和回收过程free( )。其中，空闲分区通过空闲分区链来管理：在进行内存分配时，系统优先使用空闲区低端的空间。</p><p>假设初始状态下，<strong>可用的内存空间为640KB</strong>，并有下列的请求序列：</p><pre><code class="hljs plain">•作业1申请130KB。•作业2申请60KB。•作业3申请100KB。•作业2释放60KB。•作业4申请200KB。•作业3释放100KB。•作业1释放130KB。•作业5申请140KB。•作业6申请60KB。•作业7申请50KB。•作业6释放60KB。</code></pre><p>请分别采用首次适应算法和最佳适应算法，对内存块进行分配和回收，要求每次分配和回收后显示出空闲分区链的情况。</p><h2 id="首次适应算法-FF"><a href="#首次适应算法-FF" class="headerlink" title="首次适应算法 FF"></a>首次适应算法 FF</h2><p>该算法从空闲分区链首开始查找，直至找到一个能满足其大小要求的空闲分区为止。然后再按照作业的大小，从该分区中划出一块内存分配给请求者，余下的空闲分区仍留在空闲分区链    中。</p><p>特点： 该算法倾向于使用内存中低地址部分的空闲区，在高地址部分的空闲区很少被利用，从而保留了高地址部分的大空闲区。显然为以后到达的大作业分配大的内存空间创造了条件。</p><p>缺点：低地址部分不断被划分，留下许多难以利用、很小的空闲区，而每次查找又都从低地址部分开始，会增加查找的开销。</p><h2 id="最佳适应算法-BF"><a href="#最佳适应算法-BF" class="headerlink" title="最佳适应算法 BF"></a>最佳适应算法 BF</h2><p>该算法总是把既能满足要求，又是最小的空闲分区分配给作业。为了加速查找，该算法要求将所有的空闲区按其大小排序后，以递增顺序形成一个空白链。这样每次找到的第一个满足要求的空闲区，必然是最优的。孤立地看，该算法似乎是最优的，但事实上并不一定。因为每次分配后剩余的空间一定是最小的，在存储器中将留下许多难以利用的小空闲区。同时每次分配后必须重新排序，这也带来了一定的开销。</p><p>特点：每次分配给文件的都是最合适该文件大小的分区。</p><p>缺点：内存中留下许多难以利用的小的空闲区。</p><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><p>采用单链表来完成区间的分配释放的模拟。</p><p>需要申请一块空间就给单链表增加一个节点，然后修改原来节点的参数。</p><p>需要释放一块空间就找到单链表中对应的节点，改变其空间状态(占用 -&gt; 空闲)，然后查看该节点周边的节点状态，判断是否需要合并。</p><h2 id="首次适应算法代码"><a href="#首次适应算法代码" class="headerlink" title="首次适应算法代码"></a>首次适应算法代码</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Memory</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">int</span> begin_add;<span class="hljs-keyword">int</span> end_add;<span class="hljs-keyword">int</span> size;<span class="hljs-keyword">bool</span> state;<span class="hljs-comment">//false表示空闲</span><span class="hljs-keyword">int</span> pro_id;<span class="hljs-comment">//申请内存的作业id</span>Memory *next;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitMemory</span><span class="hljs-params">(Memory* oneMemoryHead)</span></span><span class="hljs-function"></span>&#123;Memory* oneMemory = (Memory*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Memory));oneMemory-&gt;begin_add = <span class="hljs-number">0</span>;oneMemory-&gt;end_add = <span class="hljs-number">640</span>;oneMemory-&gt;size = <span class="hljs-number">640</span>;oneMemory-&gt;state = <span class="hljs-literal">false</span>;oneMemory-&gt;pro_id = <span class="hljs-number">-1</span>; <span class="hljs-comment">//当分区域空闲时 pro_id为-1</span>oneMemory-&gt;next = <span class="hljs-literal">NULL</span>;oneMemoryHead-&gt;next = oneMemory;&#125;<span class="hljs-comment">//FF算法</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RequestMemoryByFF</span><span class="hljs-params">(Memory* oneMemoryHead,<span class="hljs-keyword">int</span> RequestId,<span class="hljs-keyword">int</span> RequestSize)</span></span><span class="hljs-function"></span>&#123;Memory * p_before = oneMemoryHead;Memory *p = oneMemoryHead-&gt;next;<span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-keyword">if</span> (p-&gt;state == <span class="hljs-literal">false</span> &amp;&amp; p-&gt;size &gt;= RequestSize)&#123;<span class="hljs-comment">//申请内存</span>Memory * newMemory = (Memory*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Memory));newMemory-&gt;begin_add = p-&gt;begin_add;newMemory-&gt;end_add = p-&gt;begin_add + RequestSize;newMemory-&gt;size = RequestSize;newMemory-&gt;pro_id = RequestId;newMemory-&gt;state = <span class="hljs-literal">true</span>;newMemory-&gt;next = p;p_before-&gt;next = newMemory;<span class="hljs-comment">//修改剩余内存的</span>p-&gt;begin_add = p-&gt;begin_add + RequestSize;p-&gt;size = p-&gt;size - RequestSize;<span class="hljs-comment">//如果剩余内存变成0</span><span class="hljs-keyword">if</span> (p-&gt;size == <span class="hljs-number">0</span>)&#123;p_before-&gt;next = p-&gt;next;&#125;<span class="hljs-comment">//跳出循环</span><span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span>&#123;p_before = p;p = p-&gt;next;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FreeMemory</span><span class="hljs-params">(Memory* oneMemoryHead, <span class="hljs-keyword">int</span> FreeId, <span class="hljs-keyword">int</span> FreeSize)</span></span><span class="hljs-function"></span>&#123;Memory * p_before = oneMemoryHead;Memory *p = oneMemoryHead-&gt;next;<span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-keyword">if</span> (p-&gt;pro_id == FreeId)&#123;<span class="hljs-comment">//释放内存</span>p-&gt;state = <span class="hljs-literal">false</span>;p-&gt;pro_id = <span class="hljs-number">-1</span>;<span class="hljs-comment">//寻找周围的内存，查看是否是空闲内存</span><span class="hljs-keyword">if</span> (p_before-&gt;state == <span class="hljs-literal">false</span>)&#123;<span class="hljs-comment">//前面的内存，合并</span>p_before-&gt;end_add += FreeSize;p_before-&gt;size += FreeSize;p_before-&gt;next = p-&gt;next;p = p_before;&#125;<span class="hljs-keyword">if</span> (p-&gt;next!= <span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;next-&gt;state == <span class="hljs-literal">false</span>)&#123;<span class="hljs-comment">//后面的内存，合并</span>p-&gt;end_add += p-&gt;next-&gt;size;p-&gt;size += p-&gt;next-&gt;size;p-&gt;next = p-&gt;next-&gt;next;&#125;<span class="hljs-comment">//跳出循环</span><span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span>&#123;p_before = p;p = p-&gt;next;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowMemory</span><span class="hljs-params">(Memory* oneMemoryHead)</span></span><span class="hljs-function"></span>&#123;Memory* p = oneMemoryHead-&gt;next;<span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\tBegin Address: &quot;</span> &lt;&lt; p-&gt;begin_add &lt;&lt; <span class="hljs-string">&quot; End Address: &quot;</span> &lt;&lt; p-&gt;end_add  &lt;&lt; <span class="hljs-string">&quot; Size: &quot;</span> &lt;&lt; p-&gt;size&lt;&lt;<span class="hljs-string">&quot; State: &quot;</span>&lt;&lt;p-&gt;state&lt;&lt;<span class="hljs-string">&quot; Pro_Id:&quot;</span>&lt;&lt;p-&gt;pro_id&lt;&lt; <span class="hljs-built_in">endl</span>;p = p-&gt;next;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;Memory *oneMemoryHead = (Memory *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Memory));oneMemoryHead-&gt;state = <span class="hljs-literal">true</span>;oneMemoryHead-&gt;next = <span class="hljs-literal">NULL</span>;InitMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;FF&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业1申请130KB&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;RequestMemoryByFF(oneMemoryHead,<span class="hljs-number">1</span>,<span class="hljs-number">130</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业2申请60KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;RequestMemoryByFF(oneMemoryHead,<span class="hljs-number">2</span>,<span class="hljs-number">60</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业3申请100KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;RequestMemoryByFF(oneMemoryHead,<span class="hljs-number">3</span>,<span class="hljs-number">100</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业2释放60KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;FreeMemory(oneMemoryHead,<span class="hljs-number">2</span>,<span class="hljs-number">60</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业4申请200KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;RequestMemoryByFF(oneMemoryHead, <span class="hljs-number">4</span>, <span class="hljs-number">200</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业3释放100KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;FreeMemory(oneMemoryHead, <span class="hljs-number">3</span>, <span class="hljs-number">100</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业1释放130KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;FreeMemory(oneMemoryHead, <span class="hljs-number">1</span>, <span class="hljs-number">130</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业5申请140KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;RequestMemoryByFF(oneMemoryHead, <span class="hljs-number">5</span>, <span class="hljs-number">140</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业6申请60KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;RequestMemoryByFF(oneMemoryHead, <span class="hljs-number">6</span>, <span class="hljs-number">60</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业7申请50KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;RequestMemoryByFF(oneMemoryHead, <span class="hljs-number">7</span>, <span class="hljs-number">50</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业6释放60KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;FreeMemory(oneMemoryHead, <span class="hljs-number">6</span>, <span class="hljs-number">60</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;_getch();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>结果</strong>：</p><pre><code class="hljs groovy">FF作业<span class="hljs-number">1</span>申请<span class="hljs-number">130</span>KB        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">130</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">510</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">2</span>申请<span class="hljs-number">60</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">130</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">190</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">60</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">2</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">190</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">450</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">3</span>申请<span class="hljs-number">100</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">130</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">190</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">60</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">2</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">190</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">100</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">3</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">350</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">2</span>释放<span class="hljs-number">60</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">130</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">190</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">60</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">190</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">100</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">3</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">350</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">4</span>申请<span class="hljs-number">200</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">130</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">190</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">60</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">190</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">100</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">3</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">200</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">4</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">150</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">3</span>释放<span class="hljs-number">100</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">130</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">160</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">200</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">4</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">150</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">1</span>释放<span class="hljs-number">130</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">290</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">200</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">4</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">150</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">5</span>申请<span class="hljs-number">140</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">140</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">140</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">5</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">140</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">150</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">200</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">4</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">150</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">6</span>申请<span class="hljs-number">60</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">140</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">140</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">5</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">140</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">200</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">60</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">6</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">200</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">90</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">200</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">4</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">150</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">7</span>申请<span class="hljs-number">50</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">140</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">140</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">5</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">140</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">200</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">60</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">6</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">200</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">250</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">50</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">7</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">250</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">40</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">200</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">4</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">150</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">6</span>释放<span class="hljs-number">60</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">140</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">140</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">5</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">140</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">200</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">60</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">200</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">250</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">50</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">7</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">250</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">40</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">200</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">4</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">150</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================</code></pre><h2 id="最佳适应算法代码"><a href="#最佳适应算法代码" class="headerlink" title="最佳适应算法代码"></a>最佳适应算法代码</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Memory</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">int</span> begin_add;<span class="hljs-keyword">int</span> end_add;<span class="hljs-keyword">int</span> size;<span class="hljs-keyword">bool</span> state;<span class="hljs-comment">//false表示空闲</span><span class="hljs-keyword">int</span> pro_id;<span class="hljs-comment">//申请内存的作业id</span>Memory *next;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitMemory</span><span class="hljs-params">(Memory* oneMemoryHead)</span></span><span class="hljs-function"></span>&#123;Memory* oneMemory = (Memory*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Memory));oneMemory-&gt;begin_add = <span class="hljs-number">0</span>;oneMemory-&gt;end_add = <span class="hljs-number">640</span>;oneMemory-&gt;size = <span class="hljs-number">640</span>;oneMemory-&gt;state = <span class="hljs-literal">false</span>;oneMemory-&gt;pro_id = <span class="hljs-number">-1</span>;oneMemory-&gt;next = <span class="hljs-literal">NULL</span>;oneMemoryHead-&gt;next = oneMemory;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FreeMemory</span><span class="hljs-params">(Memory* oneMemoryHead, <span class="hljs-keyword">int</span> FreeId, <span class="hljs-keyword">int</span> FreeSize)</span></span><span class="hljs-function"></span>&#123;Memory * p_before = oneMemoryHead;Memory *p = oneMemoryHead-&gt;next;<span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-keyword">if</span> (p-&gt;pro_id == FreeId)&#123;<span class="hljs-comment">//释放内存</span>p-&gt;state = <span class="hljs-literal">false</span>;p-&gt;pro_id = <span class="hljs-number">-1</span>;<span class="hljs-comment">//寻找周围的内存，查看是否是空闲内存</span><span class="hljs-keyword">if</span> (p_before-&gt;state == <span class="hljs-literal">false</span>)&#123;<span class="hljs-comment">//前面的内存，合并</span>p_before-&gt;end_add += FreeSize;p_before-&gt;size += FreeSize;p_before-&gt;next = p-&gt;next;p = p_before;&#125;<span class="hljs-keyword">if</span> (p-&gt;next != <span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;next-&gt;state == <span class="hljs-literal">false</span>)&#123;<span class="hljs-comment">//后面的内存，合并</span>p-&gt;end_add += p-&gt;next-&gt;size;p-&gt;size += p-&gt;next-&gt;size;p-&gt;next = p-&gt;next-&gt;next;&#125;<span class="hljs-comment">//跳出循环</span><span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span>&#123;p_before = p;p = p-&gt;next;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowMemory</span><span class="hljs-params">(Memory* oneMemoryHead)</span></span><span class="hljs-function"></span>&#123;Memory* p = oneMemoryHead-&gt;next;<span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\tBegin Address: &quot;</span> &lt;&lt; p-&gt;begin_add &lt;&lt; <span class="hljs-string">&quot; End Address: &quot;</span> &lt;&lt; p-&gt;end_add &lt;&lt; <span class="hljs-string">&quot; Size: &quot;</span> &lt;&lt; p-&gt;size &lt;&lt;<span class="hljs-string">&quot; State: &quot;</span> &lt;&lt; p-&gt;state &lt;&lt; <span class="hljs-string">&quot; Pro_Id:&quot;</span> &lt;&lt; p-&gt;pro_id &lt;&lt; <span class="hljs-built_in">endl</span>;p = p-&gt;next;&#125;&#125;<span class="hljs-comment">//找到合适的大小，适合当前申请的空间的 空闲分区中最小的那一块空间</span><span class="hljs-function">Memory * <span class="hljs-title">FindJustyMemory</span><span class="hljs-params">(Memory* oneMemoryHead, <span class="hljs-keyword">int</span> RequestSize)</span></span><span class="hljs-function"></span>&#123;Memory * p_before = oneMemoryHead;Memory * p = oneMemoryHead-&gt;next;Memory *tmp = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">int</span> tmpsize = <span class="hljs-number">641</span>;<span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-keyword">if</span> (p-&gt;state == <span class="hljs-literal">false</span> &amp;&amp; p-&gt;size &gt;= RequestSize)&#123;<span class="hljs-keyword">if</span> (tmpsize &gt; p-&gt;size)&#123;tmp = p;tmpsize = p-&gt;size;&#125;&#125;p_before = p;p = p-&gt;next;&#125;<span class="hljs-keyword">return</span> tmp;&#125;<span class="hljs-comment">//BF算法</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RequestMemoryByBF</span><span class="hljs-params">(Memory* oneMemoryHead, <span class="hljs-keyword">int</span> RequestId, <span class="hljs-keyword">int</span> RequestSize)</span></span><span class="hljs-function"></span>&#123;Memory *p = FindJustyMemory(oneMemoryHead, RequestSize);Memory * p_before = oneMemoryHead;<span class="hljs-keyword">while</span> (p_before-&gt;next != p)&#123;p_before = p_before-&gt;next;&#125;    <span class="hljs-comment">//维护 p_before永远时p的前一个</span><span class="hljs-comment">//申请内存</span>Memory * newMemory = (Memory*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Memory));newMemory-&gt;begin_add = p-&gt;begin_add;newMemory-&gt;end_add = p-&gt;begin_add + RequestSize;newMemory-&gt;size = RequestSize;newMemory-&gt;pro_id = RequestId;newMemory-&gt;state = <span class="hljs-literal">true</span>;newMemory-&gt;next = p;p_before-&gt;next = newMemory;<span class="hljs-comment">//修改剩余内存的</span>p-&gt;begin_add = p-&gt;begin_add + RequestSize;p-&gt;size = p-&gt;size - RequestSize;<span class="hljs-comment">//如果剩余内存变成0</span><span class="hljs-keyword">if</span> (p-&gt;size == <span class="hljs-number">0</span>)&#123;p_before-&gt;next = p-&gt;next;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;Memory *oneMemoryHead = (Memory *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Memory));oneMemoryHead-&gt;state = <span class="hljs-literal">true</span>;oneMemoryHead-&gt;next = <span class="hljs-literal">NULL</span>;InitMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;BF&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业1申请130KB&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;RequestMemoryByBF(oneMemoryHead, <span class="hljs-number">1</span>, <span class="hljs-number">130</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业2申请60KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;RequestMemoryByBF(oneMemoryHead, <span class="hljs-number">2</span>, <span class="hljs-number">60</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业3申请100KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;RequestMemoryByBF(oneMemoryHead, <span class="hljs-number">3</span>, <span class="hljs-number">100</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业2释放60KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;FreeMemory(oneMemoryHead, <span class="hljs-number">2</span>, <span class="hljs-number">60</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业4申请200KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;RequestMemoryByBF(oneMemoryHead, <span class="hljs-number">4</span>, <span class="hljs-number">200</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业3释放100KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;FreeMemory(oneMemoryHead, <span class="hljs-number">3</span>, <span class="hljs-number">100</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业1释放130KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;FreeMemory(oneMemoryHead, <span class="hljs-number">1</span>, <span class="hljs-number">130</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业5申请140KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;RequestMemoryByBF(oneMemoryHead, <span class="hljs-number">5</span>, <span class="hljs-number">140</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业6申请60KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;RequestMemoryByBF(oneMemoryHead, <span class="hljs-number">6</span>, <span class="hljs-number">60</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业7申请50KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;RequestMemoryByBF(oneMemoryHead, <span class="hljs-number">7</span>, <span class="hljs-number">50</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业6释放60KB。&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;FreeMemory(oneMemoryHead, <span class="hljs-number">6</span>, <span class="hljs-number">60</span>);ShowMemory(oneMemoryHead);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;==================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;_getch();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>结果</strong>：</p><pre><code class="hljs groovy">BF作业<span class="hljs-number">1</span>申请<span class="hljs-number">130</span>KB        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">130</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">510</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">2</span>申请<span class="hljs-number">60</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">130</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">190</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">60</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">2</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">190</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">450</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">3</span>申请<span class="hljs-number">100</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">130</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">190</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">60</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">2</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">190</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">100</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">3</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">350</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">2</span>释放<span class="hljs-number">60</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">130</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">190</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">60</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">190</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">100</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">3</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">350</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">4</span>申请<span class="hljs-number">200</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">130</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">190</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">60</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">190</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">100</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">3</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">200</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">4</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">150</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">3</span>释放<span class="hljs-number">100</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">130</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">130</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">160</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">200</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">4</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">150</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">1</span>释放<span class="hljs-number">130</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">290</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">200</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">4</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">150</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">5</span>申请<span class="hljs-number">140</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">290</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">200</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">4</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">630</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">140</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">5</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">630</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">10</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">6</span>申请<span class="hljs-number">60</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">60</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">60</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">6</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">60</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">230</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">200</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">4</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">630</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">140</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">5</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">630</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">10</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">7</span>申请<span class="hljs-number">50</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">60</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">60</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">6</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">60</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">110</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">50</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">7</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">110</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">180</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">200</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">4</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">630</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">140</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">5</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">630</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">10</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================作业<span class="hljs-number">6</span>释放<span class="hljs-number">60</span>KB。        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">0</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">60</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">60</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">60</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">110</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">50</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">7</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">110</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">180</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">290</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">200</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">4</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">490</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">630</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">140</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">5</span>        Begin <span class="hljs-attr">Address:</span> <span class="hljs-number">630</span> End <span class="hljs-attr">Address:</span> <span class="hljs-number">640</span> <span class="hljs-attr">Size:</span> <span class="hljs-number">10</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Pro_Id:</span><span class="hljs-number">-1</span>==================</code></pre><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>出于实验的考虑，没有增加任何的逻辑判断语句来判断内存不足或者其他情况</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lua快速入门 —— 基本语法</title>
    <link href="/lua-1/"/>
    <url>/lua-1/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：Lua的语法规则、变量类型。</p><a id="more"></a><blockquote><p>参照书籍：<strong>《Lua程序设计（第二版）》</strong></p><p>Lua版本：<strong>Lua 5.3.5</strong></p></blockquote><h2 id="lua的语法规则"><a href="#lua的语法规则" class="headerlink" title="lua的语法规则"></a>lua的语法规则</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><pre><code class="hljs lua"><span class="hljs-keyword">and</span>    <span class="hljs-keyword">break</span>   <span class="hljs-keyword">do</span>     <span class="hljs-keyword">else</span>    <span class="hljs-keyword">elseif</span><span class="hljs-keyword">end</span>    <span class="hljs-literal">false</span>   <span class="hljs-keyword">for</span>    <span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">if</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">in</span>     <span class="hljs-title">local</span>   <span class="hljs-title">nil</span>    <span class="hljs-title">not</span>    <span class="hljs-title">or</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">repeat</span>   <span class="hljs-title">return</span>   <span class="hljs-title">then</span>    <span class="hljs-title">true</span>    <span class="hljs-title">until</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">while</span></span></code></pre><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>以<strong>字母或者下划线</strong>开头的字母、下划线、数字序列。（与C语言相同）</p><blockquote><p>最好不要使用下划线加大写字母的标识符（可能会与lua的保留字冲突）</p></blockquote><p>lua是大小写敏感的！</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>lua的变量不需要声明。</p><p>给一个变量赋值后就会创建这个变量</p><p>当访问一个没有初始化的全局变量时也不会出错，得到值为 nil</p><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment">-- nil</span></code></pre><p><strong>需要注意的是：lua中的变量如果没有特殊说明，全是全局变量，那怕是语句块或是函数里。变量前加local关键字的是局部变量。</strong> </p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-string">&quot;aa&quot;</span>))  <span class="hljs-comment">--print &quot;aa&quot; type is string</span><span class="hljs-comment">--[[</span><span class="hljs-comment"></span><span class="hljs-comment">多行注释</span><span class="hljs-comment"></span><span class="hljs-comment">--]]</span></code></pre><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>Lua是动态类型的语言，变量不需要类型定义。</p><p>Lua中共有8种基本类型：nil、boolean、number、string、userdata、function、thread、table.</p><p>使用函数type()可以查看变量的类型</p><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-string">&quot;Hello world&quot;</span>))      <span class="hljs-comment">--&gt; string</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-number">10.4</span>*<span class="hljs-number">3</span>))             <span class="hljs-comment">--&gt; number</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">print</span>))              <span class="hljs-comment">--&gt; function</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">type</span>))               <span class="hljs-comment">--&gt; function</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-literal">true</span>))               <span class="hljs-comment">--&gt; boolean</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-literal">nil</span>))                <span class="hljs-comment">--&gt; nil</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">type</span>(X)))            <span class="hljs-comment">--&gt; string</span></code></pre><h2 id="变量类型-1"><a href="#变量类型-1" class="headerlink" title="变量类型"></a>变量类型</h2><h3 id="nil（空）"><a href="#nil（空）" class="headerlink" title="nil（空）"></a>nil（空）</h3><p>Lua中特殊的类型，他只有一个值：nil；</p><p>一个全局变量没有被赋值以前默认值为nil；</p><p>给全局变量赋值nil可以删除该变量。</p><h3 id="boolean（布尔）"><a href="#boolean（布尔）" class="headerlink" title="boolean（布尔）"></a>boolean（布尔）</h3><p>两个取值false和true。</p><p>但要注意<strong>Lua中所有的值都可以作为条件</strong>。</p><p>在控制结构的条件中除了<strong>false和nil为假</strong>，其他值都为真。</p><p>所以Lua认为0和空串都是真。</p><h3 id="number-（双精度浮点数）"><a href="#number-（双精度浮点数）" class="headerlink" title="number （双精度浮点数）"></a>number （双精度浮点数）</h3><p>Lua中没有整数，数字只有这一种类型</p><p>数字常量的例子：</p><pre><code class="hljs apache"><span class="hljs-attribute">4</span>   <span class="hljs-number">0</span>.<span class="hljs-number">4</span>  <span class="hljs-number">4</span>.<span class="hljs-number">57</span>e-<span class="hljs-number">3</span>    <span class="hljs-number">0</span>.<span class="hljs-number">3</span>e<span class="hljs-number">12</span>   <span class="hljs-number">5</span>e+<span class="hljs-number">20</span></code></pre><h3 id="string-（字符串）"><a href="#string-（字符串）" class="headerlink" title="string （字符串）"></a>string （字符串）</h3><ol><li><p>lua中字符串可以包含任何字符。（lua是8位字节）</p></li><li><p>Lua中字符串不允许被修改。</p></li><li><p>Lua的string是由Lua自动进行内存分配和释放。一个string可以只包含一个字母也可以包含一本书，Lua可以高效的处理长字符串，<strong>1M的string在Lua中是很常见的</strong>。</p></li><li><p>字符串可用<strong>单引号或者双引号</strong>括起来表示字符串</p></li><li><p>Lua支持转义字符</p><pre><code class="hljs Lua">\a bell\b back space               <span class="hljs-comment">-- 后退</span>\f form feed                <span class="hljs-comment">-- 换页</span>\n newline                  <span class="hljs-comment">-- 换行</span>\r carriage <span class="hljs-keyword">return</span>          <span class="hljs-comment">-- 回车</span>\t horizontal tab           <span class="hljs-comment">-- 制表</span>\v vertical tab\\ backslash                 <span class="hljs-comment">-- &quot;\&quot;</span>\<span class="hljs-string">&quot; double quote             -- 双引号</span><span class="hljs-string"></span><span class="hljs-string">\&#x27; single quote             -- 单引号</span><span class="hljs-string"></span><span class="hljs-string">\[ left square bracket      -- 左中括号</span><span class="hljs-string"></span><span class="hljs-string">\] right square bracket     -- 右中括号</span></code></pre></li><li><p>string支持通过数值来指定字符串中的字符</p><p>如：“alo” 可以用”\97lo“表示</p></li><li><p>string使用[[…]]表示字符串。这种形式的字符串可以包含多行也，可以嵌套且<strong>不会解释转义序列</strong>，如果第一个字符是换行符会被自动忽略掉。这种形式的字符串用来包含一段代码是非常方便的。</p><pre><code class="hljs lua">page = <span class="hljs-string">[[</span><span class="hljs-string">&lt;HTML&gt;</span><span class="hljs-string">&lt;HEAD&gt;</span><span class="hljs-string">&lt;TITLE&gt;An HTML Page&lt;/TITLE&gt;</span><span class="hljs-string">&lt;/HEAD&gt;</span><span class="hljs-string">&lt;BODY&gt;</span><span class="hljs-string">Lua</span><span class="hljs-string">[[a text between double brackets]]</span><span class="hljs-string">&lt;/BODY&gt;</span><span class="hljs-string">&lt;/HTML&gt;</span><span class="hljs-string">]]</span><span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>(page)</code></pre></li><li><p>Lua会自动在string和numbers之间自动进行类型转换，当一个字符串使用算术操作符时，string就会被转成数字。</p><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;10&quot;</span> + <span class="hljs-number">1</span>)             <span class="hljs-comment">--&gt; 11</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;10 + 1&quot;</span>)             <span class="hljs-comment">--&gt; 10 + 1</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-5.3e - 10&quot;</span> * <span class="hljs-string">&quot;2&quot;</span>)   <span class="hljs-comment">--&gt; -1.06e-09</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-number">1</span>)          <span class="hljs-comment">-- ERROR (cannot convert &quot;hello&quot;)</span></code></pre><p>反过来，当Lua期望一个string而碰到数字时，会将数字转成string。</p><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-number">10</span> .. <span class="hljs-number">20</span>)      <span class="hljs-comment">--&gt; 1020</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-number">10</span> .. <span class="hljs-number">20</span>))  <span class="hljs-comment">--&gt; string</span></code></pre><p>..在Lua中是字符串连接符，当在一个数字后面写时，必须加上空格以防止被解释错。</p><p>管字符串和数字可以自动转换，但两者是不同的，像10 == “10”这样的比较永远都是错的。如果需要显式将string转成数字可以使用函数tonumber()，如果string不是正确的数字该函数将返回nil。</p><pre><code class="hljs lua">line = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()         <span class="hljs-comment">-- read a line</span>n = <span class="hljs-built_in">tonumber</span>(line)       <span class="hljs-comment">-- try to convert it to a number</span><span class="hljs-keyword">if</span> n == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span>    <span class="hljs-built_in">error</span>(line .. <span class="hljs-string">&quot; is not a valid number&quot;</span>)<span class="hljs-keyword">else</span>    <span class="hljs-built_in">print</span>(n*<span class="hljs-number">2</span>)<span class="hljs-keyword">end</span></code></pre><p>反之,tostring()将数字转成字符串，这种转换一直有效</p><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">tostring</span>(<span class="hljs-number">10</span>) == <span class="hljs-string">&quot;10&quot;</span>)     <span class="hljs-comment">--&gt; true</span><span class="hljs-built_in">print</span>(<span class="hljs-number">10</span> .. <span class="hljs-string">&quot;&quot;</span> == <span class="hljs-string">&quot;10&quot;</span>)         <span class="hljs-comment">--&gt; true</span></code></pre></li><li><p>Lua5.1中，字符串前放置操作符”#“来获得该字符串的长度</p><pre><code class="hljs lua">a = <span class="hljs-string">&quot;hello&quot;</span><span class="hljs-built_in">print</span>(#a)           <span class="hljs-comment">--&gt;5</span><span class="hljs-built_in">print</span>(#<span class="hljs-string">&quot;good\0bye&quot;</span>) <span class="hljs-comment">--&gt;8</span></code></pre></li></ol><h3 id="table-（表）"><a href="#table-（表）" class="headerlink" title="table （表）"></a>table （表）</h3><p>table是Lua的主要的数据结构，具有强大的功能。</p><ol><li><p>table无固定的大小，可以动态增长</p></li><li><p>就Lua的习惯而言，如果以<strong>数字</strong>作为table的索引值的话，<strong>一般从1开始</strong></p></li><li><p>table实现了“关联数组”：可以通过整数或者任意其他类型的值(除了nil)来索引</p></li><li><p>Lua中无法声明table。创建table是通过<strong>构造表达式</strong>进行创建的。<code>最常用的是&#123;&#125;</code></p><pre><code class="hljs lua">a = &#123;&#125;  <span class="hljs-comment">-- 创建一个table，并将它的引用存储到a上</span>k = <span class="hljs-string">&quot;x&quot;</span>a[k] = <span class="hljs-number">10</span>a[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;great&quot;</span><span class="hljs-built_in">print</span>(a[<span class="hljs-string">&quot;x&quot;</span>])  <span class="hljs-comment">--&gt;10</span>y = <span class="hljs-number">20</span><span class="hljs-built_in">print</span>(a[y]) <span class="hljs-comment">--&gt; great</span>a[<span class="hljs-string">&quot;x&quot;</span>] = a[<span class="hljs-string">&quot;x&quot;</span>]+<span class="hljs-number">1</span><span class="hljs-built_in">print</span>(a[<span class="hljs-string">&quot;x&quot;</span>])  <span class="hljs-comment">--&gt;11</span></code></pre></li><li><p>table永远是“匿名的”，一个持有table的变量与table自身没有任何固定的关联</p><p>当一个程序再也没有对一个table的引用时吗，Lua的垃圾收集器（GC – garbage collection）最终会删除该table，并且复用它的内存</p><pre><code class="hljs lua">a = &#123;&#125;  <span class="hljs-comment">-- 创建一个table，并将它的引用存储到a上</span>k = <span class="hljs-string">&quot;x&quot;</span>a[k] = <span class="hljs-number">10</span><span class="hljs-built_in">print</span>(a[<span class="hljs-string">&quot;x&quot;</span>])  <span class="hljs-comment">--&gt;10</span>b = a<span class="hljs-built_in">print</span>(b[<span class="hljs-string">&quot;x&quot;</span>])  <span class="hljs-comment">--&gt;10</span>a = <span class="hljs-literal">nil</span>  <span class="hljs-comment">-- 删除该变量</span><span class="hljs-built_in">print</span>(b[<span class="hljs-string">&quot;x&quot;</span>])  <span class="hljs-comment">--&gt;10</span>b = <span class="hljs-literal">nil</span>  <span class="hljs-comment">--删除完本程序对table的引用</span></code></pre></li><li><p>table索引的语法糖</p><pre><code class="hljs lua">a = &#123;&#125;x = <span class="hljs-string">&quot;y&quot;</span>a[x] = <span class="hljs-number">10</span><span class="hljs-built_in">print</span>(a[x])  <span class="hljs-comment">--&gt; 10</span><span class="hljs-built_in">print</span>(a.x)   <span class="hljs-comment">--&gt; nil  --&gt;以字符串x为索引 表示 a[&quot;x&quot;]</span><span class="hljs-built_in">print</span>(a.y)   <span class="hljs-comment">--&gt; 10   --&gt;以字符串y为索引 表示 a[&quot;y&quot;]</span></code></pre></li><li><p>Lua 5.1中长度操作符 # 与table的一些用法</p><p>Lua 5.1中“#”长度操作符可以返回一个数组或者线性表的最后一个索引值（或为其大小）</p><pre><code class="hljs lua">a = &#123;&#125;<span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">5</span> <span class="hljs-keyword">do</span>    a[i] = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()  <span class="hljs-comment">--&gt;读取一行</span><span class="hljs-keyword">end</span><span class="hljs-comment">-- 打印所有读取的内容</span><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,#a <span class="hljs-keyword">do</span>  <span class="hljs-built_in">print</span>(a[i])<span class="hljs-keyword">end</span><span class="hljs-comment">---</span><span class="hljs-built_in">print</span>(a[#a]) <span class="hljs-comment">--打印列表a的最后一个值</span>a[#a] = <span class="hljs-literal">nil</span>  <span class="hljs-comment">--删除最后一个值</span>a[#a+<span class="hljs-number">1</span>] = <span class="hljs-number">11</span> <span class="hljs-comment">--将一个新的值添加到a的末尾</span><span class="hljs-comment">-- 读取一个文件的前十行</span>a = &#123;&#125;<span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">10</span> <span class="hljs-keyword">do</span>    a[#a+<span class="hljs-number">1</span>] = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()<span class="hljs-keyword">end</span></code></pre></li><li><p>Lua将nil作为界定数组结尾的标志</p><p>当一个数组中间有nil时，使用#a得到的就不会是你的预期</p><p>可以使用<code>table.maxn(a)</code>函数 – （Lua5.1新函数），来取得table的最大索引数</p></li></ol><h3 id="function-（函数）"><a href="#function-（函数）" class="headerlink" title="function （函数）"></a>function （函数）</h3><p>Lua中的函数可以存储在变量之中，</p><p>可以通过参数传递给其他函数，</p><p>也可以作为其他函数的返回值。</p><h3 id="userdata-（自定义类型）"><a href="#userdata-（自定义类型）" class="headerlink" title="userdata （自定义类型）"></a>userdata （自定义类型）</h3><p>userdata可将任意的C语言数据存储到Lua变量之中。</p><p>userdata用于表示一种由应用程序或C语言库所创建的新类型，例如标准的I/O库就用userdata来表示文件.</p><h3 id="thread-（线程）"><a href="#thread-（线程）" class="headerlink" title="thread （线程）"></a>thread （线程）</h3><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>加 + 减 - 乘 * 除 / 指数 ^ 取模 % 负号 -</p><p>和C语言的几乎相同,不过Lua中的数据都是双精度浮点数</p><ul><li>Lua中没有 +=, ++ ,–这一类的运算符</li></ul><p>但是对于这些实数而言有些其他的不同</p><ul><li>x %1 得到x的小数部分</li><li>x - x%1 得到x的整数部分</li><li>x - x%0.01 精确到小数点后两位的结果</li></ul><pre><code class="hljs lua">x = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">pi</span><span class="hljs-built_in">print</span>(x)       <span class="hljs-comment">--&gt;3.1415926535898</span><span class="hljs-built_in">print</span>(x%<span class="hljs-number">1</span>)     <span class="hljs-comment">--&gt;0.14159265358979</span><span class="hljs-built_in">print</span>(x-x%<span class="hljs-number">1</span>)   <span class="hljs-comment">--&gt;3</span><span class="hljs-built_in">print</span>(x-x%<span class="hljs-number">0.01</span>)<span class="hljs-comment">--&gt;3.14</span></code></pre><h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;&gt;</span><span class="hljs-attribute">&lt;=&gt;</span>=== ~=不等于</code></pre><p>运算结果都是true或者false</p><ul><li><p>nil只与其自身相等</p></li><li><p>对于table,userdata和function,Lua是做引用比较的,即只有他们引用同一个对象是才相等</p></li><li><p>比较字符串是按照字母次序进行比较的,与字符串长度无关</p></li><li><p>Lua遇到字符串和数字做比较会引发错误</p><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-number">5</span> &lt; <span class="hljs-number">10</span>)     <span class="hljs-comment">--&gt;true</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a&quot;</span> &lt; <span class="hljs-string">&quot;b&quot;</span>)  <span class="hljs-comment">--&gt;true</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ab&quot;</span> &lt; <span class="hljs-string">&quot;b&quot;</span>) <span class="hljs-comment">--&gt;true</span></code></pre><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3></li></ul><p>and  or  not</p><ul><li><p>and和or的运算结果不是true和false，而是和它的两个操作数相关。</p><pre><code class="hljs lua">a <span class="hljs-keyword">and</span> b    <span class="hljs-comment">-- 如果a为false，则返回a，否则返回b</span>a <span class="hljs-keyword">or</span> b    <span class="hljs-comment">--  如果a为true，则返回a，否则返回b</span></code></pre></li><li><p>注意and和or都是短路求值,只有在需要的时候才会去评估它的第二个操作数</p>  <pre><code class="hljs lua"><span class="hljs-comment">-- 一个很实用的技巧：如果x为false或者nil则给x赋初始值v</span>x = x <span class="hljs-keyword">or</span> v<span class="hljs-comment">-- 等价于</span><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> x <span class="hljs-keyword">then</span>    x = v<span class="hljs-keyword">end</span></code></pre></li><li><p>c语言的三目运算符 a ? b : c</p><pre><code class="hljs lua">(a <span class="hljs-keyword">and</span> b) <span class="hljs-keyword">or</span> c</code></pre></li><li><ul><li>求x y中较大的数<br>max = ( x &gt; y) and x or y<pre><code class="hljs clean">  ### 操作符优先级从高到低​```lua^not    - (负号)*      /+      -..&lt;      &gt;      &lt;=     &gt;=     ~=     ==andor</code></pre><h3 id="table的构造"><a href="#table的构造" class="headerlink" title="table的构造"></a>table的构造</h3></li></ul></li></ul><p>构造器是创建和初始化表的表达式。表是Lua特有的功能强大的东西。最简单的构造函数是{}，用来创建一个空表。可以直接初始化数组:</p><pre><code class="hljs lua">days = &#123;<span class="hljs-string">&quot;Sunday&quot;</span>, <span class="hljs-string">&quot;Monday&quot;</span>, <span class="hljs-string">&quot;Tuesday&quot;</span>,  <span class="hljs-string">&quot;Wednesday&quot;</span>,       <span class="hljs-string">&quot;Thursday&quot;</span>, <span class="hljs-string">&quot;Friday&quot;</span>, <span class="hljs-string">&quot;Saturday&quot;</span>&#125;</code></pre><p>Lua将”Sunday”初始化days[1]（第一个元素索引为1），用”Monday”初始化days[2]</p><p>构造函数可以使用任何表达式初始化：</p><pre><code class="hljs lua">tab  = &#123;<span class="hljs-built_in">sin</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span>), <span class="hljs-built_in">sin</span>(<span class="hljs-number">3</span>), <span class="hljs-built_in">sin</span>(<span class="hljs-number">4</span>),     <span class="hljs-built_in">sin</span>(<span class="hljs-number">5</span>),<span class="hljs-built_in">sin</span>(<span class="hljs-number">6</span>), <span class="hljs-built_in">sin</span>(<span class="hljs-number">7</span>), <span class="hljs-built_in">sin</span>(<span class="hljs-number">8</span>)&#125;</code></pre><p>如果想初始化一个表作为record使用可以这样：</p><pre><code class="hljs lua">a = &#123;x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>&#125;    &lt;<span class="hljs-comment">--&gt;    a = &#123;&#125;; a.x=0; a.y=0  </span>a = &#123;x=<span class="hljs-number">10</span>,y=<span class="hljs-number">20</span>&#125;<span class="hljs-built_in">print</span>(a[<span class="hljs-number">1</span>])    <span class="hljs-comment">--&gt; nil</span><span class="hljs-built_in">print</span>(a[<span class="hljs-string">&quot;x&quot;</span>])  <span class="hljs-comment">--&gt; 10</span><span class="hljs-built_in">print</span>(a.x)      <span class="hljs-comment">--&gt; 10</span></code></pre><p>不管用何种方式创建table，我们<strong>都可以向表中添加或者删除任何类型的域</strong>，构造函数仅仅影响表的初始化。</p><pre><code class="hljs lua">w = &#123;x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>, label=<span class="hljs-string">&quot;console&quot;</span>&#125;x =  &#123;<span class="hljs-built_in">sin</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">sin</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span>)&#125;w[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;another field&quot;</span>   <span class="hljs-comment">-- 添加key 1到table w中,值为 another field</span>x.f  = w                 <span class="hljs-comment">-- 添加key &quot;f&quot;到table x中,值为 w</span><span class="hljs-built_in">print</span>(w[<span class="hljs-string">&quot;x&quot;</span>])   <span class="hljs-comment">--&gt; 0</span><span class="hljs-built_in">print</span>(w[<span class="hljs-number">1</span>])    <span class="hljs-comment">--&gt; another  field</span><span class="hljs-built_in">print</span>(x.f[<span class="hljs-number">1</span>])   <span class="hljs-comment">--&gt; another  field</span>w.x  = <span class="hljs-literal">nil</span>     <span class="hljs-comment">--  remove field &quot;x&quot;</span></code></pre><p>每次调用构造函数，Lua都会创建一个新的table，可以使用table构造一个list：</p><pre><code class="hljs lua">list = <span class="hljs-literal">nil</span><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> <span class="hljs-built_in">io</span>.<span class="hljs-built_in">lines</span>() <span class="hljs-keyword">do</span>   list = &#123;<span class="hljs-built_in">next</span>=list, value=line&#125;<span class="hljs-keyword">end</span></code></pre><p>这段代码从标准输入读进每行，然后反序形成链表。下面的代码打印链表的内容：</p><pre><code class="hljs lua">l = list<span class="hljs-keyword">while</span> l <span class="hljs-keyword">do</span>  <span class="hljs-built_in">print</span>(l.value)   l = l.<span class="hljs-built_in">next</span><span class="hljs-keyword">end</span></code></pre><p>在同一个构造函数中可以混合列表风格和record风格进行初始化，如：</p><pre><code class="hljs lua">polyline = &#123;color=<span class="hljs-string">&quot;blue&quot;</span>,  thickness=<span class="hljs-number">2</span>, npoints=<span class="hljs-number">4</span>,       &#123;x=<span class="hljs-number">0</span>,  y=<span class="hljs-number">0</span>&#125;,       &#123;x=<span class="hljs-number">-10</span>, y=<span class="hljs-number">0</span>&#125;,       &#123;x=<span class="hljs-number">-10</span>, y=<span class="hljs-number">1</span>&#125;,       &#123;x=<span class="hljs-number">0</span>,  y=<span class="hljs-number">1</span>&#125;&#125;</code></pre><p>这个例子也表明我们可以嵌套构造函数来表示复杂的数据结构.</p><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(polyline[<span class="hljs-string">&quot;color&quot;</span>])  <span class="hljs-comment">--&gt; blue</span><span class="hljs-built_in">print</span>(polyline[<span class="hljs-number">1</span>].x)      <span class="hljs-comment">--&gt; 0</span><span class="hljs-built_in">print</span>(polyline[<span class="hljs-number">2</span>].x)   <span class="hljs-comment">--&gt;  -10</span></code></pre><p>上面两种构造函数的初始化方式还有限制，比如你不能使用负索引初始化一个表中元素，字符串索引也不能被恰当的表示。下面介绍一种更一般的初始化方式，我们用[expression]显示的表示将被初始化的索引：</p><pre><code class="hljs lua">opnames = &#123;[<span class="hljs-string">&quot;+&quot;</span>] = <span class="hljs-string">&quot;add&quot;</span>, [<span class="hljs-string">&quot;-&quot;</span>] = <span class="hljs-string">&quot;sub&quot;</span>,       [<span class="hljs-string">&quot;*&quot;</span>] = <span class="hljs-string">&quot;mul&quot;</span>, [<span class="hljs-string">&quot;/&quot;</span>] = <span class="hljs-string">&quot;div&quot;</span>&#125;i = <span class="hljs-number">20</span>; s = <span class="hljs-string">&quot;-&quot;</span>a =  &#123;[i+<span class="hljs-number">0</span>] = s, [i+<span class="hljs-number">1</span>] = s..s, [i+<span class="hljs-number">2</span>] = s..s..s&#125;<span class="hljs-built_in">print</span>(opnames[s])  <span class="hljs-comment">--&gt;  sub</span><span class="hljs-built_in">print</span>(a[<span class="hljs-number">22</span>])     <span class="hljs-comment">--&gt;  ---</span></code></pre><p>list风格初始化和record风格初始化是这种一般初始化的特例:</p><pre><code class="hljs lua">&#123;x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>&#125;    &lt;<span class="hljs-comment">--&gt;    &#123;[&quot;x&quot;]=0, [&quot;y&quot;]=0&#125;</span>&#123;<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>&#125;    &lt;<span class="hljs-comment">--&gt;</span>       &#123;[<span class="hljs-number">1</span>]=<span class="hljs-string">&quot;red&quot;</span>,  [<span class="hljs-number">2</span>]=<span class="hljs-string">&quot;green&quot;</span>, [<span class="hljs-number">3</span>]=<span class="hljs-string">&quot;blue&quot;</span>&#125;</code></pre><p>如果真的想要数组下标从0开始：</p><pre><code class="hljs lua">days = &#123;[<span class="hljs-number">0</span>]=<span class="hljs-string">&quot;Sunday&quot;</span>, <span class="hljs-string">&quot;Monday&quot;</span>, <span class="hljs-string">&quot;Tuesday&quot;</span>, <span class="hljs-string">&quot;Wednesday&quot;</span>,      <span class="hljs-string">&quot;Thursday&quot;</span>, <span class="hljs-string">&quot;Friday&quot;</span>, <span class="hljs-string">&quot;Saturday&quot;</span>&#125;</code></pre><p>注意：不推荐数组下标从0开始，否则很多标准库不能使用。</p><p>在构造函数的最后的”,”是可选的，可以方便以后的扩展。</p><pre><code class="hljs lua">a =  &#123;[<span class="hljs-number">1</span>]=<span class="hljs-string">&quot;red&quot;</span>, [<span class="hljs-number">2</span>]=<span class="hljs-string">&quot;green&quot;</span>, [<span class="hljs-number">3</span>]=<span class="hljs-string">&quot;blue&quot;</span>,&#125;</code></pre><p>在构造函数中域分隔符逗号（”,”）可以用分号（”;”）替代，通常我们使用分号用来分割不同类型的表元素。</p><pre><code class="hljs lua">&#123;x=<span class="hljs-number">10</span>, y=<span class="hljs-number">45</span>; <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>&#125;</code></pre><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>大体和C语言类似，不过没有<code>+=，-=</code>这一类的赋值。</p><p>Lua允许<strong>多重赋值</strong>，即对多个变量同时赋值。变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。</p><pre><code class="hljs lua">a, b = <span class="hljs-number">10</span>, <span class="hljs-number">2</span>*x       &lt;<span class="hljs-comment">--&gt;       a=10; b=2*x</span></code></pre><p>遇到赋值语句Lua会<strong>先计算右边所有的值</strong>然后再执行赋值操作，所以我们可以这样进行交<strong>换变量</strong>的值</p><pre><code class="hljs lua">x, y = y, x                     <span class="hljs-comment">-- swap &#x27;x&#x27; for &#x27;y&#x27;</span>a[i], a[j] = a[j], a[i]         <span class="hljs-comment">-- swap &#x27;a[i]&#x27; for &#x27;a[i]&#x27;</span></code></pre><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>使用<code>local</code>创建一个局部变量，与全局变量不同，局部变量只在被声明的那个代码块内有效。</p><p><strong>需要注意的是：lua中的变量如果没有特殊说明，全是全局变量，那怕是语句块或是函数里。变量前加local关键字的是局部变量。</strong></p><p>尽可能的去使用局部变量。</p><ul><li>访问局部变量比访问全局变量要快</li><li>局部变量会随着其作用域的消失而结束，便于垃圾收集器释放其值。</li></ul><h3 id="if-then-else语句"><a href="#if-then-else语句" class="headerlink" title="if then else语句"></a>if then else语句</h3><p>控制结构的条件表达式结果可以是任何值，<strong>Lua认为false和nil为假，其他值为真</strong>。</p><ul><li><strong>Lua不支持switch语句</strong>。</li></ul><pre><code class="hljs lua"><span class="hljs-comment">-- 第一种</span><span class="hljs-keyword">if</span> conditions <span class="hljs-keyword">then</span>     <span class="hljs-keyword">then</span>-part<span class="hljs-keyword">end</span>;<span class="hljs-comment">-- 第二种</span><span class="hljs-keyword">if</span> conditions <span class="hljs-keyword">then</span>     <span class="hljs-keyword">then</span>-part<span class="hljs-keyword">else</span>    <span class="hljs-keyword">else</span>-part<span class="hljs-keyword">end</span>;<span class="hljs-comment">-- 第三种</span><span class="hljs-keyword">if</span> conditions <span class="hljs-keyword">then</span>     <span class="hljs-keyword">then</span>-part<span class="hljs-keyword">elseif</span> conditions <span class="hljs-keyword">then</span>    <span class="hljs-keyword">elseif</span>-part..            <span class="hljs-comment">---&gt;多个elseif</span><span class="hljs-keyword">else</span>    <span class="hljs-keyword">else</span>-part<span class="hljs-keyword">end</span>;</code></pre><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><pre><code class="hljs lua"><span class="hljs-keyword">while</span> condition <span class="hljs-keyword">do</span>    statements;<span class="hljs-keyword">end</span>;</code></pre><h3 id="repeat-until语句"><a href="#repeat-until语句" class="headerlink" title="repeat until语句"></a>repeat until语句</h3><pre><code class="hljs lua"><span class="hljs-keyword">repeat</span>    statements;<span class="hljs-keyword">until</span> conditions;</code></pre><h3 id="for-语句-数字型"><a href="#for-语句-数字型" class="headerlink" title="for 语句 数字型"></a>for 语句 数字型</h3><pre><code class="hljs lua"><span class="hljs-keyword">for</span> var=exp1,exp2,exp3 <span class="hljs-keyword">do</span>   loop-part<span class="hljs-keyword">end</span></code></pre><p>for将用作为从exp1（初始值）到exp2（终止值），按照步长exp3执行。其中步长可以省略，默认为1.</p><ul><li>三个表达式只会被计算一次，并且是在循环开始前。</li><li>控制变量var是<strong>局部变量</strong>自动被声明,并且只在循环内有效.</li><li>循环过程中<strong>不要改变控制变量的值</strong>，那样做的结果是不可预知的。如果要退出循环，使用<strong>break</strong>语句。</li></ul><h3 id="for-语句-范型"><a href="#for-语句-范型" class="headerlink" title="for 语句 范型"></a>for 语句 范型</h3><pre><code class="hljs lua"><span class="hljs-comment">-- 范型for遍历迭代子函数返回的每一个值。</span><span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(a) <span class="hljs-keyword">do</span> <span class="hljs-built_in">print</span>(v) <span class="hljs-keyword">end</span></code></pre><p>Lua的基础库提供了<code>ipairs</code>，这是一个用于遍历数组的<strong>迭代器</strong>函数。在每次循环中，i会被赋予一个索引值，同时v被赋予一个对应于索引值的数组元素值。</p><ul><li> 控制变量是局部变量</li><li>不要修改控制变量的值</li></ul><h3 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h3><p>break语句用来退出当前循环<code>（for、repeat、while）</code>，在循环外部不可以使用。它只会跳出内部循环。</p><h3 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h3><p>return用来从函数返回结果，或者结束一个函数的执行。当一个函数自然结束时，结尾会有一个默认的return。</p><p>Lua语法要求break和return只能出现在block的结尾一句（也就是说：作为chunk的最后一句，或者在end之前，或者else前，或者until前），例如：</p><pre><code class="hljs lua"><span class="hljs-keyword">local</span> i = <span class="hljs-number">1</span><span class="hljs-keyword">while</span> a[i] <span class="hljs-keyword">do</span>    <span class="hljs-keyword">if</span> a[i] == v <span class="hljs-keyword">then</span> <span class="hljs-keyword">break</span> <span class="hljs-keyword">end</span>    i = i + <span class="hljs-number">1</span><span class="hljs-keyword">end</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>入门Lua —— Windows下安装Lua</title>
    <link href="/lua-0/"/>
    <url>/lua-0/</url>
    
    <content type="html"><![CDATA[<p>建议全部看完再决定使用哪种方式~</p><a id="more"></a><h2 id="直接安装"><a href="#直接安装" class="headerlink" title="直接安装"></a>直接安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>进入网站： <a href="http://joedf.ahkscript.org/LuaBuilds/">http://joedf.ahkscript.org/LuaBuilds/</a> </p><p>这里我下载的是 <code>lua-5.3.5_Win64_bin</code> 。解压内容如下所示</p><p><img src="/lua-0/dow.png"></p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>然后存放于一个不会轻易删除的文件夹，不要带中文。复制整个路径，添加环境变量。</p><p><img src="/lua-0/path.png"></p><ol><li>点击环境变量</li><li>点击path，之后点击编辑</li><li>弹出编辑环境变量的窗口，点击新建</li><li>填入刚才复制的路径，点击确定。结束</li></ol><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在cmd输入lua，输出所示：<code>Lua 5.3.5  Copyright (C) 1994-2018 Lua.org, PUC-Rio</code></p><p>然后尝试打出入门语句  <code>Hello World</code>。</p><p><img src="/lua-0/hello.png"></p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p><strong>貌似执行的时候只能先写好文件，然后去用cmd来执行文件。</strong></p><pre><code class="hljs vim"><span class="hljs-keyword">lua</span> hello.<span class="hljs-keyword">lua</span></code></pre><p>形如这种形式</p><h2 id="使用VS-CODE"><a href="#使用VS-CODE" class="headerlink" title="使用VS CODE"></a>使用VS CODE</h2><p>在VS CODE中安装插件 <code>Lua Debug</code> 。之后要对VS CODE 进行重启。</p><p>之后写一个lua文件，然后<code>Ctrl +F5</code> (在不调试的情况下启动)，即可在vs code的控制台查看到结果。</p><p>参看视频 <a href="https://www.bilibili.com/video/av57593220/?p=1">B站Lua基础知识</a> </p><h3 id="存在的问题-1"><a href="#存在的问题-1" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>运行一个递归程序出现问题</p><h2 id="使用软件-ZeroBrane-Studio"><a href="#使用软件-ZeroBrane-Studio" class="headerlink" title="使用软件 ZeroBrane Studio"></a>使用软件 ZeroBrane Studio</h2><p>这是一个满足Lua需求的轻量级IDE .</p><p>官网： <a href="https://studio.zerobrane.com/">https://studio.zerobrane.com/</a> </p><p>下载： <a href="https://studio.zerobrane.com/support">https://studio.zerobrane.com/support</a> </p><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p>界面有点老。其他还好</p><h2 id="使用软件LuaEditor6-30"><a href="#使用软件LuaEditor6-30" class="headerlink" title="使用软件LuaEditor6.30"></a>使用软件LuaEditor6.30</h2><p>界面有点像vc6，环境软件中都配置好了，是Lua 5.1 。</p><p>软件无须安装，打开就可以用，整体来说还是比较方便的。</p><p>下载链接：<a href="https://pan.baidu.com/s/1DOufTjqlYvbf0R9Ewk1zWw">https://pan.baidu.com/s/1DOufTjqlYvbf0R9Ewk1zWw</a><br>提取码：otm6</p>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件下载</tag>
      
      <tag>SOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理实验（二）—— 递归子程序分析器的设计与实现</title>
    <link href="/compile-lab-2/"/>
    <url>/compile-lab-2/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：基于《编译原理（第三版）》(清华大学出版社，王生原版)的递归子程序分析器程序。</p><a id="more"></a><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>本分析程序所分析的文法如下：</p><pre><code class="hljs 1c">G[E]：E→eBaAA→a<span class="hljs-string">|bAcB</span>B→dEd<span class="hljs-string">|aC</span>C→e<span class="hljs-string">|dC</span></code></pre><p>针对上述文法编写一递归子程序分析程序，该程序的输入是任意符号串，输出是本次输入的符号串是否是该文法的句子的结论。<br>测试样例为：</p><pre><code class="hljs 1c">eadeaa<span class="hljs-meta">#</span>edeaebd<span class="hljs-meta">#</span>edeaeaadabacae<span class="hljs-meta">#</span></code></pre><h2 id="分析说明"><a href="#分析说明" class="headerlink" title="分析说明"></a>分析说明</h2><p>分析说明：<br>针对上述文法求得各个非终结符的<strong>First集</strong>、<strong>Follow集</strong>以及各个产生式的<strong>Select集</strong>。</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">FIRST</span><span class="hljs-params">(E)</span></span> = &#123;e&#125;、FIRST(A) = &#123;<span class="hljs-selector-tag">a</span>,b&#125;、FIRST(B) = &#123;<span class="hljs-selector-tag">a</span>,d&#125;、FIRST(C) = &#123;d,e&#125;<span class="hljs-function"><span class="hljs-title">FOLLOW</span><span class="hljs-params">(E)</span></span> = &#123;#,d&#125;  FOLLOE(A) = &#123;#,c,d&#125;<span class="hljs-function"><span class="hljs-title">FOLLOW</span><span class="hljs-params">(B)</span></span> = &#123;#,<span class="hljs-selector-tag">a</span>,c,d&#125;  FOLLOW(C) = &#123;#,<span class="hljs-selector-tag">a</span>,c,d&#125;<span class="hljs-function"><span class="hljs-title">SELECT</span><span class="hljs-params">(E-&gt;eBaA)</span></span> = &#123;e&#125;<span class="hljs-function"><span class="hljs-title">SELECT</span><span class="hljs-params">(A-&gt;a)</span></span> = &#123;a&#125;<span class="hljs-function"><span class="hljs-title">SELECT</span><span class="hljs-params">(A-&gt;bAcB)</span></span> = &#123;b&#125;<span class="hljs-function"><span class="hljs-title">SELECT</span><span class="hljs-params">(B-&gt;dEd)</span></span> = &#123;d&#125;<span class="hljs-function"><span class="hljs-title">SELECT</span><span class="hljs-params">(B-&gt;Ac)</span></span> = &#123;a&#125;<span class="hljs-function"><span class="hljs-title">SELECT</span><span class="hljs-params">(C-&gt;e)</span></span> = &#123;e&#125;<span class="hljs-function"><span class="hljs-title">SELECT</span><span class="hljs-params">(C-&gt;dC)</span></span> = &#123;d&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理实验（一）—— 词法分析程序的设计与实现</title>
    <link href="/compile-lab-1/"/>
    <url>/compile-lab-1/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：基于《编译原理（第三版）》(清华大学出版社，王生原版)的PL/0词法分析程序。</p><a id="more"></a><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>通过对PL/0词法分析程序（GETSYM）的分析，并在此基础上按照课本1.4节中给出的PL/0语言的语法描述，编写一个PL/0语言的词法分析程序。然后使用该词法分析程序实现对课本12页的图1.19中的源程序的词法分析。</p><p>要求：输入为字符串（即待进行词法分析的源程序），输出为二元式，表示为：（单词种别、单词自身的值）。详细见P38。有一定检查词法错误的能力，例如发现<strong>2a</strong>这类不能作为单词的字符串。</p><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> m,n,r,q;r := <span class="hljs-number">2</span>a;<span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">gcd</span>;</span><span class="hljs-keyword">begin</span><span class="hljs-keyword">while</span> r<span class="hljs-string">#0</span> <span class="hljs-keyword">do</span><span class="hljs-keyword">begin</span>q := m /n;r := m - q * n;m := n;n := r;<span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>;<span class="hljs-keyword">begin</span> <span class="hljs-keyword">read</span>(m);<span class="hljs-keyword">read</span>(n);<span class="hljs-keyword">if</span> m&lt;n <span class="hljs-keyword">then</span><span class="hljs-keyword">begin</span>r := m;m := n;n := r;<span class="hljs-keyword">end</span>;<span class="hljs-keyword">begin</span>r := <span class="hljs-number">12</span>s;r := <span class="hljs-number">12</span>ss;call gcd;<span class="hljs-keyword">write</span>(m);<span class="hljs-keyword">end</span>;<span class="hljs-keyword">end</span>.</code></pre><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>这个词法分析程序需要以一个文件作为读入文件，读取文件内的内容，识别其中的各种PL0语言的关键字、标识符等。本程序是一次<strong>读取一行字符串</strong>，这样方便获取文件的行号。</p><blockquote><p>读取一行字符串，<strong>字符串的结束标志为’\0’.</strong></p></blockquote><p>读取一行之后如果遇到空格或者缩进之类的全部略过向后读取。如果遇到字母就开始暂存到一个char数组，一直读取直到遇到空格、回车、缩进以及各种符号之类的停止读取。这就是获取到的一个token，使用这个token对PL0语言的保留字表进行检查，如果有相同的，那么这个token就是关键字，如果没有相同的那就是一个标识符。如果读到的内容以数字开头就暂存入char数组，继续向后读取，如果碰到空格或者换行缩进就停止读取，则获取到一个数字，如果碰到字母之类的说明出错，这是错误的标识符，向后读完整个错误的标识符，然后打印错误。</p><p>之后就是符号<code>:</code>了，如果向后读取不是<code>=</code>，那么报错，<code>：</code>是无法单独出现的。</p><p>对于大于号<code>&gt;</code>、小于号<code>&lt;</code>都要去考虑后面有无等于号<code>=</code>，如果有那就是两个符号共同组合，如果没有就是单独的符号。剩下的就是对PL0语言的单个运算符以及单个界符的判断了。然后如果遇到未定义的符号也要报出相应的错误。</p><p>参考<strong>PL/0词法规则状态转换图</strong></p><p><img src="/compile-lab-1/principle.jpg"></p><h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><p><code>void init()</code>函数 ：负责将关键字、操作符和界符初始化赋值给全局变量。</p><p><code>void getsym(string str,int index,int lines)</code>函数：负责对字符串str从它的下标index开始进行词法分析，lines表示当前分析的第几行。</p><p><code>void errors(int lines,int err_num,string errstr)</code>函数：显示错误的函数，显示错误出现在第几行lines上，err_num表示错误类型，errstr表示错误造成的原因。</p><p><code>main()</code>函数，这个程序的入口，进行流程控制以及结果显示。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt; keyword_list;<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">char</span>&gt; operator_list;<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">char</span>&gt; board_list;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getsym</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str,<span class="hljs-keyword">int</span> index,<span class="hljs-keyword">int</span> lines)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printchar</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">int</span> len)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">errors</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lines, <span class="hljs-keyword">int</span> err_num,<span class="hljs-built_in">string</span> errstr)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;init();ifstream readfile;readfile.open(<span class="hljs-string">&quot;resourse.txt&quot;</span>, ios::in);<span class="hljs-built_in">string</span> tmp;<span class="hljs-keyword">int</span> lines = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (getline(readfile,tmp))&#123;<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;Lines&quot;</span>&lt;&lt;lines&lt;&lt;<span class="hljs-string">&quot;: &#123;&quot;</span>&lt;&lt; tmp &lt;&lt;<span class="hljs-string">&quot;&#125;&quot;</span>&lt;&lt; <span class="hljs-built_in">endl</span>;getsym(tmp, <span class="hljs-number">0</span>, lines);lines++;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;_getch();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">string</span> keyword[<span class="hljs-number">13</span>] = &#123; <span class="hljs-string">&quot;begin&quot;</span>, <span class="hljs-string">&quot;call&quot;</span> ,<span class="hljs-string">&quot;const&quot;</span> ,<span class="hljs-string">&quot;do&quot;</span> ,<span class="hljs-string">&quot;end&quot;</span> ,<span class="hljs-string">&quot;if&quot;</span> ,<span class="hljs-string">&quot;odd&quot;</span> ,<span class="hljs-string">&quot;procedure&quot;</span> ,<span class="hljs-string">&quot;read&quot;</span> ,<span class="hljs-string">&quot;then&quot;</span> ,<span class="hljs-string">&quot;var&quot;</span> ,<span class="hljs-string">&quot;while&quot;</span> ,<span class="hljs-string">&quot;write&quot;</span> &#125;;keyword_list.assign(keyword,keyword+ <span class="hljs-keyword">sizeof</span>(keyword) / <span class="hljs-keyword">sizeof</span>(keyword[<span class="hljs-number">0</span>]));<span class="hljs-keyword">char</span> operators[<span class="hljs-number">8</span>] = &#123;<span class="hljs-string">&#x27;+&#x27;</span>,<span class="hljs-string">&#x27;-&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-string">&#x27;=&#x27;</span>,<span class="hljs-string">&#x27;#&#x27;</span>,<span class="hljs-string">&#x27;&lt;&#x27;</span>,<span class="hljs-string">&#x27;&gt;&#x27;</span>&#125;;operator_list.assign(operators, operators + <span class="hljs-keyword">sizeof</span>(operators) / <span class="hljs-keyword">sizeof</span>(operators[<span class="hljs-number">0</span>]));<span class="hljs-keyword">char</span> boards[<span class="hljs-number">5</span>] = &#123; <span class="hljs-string">&#x27;(&#x27;</span>,<span class="hljs-string">&#x27;)&#x27;</span>,<span class="hljs-string">&#x27;,&#x27;</span>,<span class="hljs-string">&#x27;;&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span> &#125;;board_list.assign(boards, boards + <span class="hljs-keyword">sizeof</span>(boards) / <span class="hljs-keyword">sizeof</span>(boards[<span class="hljs-number">0</span>]));&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getsym</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str,<span class="hljs-keyword">int</span> index,<span class="hljs-keyword">int</span> lines)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> ch = str[index];<span class="hljs-comment">/*如果遇到字符串结束符，结束*/</span><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;\0&#x27;</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">while</span> (ch == <span class="hljs-string">&#x27; &#x27;</span> || ch == <span class="hljs-string">&#x27;\t&#x27;</span>)<span class="hljs-comment">/*忽略空格和TAB*/</span>&#123;index++;ch = str[index];&#125;<span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;\0&#x27;</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">/*以字母开头*/</span><span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<span class="hljs-comment">/*如果程序是以字母a~z之间开头的，就继续读取，知道遇到空格、换行或者TAB结束*/</span>&#123;<span class="hljs-keyword">int</span> word_index = <span class="hljs-number">0</span>;<span class="hljs-keyword">char</span> new_word[<span class="hljs-number">100</span>];new_word[word_index] = ch;<span class="hljs-keyword">while</span>(str[index + <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; (str[index + <span class="hljs-number">1</span>] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; str[index + <span class="hljs-number">1</span>] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) || (str[index + <span class="hljs-number">1</span>] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[index + <span class="hljs-number">1</span>] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>))&#123;word_index++;index++;new_word[word_index] = str[index];&#125;<span class="hljs-comment">/*当读取完一个完整的单词之后,搜索是不是保留字*/</span><span class="hljs-built_in">string</span> strs = <span class="hljs-built_in">string</span>(new_word, new_word + word_index+<span class="hljs-number">1</span>);<span class="hljs-comment">/*如果是保留字，输出*/</span><span class="hljs-keyword">if</span> (find(keyword_list.begin(), keyword_list.end(), strs) != keyword_list.end())&#123;<span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-string">&quot;保留字 —— &quot;</span> &lt;&lt; strs &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">/*如果不是保留字，则就是标识符号*/</span><span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;标识符 —— &quot;</span> &lt;&lt; strs &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">/*数字开头*/</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<span class="hljs-comment">/*如果单词是以数字开头的，就继续读取，遇到空格、换行或者TAB*/</span>&#123;<span class="hljs-keyword">int</span> word_index = <span class="hljs-number">0</span>;<span class="hljs-keyword">char</span> new_word[<span class="hljs-number">100</span>];new_word[word_index] = ch;<span class="hljs-keyword">while</span> (str[index + <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; str[index + <span class="hljs-number">1</span>] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[index + <span class="hljs-number">1</span>] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)&#123;word_index++;index++;new_word[word_index] = str[index];&#125;<span class="hljs-comment">/*如果数字中碰到了字母，那么就是词法错误*/</span><span class="hljs-keyword">if</span> (str[index + <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; str[index + <span class="hljs-number">1</span>] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; str[index + <span class="hljs-number">1</span>] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)&#123;<span class="hljs-built_in">string</span> errstr = <span class="hljs-built_in">string</span>(new_word,new_word+word_index+<span class="hljs-number">1</span>);errstr.append(<span class="hljs-number">1</span>,str[index+<span class="hljs-number">1</span>]);index++;<span class="hljs-keyword">while</span> (str[index + <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; str[index + <span class="hljs-number">1</span>] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; str[index + <span class="hljs-number">1</span>] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)&#123;errstr.append(<span class="hljs-number">1</span>, str[index + <span class="hljs-number">1</span>]);index++;&#125;errors(lines, <span class="hljs-number">1</span>,errstr);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;数字 —— &quot;</span>;printchar(new_word, word_index);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;<span class="hljs-comment">/*:=*/</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;:&#x27;</span>)&#123;<span class="hljs-keyword">if</span> (str[index + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;=&#x27;</span>)&#123;index++;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;运算符 —— :=&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">/*出错*/</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[index + <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;=&#x27;</span>)&#123;<span class="hljs-built_in">string</span> errstr = <span class="hljs-string">&quot;&quot;</span>;errors(lines, <span class="hljs-number">0</span>,errstr);&#125;&#125;<span class="hljs-comment">/*&lt;=*/</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;&lt;&#x27;</span>)&#123;<span class="hljs-keyword">if</span> (str[index + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;=&#x27;</span>)&#123;index++;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;运算符 —— &lt;=&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;运算符 —— &lt;&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">/*&gt;=*/</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;&gt;&#x27;</span>)&#123;<span class="hljs-keyword">if</span> (str[index + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;=&#x27;</span>)&#123;index++;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;运算符 —— &gt;=&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;运算符 —— &gt;&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">/*其他单符号*/</span><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/*如果其他单符号属于已经定义的符号，那么正确，输出二元组*/</span><span class="hljs-keyword">if</span> (find(operator_list.begin(), operator_list.end(), ch) != operator_list.end())&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;运算符 —— &quot;</span> &lt;&lt; ch &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (find(board_list.begin(), board_list.end(), ch) != board_list.end())&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;界符 —— &quot;</span> &lt;&lt; ch &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">string</span> errstr = <span class="hljs-built_in">string</span>(<span class="hljs-number">1</span>, ch);errors(lines, <span class="hljs-number">2</span>, errstr);&#125;&#125;getsym(str, index+<span class="hljs-number">1</span>, lines);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printchar</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">int</span> len)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= len; i++)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; str[i];&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">errors</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lines, <span class="hljs-keyword">int</span> err_num, <span class="hljs-built_in">string</span> errstr)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;出错在&quot;</span> &lt;&lt; lines &lt;&lt; <span class="hljs-string">&quot;行&quot;</span> &lt;&lt; <span class="hljs-string">&quot;原因是: &quot;</span> ;<span class="hljs-keyword">switch</span> (err_num)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;&#123; : 无法单独使用，需要联合 = 组成:= 才能一起使用 &#125;&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;&#123; : &quot;</span>&lt;&lt; errstr &lt;&lt;<span class="hljs-string">&quot; 是错误的数字或者错误的标识符 &#125;&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;&#123; :&quot;</span> &lt;&lt; errstr &lt;&lt; <span class="hljs-string">&quot; 符号未定义 &#125;&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;</code></pre><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p><img src="/compile-lab-1/result.png"></p><h2 id="设计技巧"><a href="#设计技巧" class="headerlink" title="设计技巧"></a>设计技巧</h2><p>标识符、运算符和界符存放进了C++ STL的list链表中，这样查询时比较方便。然后读取文件是按行进行读取，<code>getsym()</code>函数一次处理一行的数据，当此函数识别完一个单词或者数字后，如果这一行并没有结束，他会递归调用自己直到处理完这一行为止。此外报错函数<code>errors()</code>里使用了<code>switch case</code>语句，可以给不同的错误类型赋予不同的编号，使用时传入相关参数直接调用。</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>通过本次实验我了解到了一个词法分析器的实现过程，根据字符的识别来分析得到token，同时也明白了一个词法分析器实现的复杂，需要考虑各种各样的情况，同时也应该考虑设计之后针对语法分析器所留的接口之类的问题，总之通过这次实验收获了很多，更加对编译原理有了浓厚的兴趣。  </p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>囚鸟</title>
    <link href="/%E5%9B%9A%E9%B8%9F/"/>
    <url>/%E5%9B%9A%E9%B8%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来源：微信公众号：<a href="https://mp.weixin.qq.com/s/MetzJq3EjnL4sQBku7cd7w">秦朔朋友圈——囚鸟</a></p><p>作者： 忆湄 </p><p>时间：2019.10.27</p></blockquote><a id="more"></a><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>几年前当我走进一家大数据公司，我就开始怀疑这个时代真的还有多少自由人类。</p><p>大数据公司的CEO娴熟地展示他们引以自豪的生产资料，也就是这个时代的“石油”——数据，当然重点是对于人类的控制。你的数码足迹、交易记录、坐标位置、甚至脸部细微的肌肉变动，都被记录在案，然后精准投喂。</p><p><strong>这年头控制不靠威胁，而是靠满足，铺天盖地的满足。据说如今能随时随地服务中国大城市一个普通人的人，比当年伺候路易十四的人还多。</strong>你我心知肚明，当隐私可作抵押，换取信用和舒适，每个人都是网中之鱼，甚至是，提线木偶。</p><p>人的隐私被全面围剿得手了。好像每个天花板都藏着眼睛，每堵墙都有耳朵。它们像是伴随着你的生命活动出没的，在你独身、结婚、生子、买房、旅行时它们都会掐准了时间打来兴冲冲的电话，像上帝派发的贴心管家，让混乱的人生瞬时变成了一道有序可解的题。记得有次说起一位阿里高管不知什么时候搜过一次骨灰盒，每次打开淘宝，都给他推送骨灰盒，气得他把产品经理叫来好好盘问一番。</p><p>但我不是要赶来嘲讽这些时代的异象，我想说的是，虽然这已经是一个越来越好的时代，物质丰富，科技进步，精神解放，但架在人脖子上的隐性枷锁，还是没少。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>在我们成长过程中，显性的枷锁已经太多。时代、命运、体制……都是庞大而让人望而生畏的对手。</p><p>80后从小到大的命运卷轴上，也被时代说来就来的浪潮扑打过好多次。</p><p>小时候国企改革，有人的父母下岗丢掉了铁饭碗。一路受教育的过程中总会有跟西方发达世界的信息差，好像凭空就被降维打击掉了一截。</p><p>上大学时高校扩招，大学生变成和满大街汽车一样的普通。毕业时又恰逢金融危机，那些暑假还在国外做Summer Intern的小伙伴一毕业就面临失业的窘境。</p><p>工作没两年房价噌噌噌上涨，买房成了大城市独自打拼的年轻人三十而立最大的绊脚石。</p><p>但早个几十年，可能人生头等大事，就是填饱肚子。所以有朋友说不吃隔夜菜对于我们而言是天经地义的，但对于父母来讲就是很难。当他们没有被时代欺负过，对不浪费食物就不会有那么深的执念。</p><p>而再早一点，在战争年代，或许能活下来，就已经是谢天谢地。写《万历十五年》的黄仁宇说他“恰巧出生在中国政治的最低点，以及人心惶惶的最高点”。他有本自传叫《黄河青山》，讲他的一生基本就是壮志未酬的一生。二战、八年抗战、四年内战，无法复制的历史造成了那代人无法复制的命运，他想当拿破仑的心在那个时代根本翻不出什么浪花来。</p><p>到后来你发现人就是一种无奈的存在。不喜欢的事，让你愤怒的事，和灰尘一样多。每个时代都有它的目光和举止，从而圈养了一批批的囚鸟。</p><p>囚鸟被笼子囚禁。时代、社会、体制都是笼子，这些是你看得见的、感觉得到的显性枷锁。</p><p>但更可怕的是那些看不见的隐性枷锁——当眼界、知识、资源的限制导致了观念限制，当囚鸟已经忘了天有多高，或者压根不知道天有多高，才是人们都在迅速变成分母的原因。</p><p>有个流行词叫“智商税”，同样的，“眼界税”、“知识税”、“观念税”都是隐性枷锁，因为你不仅不知道，而且并不知道自己不知道，甚至以为自己知道。世界是一口紧锁的箱子，你觉得自己打开看过，其实看到的也只有最上面一层。就跟文章一开始说的，普通人并不知道好好聊着天呢，暗搓搓搜索了一个词，暗自庆幸终于有自己的私有领地了，未曾想却走进了他人安排的战局。</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>想要跨越阶层？隐性枷锁是一个槛。</p><p>穷人为什么穷？</p><p>我小时候去乡村扶贫，乡村孩子每天走路上下学花掉几小时，做农活花掉几小时，读书也很勤奋，但他们除了课本没有课外书读，更别说有机会去看世界，他们和这个正在蓬勃发展的世界有着绝对的时差。</p><p>新晋诺贝尔经济学奖得主在《贫穷的本质》里说，你以为是因为穷人懒吗，是被贫穷限制了想象啊。因为知识、眼界、信息的局限带来的观念差异大相径庭。</p><p>但“时差”不是穷人的专利。有体制内的高管到了退休才发现，原来这市场这么大啊，原来自己远远可以发展得更好。但当年贪恋权力和地位，又背负家人的期望，只看见眼前那条笔直的所谓“成功”的道路，走了之后就很难回头，越不回头越把自己捆绑了，只能一个劲往前赶。后来才发现，陷在眼前能看到的东西，那些“自以为”的观念覆盖在身上，就像身体上发育出了一个巨大的后天器官，把一辈子过成了一笔糊涂账。</p><p>相反，那些抓住时代大机会的人呢，知识结构和认知维度一定高于同时代的常人。1995年的马云去了一趟西雅图，第一次用电脑，第一次上网，然后发现了互联网的巨大机会，他当时的眼界一定高于还在杭州勤勤恳恳干活的普通人。2000年初的安立欣，根据他宏观经济研究生的知识结构，判断出中国到了房地产崛起的阶段，又根据他的信息来源，发现了北京贷款买二手房很难的问题，于是他创办了一个融资担保公司，一干就是10年。安立欣后来创办了格上财富，但这才是他的第一桶金。</p><p><strong>眼睛得毒，脑子里底片的像素要比其他人高，尺幅要比其他人阔</strong>——这是冯唐形容作家的，但哪止作家呢，跃升阶层的人恐怕都是一种新目光的发明者。</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>想要争取权利？隐性枷锁是一个槛。</p><p>我印象很深的一个插曲是，今年诺贝尔经济学奖的获得者埃斯特·迪弗洛是史上最年轻的得主，也是有史以来第二位女性获得者，她说，“我希望（自己的获奖）可以表明一个女人有可能成功，并获得成功的认可。这将激励许多其他妇女继续工作，并鼓励其他许多男人给予她们应有的尊重。”</p><p>这句获奖词非常经典，因为她道出了女性获得成功最大的障碍不是她们本身的能力，而是不被认同也不被尊重。</p><p>大多数女性大概只能像《82年生的金智英》里的金智英小姐一样，生活是由旁人的意愿组装而成的——男孩子欺负你就是“喜欢你”，遭遇了性骚扰是“自己先释放了信号”，工作了被男客户强拉着灌酒，婚后“众望所归”成为全职母亲。但作者的重点，不是控诉性别不公，而是”不被看见”，认为那些置若罔闻的日常都“理所应当”，甚至会被认作“这才是好命”。就像古代女子的缠足，就是要在你还懵懂之时，就断了你四处活动翅膀变硬的念想。</p><p>她们没有能力从一片斩钉截铁的“不信”中去构建一些“相信”，无法从“你是女孩子”这样开头的句子里发现一点不正常，不相信努力就可以平衡掉那些旧时代的负债。她们甚至都不用燃起内心的战火，就永久让渡了那片安放自我的领地。</p><p>可怕的不是“我不要你觉得，我要我觉得”的霸道粗暴，而是“我要你自己觉得”的绵里藏针。这样的故事，怎么讲都觉得苦。</p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>想要活得清明？隐性枷锁也是一个槛。</p><p><strong>企业家一地鸡毛的婚姻真相由愤怒的当事人喷薄而出后，很多人在网上热议，原来有钱女性也要承受透着屏幕都能感同身受的煎熬，金钱和地位抵挡不了生活的千疮百孔的真相，原来中国没有“贵族”。</strong></p><p>局外人常常会羡慕那些这个时代权利和财富的掌舵者，金钱主动成了柔光滤镜，把所有的生活褶皱都熨平了。<strong>但一个让人沮丧的真相是，无论是谁，都有活在夹缝里的时刻。</strong>局外人对某一类人的态度习惯一刀切，比如企业家都风光无限，明星都赚钱如流水，他们很难知晓圈内微妙的等级划分，谁值得羡慕，谁值得同情，谁将蓄势待发，谁快走到尽头。</p><p>所以写《事实》的汉斯·罗斯林说，<strong>人类一分为二的本能让我们把世界分成“我们”和“他们”，而以偏概全的本能则让“我们”认为“他们”完全一样。</strong></p><p>这种情绪化的想法是人类的本能，帮助我们的祖先在遥远的年代幸存下来，但却是这个时代无数焦虑人类的“隐形枷锁”。情绪化的世界观让人盲目认为金钱和地位就能解决人生幸福，就无法在还未拥有金钱和地位时活得心平气和。</p><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>囚鸟最好的命运是什么？我90岁的外婆和我说过一句话我至今印象深刻，她同样出生在中国政治的最低点，经历近一个世纪的坎坷沉浮。她说“我这一生受过多少刺激，但是我都让自己忘记，我只知道朝前看。” </p><p>显性的枷锁无法对抗，但隐形的枷锁却值得去拆解。如果和更辽阔的世界永远隔着那几道栏杆，也不要忘了去撑开更辽阔的大脑和内心。最好的人生，不过就是在一堆残垣破壁之中，努力去找到一些闪闪发光的东西。</p>]]></content>
    
    
    <categories>
      
      <category>转载</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理 —— 文法</title>
    <link href="/compile-0/"/>
    <url>/compile-0/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：文法、语言、以及文法的类型</p><a id="more"></a><h2 id="如何描述一种语言"><a href="#如何描述一种语言" class="headerlink" title="如何描述一种语言"></a>如何描述一种语言</h2><ul><li>如果语言是<strong>有穷</strong>的（只含有有穷个句子），可以将句子逐一列出来表示</li><li>如果语言是<strong>无穷</strong>的，则找出语言的有穷表示：<ul><li><strong>生成方式</strong>(文法)：语言中的每个句子可以用严格定义的规则来构造</li><li><strong>识别方式</strong>(自动机)：用一个过程，当输入一串任意语言时，该过程经过有限次计算就会停止，若属于，回答“是”，若不属于，要能停止并回答“不是”。</li></ul></li></ul><h2 id="文法的定义"><a href="#文法的定义" class="headerlink" title="文法的定义"></a>文法的定义</h2><p><img src="/compile-0/compile-0%5Cwenfa.png"></p><h2 id="语言的定义"><a href="#语言的定义" class="headerlink" title="语言的定义"></a>语言的定义</h2><p><img src="/compile-0/yuyan.png"></p><h2 id="文法的类型"><a href="#文法的类型" class="headerlink" title="文法的类型"></a>文法的类型</h2><p>   通过对<strong>产生式施加不同的限制</strong>，Chomsky(乔姆斯基)将文法分为四种类型：</p><p><img src="/compile-0/wenfaleixing.png"></p><p>0型文法（短语结构文法）的能力相当于图灵机。</p><p>1型文法（<strong>上下文有关文法</strong>）：产生式的形式为 <code>α1Aα2→α1βα2</code> ，即只有A出现在α1和α2的上下文中时，才允许β取代A。其识别系统是线性界限自动机。</p><p>2型文法（<strong>上下文无关文法</strong>CFG）：产生式的形式为A→β，β取代A时与A的上下文无关。其识别系统是不确定的下推自动机。（其产生式左部只有一个非终结符）</p><p>3型文法（正规文法RG）：文法G= (VN,VT,P,S),其中P中的产生式的形式为A→αB或者A→α，其中A和B是非终结符号，α属于VT* 。产生的语言是有穷自动机（FA）所接受的集合。</p><p><strong>上下文无关文法(2型文法)有足够的能力描述程序设计语言的语法结构，如描述算术表达式或者各种语句。</strong></p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统实验（一）—— 使用动态优先权的进程调度算法模拟</title>
    <link href="/os-lab-1/"/>
    <url>/os-lab-1/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：动态优先权的进程调度算法模拟，主要使用<strong>单链表</strong>完成。</p><a id="more"></a><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>用C语言来实现对N个进程采用动态优先权优先算法的进程调度。</p><p>每个用来标识进程的进程控制块PCB用结构来描述，包括以下字段：</p><ul><li>进程标识数 ID。</li><li> 进程优先数 PRIORITY，并规定优先数越大的进程，其优先权越高。</li><li>进程已占用的CPU时间CPUTIME。</li><li>进程还需占用的CPU时间ALLTIME。当进程运行完毕时，ALLTIME变为0。</li><li>进程的阻塞时间STARTBLOCK，表示当进程再运行STARTBLOCK个时间片后，将进入阻塞状态。</li><li>进程被阻塞的时间BLOCKTIME，表示已足赛的进程再等待BLOCKTIME个时间片后，将转换成就绪状态。</li><li>进程状态START。</li><li>队列指针NEXT，用来将PCB排成队列。</li></ul><p><strong>优先数改变的原则</strong>：</p><p>进程在就绪队列中呆一个时间片，优先数加1。</p><p>进程每运行一个时间片，优先数减3。</p><p>假设在调度前，系统中有5个进程，它们的初始状态如下：</p><table><thead><tr><th>ID</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>PRIORITY</td><td>9</td><td>38</td><td>30</td><td>29</td><td>0</td></tr><tr><td>CPUTIME</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>ALLTIME</td><td>3</td><td>3</td><td>6</td><td>3</td><td>4</td></tr><tr><td>STARTBLOCK</td><td>2</td><td>-1</td><td>-1</td><td>-1</td><td>-1</td></tr><tr><td>BLOCKTIME</td><td>3</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>STATE</td><td>READY</td><td>READY</td><td>READY</td><td>READY</td><td>READY</td></tr></tbody></table><p>为了清楚的观察各进程的调度过程，程序应将每个时间片内的情况显示出来</p><h2 id="代码思想"><a href="#代码思想" class="headerlink" title="代码思想"></a>代码思想</h2><blockquote><p>头一次做这个实验的时候，总是想的太多，导致写的代码十分混乱，重写多次都还是给自己挖了很多坑，于是上CSDN找了一份代码，仔细抄录了一遍。理解了思想之后，修改其中部分代码，结果如下。</p><p>过了几天找不到原作者的文章和链接了，就不放参考链接了，见谅……</p></blockquote><p>整个代码使用了单链表，构建了两个链：就绪队列链和阻塞队列链。同时使用的链表时带头节点的链表。</p><p>然后链表构造的时候按照了<strong>优先级的大小</strong>来排序。这样从就绪队列中找到优先级最高的进程时非常的方便。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PCB</span> &#123;</span><span class="hljs-keyword">int</span> id;<span class="hljs-keyword">int</span> priority;<span class="hljs-comment">/*进程优先数*/</span><span class="hljs-keyword">int</span> cputime;<span class="hljs-comment">/*已经占用的cpu时间*/</span><span class="hljs-keyword">int</span> alltime;<span class="hljs-comment">/*还需占用的cpu时间*/</span><span class="hljs-keyword">int</span> startblock;<span class="hljs-comment">/*进程的阻塞时间*/</span><span class="hljs-keyword">int</span> blocktime;<span class="hljs-comment">/*进程被阻塞的时间*/</span><span class="hljs-keyword">int</span> state;<span class="hljs-comment">/*进程状态,0表示就绪，1表示运行,2表示阻塞,3表示完成*/</span>PCB *next;<span class="hljs-comment">//指向下一个进程</span>    <span class="hljs-comment">//结构体的构造函数</span>PCB(<span class="hljs-keyword">int</span> a1, <span class="hljs-keyword">int</span> a2, <span class="hljs-keyword">int</span> a3, <span class="hljs-keyword">int</span> a4, <span class="hljs-keyword">int</span> a5, <span class="hljs-keyword">int</span> a6, <span class="hljs-keyword">int</span> a7)&#123;id = a1;priority = a2;cputime = a3;alltime = a4;startblock = a5;blocktime = a6;state = a7;next = <span class="hljs-literal">NULL</span>;&#125;&#125;;PCB *Ready_Queue_Head = <span class="hljs-literal">NULL</span>;PCB *Block_Queue_Head = <span class="hljs-literal">NULL</span>;PCB *Finish_Queue_Head = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//实际上基本没用到</span><span class="hljs-comment">//创建了就绪队列和阻塞队列，均包含头结点，以后的节点插入均采取插入排序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;Ready_Queue_Head = (PCB*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(PCB));Ready_Queue_Head-&gt;priority = <span class="hljs-number">99999</span>;Ready_Queue_Head-&gt;next = <span class="hljs-literal">NULL</span>;Block_Queue_Head = (PCB*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(PCB));Block_Queue_Head-&gt;priority = <span class="hljs-number">99999</span>;Block_Queue_Head-&gt;next = <span class="hljs-literal">NULL</span>;Finish_Queue_Head = (PCB*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(PCB));Finish_Queue_Head-&gt;priority = <span class="hljs-number">99999</span>;Finish_Queue_Head-&gt;next = <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FreeQueue</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">free</span>(Ready_Queue_Head);<span class="hljs-built_in">free</span>(Block_Queue_Head);<span class="hljs-built_in">free</span>(Finish_Queue_Head);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertProcess</span><span class="hljs-params">(PCB *InsertProcess, PCB *InsertProcessHead)</span></span><span class="hljs-function"></span>&#123;PCB *p = InsertProcessHead-&gt;next;PCB *p_before = InsertProcessHead;<span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;priority &gt; InsertProcess-&gt;priority)&#123;p_before = p;p = p-&gt;next;&#125;InsertProcess-&gt;next = p;p_before-&gt;next = InsertProcess;&#125;<span class="hljs-comment">//获取进程列表的第一个进程</span><span class="hljs-function">PCB * <span class="hljs-title">GetFirstProcess</span><span class="hljs-params">(PCB *ProcessQueue)</span></span><span class="hljs-function"></span>&#123;PCB * p = ProcessQueue-&gt;next;ProcessQueue-&gt;next = p-&gt;next;<span class="hljs-keyword">return</span> p;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EmptyProcessQueue</span><span class="hljs-params">(PCB *ProcessQueue)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (ProcessQueue-&gt;next == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowProcess</span><span class="hljs-params">(PCB *p)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\tId: &quot;</span> &lt;&lt; p-&gt;id &lt;&lt; <span class="hljs-string">&quot; Priority: &quot;</span> &lt;&lt; p-&gt;priority &lt;&lt; <span class="hljs-string">&quot; Cputime: &quot;</span> &lt;&lt; p-&gt;cputime &lt;&lt; <span class="hljs-string">&quot; Alltime:&quot;</span> &lt;&lt; p-&gt;alltime&lt;&lt; <span class="hljs-string">&quot; Startblock: &quot;</span> &lt;&lt; p-&gt;startblock &lt;&lt; <span class="hljs-string">&quot; Blocktime: &quot;</span> &lt;&lt; p-&gt;blocktime &lt;&lt; <span class="hljs-string">&quot; State: &quot;</span> &lt;&lt; p-&gt;state &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowProcessQueue</span><span class="hljs-params">(PCB *ProcessQueue)</span></span><span class="hljs-function"></span>&#123;PCB *p = ProcessQueue-&gt;next;<span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\tId: &quot;</span> &lt;&lt; p-&gt;id &lt;&lt; <span class="hljs-string">&quot; Priority: &quot;</span> &lt;&lt; p-&gt;priority &lt;&lt; <span class="hljs-string">&quot; Cputime: &quot;</span> &lt;&lt; p-&gt;cputime &lt;&lt; <span class="hljs-string">&quot; Alltime:&quot;</span> &lt;&lt; p-&gt;alltime&lt;&lt; <span class="hljs-string">&quot; Startblock: &quot;</span> &lt;&lt; p-&gt;startblock &lt;&lt; <span class="hljs-string">&quot; Blocktime: &quot;</span> &lt;&lt; p-&gt;blocktime &lt;&lt; <span class="hljs-string">&quot; State: &quot;</span> &lt;&lt; p-&gt;state &lt;&lt; <span class="hljs-built_in">endl</span>;p = p-&gt;next;&#125;&#125;<span class="hljs-comment">//就绪队列</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UpdateReadyQueue</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;PCB *p = Ready_Queue_Head-&gt;next;<span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)&#123;p-&gt;priority += <span class="hljs-number">1</span>;p = p-&gt;next;&#125;&#125;<span class="hljs-comment">//阻塞队列</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UpdateBlockQueue</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;PCB *p = Block_Queue_Head-&gt;next;PCB *p_before = Block_Queue_Head;<span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)&#123;p-&gt;blocktime -= <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (p-&gt;blocktime == <span class="hljs-number">0</span>)&#123;p_before-&gt;next = p-&gt;next;p-&gt;state = <span class="hljs-number">0</span>;InsertProcess(p, Ready_Queue_Head);p = p_before-&gt;next;&#125;<span class="hljs-keyword">else</span>&#123;p_before = p;p = p-&gt;next;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;InitQueue();<span class="hljs-function">PCB <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>)</span></span>;InsertProcess(&amp;p1, Ready_Queue_Head);<span class="hljs-function">PCB <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">38</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;InsertProcess(&amp;p2, Ready_Queue_Head);<span class="hljs-function">PCB <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;InsertProcess(&amp;p3, Ready_Queue_Head);<span class="hljs-function">PCB <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">29</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;InsertProcess(&amp;p4, Ready_Queue_Head);<span class="hljs-function">PCB <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;InsertProcess(&amp;p5, Ready_Queue_Head);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Init&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Ready Process:&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;ShowProcessQueue(Ready_Queue_Head);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Block Process:&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;ShowProcessQueue(Block_Queue_Head);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;========================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    PCB *NowRunProcess = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">bool</span> Is_CPU_Busy = <span class="hljs-literal">false</span>;<span class="hljs-keyword">int</span> time = <span class="hljs-number">1</span>; <span class="hljs-comment">//表示时间片</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span> (EmptyProcessQueue(Ready_Queue_Head) &amp;&amp; EmptyProcessQueue(Block_Queue_Head))<span class="hljs-keyword">break</span>; <span class="hljs-comment">//如果就绪队列和阻塞对列都为空，结束</span><span class="hljs-comment">//获取要运行的程序</span><span class="hljs-keyword">if</span> (!Is_CPU_Busy)&#123;NowRunProcess = GetFirstProcess(Ready_Queue_Head);NowRunProcess-&gt;state = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//不忙</span><span class="hljs-keyword">if</span> (!EmptyProcessQueue(Ready_Queue_Head) &amp;&amp; NowRunProcess-&gt;priority &lt; Ready_Queue_Head-&gt;next-&gt;priority)&#123;<span class="hljs-comment">//如果现在运行的程序小于就绪队列中第一个程序的优先级</span>NowRunProcess-&gt;state = <span class="hljs-number">0</span>;InsertProcess(NowRunProcess, Ready_Queue_Head);NowRunProcess = GetFirstProcess(Ready_Queue_Head);NowRunProcess-&gt;state = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-comment">//运行进程</span>Is_CPU_Busy = <span class="hljs-literal">true</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;第&quot;</span> &lt;&lt; time &lt;&lt; <span class="hljs-string">&quot;个时间片：&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Running Process: Id&quot;</span> &lt;&lt; NowRunProcess-&gt;id &lt;&lt; <span class="hljs-built_in">endl</span>;ShowProcess(NowRunProcess);<span class="hljs-comment">//就绪队列</span>UpdateReadyQueue();<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Ready Process:&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;ShowProcessQueue(Ready_Queue_Head);<span class="hljs-comment">//阻塞队列</span>UpdateBlockQueue();<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Block Process:&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;ShowProcessQueue(Block_Queue_Head);<span class="hljs-comment">//运行进程</span>NowRunProcess-&gt;priority -= <span class="hljs-number">3</span>;NowRunProcess-&gt;cputime += <span class="hljs-number">1</span>;NowRunProcess-&gt;alltime -= <span class="hljs-number">1</span>;NowRunProcess-&gt;startblock -= <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (NowRunProcess-&gt;alltime == <span class="hljs-number">0</span>)&#123;Is_CPU_Busy = <span class="hljs-literal">false</span>;NowRunProcess-&gt;state = <span class="hljs-number">3</span>;InsertProcess(NowRunProcess, Finish_Queue_Head);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (NowRunProcess-&gt;startblock == <span class="hljs-number">0</span>)&#123;Is_CPU_Busy = <span class="hljs-literal">false</span>;NowRunProcess-&gt;state = <span class="hljs-number">2</span>;InsertProcess(NowRunProcess, Block_Queue_Head);&#125;&#125;time++;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Runned Process:&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;ShowProcess(NowRunProcess);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;========================&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;    FreeQueue();_getch();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><pre><code class="hljs groovy">InitReady <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">38</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">30</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">6</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">29</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">9</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">4</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>Block <span class="hljs-attr">Process:</span>========================第<span class="hljs-number">1</span>个时间片：Running <span class="hljs-attr">Process:</span> Id1        <span class="hljs-symbol">Id:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">38</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>Ready <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">31</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">6</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">30</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">10</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">4</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>Block <span class="hljs-attr">Process:</span>Runned <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">35</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">2</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>========================第<span class="hljs-number">2</span>个时间片：Running <span class="hljs-attr">Process:</span> Id1        <span class="hljs-symbol">Id:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">35</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">2</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>Ready <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">32</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">6</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">31</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">11</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">4</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>Block <span class="hljs-attr">Process:</span>Runned <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">32</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">1</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-3</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>========================第<span class="hljs-number">3</span>个时间片：Running <span class="hljs-attr">Process:</span> Id1        <span class="hljs-symbol">Id:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">32</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">1</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-3</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>Ready <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">33</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">6</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">32</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">12</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">4</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>Block <span class="hljs-attr">Process:</span>Runned <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">29</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">0</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-4</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">3</span>========================第<span class="hljs-number">4</span>个时间片：Running <span class="hljs-attr">Process:</span> Id2        <span class="hljs-symbol">Id:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">33</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">6</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>Ready <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">33</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">13</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">4</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>Block <span class="hljs-attr">Process:</span>Runned <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">30</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">5</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>========================第<span class="hljs-number">5</span>个时间片：Running <span class="hljs-attr">Process:</span> Id3        <span class="hljs-symbol">Id:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">33</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>Ready <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">31</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">5</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">14</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">5</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">4</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>Block <span class="hljs-attr">Process:</span>Runned <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">30</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">2</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>========================第<span class="hljs-number">6</span>个时间片：Running <span class="hljs-attr">Process:</span> Id2        <span class="hljs-symbol">Id:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">31</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">5</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>Ready <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">31</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">2</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">15</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">6</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">4</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>Block <span class="hljs-attr">Process:</span>Runned <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">28</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">4</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-3</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>========================第<span class="hljs-number">7</span>个时间片：Running <span class="hljs-attr">Process:</span> Id3        <span class="hljs-symbol">Id:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">31</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">2</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>Ready <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">29</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">4</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-3</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">16</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">7</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">4</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>Block <span class="hljs-attr">Process:</span>Runned <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">28</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">1</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-3</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>========================第<span class="hljs-number">8</span>个时间片：Running <span class="hljs-attr">Process:</span> Id2        <span class="hljs-symbol">Id:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">29</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">4</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-3</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>Ready <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">29</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">1</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-3</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">17</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">8</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">4</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>Block <span class="hljs-attr">Process:</span>Runned <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">26</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-4</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>========================第<span class="hljs-number">9</span>个时间片：Running <span class="hljs-attr">Process:</span> Id3        <span class="hljs-symbol">Id:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">29</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">1</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-3</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>Ready <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">27</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-4</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">18</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">9</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">4</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>Block <span class="hljs-attr">Process:</span>Runned <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">26</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">0</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-4</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">3</span>========================第<span class="hljs-number">10</span>个时间片：Running <span class="hljs-attr">Process:</span> Id2        <span class="hljs-symbol">Id:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">27</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-4</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>Ready <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">19</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">10</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">4</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>Block <span class="hljs-attr">Process:</span>Runned <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">24</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">2</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-5</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>========================第<span class="hljs-number">11</span>个时间片：Running <span class="hljs-attr">Process:</span> Id2        <span class="hljs-symbol">Id:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">24</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">2</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-5</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>Ready <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">20</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">11</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">4</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>Block <span class="hljs-attr">Process:</span>Runned <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">21</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">5</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">1</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-6</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>========================第<span class="hljs-number">12</span>个时间片：Running <span class="hljs-attr">Process:</span> Id2        <span class="hljs-symbol">Id:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">21</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">5</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">1</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-6</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>Ready <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">21</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">12</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">4</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>Block <span class="hljs-attr">Process:</span>Runned <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">18</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">6</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">0</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-7</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">3</span>========================第<span class="hljs-number">13</span>个时间片：Running <span class="hljs-attr">Process:</span> Id0        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">21</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>Ready <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">13</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">4</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>Block <span class="hljs-attr">Process:</span>Runned <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">18</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">2</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>========================第<span class="hljs-number">14</span>个时间片：Running <span class="hljs-attr">Process:</span> Id0        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">18</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">2</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>Ready <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">14</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">4</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>Block <span class="hljs-attr">Process:</span>Runned <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">15</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">1</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">State:</span> <span class="hljs-number">2</span>========================第<span class="hljs-number">15</span>个时间片：Running <span class="hljs-attr">Process:</span> Id4        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">14</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">4</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>Ready <span class="hljs-attr">Process:</span>Block <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">15</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">1</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">2</span> <span class="hljs-attr">State:</span> <span class="hljs-number">2</span>Runned <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">11</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>========================第<span class="hljs-number">16</span>个时间片：Running <span class="hljs-attr">Process:</span> Id4        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">11</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">1</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">3</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-2</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>Ready <span class="hljs-attr">Process:</span>Block <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">15</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">1</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">1</span> <span class="hljs-attr">State:</span> <span class="hljs-number">2</span>Runned <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">8</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">2</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-3</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>========================第<span class="hljs-number">17</span>个时间片：Running <span class="hljs-attr">Process:</span> Id4        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">8</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">2</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-3</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>Ready <span class="hljs-attr">Process:</span>Block <span class="hljs-attr">Process:</span>Runned <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">5</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">1</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-4</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>========================第<span class="hljs-number">18</span>个时间片：Running <span class="hljs-attr">Process:</span> Id0        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">15</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">2</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">1</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>Ready <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">6</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">1</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-4</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">0</span>Block <span class="hljs-attr">Process:</span>Runned <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">0</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">12</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">0</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-1</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">3</span>========================第<span class="hljs-number">19</span>个时间片：Running <span class="hljs-attr">Process:</span> Id4        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">6</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">1</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-4</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">1</span>Ready <span class="hljs-attr">Process:</span>Block <span class="hljs-attr">Process:</span>Runned <span class="hljs-attr">Process:</span>        <span class="hljs-symbol">Id:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Priority:</span> <span class="hljs-number">3</span> <span class="hljs-attr">Cputime:</span> <span class="hljs-number">4</span> <span class="hljs-attr">Alltime:</span><span class="hljs-number">0</span> <span class="hljs-attr">Startblock:</span> <span class="hljs-number">-5</span> <span class="hljs-attr">Blocktime:</span> <span class="hljs-number">0</span> <span class="hljs-attr">State:</span> <span class="hljs-number">3</span>========================</code></pre>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows下QT的安装</title>
    <link href="/qt5-use/"/>
    <url>/qt5-use/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：QT安装时的选择MinGW/MSVC ?</p><a id="more"></a><h2 id="QT安装时的选择"><a href="#QT安装时的选择" class="headerlink" title="QT安装时的选择"></a>QT安装时的选择</h2><p>QT安装时有着非常多的组件让人进行选择，作为萌新非常尴尬~~</p><p>看了一下，大部分的教程都是推荐windows环境之下选择<strong>msvc版本</strong>。</p><h2 id="Qt-MinGW和MSVC对比"><a href="#Qt-MinGW和MSVC对比" class="headerlink" title="Qt MinGW和MSVC对比"></a>Qt MinGW和MSVC对比</h2><p>主要就是两大阵营 MSVC 和 MinGW两种编译器选择。</p><blockquote><p><strong>MSVC</strong>，需要使用Visual C++（微软的VC编译器）作为编译器</p><p><strong>MinGW</strong>是指Minimalist GNU For Windows，是将GNU开发工具移植到Win32平台下的产物，是一套Windows上的GNU开发工具移植到Win32平台下的产物，是一套Windows上的GNU工具集，用其开发的程序不需要额外的第三方DLL支持就可以在Windows下运行。</p><p>参看链接： <a href="https://blog.csdn.net/vict_wang/article/details/85334175">https://blog.csdn.net/vict_wang/article/details/85334175</a> </p></blockquote><blockquote><ol><li><p>都是很好用的编译工具，但是他们兼容的并不好。当你的项目使用MinGW编译的使用，想要用一个MSVC编译生成的库时就会有问题。使用MinGW编译项目的时候，所使用的Lib也要是MinGW编译的。如果你只是开发Window平台的软件时，最好用Qt MSVC组合，这样可以使用大量的第三方lib，还有很多的构建指令，毕竟window上MSVC才是王道。</p></li><li><p>编码的问题，QT5的Qstring默认是UTF8格式，QT5极力推介把源码用UTF8格式存储。 但是MSVC只支持带BOM的UTF8格式，qmake不支持带BOM的UTF8格式，逼我只能用GBK么。这样的话，用qt5，每次都要<code>Qstring::fromLocal8bit(“我是中国人”)；</code>况且就算BOM问题解决了，源代码是UTF8了。MSVC的执行编码也是GBK。<br><a href="https://blog.csdn.net/u014746838/article/details/83032817">Qt MinGW与MSVC对比</a></p></li></ol></blockquote><h2 id="QT库与编译器不一致导致的错误"><a href="#QT库与编译器不一致导致的错误" class="headerlink" title="QT库与编译器不一致导致的错误"></a>QT库与编译器不一致导致的错误</h2><p><img src="/qt5-use/err.png"></p><p>我碰到了类似的一堆错误，将近上千条的报错信息，顿时绝望~</p><p>因为你的库和编译器不一致导致的~~，比如你用的msvc的qt库，但是使用MinGW的编译器编译就会出各种各样的错误~</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p><a href="https://blog.csdn.net/qq598535550/article/details/60634519">QT入门系列（1）：QT Creator下载与安装 Helloworld</a></p><h2 id="2020-02-27-安装"><a href="#2020-02-27-安装" class="headerlink" title="2020-02-27 安装"></a>2020-02-27 安装</h2><p>这次安装时，发现必须得注册一个QT账号才行了~</p><p>经过多次安装，我现在固定是选择MinGW，缺少组件后期还是可以查教程再添加的。~</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络——第五章 运输层</title>
    <link href="/network-chapter-5/"/>
    <url>/network-chapter-5/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：计算机网络中网络层的基本概念以及应用.</p><a id="more"></a><blockquote><p>参照书籍：</p><p><strong>《计算机网络(第七版)》——谢希仁编著</strong></p><p><strong>《图解TCP/IP》第五版</strong></p></blockquote><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>端口是用来标志进程的。</p><p>是<strong>应用层的各种协议进程与运输实体进行层间交互的一种地址</strong>。</p><h2 id="TCP格式"><a href="#TCP格式" class="headerlink" title="TCP格式"></a>TCP格式</h2><h3 id="为什么在TCP首部中要把TCP的端口号放入最开始的4个字节？"><a href="#为什么在TCP首部中要把TCP的端口号放入最开始的4个字节？" class="headerlink" title="为什么在TCP首部中要把TCP的端口号放入最开始的4个字节？"></a>为什么在TCP首部中要把TCP的端口号放入最开始的4个字节？</h3><p>在ICMP差错报文中，要包含IP首部后面的8个字节的内容，而这里面有TCP首部中的源端接口和目的端口。</p><p>当TCP收到ICMP差错报文时，需要用这两个端口来确实是哪条连接出了差错。</p><h2 id="网络中的资源"><a href="#网络中的资源" class="headerlink" title="网络中的资源"></a>网络中的资源</h2><p>在计算机网络中的链路容量(即带宽)、交换结点中的缓存和处理及等，都是网络的资源。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arknights明日方舟（多图预警）</title>
    <link href="/arknights/"/>
    <url>/arknights/</url>
    
    <content type="html"><![CDATA[<p>明日方舟是我玩的一款二次元游戏，它的画风不错。这里收集了一些明日方舟的官方图片，同时也是测试一下我找的图床能否使用。当然图床是免费的，有被关停的风险~随缘</p><a id="more"></a><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><h3 id="玫兰莎"><a href="#玫兰莎" class="headerlink" title="玫兰莎"></a>玫兰莎</h3><p><img src="https://s1.ax1x.com/2020/08/13/dpiz26.png" alt="dpiz26.png"></p><p><img src="https://s2.ax1x.com/2019/10/07/u2B6aT.jpg" alt="u2B6aT.jpg"></p><hr><h3 id="初雪"><a href="#初雪" class="headerlink" title="初雪"></a>初雪</h3><p><img src="https://s1.ax1x.com/2020/08/13/dpCTJ0.png" alt="dpCTJ0.png"></p><p><img src="https://s1.ax1x.com/2020/08/13/dpCHzT.png" alt="dpCHzT.png"></p><hr><h3 id="蛇屠箱"><a href="#蛇屠箱" class="headerlink" title="蛇屠箱"></a>蛇屠箱</h3><p><img src="https://s1.ax1x.com/2020/08/13/dpiLVJ.png" alt="dpiLVJ.png"></p><p><img src="https://s1.ax1x.com/2020/08/13/dpiOa9.png" alt="dpiOa9.png"></p><p><img src="https://s2.ax1x.com/2019/10/07/u2ByZV.png" alt="u2ByZV.png"></p><hr><h3 id="灰喉"><a href="#灰喉" class="headerlink" title="灰喉"></a>灰喉</h3><p><img src="https://s1.ax1x.com/2020/08/25/d60QXT.png" alt="d60QXT.png"></p><hr><h3 id="红豆"><a href="#红豆" class="headerlink" title="红豆"></a>红豆</h3><p><img src="https://s1.ax1x.com/2020/08/25/d601nU.png" alt="d601nU.png"></p><hr><h3 id="刻俄柏"><a href="#刻俄柏" class="headerlink" title="刻俄柏"></a>刻俄柏</h3><p><img src="https://s1.ax1x.com/2020/08/25/d6BQPA.png" alt="d6BQPA.png"></p><hr><h3 id="陈"><a href="#陈" class="headerlink" title="陈"></a>陈</h3><p><img src="https://s2.ax1x.com/2019/10/07/u2e4uq.png" alt="陈"></p><p><img src="https://s1.ax1x.com/2020/08/13/dp9gb9.png" alt="dp9gb9.png"></p><hr><h3 id="拉普兰德"><a href="#拉普兰德" class="headerlink" title="拉普兰德"></a>拉普兰德</h3><p><img src="https://s2.ax1x.com/2020/01/31/13Gkaq.jpg" alt="拉普兰德"></p><p><img src="https://s1.ax1x.com/2020/08/13/dpCYRK.png" alt="dpCYRK.png"></p><hr><h3 id="空"><a href="#空" class="headerlink" title="空"></a>空</h3><p><img src="https://s1.ax1x.com/2020/08/13/dpFRsO.png" alt="dpFRsO.png"></p><p><img src="https://s2.ax1x.com/2019/10/07/u2BDrq.jpg" alt="u2BDrq.jpg"></p><hr><p><img src="https://s2.ax1x.com/2020/01/31/13GgSS.png" alt="13GgSS.png"></p><hr><h3 id="年"><a href="#年" class="headerlink" title="年"></a>年</h3><p><img src="https://s2.ax1x.com/2020/01/31/13G1d1.png" alt="年"></p><hr><h3 id="W"><a href="#W" class="headerlink" title="W"></a>W</h3><p><img src="https://s1.ax1x.com/2020/08/25/d6Jkge.png" alt="d6Jkge.png"></p><p><img src="https://s1.ax1x.com/2020/08/25/d6JF3D.jpg" alt="d6JF3D.jpg"></p><hr><h3 id="安洁莉娜"><a href="#安洁莉娜" class="headerlink" title="安洁莉娜"></a>安洁莉娜</h3><p><img src="https://s1.ax1x.com/2020/08/25/d6JB2F.png" alt="d6JB2F.png"></p><p><img src="https://s1.ax1x.com/2020/08/25/d6JwCT.jpg" alt="d6JwCT.jpg"></p><hr><h3 id="华法琳"><a href="#华法琳" class="headerlink" title="华法琳"></a>华法琳</h3><p><img src="https://s1.ax1x.com/2020/08/25/d60K10.png" alt="d60K10.png"></p><hr><h3 id="普罗旺斯"><a href="#普罗旺斯" class="headerlink" title="普罗旺斯"></a>普罗旺斯</h3><p><img src="https://s1.ax1x.com/2020/08/25/d60McV.png" alt="d60McV.png"></p><hr><h3 id="远山"><a href="#远山" class="headerlink" title="远山"></a>远山</h3><p><img src="https://s1.ax1x.com/2020/08/25/d6JbVI.png" alt="d6JbVI.png"></p><hr><h3 id="临光"><a href="#临光" class="headerlink" title="临光"></a>临光</h3><p><img src="https://s1.ax1x.com/2020/08/25/d6Jqat.png" alt="d6Jqat.png"></p><p><img src="https://s1.ax1x.com/2020/08/25/d6J42D.jpg" alt="d6J42D.jpg"></p><hr><h3 id="闪灵"><a href="#闪灵" class="headerlink" title="闪灵"></a>闪灵</h3><p><img src="https://s1.ax1x.com/2020/08/25/d6Y3i6.png" alt="d6Y3i6.png"></p><hr><h3 id="夜莺"><a href="#夜莺" class="headerlink" title="夜莺"></a>夜莺</h3><p><img src="https://s1.ax1x.com/2020/08/25/d6Y8JK.png" alt="d6Y8JK.png"></p><hr><h3 id="锡兰"><a href="#锡兰" class="headerlink" title="锡兰"></a>锡兰</h3><p><img src="https://s1.ax1x.com/2020/08/25/d6YlIx.png" alt="d6YlIx.png"></p><hr><h3 id="麦哲伦"><a href="#麦哲伦" class="headerlink" title="麦哲伦"></a>麦哲伦</h3><p><img src="https://s1.ax1x.com/2020/08/25/d6J7qA.png" alt="d6J7qA.png"></p><p><img src="https://s1.ax1x.com/2020/08/25/d6Jh8O.jpg" alt="d6Jh8O.jpg"></p><hr><h3 id="白金"><a href="#白金" class="headerlink" title="白金"></a>白金</h3><p><img src="https://s1.ax1x.com/2020/08/25/d6dTsS.png" alt="d6dTsS.png"></p><p><img src="https://s1.ax1x.com/2020/08/25/d6dLIs.png" alt="d6dLIs.png"></p><p><img src="https://s1.ax1x.com/2020/08/25/d6dXin.png" alt="d6dXin.png"></p><p><img src="https://s1.ax1x.com/2020/08/25/d6d7qg.jpg" alt="d6d7qg.jpg"></p><hr><h3 id="莫斯提马"><a href="#莫斯提马" class="headerlink" title="莫斯提马"></a>莫斯提马</h3><p><img src="https://s2.ax1x.com/2020/01/31/13Ghes.png" alt="莫斯提马"></p><hr><h3 id="梅"><a href="#梅" class="headerlink" title="梅"></a>梅</h3><p><img src="https://s2.ax1x.com/2020/01/31/13GRyQ.png" alt="梅"></p><hr><h3 id="波登可"><a href="#波登可" class="headerlink" title="波登可"></a>波登可</h3><p><img src="https://s1.ax1x.com/2020/08/25/d6BAv6.png" alt="d6BAv6.png"></p><hr><h3 id="艾斯黛尔"><a href="#艾斯黛尔" class="headerlink" title="艾斯黛尔"></a>艾斯黛尔</h3><p><img src="https://s1.ax1x.com/2020/08/25/d6BVKK.png" alt="d6BVKK.png"></p><hr><h3 id="慕斯"><a href="#慕斯" class="headerlink" title="慕斯"></a>慕斯</h3><p><img src="https://s1.ax1x.com/2020/08/25/d6BZDO.png" alt="d6BZDO.png"></p><hr><h3 id="苦艾"><a href="#苦艾" class="headerlink" title="苦艾"></a>苦艾</h3><p><img src="https://s1.ax1x.com/2020/08/25/d6BuUH.png" alt="d6BuUH.png"></p><hr><h3 id="宴"><a href="#宴" class="headerlink" title="宴"></a>宴</h3><p><a href="https://imgchr.com/i/d6BK5d"><img src="https://s1.ax1x.com/2020/08/25/d6BK5d.png" alt="d6BK5d.png"></a></p><hr><h2 id="火蓝之心-HEART-OF-SURGING-FLAME"><a href="#火蓝之心-HEART-OF-SURGING-FLAME" class="headerlink" title="火蓝之心 HEART OF SURGING FLAME"></a>火蓝之心 HEART OF SURGING FLAME</h2><p>火蓝之心是我玩明日方舟以来的参加的第一个大型活动，算是二次元游戏里的<strong>夏活</strong>吧~</p><p><img src="https://s2.ax1x.com/2019/10/07/u216pT.jpg" alt="u216pT.jpg"></p><p><a href="https://imgchr.com/i/u21OnH"><img src="https://s2.ax1x.com/2019/10/07/u21OnH.png" alt="AUS"></a></p><p><a href="https://imgchr.com/i/u21qje"><img src="https://s2.ax1x.com/2019/10/07/u21qje.png" alt="大帝"></a></p><p><img src="https://s2.ax1x.com/2019/10/07/u23ijg.png" alt="DDD"></p><h3 id="手机壁纸"><a href="#手机壁纸" class="headerlink" title="手机壁纸"></a>手机壁纸</h3><p><a href="https://imgchr.com/i/u23t4x"><img src="https://s2.ax1x.com/2019/10/07/u23t4x.jpg" alt="u23t4x.jpg"></a></p><p><a href="https://imgchr.com/i/u23UC6"><img src="https://s2.ax1x.com/2019/10/07/u23UC6.jpg" alt="u23UC6.jpg"></a></p><p><a href="https://imgchr.com/i/u21bcD"><img src="https://s2.ax1x.com/2019/10/07/u21bcD.jpg" alt="u21bcD.jpg"></a></p><h3 id="AUS-动态"><a href="#AUS-动态" class="headerlink" title="AUS 动态"></a>AUS 动态</h3><p>夏活爆肝的东西，因为一个账号只能选择一个人物，我只有两个人的动态截图，留念爆肝岁月~</p><p><a href="https://imgchr.com/i/u2nUOI"><img src="https://s2.ax1x.com/2019/10/07/u2nUOI.jpg" alt="u2nUOI.jpg"></a></p><p><img src="https://s2.ax1x.com/2019/10/07/u2nw0P.jpg" alt="u2nw0P.jpg"></p><p><a href="https://imgchr.com/i/u2nN6A"><img src="https://s2.ax1x.com/2019/10/07/u2nN6A.jpg" alt="u2nN6A.jpg"></a></p><p><img src="https://s2.ax1x.com/2019/10/07/u2ntld.jpg" alt="u2ntld.jpg"></p><p><img src="https://s2.ax1x.com/2019/10/07/u2ndmt.jpg" alt="u2ndmt.jpg"></p><hr><p><a href="https://imgchr.com/i/u2nPe0"><img src="https://s2.ax1x.com/2019/10/07/u2nPe0.jpg" alt="u2nPe0.jpg"></a></p><p><img src="https://s2.ax1x.com/2019/10/07/u2niwV.jpg" alt="u2niwV.jpg"></p><p><img src="https://s2.ax1x.com/2019/10/07/u2n9Lq.jpg" alt="u2n9Lq.jpg"></p><p><img src="https://s2.ax1x.com/2019/10/07/u2npyn.jpg" alt="u2npyn.jpg"></p><p><img src="https://s2.ax1x.com/2019/10/07/u2nSQs.jpg" alt="u2nSQs.jpg"></p><h2 id="皮肤"><a href="#皮肤" class="headerlink" title="皮肤"></a>皮肤</h2><p><img src="https://s2.ax1x.com/2019/10/07/u2Brq0.jpg" alt="u2Brq0.jpg"></p><hr><p><img src="https://s2.ax1x.com/2019/10/07/u2BBMn.jpg" alt="u2BBMn.jpg"></p><p><img src="https://s2.ax1x.com/2019/10/07/u2BcIU.jpg" alt="u2BcIU.jpg"></p><hr><p><img src="https://s2.ax1x.com/2020/01/31/13G3Ix.png" alt="13G3Ix.png"></p><hr><p><img src="https://s2.ax1x.com/2020/01/31/13G2Qg.png" alt="13G2Qg.png"></p><h2 id="其他图片"><a href="#其他图片" class="headerlink" title="其他图片"></a>其他图片</h2><p><img src="https://s2.ax1x.com/2019/10/07/u2DaTK.jpg" alt="u2DaTK.jpg"></p><hr><p><img src="https://s2.ax1x.com/2020/01/31/13GZGT.jpg" alt="13GZGT.jpg"></p><hr><p><img src="https://s1.ax1x.com/2020/08/25/d6DwwD.jpg" alt="d6DwwD.jpg"></p><h2 id="其他游戏角色乱入一张"><a href="#其他游戏角色乱入一张" class="headerlink" title="其他游戏角色乱入一张"></a>其他游戏角色乱入一张</h2><p><img src="https://s2.ax1x.com/2020/01/31/13GViV.png" alt="雪"></p><p>希望这个图床可以坚持住~</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>game</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matlab入门</title>
    <link href="/matlab/"/>
    <url>/matlab/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：本文是Matlab的简易学习笔记，为了全国大学生数学建模竞赛做一些准备。</p><a id="more"></a><p>参看视频：<a href="https://www.bilibili.com/video/av14503445?from=search&seid=10560014714789112428">https://www.bilibili.com/video/av14503445?from=search&amp;seid=10560014714789112428</a></p><h2 id="运算符与规则"><a href="#运算符与规则" class="headerlink" title="运算符与规则"></a>运算符与规则</h2><pre><code class="hljs matlab">+ - * / ^（次方）</code></pre><ul><li>^ 的优先级高于其他几个</li></ul><p><img src="/matlab/matlab%5Cmath0.png"></p><pre><code class="hljs matlab"><span class="hljs-built_in">cos</span>(((<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span>+<span class="hljs-number">4</span>)^<span class="hljs-number">3</span>/<span class="hljs-number">5</span>)^<span class="hljs-number">0.5</span>)</code></pre><p><img src="/matlab/matlab%5Cmath1.png"></p><pre><code class="hljs matlab"><span class="hljs-built_in">sin</span>(<span class="hljs-built_in">pi</span>^<span class="hljs-number">0.5</span>) + <span class="hljs-built_in">log</span>(<span class="hljs-built_in">tan</span>(<span class="hljs-number">1</span>))</code></pre><blockquote><p><strong>log函数</strong></p><p>log 以10为底的函数：lg</p><p>log 以e为底的函数：ln</p><p>在matlab中以以e为底的对数以log函数表示，以10为底的对数用log10表示</p></blockquote><h2 id="embedding-function"><a href="#embedding-function" class="headerlink" title="embedding function"></a>embedding function</h2><pre><code class="hljs matlab"><span class="hljs-built_in">sin</span>(<span class="hljs-built_in">cos</span>(<span class="hljs-built_in">pi</span>))||<span class="hljs-built_in">cos</span>(<span class="hljs-built_in">pi</span>)<span class="hljs-built_in">sin</span>(<span class="hljs-built_in">ans</span>)<span class="hljs-comment">% 当程序比较复杂的时候将其中一部分的结果暂时放到variable(ans)中</span></code></pre><h2 id="变量-variable"><a href="#变量-variable" class="headerlink" title="变量 variable"></a>变量 variable</h2><p>matlab中变量不需要指定类型</p><pre><code class="hljs matlab">变量名 = 数值a = <span class="hljs-number">10</span><span class="hljs-string">&#x27;=&#x27;</span>是assignment operator，是将<span class="hljs-number">10</span>指定给a这个变量</code></pre><ul><li>变量区分大小写</li><li>变量不能使用数字开头</li></ul><blockquote><p>命令行输入 who 可以查看当前的变量有哪些</p><p>输入 whos 可以查看当前的变量大小、类型等详细信息</p><p>一般默认的类型是double，8字节</p></blockquote><h2 id="特殊变量和关键字"><a href="#特殊变量和关键字" class="headerlink" title="特殊变量和关键字"></a>特殊变量和关键字</h2><ul><li><p>常量 e</p><p>matlab中使用 <code>exp(1)</code> 来表示</p></li><li><p>ans</p></li><li><p>i , j  复数</p></li><li><p>Inf  无限大</p></li><li><p>eps  很小很小的数</p></li><li><p>NaN  ：not a number。例如：x = Inf / Inf</p></li><li><p>pi </p></li></ul><h2 id="matlab-数据类型"><a href="#matlab-数据类型" class="headerlink" title="matlab 数据类型"></a>matlab 数据类型</h2><p><img src="/matlab/datatype.jpg"></p><h2 id="matlab-Calling-Priority"><a href="#matlab-Calling-Priority" class="headerlink" title="matlab Calling Priority"></a>matlab Calling Priority</h2><p>variable(高)</p><p>Built-in function</p><p>Subfunction</p><p>Private function(低)</p><p>当拿一个函数的名称作为变量名称时，会优先使用变量</p><h2 id="display-format"><a href="#display-format" class="headerlink" title="display format"></a>display format</h2><p>在命令行输入 <code>format  long</code> 类似的改变显示格式</p><ul><li>rat 表示分数计算</li></ul><p><img src="/matlab/displayformat.jpg"></p><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><ul><li>分号 表示不会把计算结果显示出来</li><li>clc : 清除命令行</li><li>clear : 清除workspace的变量</li><li>who : 查看在workspace的变量</li><li>whos : 查看在workspace的变量信息</li><li>iskeyword : 打印关键字</li><li>format + 格式 : 改变显示格式</li></ul><hr><h2 id="矩阵和向量-Array-Vector-and-Matrix"><a href="#矩阵和向量-Array-Vector-and-Matrix" class="headerlink" title="矩阵和向量 Array(Vector  and Matrix)"></a>矩阵和向量 Array(Vector  and Matrix)</h2><p>行向量：</p><pre><code class="hljs matlab">a = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]</code></pre><p>列向量</p><pre><code class="hljs matlab">b = [<span class="hljs-number">1</span>; <span class="hljs-number">2</span>; <span class="hljs-number">3</span>; <span class="hljs-number">4</span>]</code></pre><p>乘积</p><pre><code class="hljs matlab">a * b = <span class="hljs-number">30</span>b * a =  <span class="hljs-number">1</span>     <span class="hljs-number">2</span>     <span class="hljs-number">3</span>     <span class="hljs-number">4</span>     <span class="hljs-number">2</span>     <span class="hljs-number">4</span>     <span class="hljs-number">6</span>     <span class="hljs-number">8</span>     <span class="hljs-number">3</span>     <span class="hljs-number">6</span>     <span class="hljs-number">9</span>    <span class="hljs-number">12</span>     <span class="hljs-number">4</span>     <span class="hljs-number">8</span>    <span class="hljs-number">12</span>    <span class="hljs-number">16</span></code></pre><p>输入矩阵： 空格隔开列，分号分隔行</p><pre><code class="hljs matlab">&gt;&gt; A = [<span class="hljs-number">1</span> <span class="hljs-number">21</span> <span class="hljs-number">6</span>; <span class="hljs-number">5</span> <span class="hljs-number">17</span> <span class="hljs-number">9</span>; <span class="hljs-number">31</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span>]A =     <span class="hljs-number">1</span>    <span class="hljs-number">21</span>     <span class="hljs-number">6</span>     <span class="hljs-number">5</span>    <span class="hljs-number">17</span>     <span class="hljs-number">9</span>    <span class="hljs-number">31</span>     <span class="hljs-number">2</span>     <span class="hljs-number">7</span></code></pre><h3 id="Array-index"><a href="#Array-index" class="headerlink" title="Array index"></a>Array index</h3><p>取出上述矩阵A的特定位置的元素</p><p>matlab下标从1开始</p><ul><li>A(1,2) ——取出矩阵坐标为(1,2)位置的元素。第一行，第二列</li><li>A(4) ——从第一列数起对应的index值</li><li>A([1 3 5]) —— 取出第1、3、5个元素的值</li><li>A([1 3; 1 3])  ——取出第1、3个元素构成一个矩阵</li><li>A([1 3] , [1 3]) ——前面代表第1、3行，后面代表第1、3列，取出他们构成的交集，然后组成一个矩阵</li></ul><h3 id="矩阵值替换"><a href="#矩阵值替换" class="headerlink" title="矩阵值替换"></a>矩阵值替换</h3><pre><code class="hljs apache"><span class="hljs-attribute">A</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>) = <span class="hljs-number">31</span></code></pre><h3 id="Colon-Operator"><a href="#Colon-Operator" class="headerlink" title="Colon Operator"></a>Colon Operator</h3><p>创建等差数列</p><pre><code class="hljs matlab"><span class="hljs-comment">%创建从1到100的等差数列</span>A = [<span class="hljs-number">1</span>:<span class="hljs-number">100</span>]<span class="hljs-comment">%或者 A = 1:100</span><span class="hljs-comment">%创建1，3，5，……，99</span>A = [<span class="hljs-number">1</span>:<span class="hljs-number">2</span>:<span class="hljs-number">99</span>]<span class="hljs-comment">%可以创建矩阵</span>B = [<span class="hljs-number">1</span>:<span class="hljs-number">5</span>; <span class="hljs-number">2</span>:<span class="hljs-number">3</span>:<span class="hljs-number">15</span>; <span class="hljs-number">-2</span>:<span class="hljs-number">0.5</span>:<span class="hljs-number">0</span>]<span class="hljs-comment">%可以和字符联合使用</span>strs = <span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">2</span>:<span class="hljs-string">&#x27;z&#x27;</span><span class="hljs-comment">% acegikmoqsuwy</span></code></pre><p>当然，当Colon Operator前后都无参数时表示这个矩阵<strong>全部的值</strong>。</p><h3 id="删除行或者列"><a href="#删除行或者列" class="headerlink" title="删除行或者列"></a>删除行或者列</h3><pre><code class="hljs matlab"><span class="hljs-comment">%删除A的第二行</span>A(<span class="hljs-number">2</span>,:) = []<span class="hljs-comment">%删除A的第二列</span>A(:,<span class="hljs-number">2</span>) = []</code></pre><h3 id="增广矩阵"><a href="#增广矩阵" class="headerlink" title="增广矩阵"></a>增广矩阵</h3><pre><code class="hljs matlab">a = [<span class="hljs-number">1</span> <span class="hljs-number">2</span>;<span class="hljs-number">3</span> <span class="hljs-number">4</span>];b = [<span class="hljs-number">9</span> <span class="hljs-number">8</span>;<span class="hljs-number">7</span> <span class="hljs-number">6</span>];c = [a b]c =     <span class="hljs-number">1</span>     <span class="hljs-number">2</span>     <span class="hljs-number">9</span>     <span class="hljs-number">8</span>     <span class="hljs-number">3</span>     <span class="hljs-number">4</span>     <span class="hljs-number">7</span>     <span class="hljs-number">6</span>     d = [a;b]d =     <span class="hljs-number">1</span>     <span class="hljs-number">2</span>     <span class="hljs-number">3</span>     <span class="hljs-number">4</span>     <span class="hljs-number">9</span>     <span class="hljs-number">8</span>     <span class="hljs-number">7</span>     <span class="hljs-number">6</span></code></pre><h3 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h3><pre><code class="hljs gherkin">+ |<span class="hljs-string"> - </span>|<span class="hljs-string"> * </span>|<span class="hljs-string"> / </span>|<span class="hljs-string"> ^ </span>|<span class="hljs-string"> .   </span>|<span class="hljs-string"> ‘ </span>|加 |<span class="hljs-string">减 </span>|<span class="hljs-string">乘 </span>|<span class="hljs-string">除 </span>|<span class="hljs-string">乘方</span>|<span class="hljs-string">每一项</span>|<span class="hljs-string">转置</span>|</code></pre><pre><code class="hljs matlab"><span class="hljs-comment">%.* -- 点乘，表示矩阵A的每一项乘以矩阵B相对应的每一项</span><span class="hljs-comment">%同理./也是同一个意思</span>a = [<span class="hljs-number">1</span> <span class="hljs-number">2</span>;<span class="hljs-number">3</span> <span class="hljs-number">4</span>];b = [<span class="hljs-number">9</span> <span class="hljs-number">8</span>;<span class="hljs-number">7</span> <span class="hljs-number">6</span>];a.*b = <span class="hljs-number">9</span>    <span class="hljs-number">16</span>    <span class="hljs-number">21</span>    <span class="hljs-number">24</span>    a./b -- a做被除数a.\b -- a做除数</code></pre><h3 id="矩阵与实数做运算"><a href="#矩阵与实数做运算" class="headerlink" title="矩阵与实数做运算"></a>矩阵与实数做运算</h3><pre><code class="hljs livecodeserver">A <span class="hljs-comment">-- 表示矩阵， a -- 表示实数</span>A + <span class="hljs-keyword">a</span> <span class="hljs-comment">-- 矩阵的每一项都加上a</span>A / <span class="hljs-keyword">a</span> 同理A ./ <span class="hljs-keyword">a</span>与A / <span class="hljs-keyword">a</span>结果一样A ^ <span class="hljs-keyword">a</span> <span class="hljs-comment">-- 表示a个A矩阵相乘</span>A .^ <span class="hljs-keyword">a</span> <span class="hljs-comment">-- 表示A矩阵内的每一项都是a的乘方</span></code></pre><h3 id="特殊的矩阵"><a href="#特殊的矩阵" class="headerlink" title="特殊的矩阵"></a>特殊的矩阵</h3><pre><code class="hljs matlab"><span class="hljs-built_in">eye</span>(n) -- 创建n*n identity matrix<span class="hljs-built_in">zeros</span>(n1,n2) -- 创建n1*n2的值全为<span class="hljs-number">0</span>的矩阵<span class="hljs-built_in">ones</span>(n1,n2) -- 创建n1*n2的值全为<span class="hljs-number">1</span>的矩阵<span class="hljs-built_in">diag</span>() -- 创建对角线矩阵<span class="hljs-built_in">diag</span>([<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>])<span class="hljs-built_in">ans</span> =     <span class="hljs-number">2</span>     <span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">3</span>     <span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">4</span></code></pre><h3 id="矩阵的一些函数"><a href="#矩阵的一些函数" class="headerlink" title="矩阵的一些函数"></a>矩阵的一些函数</h3><pre><code class="hljs matlab">A是一个矩阵<span class="hljs-built_in">max</span>(A) -- 得到每一列最大的数<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(A)) -- 得到这个矩阵最大的数<span class="hljs-built_in">min</span>() --同理sum(A) -- 得到每一列的和sum(sum(A)) -- 得到矩阵所有数值的和<span class="hljs-built_in">mean</span>(A) -- 得到整个列的平均值<span class="hljs-built_in">sort</span>(A) -- 对矩阵的每一列按照从小到大进行排序<span class="hljs-built_in">sortrows</span>(A) -- 对矩阵的行按照每行的第一个值从小到大进行排序<span class="hljs-built_in">size</span>(A) -- 获取矩阵的行列数<span class="hljs-built_in">length</span>(A) -- 指获取向量的长度<span class="hljs-built_in">find</span>(A==<span class="hljs-number">5</span>) -- 找到矩阵中值为<span class="hljs-number">5</span>的那个元素的index</code></pre><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><pre><code class="hljs matlab"><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-number">10</span>    x=<span class="hljs-built_in">linspace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">101</span>);    <span class="hljs-built_in">plot</span>(x,<span class="hljs-built_in">sin</span>(x+<span class="hljs-built_in">i</span>));    print(gcf,<span class="hljs-string">&#x27;-deps&#x27;</span>,strcat(<span class="hljs-string">&#x27;plot&#x27;</span>,num2str(<span class="hljs-built_in">i</span>),<span class="hljs-string">&#x27;.ps&#x27;</span>));<span class="hljs-keyword">end</span></code></pre><p>当给一段程序的前面加上 <code>%%</code>  的符号的时候，就是把程序分成<code>section</code>，可以单独执行。</p><h3 id="scripts-–-指令"><a href="#scripts-–-指令" class="headerlink" title="scripts – 指令"></a>scripts – 指令</h3><p>程序内的后面加上分号;就不会把结果显示在命令行里。</p><pre><code class="hljs matlab"><span class="hljs-keyword">if</span>,<span class="hljs-keyword">elseif</span>,<span class="hljs-keyword">else</span><span class="hljs-keyword">for</span><span class="hljs-keyword">switch</span>,<span class="hljs-keyword">case</span><span class="hljs-keyword">while</span><span class="hljs-keyword">break</span>continune<span class="hljs-keyword">end</span>pause<span class="hljs-keyword">return</span></code></pre><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>如果一行内容过多可以使用三个点隔开，表示换行。</p><pre><code class="hljs matlab">a = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>;...    <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span>]</code></pre><h3 id="逻辑判别式"><a href="#逻辑判别式" class="headerlink" title="逻辑判别式"></a>逻辑判别式</h3><p>boolean: 1为true，0为false。</p><pre><code class="hljs matlab">~= 不等于== 等于<span class="hljs-comment">%其余与C++的相同</span></code></pre><p><img src="/matlab/operator.jpg"></p><h3 id="if…elseif…else"><a href="#if…elseif…else" class="headerlink" title="if…elseif…else"></a>if…elseif…else</h3><pre><code class="hljs matlab">a = <span class="hljs-number">3</span>;<span class="hljs-keyword">if</span> <span class="hljs-built_in">rem</span>(a,<span class="hljs-number">2</span>) == <span class="hljs-number">0</span> <span class="hljs-comment">%求余数</span>    <span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;a is even&#x27;</span>)<span class="hljs-keyword">else</span>    <span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;a is odd&#x27;</span>) <span class="hljs-comment">%奇数</span><span class="hljs-keyword">end</span></code></pre><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><pre><code class="hljs matlab">input_num = <span class="hljs-number">1</span>;<span class="hljs-keyword">switch</span> input_num    <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>        <span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;negative 1&#x27;</span>);    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>         <span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;zero&#x27;</span>);    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>        <span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;positive 1&#x27;</span>);    <span class="hljs-keyword">otherwise</span>        <span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;other value&#x27;</span>);<span class="hljs-keyword">end</span></code></pre><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><pre><code class="hljs matlab">n = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> prod(<span class="hljs-number">1</span>:n) &lt; <span class="hljs-number">1e100</span><span class="hljs-comment">% 1:n 会形成一个[1,2,...,n]的向量，而prod则是会将这些向量连乘起来</span><span class="hljs-comment">% 1e100 是指 1乘以10的100次方</span>    n = n + <span class="hljs-number">1</span>;<span class="hljs-keyword">end</span></code></pre><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><pre><code class="hljs matlab"><span class="hljs-keyword">for</span> variable=start:increment:<span class="hljs-keyword">end</span>commands<span class="hljs-keyword">end</span><span class="hljs-comment">%%%%%%%%%%</span><span class="hljs-keyword">for</span> n=<span class="hljs-number">1</span>:<span class="hljs-number">10</span>    a(n) = <span class="hljs-number">2</span>^n;<span class="hljs-comment">%a是一个列向量</span><span class="hljs-keyword">end</span><span class="hljs-built_in">disp</span>(a)<span class="hljs-comment">%%%%%%%%%%%%%</span>ticA = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">2000</span>,<span class="hljs-number">2000</span>);<span class="hljs-keyword">for</span> ii = <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(A,<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> jj = <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(A,<span class="hljs-number">2</span>)        A(ii,jj) = ii+jj;    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>toc<span class="hljs-comment">% 可以获得--&gt;时间已过 0.052879 秒。</span><span class="hljs-comment">% 通过 tic toc</span></code></pre><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>跳出循环</p><pre><code class="hljs matlab">x = <span class="hljs-number">2</span>;k = <span class="hljs-number">0</span>;error = <span class="hljs-built_in">inf</span>;error_threshold = <span class="hljs-number">1e-32</span>;<span class="hljs-keyword">while</span> error &gt; error_threshold     <span class="hljs-keyword">if</span> k &gt; <span class="hljs-number">100</span>        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">end</span>    x = x - <span class="hljs-built_in">sin</span>(x)/<span class="hljs-built_in">cos</span>(x);    error = <span class="hljs-built_in">abs</span>(x - <span class="hljs-built_in">pi</span>);    k = k+<span class="hljs-number">1</span>;<span class="hljs-keyword">end</span></code></pre><h2 id="function-–-函数"><a href="#function-–-函数" class="headerlink" title="function – 函数"></a>function – 函数</h2><pre><code class="hljs matlab">edit (which(<span class="hljs-string">&#x27;mean.m&#x27;</span>))<span class="hljs-comment">%就可以查看mean.m这个函数的实现</span></code></pre><h3 id="函数格式"><a href="#函数格式" class="headerlink" title="函数格式"></a>函数格式</h3><pre><code class="hljs livecodeserver"><span class="hljs-function"><span class="hljs-keyword">function</span> 输出结果 = 函数名（输入）</span>如果输出结果有多个值可以使用[<span class="hljs-keyword">a</span> F]这种形式</code></pre><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span> = <span class="hljs-title">freebody</span><span class="hljs-params">(x0,v0,t)</span></span><span class="hljs-comment">%</span>x = x0 + v0.*t + <span class="hljs-number">1</span>/<span class="hljs-number">2</span>*<span class="hljs-number">9.8</span>*t.*t;<span class="hljs-comment">%注意是.*的形式，也就意味着可以传入向量。</span><span class="hljs-comment">%%%%%%</span>freebody(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)<span class="hljs-built_in">ans</span> =   <span class="hljs-number">490</span>  freebody([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">20</span>])<span class="hljs-built_in">ans</span> =         <span class="hljs-number">490</span>        <span class="hljs-number">1981</span></code></pre><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span> = <span class="hljs-title">F2C</span><span class="hljs-params">()</span></span><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>    TinF = input(<span class="hljs-string">&#x27;pleasr input a temperature in F:&#x27;</span>);    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isempty</span>(TinF)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">end</span>    y = <span class="hljs-number">5</span>*(TinF<span class="hljs-number">-32</span>)/<span class="hljs-number">9</span>;    fprintf(<span class="hljs-string">&#x27;==&gt;Tem in C = %f\n&#x27;</span>,y);<span class="hljs-keyword">end</span></code></pre><h3 id="function-handle"><a href="#function-handle" class="headerlink" title="function handle"></a>function handle</h3><pre><code class="hljs matlab">f = @(x) <span class="hljs-built_in">exp</span>(<span class="hljs-number">-2</span>*x);x = <span class="hljs-number">0</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">2</span>;<span class="hljs-built_in">plot</span>(x,f(x));</code></pre><h2 id="方程式求根"><a href="#方程式求根" class="headerlink" title="方程式求根"></a>方程式求根</h2><h3 id="symbolic-variable"><a href="#symbolic-variable" class="headerlink" title="symbolic variable"></a>symbolic variable</h3><p>创建symbolic variable的方式有两种：<code>sym</code>或者<code>syms</code></p><pre><code class="hljs matlab">syms x<span class="hljs-comment">%或者</span>x=sym(<span class="hljs-string">&#x27;x&#x27;</span>)x+x+x = <span class="hljs-number">3</span>*x</code></pre><h3 id="solve-函数求解"><a href="#solve-函数求解" class="headerlink" title="solve()函数求解"></a>solve()函数求解</h3><p>例：<code>y = x * sin(x) - x = 0</code></p><pre><code class="hljs matlab">syms xsolve(<span class="hljs-string">&#x27;x*sin(x) - x&#x27;</span>,x)</code></pre><h3 id="解多元方程"><a href="#解多元方程" class="headerlink" title="解多元方程"></a>解多元方程</h3><pre><code class="hljs matlab">&gt;&gt; syms x y&gt;&gt; eq1 = x <span class="hljs-number">-2</span>*y <span class="hljs-number">-5</span>;&gt;&gt; eq2 = x + y <span class="hljs-number">-6</span>;&gt;&gt; A = solve(eq1,eq2,x,y)&gt;&gt; A =     x: [<span class="hljs-number">1</span>x1 sym]    y: [<span class="hljs-number">1</span>x1 sym]&gt;&gt; A.x <span class="hljs-built_in">ans</span> = <span class="hljs-number">17</span>/<span class="hljs-number">3</span> &gt;&gt; A.y <span class="hljs-built_in">ans</span> = <span class="hljs-number">1</span>/<span class="hljs-number">3</span></code></pre><h3 id="多个未知数"><a href="#多个未知数" class="headerlink" title="多个未知数"></a>多个未知数</h3><pre><code class="hljs matlab"><span class="hljs-comment">% ax^2 - b = 0</span>syms x a bsolve(<span class="hljs-string">&#x27;ax^2 - b&#x27;</span>)<span class="hljs-built_in">ans</span> =   b^(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>)/a^(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>) -b^(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>)/a^(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>) <span class="hljs-comment">%%%%%%%%%%</span><span class="hljs-comment">%如果想要把b作为未知数求解的话</span>solve(<span class="hljs-string">&#x27;ax^2 - b&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-built_in">ans</span> = a*z^<span class="hljs-number">2</span></code></pre><h2 id="其他参考连接"><a href="#其他参考连接" class="headerlink" title="其他参考连接"></a>其他参考连接</h2><p><a href="https://blog.csdn.net/limin_yu/article/details/80256051">matlab线性规划</a></p><p><a href="https://blog.csdn.net/qq_42764468/article/details/87866348">matlab绘制曲线相交的交点</a></p><h2 id="历年国赛"><a href="#历年国赛" class="headerlink" title="历年国赛"></a>历年国赛</h2><p><img src="/matlab/all.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Matlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络——第四章 网络层</title>
    <link href="/network-chapter-4/"/>
    <url>/network-chapter-4/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：计算机网络中网络层的基本概念以及应用.</p><a id="more"></a><blockquote><p>参照书籍：</p><p><strong>《计算机网络(第七版)》——谢希仁编著</strong></p><p><strong>《图解TCP/IP》第五版</strong></p></blockquote><h2 id="网络层的服务"><a href="#网络层的服务" class="headerlink" title="网络层的服务"></a>网络层的服务</h2><p>网络层向上（如传输层或调用IP协议的协议）只提供<strong>简单灵活</strong>的、<strong>无连接</strong>的、<strong>尽最大努力交付</strong>的数据报服务。</p><p>网络在发送分组时不需要事先建立连接。每一个分组（即 IP 数据报）均独立发送，与其前后的分组无关。</p><p>网络层不提供服务质量的承诺。即所传送的分组可能会出现出错、丢失、重复和失序（不按序到达终点）等问题，同时也不保证分组传送的时限。 </p><h3 id="尽最大努力交付的好处？"><a href="#尽最大努力交付的好处？" class="headerlink" title="尽最大努力交付的好处？"></a>尽最大努力交付的好处？</h3><p>由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且<strong>价格低廉</strong></p><p>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制等）。</p><p>采用这种设计思路的好处是：<strong>网络的造价大大降低，运行方式灵活，能够适应多种应用</strong>。</p><h2 id="虚拟互连网络"><a href="#虚拟互连网络" class="headerlink" title="虚拟互连网络"></a>虚拟互连网络</h2><p>存在着各种各样的性能各异的异构的物理网络。</p><p>但是我们利用 IP 协议就可以使这些性能各异的网络从用户看起来好像是一个统一的网络。</p><p>使用 IP 协议的虚拟互连网络可简称为 IP 网。</p><p>使用虚拟互连网络的好处是：<strong>当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节</strong>。</p><p>只从网络层考虑问题，那么IP数据报就可以想象是在网络层中传送。</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>我们把整个因特网看成为一个单一的、抽象的网络。IP 地址就是给每个连接在因特网上的主机（或路由器）分配一个在全世界范围是<strong>唯一</strong>的 <strong>32 位</strong>的标识符。</p><p>这是<strong>IPv4</strong>的地址，一共有32位。</p><h3 id="IP-地址的编址方法-有三类"><a href="#IP-地址的编址方法-有三类" class="headerlink" title="IP 地址的编址方法 (有三类)"></a>IP 地址的编址方法 (有三类)</h3><ul><li>分类的IP地址</li><li>子网的划分</li><li>构成超网</li></ul><h3 id="IPv4地址的表示方法"><a href="#IPv4地址的表示方法" class="headerlink" title="IPv4地址的表示方法"></a>IPv4地址的表示方法</h3><p>采用<strong>点分十进制</strong></p><p>每八位二进制位转换成一个十进制数，使用点分隔开。</p><h3 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h3><p>   <code>IP 地址 ::= &#123; &lt;网络号&gt;, &lt;主机号&gt;&#125;</code> </p><p>网络号：标志主机（或路由器）连接到的网络</p><p>主机号：标志该主机或者路由器</p><p><img src="/network-chapter-4/classnet.png"></p><h3 id="分类IP地址的好处"><a href="#分类IP地址的好处" class="headerlink" title="分类IP地址的好处"></a>分类IP地址的好处</h3><ol><li>IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。</li><li>路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间</li></ol><h3 id="IP地址与硬件地址"><a href="#IP地址与硬件地址" class="headerlink" title="IP地址与硬件地址"></a>IP地址与硬件地址</h3><p><img src="/network-chapter-4/ipandmac.png"></p><p>在具体的物理链路层中，IP数据报被封装成了MAC帧，看不见IP地址，传播是通过MAC地址进行的。</p><p>故IP层抽象的互联网<strong>屏蔽了下层很复杂的细节</strong>在抽象的网络层上讨论问题，就能够使用统一的、抽象的 IP 地址研究主机和主机或主机和路由器之间的通信 。</p><h3 id="地址解析协议-ARP-——-IP地址如何转换为MAC地址"><a href="#地址解析协议-ARP-——-IP地址如何转换为MAC地址" class="headerlink" title="地址解析协议 ARP  ——  IP地址如何转换为MAC地址"></a>地址解析协议 ARP  ——  IP地址如何转换为MAC地址</h3><p><strong>不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。</strong> </p><p>每一个主机都设有一个 <strong>ARP 高速缓存</strong>(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</p><p>当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。如没有， 则广播查询。</p><h3 id="为什么不直接使用硬件地址进行通信？"><a href="#为什么不直接使用硬件地址进行通信？" class="headerlink" title="为什么不直接使用硬件地址进行通信？"></a>为什么不直接使用硬件地址进行通信？</h3><p>由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行<strong>非常复杂</strong>的硬件地址转换工作，因此几乎是不可能的事。</p><p>连接到因特网的主机都拥有统一的 IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为调用 ARP 来寻找某个路由器或主机的硬件地址都是由<strong>计算机软件自动进行</strong>的，对用户来说是看不见这种调用过程的。  </p><h2 id="IPv4数据报格式"><a href="#IPv4数据报格式" class="headerlink" title="IPv4数据报格式"></a>IPv4数据报格式</h2><p><img src="/network-chapter-4/ipv4format.png"></p><ul><li><strong>版本</strong>： 4位，指明IP协议的版本。</li><li><strong>首部长度</strong>：4位，单位为4B(字节)，指明整个IP数据报的首部的长度。<ul><li>首部长度 * 4B = IP数据报的首部的长度。</li><li>故IP数据报的首部的长度一定是4B的整数倍，不足要使用填充字段。</li><li>这里首部长度的最小值为5，因为IP数据报首部的固定部分的长度为20字节</li></ul></li><li><strong>区分服务</strong>：8位，一般不使用。</li><li><strong>总长度</strong>：16位，单位为1B，只整个IP数据报的长度(首部+数据部分)<ul><li>总长度不能超过数据链路层的MTU(以太网的MTU是1500字节)</li></ul></li><li><strong>标识</strong>：16位，同一数据报的分片使用同一个标识。</li><li><strong>标志</strong>：3位，目前只有后两位有意义。<ul><li>DF ：0允许分片，1禁止分片</li><li>MF ：1代表后面还有分片，0代表分片的</li></ul></li><li>片偏移：13位，单位为8B，表明较长的分组在分片后某片在原分组中的<strong>相对位置</strong>。<ul><li>说明除了最后一个分片外，其余分片长度一定是8B的整数倍。</li></ul></li><li><strong>生存时间</strong>：8位，TTL，IP分组在网络中的寿命，防止数据报无限制的在网络之中传播，消耗资源</li><li><strong>协议</strong>：8位，指明数据部分使用的协议，协议字段指出应将数据部分交给哪一个进程</li><li><strong>首部检验和</strong>：16位，只检验数据报的首部，不检验数据部分。</li><li><strong>选项字段</strong>：1~40字节，用来支持排错、测量以及安全等措施，但很少被使用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络——第三章 数据链路层</title>
    <link href="/network-chapter-3/"/>
    <url>/network-chapter-3/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：计算机网络数据链路层的两个基本概念(数据链路和帧)，三个基本问题，两种信道通信方式，以及对应的协议PPP或者CSMA/CD，以及以太网。</p><a id="more"></a><blockquote><p>参照书籍：</p><p><strong>《计算机网络(第七版)》——谢希仁编著</strong></p><p><strong>《图解TCP/IP》第五版</strong></p></blockquote><hr><h2 id="数据链路层的基本概念"><a href="#数据链路层的基本概念" class="headerlink" title="数据链路层的基本概念"></a>数据链路层的基本概念</h2><p><strong>链路</strong>：链路(link)是一个结点到相邻结点的物理线路段(有线或者无线)，中间没有任何其他的交换结点。</p><p>而<strong>数据链路</strong>(data link)是在链路的基础上增加了一些必要的<strong>硬件</strong>(如网络适配器)和<strong>软件</strong>(通信协议的实现)。</p><p>数据链路层的协议数据单位是<strong>帧</strong>。</p><p><strong>数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收的帧中的数据取出并上交给网络层。</strong></p><p><img src="/network-chapter-3/zhen.png"></p><h2 id="数据链路层的三个基本问题"><a href="#数据链路层的三个基本问题" class="headerlink" title="数据链路层的三个基本问题"></a>数据链路层的三个基本问题</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。</p><p>首部和尾部的一个重要作用就是进行<strong>帧定界</strong>。 </p><p><img src="/network-chapter-3/zhen1.png"></p><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>当帧里含有SOH或者EOT这种控制字符的二进制码时，数据链路层会错误的找到帧的边界，而导致数据读取丢失等问题。</p><p>而所谓透明传输是指无论什么样组合的比特数据都可以<strong>按照原样没有差错</strong>的通过数据链路层。</p><p>解决方法——字节填充(byte stuffing)或字符填充(character stuffing)：</p><p>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个<strong>转义字符</strong>“ESC”(其十六进制编码是 1B)。</p><p>接收端的数据链路层在将数据送往网络层之前<strong>删除</strong>插入的转义字符。</p><p>如果转义字符也出现数据当中，那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个。</p><p><img src="/network-chapter-3/esc.png"></p><h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>在传输过程中可能会产生<strong>比特差错</strong>：1 可能会变成 0 而 0 也可能变成 1。</p><p>在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率</strong> BER (Bit Error Rate)。</p><p>在数据链路层传送的帧中，广泛使用了<strong>循环冗余检验 CRC</strong> 的检错技术。</p><blockquote><p>在发送端，先把数据划分为组。假定每组 k 个比特。 </p><p>假设待传送的一组数据 M = 101001（现在 k = 6）。我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送。</p><p>在数据后面添加上的冗余码称为<strong>帧检验序列 FCS</strong> (Frame Check Sequence)。</p><p>仅用循环冗余检验 CRC 差错检测技术只能做到<strong>无差错接受</strong>(accept)——<strong>凡是接收端数据链路层接受的帧都没有传输差错（有差错的帧就丢弃而不接受）</strong></p></blockquote><h2 id="两种信道"><a href="#两种信道" class="headerlink" title="两种信道"></a>两种信道</h2><p>数据链路层使用的信道主要有以下两种类型：</p><ul><li><strong>点对点信道</strong>。这种信道使用<strong>一对一的点对点通信</strong>方式。</li><li><strong>广播信道</strong>。这种信道使用<strong>一对多的广播通信</strong>方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。 </li></ul><h2 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h2><blockquote><p>现在全世界使用得最多的数据链路层协议是点对点协议 PPP (Point-to-Point Protocol)。</p><p>用户使用拨号电话线接入因特网时，一般都是使用 PPP 协议。  </p></blockquote><h2 id="局域网-–-使用广播信道的数据链路层"><a href="#局域网-–-使用广播信道的数据链路层" class="headerlink" title="局域网 – 使用广播信道的数据链路层"></a>局域网 – 使用广播信道的数据链路层</h2><h3 id="局域网的优点"><a href="#局域网的优点" class="headerlink" title="局域网的优点"></a>局域网的优点</h3><ul><li>具有<strong>广播功能</strong>，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和残存性。</li></ul><h3 id="共享信道技术"><a href="#共享信道技术" class="headerlink" title="共享信道技术"></a>共享信道技术</h3><p><img src="/network-chapter-3/sharechannel.png"></p><p>静态划分信道<strong>代价高</strong>，不适用于局域网。</p><p>动态媒体接入控制也叫做<strong>多点接入</strong>，特点是：信道并非在用户通信时固定分配给用户。</p><p><strong>随机接入</strong>：所有的用户可随机发送信息，但如果多个用户同时发送消息就会产生冲突导致失败。而<strong>以太网</strong>就是属于随机接入。</p><h3 id="适配器-–-计算机连接到局域网"><a href="#适配器-–-计算机连接到局域网" class="headerlink" title="适配器 – 计算机连接到局域网"></a>适配器 – 计算机连接到局域网</h3><p>计算机通过适配器和局域网进行通信 </p><p><img src="/network-chapter-3/communication.png"></p><p>网络接口板又称为<strong>通信适配器</strong>(adapter)或网络接口卡 <strong>NIC</strong> (Network Interface Card)，或“<strong>网卡</strong>”。 </p><p><strong>适配器的重要功能</strong>：</p><ul><li>进行串行/并行转换。</li><li>对数据进行缓存。</li><li>在计算机的操作系统安装设备驱动程序。</li><li>实现以太网协议。 </li></ul><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><h3 id="在局域网的总线上实现一对一通信"><a href="#在局域网的总线上实现一对一通信" class="headerlink" title="在局域网的总线上实现一对一通信"></a>在局域网的总线上实现一对一通信</h3><p>最初的以太网是将许多计算机都连接到一根总线上。</p><blockquote><p>总线连接的局域网内B向D发送数据，实现一对一通信。</p><p>总线上的每一个工作的计算机都能检测到 B 发送的数据信号。<br>由于只有计算机 D 的地址与数据帧首部写入的地址一致，因此只有 D 才接收这个数据帧。<br>其他所有的计算机（A, C 和 E）都检测到不是发送给它们的数据帧，因此就丢弃这个数据帧而不能够收下来。</p></blockquote><h3 id="以太网的两个重要措施"><a href="#以太网的两个重要措施" class="headerlink" title="以太网的两个重要措施"></a>以太网的两个重要措施</h3><ul><li>采用较为灵活的<strong>无连接</strong>的工作方式，即不必先建立连接就可以直接发送数据。 </li><li>以太网发送的数据都使用<strong>曼彻斯特编码</strong>(Manchester) </li></ul><p><strong>无连接的工作方式</strong>：以太网对发送的数据帧不进行编号，也不要求对方发回确认。所以以太网提供的服务是<strong>不可靠的交付</strong>，即尽最大努力的交付。差错的纠正由高层来决定。</p><h3 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h3><p>载波监听多点接入/碰撞检测</p><ul><li><strong>多点接入</strong>：说明是<strong>总线型网络</strong>。表示许多计算机以多点接入的方式连接在一根总线上。</li><li><strong>载波监听</strong>：用电子技术检测总线上有没有其他计算机发送的数据信号。</li><li><strong>碰撞检测</strong>：<strong>边发送边监听</strong>。适配器边发送数据边检测信道上的信号电压的变化情况，以便判断自己在发送数据时其他站是否也再发送数据。如果有两个站在同时发送数据，那么信号就发生了<strong>失真</strong>，无法从中恢复出有用的信息。</li></ul><h3 id="以太网发送的不确定性"><a href="#以太网发送的不确定性" class="headerlink" title="以太网发送的不确定性"></a>以太网发送的不确定性</h3><p>即，一个以太网中，<strong>每一个站在自己发送数据之后的一段时间内，存在着遭遇碰撞的可能性</strong>。这一段时间是不确定的。</p><p><img src="/network-chapter-3/chuanboshiyan.png"></p><p>课本P87。</p><p>在发送数据帧后最多经过以太网端到端的往返时间的这一段<strong>争用期</strong>。只要经过这一段争用期而没有检测到碰撞，才能肯定这次发送不会碰撞。</p><p>以太网使用截断二进制指数退避算法来确定碰撞后<strong>重传</strong>的时机。</p><h3 id="截断二进制指数退避算法"><a href="#截断二进制指数退避算法" class="headerlink" title="截断二进制指数退避算法"></a>截断二进制指数退避算法</h3><p>todo</p><hr><h2 id="OSI参考模型中的数据链路层"><a href="#OSI参考模型中的数据链路层" class="headerlink" title="OSI参考模型中的数据链路层"></a>OSI参考模型中的数据链路层</h2><p>数据链路层负责物理层面上互连的、节点之间的通信传输。例如与1个以太网相连的2个节点之间的通信。</p><p><strong>主要功能</strong>：将0、1序列划分为具有意义的数据帧传送给对端(<strong>数据帧的生成与接受</strong>)。</p><p>数据链路层的协议定义了通过通信媒介互连的设备之间传输的规范。</p><h2 id="设备之间的数据传输"><a href="#设备之间的数据传输" class="headerlink" title="设备之间的数据传输"></a>设备之间的数据传输</h2><p><strong>各个设备之间在数据传输时，数据链路层和物理层都是必不可少的</strong>。</p><p>因为计算机用0、1表示信息，而实际的通信媒介处理的却是电压的高低、光的闪灭以及电波的强弱等信号。</p><p>物理层将这些信号与二进制的0、1进行转换。</p><p>数据链路层将0、1序列集合为”帧“，然后再进行传输。</p><h2 id="《图解TCP-IP》中的数据链路层"><a href="#《图解TCP-IP》中的数据链路层" class="headerlink" title="《图解TCP/IP》中的数据链路层"></a>《图解TCP/IP》中的数据链路层</h2><p><img src="/network-chapter-3/tcpipOSI.png"></p><p>网卡层(网络接口层)及对应的数据链路层，是利用以太网中的数据链路层进行通信的，属于接口层。可以当作让NIC(网卡)起作用的“驱动程序”。</p><blockquote><p> TCP/IP对于OSI参考模型中的数据链路层及一下部分(物理层)未做定义，因为TCP/IP以这两层的功能是透明的为前提。</p></blockquote><h2 id="数据链路层的相关技术"><a href="#数据链路层的相关技术" class="headerlink" title="数据链路层的相关技术"></a>数据链路层的相关技术</h2><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC地址用于识别数据链路中互连的节点。</p><p>MAC地址长为48比特，这是IEEE 802标准规定的全球地址，MAC地址会被固化到适配器(比如网卡)的ROM中，要求任何一个适配器的MAC地址都是唯一的，在全世界都不会有重复。</p><p><img src="/network-chapter-3/macaddress.png"></p><ul><li>除了以太网，FDDI、ATM、无线LAN、蓝牙等都使用的相同规格的MAC地址。</li></ul><h3 id="共享介质型网络"><a href="#共享介质型网络" class="headerlink" title="共享介质型网络"></a>共享介质型网络</h3><p>指多个设备共享一个通信介质的一种网络。在这种方式下，设备之间使用同一个载波信道进行发送和接受。(基本采用半双工通信)。需要对介质进行访问控制。</p><p>两种介质访问控制方式：<strong>争用方式</strong>和<strong>令牌传递方式</strong>。</p><h4 id="争用方式"><a href="#争用方式" class="headerlink" title="争用方式"></a>争用方式</h4><p>争夺获取数据传输的权力，即<strong>先到先得</strong>。也叫做CSMA(载波监听多路访问)。</p><ul><li>如果多个站同时发送帧，则会产生<strong>冲突现象</strong>，也因此会导致网络拥堵与性能下降，</li></ul><p><img src="/network-chapter-3/csma.png"></p><p>CSMA的改良版本——<strong>CSMA/CD方式</strong>(载波监听多路访问/碰撞检测)。</p><p>CSMA/CD方式会要求每个站提前检查冲突，一旦发生冲突，则尽早释放信道。</p><p><strong>CSMA/CD工作原理</strong>：</p><ul><li>如果载波信道上没有数据流动，则任何站都可以发送数据。</li><li>检查是否会发生冲突。一旦发生冲突时，放弃发送数据，同时立即释放载波通道。</li><li>放弃发送以后，随机延时一段时间，再重新争用介质，重新发送帧。</li></ul><p><img src="/network-chapter-3/CSMACD.png"></p><h4 id="令牌传递方式"><a href="#令牌传递方式" class="headerlink" title="令牌传递方式"></a>令牌传递方式</h4><p>是沿着令牌环发送一种“令牌”的特殊报文，只有获得令牌的站才能发送数据。</p><ul><li>不会有冲突</li><li>每个站都有通过平等循环获得令牌的机会。</li></ul><p><img src="/network-chapter-3/token.png"></p><h3 id="非介质共享网络"><a href="#非介质共享网络" class="headerlink" title="非介质共享网络"></a>非介质共享网络</h3><p>发送端与接收端不共享通信介质，而是直连交换机，由<strong>交换机负责转发数据帧</strong>。(采用全双工通信方式)</p><p><img src="/network-chapter-3/exchange.png"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络——第二章 物理层</title>
    <link href="/network-chapter-2/"/>
    <url>/network-chapter-2/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：计算机网络物理层的作用。</p><a id="more"></a><blockquote><p>参照书籍：</p><p><strong>《计算机网络(第七版)》——谢希仁编著</strong></p><p><strong>《图解TCP/IP》第五版</strong></p></blockquote><h2 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h2><p>物理层考虑的是<strong>怎样才能在连接各种计算机的传输媒体上传输数据比特流</strong>。</p><p>物理层的主要任务：确定与传输媒体的接口的一些特性</p><ul><li><strong>机械特性</strong>    指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。</li><li><strong>电气特性</strong>    指明在接口电缆的各条线上出现的电压的范围。</li><li><strong>功能特性</strong>    指明某条线上出现的某一电平的电压表示何种意义。</li><li><strong>过程特性</strong>    指明对于不同功能的各种可能事件的出现顺序。</li></ul><h2 id="信道-channel"><a href="#信道-channel" class="headerlink" title="信道(channel)"></a>信道(channel)</h2><p>信道一般都是用来表示向某一个方向传送信息的媒体，因此，一条信道电路往往包含一条发送信道和一条接收信道。</p><p>信道的双方信息交互方式有一下三种</p><ul><li><p>单向通信（<strong>单工通信</strong>）——只能有一个方向的通信而没有反方向的交互。</p></li><li><p>双向交替通信（<strong>半双工通信</strong>）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</p></li><li><p>双向同时通信（<strong>全双工通信</strong>）——通信的双方可以同时发送和接收信息。 </p></li></ul><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><ul><li><strong>基带信号</strong>（即基本频带信号）——来自信源的信号。像<strong>计算机输出</strong>的代表各种文字或图像文件的数据信号都属于基带信号。</li><li><strong>带通信号</strong>——把基带信号经过<strong>载波调制</strong>后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。</li></ul><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><ul><li>频分复用 FDM (Frequency Division Multiplexing) </li><li>时分复用TDM (Time Division Multiplexing) </li><li>统计时分复用 STDM (Statistic TDM)  </li><li>波分复用 WDM (Wavelength Division Multiplexing)  </li><li>码分复用 CDM (Code Division Multiplexing)  </li></ul><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><p><strong>信道的极限信息传输速率</strong>是：</p><pre><code class="hljs gcode">C = W * lo<span class="hljs-name">g2</span> <span class="hljs-comment">(1 + S/N)</span> <span class="hljs-comment">(bits/s)</span></code></pre><p>W为信道的宽度(单位Hz)，S为信道内所传信号的平均功率，N为信道内部的高斯噪声功率。</p><p>S/N为信噪比(dB)——信号的平均功率和噪声的平均功率之比</p><hr><h2 id="《图解TCP-IP》中的物理层"><a href="#《图解TCP-IP》中的物理层" class="headerlink" title="《图解TCP/IP》中的物理层"></a>《图解TCP/IP》中的物理层</h2><p><img src="/network-chapter-2/tcpipOSI.png"></p><p>TCP/IP的最底层是负责数据传输的硬件。这种硬件就相当于以太网或电话线路等物理层设备。</p><h2 id="OSI参考模型中物理层"><a href="#OSI参考模型中物理层" class="headerlink" title="OSI参考模型中物理层"></a>OSI参考模型中物理层</h2><p>–来自《图解TCP/IP》第五版，第20页。</p><p><strong>负责0、1比特流(0、1序列)与电压高低、光的闪灭之间的互换。</strong></p><p>物理层通过把上层的比特流(0、1的二进制流)转化为电压的高低、灯光的闪灭等物理信号，将数据传输出去。而接收端收到这些物理信号以后再将这些电压的高低、灯光的闪灭恢复为比特流(0、1的二进制流)。因此，物理层的规范中包括比特流转换规则、缆线结构和质量以及接口形状等。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络——第一章 概述</title>
    <link href="/network-chapter-1/"/>
    <url>/network-chapter-1/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：计算机网络概述，互联网边缘部分与核心部分、计算机网络性能指标、计算机网络体系结构。</p><a id="more"></a><blockquote><p>参照课本：<strong>《计算机网络(第七版)》——谢希仁编著</strong></p></blockquote><h2 id="互联网的两个基本特点"><a href="#互联网的两个基本特点" class="headerlink" title="互联网的两个基本特点"></a>互联网的两个基本特点</h2><ul><li>连通性：互联网使用户不管相距多远都可以非常便捷方便的交换各种信息，好像这些用户的计算机都可以彼此直接连通一样。 </li><li>共享：指资源共享：包括信息共享、软件共享甚至是硬件共享。</li></ul><h2 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h2><p><strong>计算机网络</strong>是由若干<strong>结点</strong>(node)以及连接这些结点的<strong>链路</strong>(link)组成的.</p><ul><li>结点：可以是计算机、集线器、交换机或路由器等。</li></ul><p>此外<strong>网络与网络之间</strong>还可以<strong>通过路由器连接</strong>起来，构成一个覆盖范围更大的计算机网络这就是互联网。</p><p>所以：</p><blockquote><p>网络把许多计算机连接在一起，而互联网则把许多网络通过路由器连接在一起。与网络相连的计算机常称为主机。</p></blockquote><h2 id="互联网基础结构发展的三个阶段"><a href="#互联网基础结构发展的三个阶段" class="headerlink" title="互联网基础结构发展的三个阶段"></a>互联网基础结构发展的三个阶段</h2><ul><li>第一阶段是从单个网络 ARPANET 向互联网发展的过程。</li><li>第二阶段的特点是建成了三级结构的因特网。三级计算机网络，分为主干网、地区网和校园网（或企业网）。 </li><li>第三阶段的特点是逐渐形成了多层次 ISP 结构的因特网。</li></ul><h2 id="ISP-–-互联网服务提供商"><a href="#ISP-–-互联网服务提供商" class="headerlink" title="ISP – 互联网服务提供商"></a>ISP – 互联网服务提供商</h2><p>ISP –  Internet Service Provider</p><p>ISP可以从互联网管理结构申请到很多的IP地址，同时还拥有通信线路以及路由器等联网设备。</p><p>个人或者机构向ISP缴纳费用得到IP地址的使用权，并通过ISP接入到互联网上 —— 这就是所谓的<strong>上网</strong>。</p><p>根据提供服务的覆盖面积大小以及所拥有的IP 地址数目的不同，ISP 也分成为不同的层次：主干ISP、地区ISP、本地ISP。</p><p><img src="/network-chapter-1/ISP.png"></p><p>IXP(Internet eXchange Point) – 互联网交换点</p><p>其作用是允许两个网络直接相连并交换分组，促使互联网上的数据流量分布更加合理，同时也减少了分组转发的延迟，降低了分组转发的费用。</p><h2 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h2><p><img src="/network-chapter-1/composition.png"></p><ul><li><strong>边缘部分</strong>：由所有连接在互联网上的<strong>主机</strong>构成。由用户直接使用，进行通信与资源共享。主机接入核心部分通常以相对核心部分<strong>低速率</strong>的链路相连接。</li><li><strong>核心部分</strong>：由大量网络和连接这些网络的<strong>路由器</strong>构成。为边缘部分提供服务。且路由器之间一般用<strong>高速链路</strong>相连接。</li><li><strong>主机</strong>：即为用户进行信息处理，并且还可以和其他主机通过网络交换信息。</li><li><strong>路由器</strong>：是一种专用计算机，用于<strong>转发分组</strong>。</li></ul><h3 id="互联网的边缘部分"><a href="#互联网的边缘部分" class="headerlink" title="互联网的边缘部分"></a>互联网的边缘部分</h3><p>互联网的边缘部分由连接在互联网上的所有主机构成。这些主机也叫做<strong>端(end)</strong>.</p><p>边缘部分利用核心部分提供的服务来完成<strong>计算机之间的通信</strong>。</p><h3 id="计算机之间的通信"><a href="#计算机之间的通信" class="headerlink" title="计算机之间的通信"></a>计算机之间的通信</h3><p>网络边缘部分的端系统之间的通信方式一共有两大类。</p><ul><li><p>C/S方式 – 客户–服务器方式</p></li><li><p>P2P方式 – 对等方式</p><p>此外B/S方式 – 浏览器-服务器方式是C/S的一种特例。</p></li></ul><h4 id="C-S方式"><a href="#C-S方式" class="headerlink" title="C/S方式"></a>C/S方式</h4><p>客户 client 是服务请求方，在通信时向服务器请求服务。(需要知道服务器的地址)</p><p>服务器 server 是服务提供方，等待并且接受客户的通信请求。(不需要之道客户端的地址)</p><h4 id="P2P方式"><a href="#P2P方式" class="headerlink" title="P2P方式"></a>P2P方式</h4><p>两台主机都运行对等连接软件，他们之间平等的进行通信。</p><p>P2P也可以看作C/S方式，只是每一台主机既做客户端又做服务器。</p><h3 id="互联网的核心部分"><a href="#互联网的核心部分" class="headerlink" title="互联网的核心部分"></a>互联网的核心部分</h3><p>网络的核心部分要向边缘部分的主机提供服务。</p><p><strong>通过路由器来转发分组</strong>，即分组交换的</p><h3 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h3><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>类似于使用电话通话。双方接通之后就建立了<strong>连接</strong>(一条专用的物理通道)–&gt;<strong>通话</strong>中会一直占用通信资源–&gt;<strong>释放连接</strong>之后会归还通信资源。</p><ul><li><strong>特点</strong>：在通话的全部时间之内，通话的两个用户始终占用端到端的通信资源。<strong>整个报文的比特流连续地从源头直达终点。</strong></li><li><strong>缺点</strong>：线路传输效率低，(<strong>线路上传输数据的时间非常短</strong>，通信线路的资源大部分时间都是空闲的)</li></ul><h4 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h4><p>整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</p><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p>分组交换采用<strong>存储转发</strong>技术，将一个<strong>报文</strong>(整块数据)划分为几个数据段，给每个数据段的头部添加控制信息，构成<strong>分组</strong>(packet)或者叫做<strong>包</strong>。<strong>包头</strong>(分组被添加的头部信息)内包括目的地址、源地址等重要控制信息。</p><p>路由器会把主机发来的分组暂时放入缓存(路由器的内存，速度快，保证高速率)，然后从转发表中查询，转发给其他路由器，最后传给另一台主机。</p><p>将单个分组传送到相邻结点，存储下来后查找转发表，转发到下一个结点。</p><p><img src="/network-chapter-1/fenzuyoudian.png"></p><center>分组交换的<b>优点</b></center>- **缺点**：时延问题(分组在路由器转发时需要排队)、额外开销(分组需要携带头部信息)<p><img src="/network-chapter-1/threechange.png"></p><h2 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h2><h3 id="作用范围分类"><a href="#作用范围分类" class="headerlink" title="作用范围分类"></a>作用范围分类</h3><ul><li><strong>广域网 WAN</strong>  –作用范围几十到几千公里</li><li><strong>城域网 MAN</strong>  –作用范围5-50km</li><li><strong>局域网 LAN</strong>  校园网、企业网</li><li><strong>个人区域网 PAN</strong>  个人电子设备连接构成的网络</li></ul><h3 id="网络使用者分类"><a href="#网络使用者分类" class="headerlink" title="网络使用者分类"></a>网络使用者分类</h3><ul><li><strong>公用网</strong> ：电信公司出资建造的大型网络</li><li><strong>专用网</strong> ：某部门或单位专用网络</li></ul><h3 id="接入网-AN"><a href="#接入网-AN" class="headerlink" title="接入网 AN"></a>接入网 AN</h3><p>又称为<strong>本地接入网</strong>或<strong>居民接入网</strong>。课本P20</p><h2 id="计算机网络性能"><a href="#计算机网络性能" class="headerlink" title="计算机网络性能"></a>计算机网络性能</h2><p><img src="/network-chapter-1/eProperty.png"></p><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul><li><strong>速率</strong>：指<strong>数据的传送速率</strong>，又称数据率或比特率，单位为bit/s(比特每秒)。</li><li><strong>带宽</strong>：计网中的带宽指<strong>通道传送数据能力</strong>，网络带宽指单位时间内信道能通过的最高数据率，单位为bit/s(比特每秒)。</li><li><strong>吞吐量</strong>：单位时间内通过某个网络(或者信道、接口)的实际数据量。</li><li><strong>时延</strong>：又称延迟或迟延。指一个数据从网络一段传送到另一端所需时间。总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延<ul><li><strong>发送时延</strong>：主机或路由器发送数据帧所需要的时间。</li><li><strong>传播时延</strong>：电磁波在信道传播一定距离花费的时间。</li><li><strong>处理时延</strong>：主机或者路由器收到分组要花费处理的时间。</li><li><strong>排队时延</strong>：分组在网络传输时，在路由器数据队列排队等待处理。</li></ul></li><li><strong>时延带宽积</strong>：时延带宽积 = 传播时延 * 带宽。表示链路能容纳的比特数。</li><li><strong>往返时间 RTT</strong>：双向交互所花的时间啊。</li><li><strong>利用率</strong>：分为信道利用率和网路利用率两种。<strong>信道或者网络利用率过高会产生非常大的时延</strong>。<ul><li><strong>信道利用率</strong>：指出信道有百分之几的时间是被利用的。完全空闲的信道利用率就是0.</li><li><strong>网络利用率</strong>：是全网络的信道利用率的加权平均值。</li></ul></li></ul><h3 id="非性能指标"><a href="#非性能指标" class="headerlink" title="非性能指标"></a>非性能指标</h3><ul><li>费用：网络的价格(包括设计与实现的费用).</li><li>质量：质量会影响到网络的可靠性、网络管理的建议性以及网络的性能。</li><li>标准化</li><li>可靠性</li><li>可扩展和可升级</li><li>易于管理和维护</li></ul><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><strong>OSI</strong>是法律上的国际标准，但应用最广的是非国际标准<strong>TCP/IP</strong>。</p><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p><strong>网络协议</strong>：为网络中的数据交换建立的规则和标准。这些规则明确规定了所交换的数据的格式以及有关的同步问题。网络协议由<strong>语法</strong>、<strong>语义</strong>以及<strong>同步</strong>构成。</p><ul><li><strong>语法</strong>：数据与控制信息的结构或格式。</li><li><strong>语义</strong>：需要发出何种控制信息，完成何种动作以及做出何种响应。</li><li><strong>同步</strong>：事件实现顺序的详细说明。</li></ul><h3 id="分层协议"><a href="#分层协议" class="headerlink" title="分层协议"></a>分层协议</h3><p><img src="/network-chapter-1/agreement.png"></p><center><b>五层协议是为了介绍网络原理而设计的，实际应用的是TCP/IP四层体系结构</b></center>- **应用层**：应用层协议定义进程间通信和交互的规则。而应用层是通过应用进程间的交互来完成特定网络应用。- **运输层**：向负责两台主机中进程之间的通信提供同通用的数据传输服务。  - **TCP 传输控制协议**：提供面向连接、可靠的数据传输服务。  - **UDP 用户数据报协议**：提供无连接的、尽最大努力的数据传输服务，不保证数据传输的可靠性。- **网络层**：为分组交换网上的不同主机提供通信服务。把运输层产生的数据封装成IP数据报。- **数据链路层**：数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送帧。- **物理层**：用电压表示0/1，识别发送发的比特。<p><img src="/network-chapter-1/transfer.png"></p><h3 id="为什么要分层？"><a href="#为什么要分层？" class="headerlink" title="为什么要分层？"></a>为什么要分层？</h3><p>分层可以把庞大的问题转化为若干较小的、比较易于研究和处理的局部问题。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python入门</title>
    <link href="/Python/"/>
    <url>/Python/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：本文是Python3.x的简易学习笔记。</p><a id="more"></a><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>整数：int  8</p><p>浮点数： float  8.8</p><p>字符串： str  “8个人部分股”</p><p>布尔值：bool  True  False</p><h3 id="查看数据类型"><a href="#查看数据类型" class="headerlink" title="查看数据类型"></a>查看数据类型</h3><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">type</span><span class="hljs-params">(<span class="hljs-number">8</span>)</span></span> 可以返回变量的基本类型<span class="hljs-function"><span class="hljs-title">id</span><span class="hljs-params">(<span class="hljs-number">8</span>)</span></span>   可以返回变量所指的内存地址</code></pre><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><pre><code class="hljs ocaml">str --&gt; <span class="hljs-built_in">int</span> ： <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;8&#x27;</span>)<span class="hljs-built_in">int</span> --&gt; str ： str(<span class="hljs-number">123</span>)<span class="hljs-built_in">int</span> --&gt; <span class="hljs-built_in">bool</span>： <span class="hljs-built_in">bool</span>(<span class="hljs-number">123</span>) = <span class="hljs-type">True</span></code></pre><h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>字符串、列表、元组三种类型都属于序列。</p><pre><code class="hljs prolog">字符串： <span class="hljs-string">&quot;abcd&quot;</span>列表：  [<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;abcd&#x27;</span>]元组：  (<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>)</code></pre><p>列表存储的内容可变更</p><p>但是元组存储的内容不可变更</p><h3 id="序列的基本操作"><a href="#序列的基本操作" class="headerlink" title="序列的基本操作"></a>序列的基本操作</h3><h4 id="切片操作-–-0-整数"><a href="#切片操作-–-0-整数" class="headerlink" title="切片操作 – [0:整数]"></a>切片操作 – [0:整数]</h4><pre><code class="hljs python">chineseZodiac = <span class="hljs-string">&quot;鼠牛虎兔龙蛇马羊猴鸡狗猪&quot;</span>print(chineseZodiac[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]) <span class="hljs-comment"># 鼠牛虎兔 [0,4) 左闭右开</span></code></pre><pre><code class="hljs python"><span class="hljs-comment"># 切片语法</span>sname[start : end : step]<span class="hljs-comment">#sname:序列的名称</span><span class="hljs-comment">#start:切片开始的位置，包括该位置</span><span class="hljs-comment">#end: 切片截至的位置，但不包括该位置</span><span class="hljs-comment">#step: 切片的步长，如果省略，默认为1</span></code></pre><h4 id="成员关系-–-in、not-in"><a href="#成员关系-–-in、not-in" class="headerlink" title="成员关系 – in、not in"></a>成员关系 – in、not in</h4><pre><code class="hljs python">print(<span class="hljs-string">&#x27;狗&#x27;</span> <span class="hljs-keyword">in</span> chineseZodiac)  <span class="hljs-comment"># True</span>print(<span class="hljs-string">&#x27;狗&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> chineseZodiac)  <span class="hljs-comment"># False</span></code></pre><h4 id="连接操作-–-序列-序列"><a href="#连接操作-–-序列-序列" class="headerlink" title="连接操作 – 序列+序列"></a>连接操作 – 序列+序列</h4><pre><code class="hljs python">print(chineseZodiac + <span class="hljs-string">&#x27;abcd&#x27;</span>)</code></pre><h4 id="重复操作-–-序列-整数"><a href="#重复操作-–-序列-整数" class="headerlink" title="重复操作 – 序列 * 整数"></a>重复操作 – 序列 * 整数</h4><pre><code class="hljs python">chineseZodiac = <span class="hljs-string">&quot;猴鸡狗猪鼠牛虎兔龙蛇马羊&quot;</span>print(chineseZodiac * <span class="hljs-number">3</span>) <span class="hljs-comment">#猴鸡狗猪鼠牛虎兔龙蛇马羊猴鸡狗猪鼠牛虎兔龙蛇马羊猴鸡狗猪鼠牛虎兔龙蛇马羊</span></code></pre><h4 id="序列长度"><a href="#序列长度" class="headerlink" title="序列长度"></a>序列长度</h4><pre><code class="hljs python"><span class="hljs-built_in">len</span>() <span class="hljs-comment">#计算列表的长度</span></code></pre><h3 id="字符串、元组、列表"><a href="#字符串、元组、列表" class="headerlink" title="字符串、元组、列表"></a>字符串、元组、列表</h3><pre><code class="hljs python">chineseZodiac = <span class="hljs-string">&quot;鼠牛虎兔龙蛇马羊猴鸡狗猪&quot;</span> <span class="hljs-comment"># &lt;class &#x27;str&#x27;&gt;</span>zodiac_name = (<span class="hljs-string">u&#x27;摩羯座&#x27;</span>,<span class="hljs-string">u&#x27;水瓶座&#x27;</span>,<span class="hljs-string">u&#x27;双鱼座&#x27;</span>,<span class="hljs-string">u&#x27;白羊座&#x27;</span>,<span class="hljs-string">u&#x27;金牛座&#x27;</span>,<span class="hljs-string">u&#x27;双子座&#x27;</span>,               <span class="hljs-string">u&#x27;巨蟹座&#x27;</span>,<span class="hljs-string">u&#x27;狮子座&#x27;</span>,<span class="hljs-string">u&#x27;处女座&#x27;</span>,<span class="hljs-string">u&#x27;天秤座&#x27;</span>,<span class="hljs-string">u&#x27;天蝎座&#x27;</span>,<span class="hljs-string">u&#x27;射手座&#x27;</span>) <span class="hljs-comment">#&lt;class &#x27;tuple&#x27;&gt;</span>               alist = [<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;xyz&#x27;</span>]  <span class="hljs-comment">#&lt;class &#x27;list&#x27;&gt;</span></code></pre><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><pre><code class="hljs python"><span class="hljs-comment">#普通方式的列表</span>alist = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>):    <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>):        alist.append(i*i)print(alist) <span class="hljs-comment"># [4, 16, 36, 64, 100]</span><span class="hljs-comment">#列表推导式</span>blist = [i*i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>) <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)]print(blist) <span class="hljs-comment"># [4, 16, 36, 64, 100]</span></code></pre><h3 id="字符串的一些操作"><a href="#字符串的一些操作" class="headerlink" title="字符串的一些操作"></a>字符串的一些操作</h3><pre><code class="hljs python">split(<span class="hljs-string">&#x27;|&#x27;</span>) -- 将字符串按照符号“|”来进行分割成为一个列表strip(<span class="hljs-string">&#x27;\n&#x27;</span>) -- 将字符串里的换行符剔除replace(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>) -- 将字符串里的字母<span class="hljs-string">&#x27;a&#x27;</span>全都替换成为字母<span class="hljs-string">&#x27;b&#x27;</span></code></pre><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典是无序的可变序列。保存的内容是以“键值对”的形式存放的。</p><p>类似于C++中的map。</p><p>特征：</p><blockquote><p>字典中的键值必须唯一，且不能够改变。所以列表不能作为字典的键。</p><p>字典是通过键值来读取的，字典也称为散列表(hash)。不能向序列那样通过索引获取值。</p><p>字典是无序集合，各项随机排列，这样能够提高查找的效率。</p></blockquote><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">&#x27;x&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&quot;y&quot;</span>:<span class="hljs-number">2</span>&#125;print(<span class="hljs-built_in">type</span>(dict1)) <span class="hljs-comment">#&lt;class &#x27;dict&#x27;&gt;</span>print(dict1)       <span class="hljs-comment">#&#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2&#125;</span>dict1[<span class="hljs-string">&#x27;z&#x27;</span>] = <span class="hljs-number">3</span>print(dict1)       <span class="hljs-comment">#&#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2, &#x27;z&#x27;: 3&#125;</span><span class="hljs-comment"># 通过键值去遍历字典</span><span class="hljs-keyword">for</span> each_key <span class="hljs-keyword">in</span> dict1.keys():    print(each_key + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-built_in">str</span>(dict1[each_key]))    <span class="hljs-comment"># x: 1</span>    <span class="hljs-comment"># y: 2</span>    <span class="hljs-comment"># z: 3</span><span class="hljs-comment">#遍历键值对列表</span><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> dict1.items():    print(item)    <span class="hljs-comment"># (&#x27;x&#x27;, 1)</span>    <span class="hljs-comment"># (&#x27;y&#x27;, 2)</span>    <span class="hljs-comment"># (&#x27;z&#x27;, 3)</span>dict1.clear()print(dict1)       <span class="hljs-comment">#&#123;&#125;</span></code></pre><h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><pre><code class="hljs python"><span class="hljs-comment"># 普通方式</span>dict1 = &#123;<span class="hljs-string">&#x27;x&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;y&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;z&#x27;</span>:<span class="hljs-number">1</span>&#125;print(dict1)    <span class="hljs-comment">#&#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 1, &#x27;z&#x27;: 1&#125;</span><span class="hljs-comment"># 字典推导式</span>str1 = <span class="hljs-string">&#x27;xyz&#x27;</span>dict2 = &#123;i:<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> str1&#125;print(dict2)    <span class="hljs-comment">#&#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 1, &#x27;z&#x27;: 1&#125;</span></code></pre><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><pre><code class="hljs python">chineseZodiac = <span class="hljs-string">&quot;猴鸡狗猪鼠牛虎兔龙蛇马羊&quot;</span>year  = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请用户输入年份：&#x27;</span>))<span class="hljs-keyword">if</span> chineseZodiac[year%<span class="hljs-number">12</span>] == <span class="hljs-string">&#x27;狗&#x27;</span>:    print(<span class="hljs-string">&quot;狗年发大财&quot;</span>)<span class="hljs-keyword">elif</span> chineseZodiac[year%<span class="hljs-number">12</span>] == <span class="hljs-string">&#x27;猪&#x27;</span>:    print(<span class="hljs-string">&quot;猪年快乐&quot;</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">&quot;笑口常开&quot;</span>)</code></pre><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><pre><code class="hljs python">chineseZodiac = <span class="hljs-string">&quot;猴鸡狗猪鼠牛虎兔龙蛇马羊&quot;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> chineseZodiac:    print(i)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">13</span>):    print(i) <span class="hljs-comment">#0-12</span><span class="hljs-keyword">for</span> year <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2000</span>,<span class="hljs-number">2020</span>):    print(<span class="hljs-string">&quot;%s 年的生肖是 %s&quot;</span> %(year,chineseZodiac[year%<span class="hljs-number">12</span>]))</code></pre><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    print(<span class="hljs-string">&#x27;a&#x27;</span>)    <span class="hljs-keyword">break</span><span class="hljs-comment">###############</span>num = <span class="hljs-number">5</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    print(num)    num += <span class="hljs-number">1</span>    <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">10</span>:        <span class="hljs-keyword">break</span><span class="hljs-comment">##########</span>num = <span class="hljs-number">5</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    num += <span class="hljs-number">1</span>    <span class="hljs-keyword">if</span> num == <span class="hljs-number">10</span>:        <span class="hljs-keyword">continue</span>     print(num)    <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">15</span>:        <span class="hljs-keyword">break</span>;</code></pre><h3 id="👍元组中的filter"><a href="#👍元组中的filter" class="headerlink" title="👍元组中的filter"></a>👍元组中的filter</h3><pre><code class="hljs python">zodiac_name = (<span class="hljs-string">u&#x27;摩羯座&#x27;</span>,<span class="hljs-string">u&#x27;水瓶座&#x27;</span>,<span class="hljs-string">u&#x27;双鱼座&#x27;</span>,<span class="hljs-string">u&#x27;白羊座&#x27;</span>,<span class="hljs-string">u&#x27;金牛座&#x27;</span>,<span class="hljs-string">u&#x27;双子座&#x27;</span>,               <span class="hljs-string">u&#x27;巨蟹座&#x27;</span>,<span class="hljs-string">u&#x27;狮子座&#x27;</span>,<span class="hljs-string">u&#x27;处女座&#x27;</span>,<span class="hljs-string">u&#x27;天秤座&#x27;</span>,<span class="hljs-string">u&#x27;天蝎座&#x27;</span>,<span class="hljs-string">u&#x27;射手座&#x27;</span>)zodiac_day = ((<span class="hljs-number">1</span>,<span class="hljs-number">20</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">19</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">21</span>),(<span class="hljs-number">4</span>,<span class="hljs-number">21</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">23</span>),(<span class="hljs-number">6</span>,<span class="hljs-number">22</span>),              (<span class="hljs-number">7</span>,<span class="hljs-number">23</span>),(<span class="hljs-number">8</span>,<span class="hljs-number">23</span>),(<span class="hljs-number">9</span>,<span class="hljs-number">23</span>),(<span class="hljs-number">10</span>,<span class="hljs-number">23</span>),(<span class="hljs-number">11</span>,<span class="hljs-number">23</span>),(<span class="hljs-number">12</span>,<span class="hljs-number">23</span>))(month,day) = (<span class="hljs-number">2</span>,<span class="hljs-number">11</span>)zodiac = <span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x&lt;=(month,day), zodiac_day)zodiac_len = <span class="hljs-built_in">len</span>( <span class="hljs-built_in">list</span>(zodiac) ) <span class="hljs-comment"># 取出长度</span>print(zodiac_name[zodiac_len%<span class="hljs-number">12</span>]) <span class="hljs-comment">#水瓶座</span></code></pre><pre><code class="hljs python">zodiac_name = (<span class="hljs-string">u&#x27;摩羯座&#x27;</span>,<span class="hljs-string">u&#x27;水瓶座&#x27;</span>,<span class="hljs-string">u&#x27;双鱼座&#x27;</span>,<span class="hljs-string">u&#x27;白羊座&#x27;</span>,<span class="hljs-string">u&#x27;金牛座&#x27;</span>,<span class="hljs-string">u&#x27;双子座&#x27;</span>,               <span class="hljs-string">u&#x27;巨蟹座&#x27;</span>,<span class="hljs-string">u&#x27;狮子座&#x27;</span>,<span class="hljs-string">u&#x27;处女座&#x27;</span>,<span class="hljs-string">u&#x27;天秤座&#x27;</span>,<span class="hljs-string">u&#x27;天蝎座&#x27;</span>,<span class="hljs-string">u&#x27;射手座&#x27;</span>)zodiac_day = ((<span class="hljs-number">1</span>,<span class="hljs-number">20</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">19</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">21</span>),(<span class="hljs-number">4</span>,<span class="hljs-number">21</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">23</span>),(<span class="hljs-number">6</span>,<span class="hljs-number">22</span>),              (<span class="hljs-number">7</span>,<span class="hljs-number">23</span>),(<span class="hljs-number">8</span>,<span class="hljs-number">23</span>),(<span class="hljs-number">9</span>,<span class="hljs-number">23</span>),(<span class="hljs-number">10</span>,<span class="hljs-number">23</span>),(<span class="hljs-number">11</span>,<span class="hljs-number">23</span>),(<span class="hljs-number">12</span>,<span class="hljs-number">23</span>))<span class="hljs-comment"># 用户输入月份与日期</span>month = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入月份：&quot;</span>))day = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入日期：&quot;</span>))<span class="hljs-keyword">for</span> zo <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(zodiac_day)):    <span class="hljs-keyword">if</span> (month,day) &lt;= zodiac_day[zo]:        print(<span class="hljs-string">&quot;出生于%s月%s日的星座是%s&quot;</span> %(month,day,zodiac_name[zo]))        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">elif</span> month == <span class="hljs-number">12</span> <span class="hljs-keyword">and</span> day &gt; <span class="hljs-number">23</span>:        print(<span class="hljs-string">&quot;出生于%s月%s日的星座是摩羯座&quot;</span> % (month, day))        <span class="hljs-keyword">break</span></code></pre><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><pre><code class="hljs python"><span class="hljs-comment"># ‘w&#x27;:文件不存在会新建、文件存在会覆盖</span>file1 = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;name.txt&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>)file1.write(<span class="hljs-string">&quot;hello,Python&quot;</span>)file1.close()<span class="hljs-comment"># 文件读取也叫做输入，文件写入也叫做输出</span><span class="hljs-comment"># &#x27;r&#x27;:文件不存在就报错</span>file2 = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;name.txt&quot;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)<span class="hljs-built_in">str</span> = file2.readline()<span class="hljs-comment">#读取一行</span>print(<span class="hljs-built_in">str</span>)file2.close()<span class="hljs-comment"># &#x27;a&#x27;:append追加，文件不存在就新建，文件存在就将内容添加到末尾</span>file3 = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;name.txt&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>)file3.write(<span class="hljs-string">&quot;你好/n哈哈&quot;</span>)file3.close()<span class="hljs-comment"># readlines()读取多行，返回值是list</span>file4 = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;name.txt&quot;</span>, <span class="hljs-string">&#x27;r&#x27;</span>)<span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file4.readlines():    print(line)    print(<span class="hljs-string">&quot;===&quot;</span>)<span class="hljs-comment"># 文件指针，使用tell()获得文件指针</span>file5 = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;name.txt&quot;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)print(file5.tell()) <span class="hljs-comment">#指针位置为0</span>print(file5.read(<span class="hljs-number">1</span>)) <span class="hljs-comment">#打印第一个字符</span>print(file5.tell()) <span class="hljs-comment">#现在的指针位置为1</span>file5.seek(<span class="hljs-number">0</span>) <span class="hljs-comment">#文件指针回到0</span>print(file5.tell()) <span class="hljs-comment">#指针位置为0</span>file6 = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;name.txt&quot;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)print(file6.tell())<span class="hljs-comment">#0</span>file6.seek(<span class="hljs-number">5</span>,<span class="hljs-number">0</span>)print(file6.tell())<span class="hljs-comment">#5</span><span class="hljs-comment">#seek()函数有两个参数时，第一个参数代表偏移量，第二个参数代表从什么位置开始计算</span><span class="hljs-comment"># 对于第二个参数：0 表示从文件头开始计算， 1 表示从当前位置开始计算，2 表示从文件尾开始计算</span><span class="hljs-comment">#注意！如果在打开文件时，没有使用b模式，那么只允许从文件头开始计算相对偏移量</span></code></pre><h3 id="文件打开的三个参数"><a href="#文件打开的三个参数" class="headerlink" title="文件打开的三个参数"></a>文件打开的三个参数</h3><pre><code class="hljs python">file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)</code></pre><p><img src="/Python/fileParam.png"></p><h3 id="打开文件使用with语句–上下文管理器"><a href="#打开文件使用with语句–上下文管理器" class="headerlink" title="打开文件使用with语句–上下文管理器"></a>打开文件使用with语句–上下文管理器</h3><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;name.txt&quot;</span>,<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file.readlines():        print(line)</code></pre><p>Python打开文件要及时关闭，忘记关闭可能会带来问题，另外如果在打开文件是出现了异常，那么将导致文件不能及时被关闭，为了避免此类问题，可以使用上述的with语句进行操作。</p><p>这样在处理文件时，无论是否抛出了异常，都能<strong>保证with语句执行完毕后关闭已经打开的文件</strong>。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h3><p><img src="/Python/someError.png"></p><h3 id="简单的异常处理语句"><a href="#简单的异常处理语句" class="headerlink" title="简单的异常处理语句"></a>简单的异常处理语句</h3><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    year = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入年份:&quot;</span>))<span class="hljs-keyword">except</span> ValueError:    print(<span class="hljs-string">&quot;年份应该输入数字&quot;</span>)a = <span class="hljs-number">123</span><span class="hljs-keyword">try</span>:    a.append(<span class="hljs-string">&#x27;a&#x27;</span>)<span class="hljs-keyword">except</span> AttributeError:    print(<span class="hljs-string">&#x27;数字没有append方法&#x27;</span>)<span class="hljs-keyword">try</span>:    print(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>)<span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:    print(<span class="hljs-string">&#x27;0不能作为除数：&#x27;</span>,e) <span class="hljs-comment">#0不能作为除数： division by zero</span><span class="hljs-comment">#捕获未知类型的异常</span><span class="hljs-keyword">try</span>:    print(<span class="hljs-number">1</span>/<span class="hljs-string">&#x27;a&#x27;</span>)<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:    print(e)   <span class="hljs-comment">#try...except...else语句</span><span class="hljs-keyword">try</span>:    print(<span class="hljs-number">1</span>/<span class="hljs-number">1</span>)<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:    print(e)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">&quot;正常执行&quot;</span>)</code></pre><h3 id="try…except…finally语句"><a href="#try…except…finally语句" class="headerlink" title="try…except…finally语句"></a>try…except…finally语句</h3><p>finally语句用来放置无论是否发生异常都会被执行的代码。例如：打开文件是使用此语句，释放资源的代码放在finally语句之中。</p><p><img src="/Python/errFinally.png"></p><h3 id="使用raise语句抛出异常"><a href="#使用raise语句抛出异常" class="headerlink" title="使用raise语句抛出异常"></a>使用raise语句抛出异常</h3><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">div</span>():</span>    num1 = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入被除数：&#x27;</span>))    num2 = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入除数：&#x27;</span>))    <span class="hljs-keyword">if</span> num2 == <span class="hljs-number">0</span>:        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;除数不能为0.&quot;</span>)    result = num1 / num2    print(result)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    <span class="hljs-keyword">try</span>:        div()    <span class="hljs-keyword">except</span> ZeroDivisionError:        print(<span class="hljs-string">&quot;\nerror!除数不能为0&quot;</span>)    <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:        print(<span class="hljs-string">&quot;输入错误：&quot;</span>,e)</code></pre><p>如果某个函数或者方法可能会产生异常，但不想在当前函数或方法中处理这个异常，则可以使用raise语句在函数或者方法中抛出异常。</p><h3 id="assert断言语句"><a href="#assert断言语句" class="headerlink" title="assert断言语句"></a>assert断言语句</h3><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">div</span>():</span>    num1 = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入被除数：&#x27;</span>))    num2 = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入除数：&#x27;</span>))    <span class="hljs-keyword">assert</span> num2 != <span class="hljs-number">0</span>, <span class="hljs-string">&quot;除数不能为0&quot;</span>    result = num1 / num2    print(result)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    <span class="hljs-keyword">try</span>:        div()    <span class="hljs-keyword">except</span> AssertionError <span class="hljs-keyword">as</span> e:        print(<span class="hljs-string">&quot;\nerror！&quot;</span>,e)</code></pre><p>断言语句的基本格式为</p><pre><code class="hljs python"><span class="hljs-keyword">assert</span> expression , reasonexpression:是条件表达式，表达式为<span class="hljs-literal">True</span>时什么都不做，为<span class="hljs-literal">False</span>时抛出AssertionError异常。reason：描述异常信息，可写可不写</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code class="hljs python"><span class="hljs-comment">#统计单词出现次数</span><span class="hljs-keyword">import</span> re <span class="hljs-comment">#一个模块</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_word</span>(<span class="hljs-params">word</span>):</span>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;Stone.txt&#x27;</span>,encoding=<span class="hljs-string">&#x27;GBK&#x27;</span>) <span class="hljs-keyword">as</span> f:        data = f.read().replace(<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)        words = re.findall(word, data) <span class="hljs-comment">#函数的返回值时list</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(words)<span class="hljs-comment">#读取人物信息</span><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;name.txt&quot;</span>) <span class="hljs-keyword">as</span> f:        words = f.read().split(<span class="hljs-string">&#x27;|&#x27;</span>)        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> words:            print(<span class="hljs-string">&quot;&#x27;&quot;</span>,w,<span class="hljs-string">&quot;&#x27;&quot;</span>,<span class="hljs-string">&#x27;出现了：&#x27;</span>,find_word(w))<span class="hljs-comment"># &#x27; 密苏里 &#x27; 出现了： 3</span><span class="hljs-comment"># &#x27; 他 &#x27; 出现了： 17</span><span class="hljs-comment"># &#x27; 斯通纳 &#x27; 出现了： 6</span><span class="hljs-comment"># &#x27; 的 &#x27; 出现了： 52</span></code></pre><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><pre><code class="hljs delphi">def <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(形参列表)</span>:</span>函数体</code></pre><p>如上所示，使用<code>def</code>来定义一个函数，如果函数有返回值的时候可以通过<code>return</code>语句返回。如若想定义一个空函数的画，可以使用<code>pass</code>作为占位符。</p><p>当函数中没有return语句时，或者省略了return语句后面的内容，将会返回<code>None</code>，即<strong>返回空值</strong>。</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>Python参数传递分为值传递和引用传递两种。</p><ul><li>当实参是<strong>不可变对象</strong>时，进行的是<strong>值传递</strong>。</li><li>当实参为<strong>可变对象</strong>是，进行的是<strong>引用传递</strong>。</li></ul><p>区别在于：</p><p><strong>值传递</strong>在函数内改变了形参的值，实参的值也<strong>不变</strong>。</p><p>而<strong>引用传递</strong>后，改变形参的值，实参的值也会一同<strong>改变</strong>。</p><blockquote><p>字符串就是不可变对象，而列表就是可变对象。</p></blockquote><h3 id="参数种类"><a href="#参数种类" class="headerlink" title="参数种类"></a>参数种类</h3><ul><li><strong>位置参数</strong>，也叫必备参数。即使用函数时要按照形参列表的正确顺序与数量进行使用。</li><li><strong>关键字参数</strong>。使用形参的名字来确定输入的参数值。打开文件时指定编码就是使用关键字参数：<code>open(&#39;test.txt&#39;,encoding=&#39;GBK&#39;)</code></li><li><strong>有默认值的参数</strong>。在定义函数时直接指定形参的默认值。这样没有参数传递时就会直接使用默认值。<ul><li>例如定义函数 <code>def func(filename, lenth = 5)</code></li><li>定义函数时指定的默认参数要写在所有形参的<strong>最后面</strong>。</li><li>可以使用 <code>函数名.__defaults__</code> 的形式查看函数的默认值参数，结果是元组。</li><li>此外当使用可变参数作为函数参数默认值时，多次调用可能会导致意外，所以最好将可变参数的默认值设置为<code>None</code>，<strong>默认参数必须要指向不可变对象</strong>。</li></ul></li><li><strong>可变参数</strong>。即不定长参数，可以传递的值是0个或者任意个。<ul><li>第一种形式：**<code>*parameter</code>**。接受任意多的参数并放到一个元组之中。如果若要把一个存在的列表作为参数传递进去，可以使用 <code>*列表名称</code> 作为参数传递。</li><li>第二种形式：<code>**parameter</code>。接受任意多个<strong>显式赋值</strong>的实际参数，并将其放到<strong>字典</strong>中。如果若要把一个存在的字典作为参数传递进去，可以使用 <code>**字典名称</code> 作为参数传递。</li></ul></li></ul><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><pre><code class="hljs python"><span class="hljs-comment"># 全局变量在函数内外都可以访问的到</span><span class="hljs-built_in">sum</span> = <span class="hljs-number">123</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>():</span>    print(<span class="hljs-built_in">sum</span>)func()     <span class="hljs-comment">#123</span>print(<span class="hljs-built_in">sum</span>) <span class="hljs-comment">#123</span><span class="hljs-comment"># 局部变量与全局变量重名时</span><span class="hljs-built_in">sum</span> = <span class="hljs-number">123</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>():</span>    <span class="hljs-built_in">sum</span> =  <span class="hljs-number">456</span>    print(<span class="hljs-built_in">sum</span>)func()   <span class="hljs-comment">#456</span>print(<span class="hljs-built_in">sum</span>) <span class="hljs-comment">#123</span><span class="hljs-comment"># 可以在函数体内声明一个全局变量</span><span class="hljs-built_in">sum</span> = <span class="hljs-number">123</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>():</span>    <span class="hljs-keyword">global</span> <span class="hljs-built_in">sum</span>    <span class="hljs-built_in">sum</span> =  <span class="hljs-number">456</span>    print(<span class="hljs-built_in">sum</span>)func()     <span class="hljs-comment">#456</span>print(<span class="hljs-built_in">sum</span>) <span class="hljs-comment">#456</span></code></pre><h3 id="👍迭代器、生成器与iter函数"><a href="#👍迭代器、生成器与iter函数" class="headerlink" title="👍迭代器、生成器与iter函数"></a>👍迭代器、生成器与iter函数</h3><pre><code class="hljs python">list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]it = <span class="hljs-built_in">iter</span>(list1)print(<span class="hljs-built_in">next</span>(it))print(<span class="hljs-built_in">next</span>(it))print(<span class="hljs-built_in">next</span>(it))<span class="hljs-comment"># print(next(it)) #error</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">frange</span>(<span class="hljs-params">start,stop,step</span>):</span>    x = start    <span class="hljs-keyword">while</span> x &lt; stop:        <span class="hljs-keyword">yield</span> x        x += step<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> frange(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">0.5</span>):    print(i)</code></pre><p><a href="https://www.cnblogs.com/Micro0623/p/9950528.html">Python：迭代器、生成器（yield）、iter函数</a></p><p>只要函数里有 <code>__iter__</code> 以及 <code>__next__</code> 的这种方法就可以使用 <code>for...in...</code> 的形式以及 <code>next </code>形式去取迭代值。</p><h3 id="匿名函数–lambda表达式"><a href="#匿名函数–lambda表达式" class="headerlink" title="匿名函数–lambda表达式"></a>匿名函数–lambda表达式</h3><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">true</span>():</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><span class="hljs-comment">#对应的lambda表达式</span><span class="hljs-keyword">lambda</span> : <span class="hljs-literal">True</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">x,y</span>):</span>    <span class="hljs-keyword">return</span> x+y<span class="hljs-comment">#对应的lambda表达式</span><span class="hljs-keyword">lambda</span> x,y : x+y</code></pre><p><code>:</code> 之前写函数的参数，冒号之后写实现具体功能的表达式。此外一定要有一个变量去接受或者去调用这个lambda表达式。</p><h3 id="常用的Python内置函数"><a href="#常用的Python内置函数" class="headerlink" title="常用的Python内置函数"></a>常用的Python内置函数</h3><p><img src="/Python/function1.png"></p><p><img src="/Python/function2.png"></p><pre><code class="hljs python">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]list1 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x:x&gt;<span class="hljs-number">2</span>, a))print(list1) <span class="hljs-comment">#[3, 4, 5, 6, 7]</span>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]list2 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x:x+<span class="hljs-number">1</span>, a))print(list2) <span class="hljs-comment">#[2, 3, 4, 5, 6, 7, 8]</span>b = [<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>]list3 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x,y:x+y, a,b))print(list3) <span class="hljs-comment">#[8, 9, 10, 11, 12, 13, 14]</span><span class="hljs-comment">#reduce 对参数序列中元素进行累积。</span><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduceprint(reduce(<span class="hljs-keyword">lambda</span> x,y:x+y,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])) <span class="hljs-comment">#10</span>a = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)b = (<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(a,b):    print(i)    <span class="hljs-comment"># (1, 4)</span><span class="hljs-comment"># (2, 5)</span><span class="hljs-comment"># (3, 6)</span><span class="hljs-comment">#使用zip将字典的键值进行对调</span>dict1 = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">22</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">33</span>&#125;dict2 = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(dict1.values(), dict1.keys()))print(dict2) <span class="hljs-comment">#&#123;22: &#x27;a&#x27;, 33: &#x27;b&#x27;&#125;</span></code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><pre><code class="hljs python"><span class="hljs-comment">#定义一个函数，内部还有一个函数，外部函数的返回值是内部函数的名字</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>():</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printa</span>():</span>        print(<span class="hljs-string">&quot;start&quot;</span>)    <span class="hljs-keyword">return</span> printafunc() <span class="hljs-comment">#不会执行，无结果</span>print(func()) <span class="hljs-comment">#&lt;function func.&lt;locals&gt;.printa at 0x0000014DA9557D90&gt;</span>print(<span class="hljs-built_in">type</span>(func())) <span class="hljs-comment">#&lt;class &#x27;function&#x27;&gt;</span>a = func()a()  <span class="hljs-comment">#执行函数内容：start</span></code></pre><blockquote><p>闭包是由函数及其相关的引用环境组合而成的实体。</p></blockquote><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ExFunc</span>(<span class="hljs-params">n</span>):</span>    <span class="hljs-built_in">sum</span> = n    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">InsFunc</span>():</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>+<span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> addFunmyFun1 = ExFunc(<span class="hljs-number">10</span>)sums = myFun1()print(sums) <span class="hljs-comment">#11</span>myFun2 = ExFunc(<span class="hljs-number">100</span>)sumss = myFun2()print(sumss) <span class="hljs-comment">#101</span></code></pre><p>当调用函数分别传入不同的参数的时候，得到的结果<code>myFun1</code>与<code>myFun2</code>这两个是<strong>隔离的</strong>，也就是说每次调用<code>ExFunc()</code>函数后都将生成并且保存一个新的局部变量sum。</p><blockquote><p> 按照命令式语言的规则，ExFunc函数只是返回了内嵌函数InsFunc的地址，在执行InsFunc函数时将会由于在其作用域内找不到sum变量而出 错。而在函数式语言中，当内嵌函数体内引用到体外的变量时，将会把定义时涉及到的引用环境和函数体打包成一个整体（闭包）返回。现在给出引用环境的定义就 容易理解了：引用环境是指在程序执行中的某个点所有处于活跃状态的约束（一个变量的名字和其所代表的对象之间的联系）所组成的集合。闭包的使用和正常的函 数调用没有区别。</p><p> 由于<strong>闭包把函数和运行时的引用环境打包成为一个新的整体</strong>，所以就解决了函数编程中的嵌套所引发的问题。如上述代码段中，当每次调用ExFunc函数 时都将返回<strong>一个新的闭包实例</strong>，这些实例之间是隔离的，分别包含调用时不同的引用环境现场。不同于函数，闭包在运行时可以有多个实例，不同的引用环境和相同 的函数组合可以产生不同的实例。</p><p> <strong>闭包=函数块+定义函数时的环境</strong></p><p> 引用自博客：<a href="https://zm.sm-tc.cn/?src=l4uLj4zF0NCIiIjRnJGdk5CYjNGckJLQtZCXkb69vNCejYuWnJOajNDLz8jJx8rK0ZeLkpM=&uid=0d895671b892663235a72f9f68411071&hid=952719fcaaacd90a8e3ae3928bf535f0&pos=4&cid=9&time=1566288676511&from=click&restype=1&pagetype=0020000002000408&bu=news_natural&query=python+%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85&mode=&v=1&force=true&wap=false&uc_param_str=dnntnwvepffrgibijbprsvdsdichei">Python-闭包详解</a></p><p> 并且一个常见的闭包错误以及python对应的解决方式：<a href="https://blog.csdn.net/u012881331/article/details/82881083">python nonloacal</a></p></blockquote><h3 id="闭包的实际小案例"><a href="#闭包的实际小案例" class="headerlink" title="闭包的实际小案例"></a>闭包的实际小案例</h3><pre><code class="hljs python"><span class="hljs-comment">#计数器</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">counter</span>():</span>    cnt = [<span class="hljs-number">0</span>]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_one</span>():</span>        cnt[<span class="hljs-number">0</span>] += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> cnt[<span class="hljs-number">0</span>]    <span class="hljs-keyword">return</span> add_onenum1 = counter()<span class="hljs-comment">#每执行一次函数 计数器+1</span>print(num1()) <span class="hljs-comment">#1</span>print(num1()) <span class="hljs-comment">#2</span>print(num1()) <span class="hljs-comment">#3</span>print(num1()) <span class="hljs-comment">#4</span></code></pre><pre><code class="hljs python"><span class="hljs-comment">#计算 y = a*x+b</span><span class="hljs-comment">#普通函数的写法</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">yyy</span>(<span class="hljs-params">a,b,x</span>):</span>    <span class="hljs-keyword">return</span> a*x+by = yyy(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>)print(y)y = yyy(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>)print(y)<span class="hljs-comment">#闭包的写法</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">yyy</span>(<span class="hljs-params">a,b</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">argy</span>(<span class="hljs-params">x</span>):</span>        <span class="hljs-keyword">return</span> a*x + b    <span class="hljs-keyword">return</span> argyy1 = yyy(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)ends = y1(<span class="hljs-number">5</span>)print(ends)end2 = y1(<span class="hljs-number">6</span>)print(end2)</code></pre><p>如上所示，对于计算一阶函数时，想要固定a,b的值而只改变x的值的时候就可以采用这种方式，简化代码。</p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iSleep</span>():</span>    time.sleep(<span class="hljs-number">2</span>)start_time = time.time()iSleep()end_time = time.time()print(<span class="hljs-string">&#x27;使用时间:&#x27;</span>,end_time-start_time)</code></pre><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">timmer</span>(<span class="hljs-params">func</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>():</span>        start_time = time.time()        func()        end_time = time.time()        print(<span class="hljs-string">&#x27;使用时间:&#x27;</span>, end_time - start_time)    <span class="hljs-keyword">return</span> wrapper<span class="hljs-meta">@timmer</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iSleep</span>():</span>    time.sleep(<span class="hljs-number">2</span>)<span class="hljs-comment">#执行</span>iSleep()</code></pre><blockquote><p>我们注意到装饰器可以使用def来定义，装饰器接收一个函数对象作为参数，并返回一个新的函数对象。装饰器通过名称绑定，让同一个变量名指向一个新返回的函数对象，这样就达到修改函数对象的目的。在使用装饰器时，我们通常会在新函数内部调用旧函数，以保留旧函数的功能，这正是“装饰”一词的由来。在定义好装饰器以后，就可以使用@语法了，其实际意义时，将被修饰对象作为参数传递给装饰器函数，然后将装饰器函数返回的函数对象赋给原来的被修饰对象。装饰器可以实现代码的可复用性，即我们可以用同一个装饰器修饰多个函数，以便实现相同的附加功能。</p><p>参看链接：<a href="https://zhuanlan.zhihu.com/p/33641635">深入浅出理解Python装饰器</a></p></blockquote><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tips</span>(<span class="hljs-params">func</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nei</span>(<span class="hljs-params">a,b</span>):</span>        print(<span class="hljs-string">&#x27;start&#x27;</span>)        func(a,b)        print(<span class="hljs-string">&#x27;end&#x27;</span>)    <span class="hljs-keyword">return</span> nei<span class="hljs-meta">@tips</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">a,b</span>):</span>    print(a+b)<span class="hljs-meta">@tips</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub</span>(<span class="hljs-params">a,b</span>):</span>    print(a-b)add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)sub(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>)<span class="hljs-comment">##################</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_tips</span>(<span class="hljs-params">argv</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tips</span>(<span class="hljs-params">func</span>):</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nei</span>(<span class="hljs-params">a,b</span>):</span>            print(<span class="hljs-string">&#x27;start:&#x27;</span>,argv)            func(a,b)            print(<span class="hljs-string">&#x27;end:&#x27;</span>,argv)        <span class="hljs-keyword">return</span> nei    <span class="hljs-keyword">return</span> tips<span class="hljs-meta">@new_tips(<span class="hljs-params"><span class="hljs-string">&#x27;add&#x27;</span></span>)</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">a,b</span>):</span>    print(a+b)<span class="hljs-meta">@new_tips(<span class="hljs-params"><span class="hljs-string">&#x27;sub&#x27;</span></span>)</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub</span>(<span class="hljs-params">a,b</span>):</span>    print(a-b)add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)sub(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>)</code></pre><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p><strong>Python中一切都是对象，甚至字符串、函数等都是对象。</strong></p><pre><code class="hljs python"><span class="hljs-comment">#定义一个类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, hp</span>):</span>        self.name = name        self.hp = hp    <span class="hljs-comment">#定义一个方法</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_role</span>(<span class="hljs-params">self</span>):</span>        print(self.name, <span class="hljs-string">&#x27;:&#x27;</span>, self.hp)<span class="hljs-comment">#类的实例化</span>user1 = Player(<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-number">100</span>)user2 = Player(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">200</span>)user1.print_role();user2.print_role();</code></pre><h3 id="init-方法与self参数"><a href="#init-方法与self参数" class="headerlink" title="__init__()方法与self参数"></a><code>__init__()</code>方法与self参数</h3><p><code>__init__</code>方法是构造方法，每当创建一个类的实例的时候Python就会自动执行他。</p><p>这种函数名写法用于区分Python的默认方法和普通方法。</p><p>self参数是指向实例本身的引用，用于访问类中的属性和方法，在方法调用的时候就会自动传递参数self。(类似于C++类中的this)</p><p>类中方法的第一个参数一定要是self。(self只是约定的名字，其他名字也行)</p><h3 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h3><p>类的成员由<strong>实例方法</strong>和<strong>数据成员</strong>组成。</p><p>数据成员是指类中定义的变量，即类的属性。</p><p>而类的属性根据其所在位置的不同又分为<strong>类属性</strong>和<strong>实例属性</strong>。</p><ul><li><strong>类属性</strong>：定义在类中，定义在类的实例方法之外的属性。<ul><li>类属性在类的所有实例之间共享，即所有实例化对象共用此属性。</li><li>类属性可以通过类名调用，或者通过实例名进行访问</li><li>类似于C++类中的static变量</li></ul></li><li><strong>实例属性</strong>：定义在类的方法中的属性。<ul><li>实例属性只能通过实例名进行访问。</li><li>不同实例的实例属性之间互不影响。</li></ul></li></ul><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>Python中通过给属性或者方法的名字前面添加<strong>单下划线</strong>、<strong>双下划线</strong>、<strong>首尾双下划线</strong>的方式来限制类中属性和方法的访问权限。</p><ul><li><strong>首尾双下划线</strong>：表示定义特殊方法，一般是系统定义名字。比如：<code>__init__()</code>方法</li><li><strong>单下划线开头</strong>：表示<strong>protected</strong>（保护）类型的成员，<strong>只允许类本身和子类访问</strong>，但不能使用”from modules import *”这种语句导入。比如：自定义属性 <code>_foo</code></li><li><strong>双下划线开头</strong>：表示<strong>private</strong>（私有）成员。<strong>只允许定义该方法的类本身进行访问</strong>，不能直接通过类的实例进行访问，但是可以通过”类的实例名._类名_xxx”的方式访问。</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Swan</span>:</span>    <span class="hljs-comment">#定义保护成员</span>    _neckSwan = <span class="hljs-string">&#x27;天鹅的脖子很长&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        print(<span class="hljs-string">&quot;__init__()&quot;</span>,self._neckSwan)swan = Swan()print(<span class="hljs-string">&#x27;直接访问&#x27;</span>,swan._neckSwan)<span class="hljs-comment">##########</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Swan</span>:</span>    <span class="hljs-comment">#定义私有成员</span>    __neckSwan = <span class="hljs-string">&#x27;天鹅的脖子很长&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        print(<span class="hljs-string">&quot;__init__()&quot;</span>,self.__neckSwan)swan = Swan()print(<span class="hljs-string">&#x27;直接访问&#x27;</span>,swan._Swan__neckSwan)</code></pre><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, color</span>):</span>        self.color = color        print(<span class="hljs-string">&#x27;我是水果&#x27;</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">havest</span>(<span class="hljs-params">self</span>):</span>        print(<span class="hljs-string">&#x27;水果是&#x27;</span>, self.color, <span class="hljs-string">&#x27;色的&#x27;</span>)<span class="hljs-comment">#类Orange，子类，继承于Fruit类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Orange</span>(<span class="hljs-params">Fruit</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-comment"># super(Orange, self).__init__()</span>        <span class="hljs-comment"># 调用基类的初始化方法</span>        <span class="hljs-built_in">super</span>().__init__(<span class="hljs-string">&#x27;橙&#x27;</span>)        print(<span class="hljs-string">&#x27;我是Orange&#x27;</span>)    <span class="hljs-comment">#重写方法</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">havest</span>(<span class="hljs-params">self</span>):</span>        print(<span class="hljs-string">&#x27;橙子是&#x27;</span>, self.color, <span class="hljs-string">&#x27;色的&#x27;</span>)orange = Orange()orange.havest()<span class="hljs-comment">####输出</span><span class="hljs-comment">#我是水果</span><span class="hljs-comment">#我是Orange</span><span class="hljs-comment">#橙子是 橙 色的</span></code></pre><ul><li>当要继承多个父类的时候，在小括号内类名用逗号分隔开</li><li>如果不指定时，默认继承于所有Python对象的基类Object</li></ul><h3 id="判断实例与类的关系"><a href="#判断实例与类的关系" class="headerlink" title="判断实例与类的关系"></a>判断实例与类的关系</h3><pre><code class="hljs python">print(<span class="hljs-built_in">type</span>(orange))               <span class="hljs-comment">#&lt;class &#x27;__main__.Orange&#x27;&gt;</span>print(<span class="hljs-built_in">isinstance</span>(orange, Orange)) <span class="hljs-comment">#True</span>print(<span class="hljs-built_in">isinstance</span>(orange, Fruit))  <span class="hljs-comment">#True</span></code></pre><h3 id="property-装饰器"><a href="#property-装饰器" class="headerlink" title="@property(装饰器)"></a>@property(装饰器)</h3><p>在Python中可以通过 <code>@property</code>(装饰器) 将一个方法转换为属性，从而实现用于计算的属性。</p><p>将方法转换为属性之后，可以直接通过方法名来访问方法，不再需要小括号<code>()</code></p><ul><li>通过 @property 转换的属性不能够直接赋值，否则会报错</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rect</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, width, heigh</span>):</span>        self.width = width        self.heigh = heigh<span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">area</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> self.width * self.heighrect = Rect(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>)print(<span class="hljs-string">&#x27;面积为：&#x27;</span>, rect.area)<span class="hljs-comment">#print(&#x27;面积为：&#x27;, rect.area()) # 执行错误</span>                               <span class="hljs-comment"># TypeError: &#x27;int&#x27; object is not callable</span></code></pre><h3 id="property-装饰器-创建只读但不能修改的属性"><a href="#property-装饰器-创建只读但不能修改的属性" class="headerlink" title="@property(装饰器)创建只读但不能修改的属性"></a>@property(装饰器)创建只读但不能修改的属性</h3><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TVshow</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, show</span>):</span>        self.__show = show<span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> self.__showtvshow = TVshow(<span class="hljs-string">&#x27;哪吒传奇之魔童降世&#x27;</span>)<span class="hljs-comment"># print(tvshow.__show) 错误</span><span class="hljs-comment"># print(tvshow.show()) 错误</span>print(tvshow.show)</code></pre><h3 id="自定义with语句"><a href="#自定义with语句" class="headerlink" title="自定义with语句"></a>自定义with语句</h3><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Testwith</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span>(<span class="hljs-params">self</span>):</span>        print(<span class="hljs-string">&#x27;开始&#x27;</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):</span>        <span class="hljs-keyword">if</span> exc_tb <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            print(<span class="hljs-string">&#x27;正常结束&#x27;</span>)        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">&#x27;出现异常 %s&#x27;</span> %(exc_tb))<span class="hljs-keyword">with</span> Testwith():    print(<span class="hljs-string">&#x27;测试自定义with语句&#x27;</span>)    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;手动出现异常&#x27;</span>)    <span class="hljs-comment">#####  结果</span><span class="hljs-comment"># 开始</span><span class="hljs-comment"># Traceback (most recent call last):</span><span class="hljs-comment"># 测试自定义with语句</span><span class="hljs-comment"># 出现异常 &lt;traceback object at 0x000002618D1AC188&gt;</span><span class="hljs-comment">#   File &quot;E:/Code/Python/test/mywith.py&quot;, line 12, in &lt;module&gt;</span><span class="hljs-comment">#     raise Exception(&#x27;手动出现异常&#x27;)</span><span class="hljs-comment"># Exception: 手动出现异常</span></code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><pre><code class="hljs xl">#<span class="hljs-keyword">import</span> 模块名称<span class="hljs-keyword">import</span> <span class="hljs-built_in">time</span>#<span class="hljs-keyword">import</span> 模块名称 <span class="hljs-keyword">as</span> 重命名<span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> m#from 模块名称 <span class="hljs-keyword">import</span> 方法名<span class="hljs-keyword">import</span> <span class="hljs-built_in">time</span> <span class="hljs-keyword">import</span> sleep#导入自定义模块：#将自定义的变量和函数编写在一个单独的文件之中，创建成模块名+.py的形式# 然后参照上面的语法导入</code></pre><p><img src="/Python/modules.png"></p><h3 id="Python日常应用比较广泛的模块"><a href="#Python日常应用比较广泛的模块" class="headerlink" title="Python日常应用比较广泛的模块"></a>Python日常应用比较广泛的模块</h3><ol><li>文字的处理：re</li><li>日期类型：time、datetime</li><li>数字和数学类型：math、random</li><li>文件和目录的访问：pathlib、os.path</li><li>数据压缩和归档：tarfile</li><li>通用操作系统：os、logging、argparse</li><li>多线程：threading、queue</li><li>Internet数据处理：base64、json、urllib</li><li>结构化标记处理工具：html、xml</li><li>开发工具：unitest</li><li>调试工具：timeit</li><li>软件包的发布：venv</li><li>运行服务的 <code>__main__</code></li></ol><h2 id="正则表达式-re"><a href="#正则表达式-re" class="headerlink" title="正则表达式 - re"></a>正则表达式 - re</h2><p>正则表达式可以用来处理符合某些规则的字符串。</p><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><pre><code class="hljs python"><span class="hljs-built_in">compile</span>(pattern[, flags]) <span class="hljs-comment">#根据包含正则表达式的字符串创建模式对象</span>search(pattern, string[, flags]) <span class="hljs-comment">#在字符串中查找模式</span>match(pattern, string[, flags]) <span class="hljs-comment">#在字符串开头匹配模式</span>split(pattern, string[, maxsplit=<span class="hljs-number">0</span>]) <span class="hljs-comment">#根据模式来分割字符串</span>findall(pattern, string)<span class="hljs-comment">#返回一个列表，其中包含字符串中所有与模式匹配的子串</span>sub(pat, repl, string[, count=<span class="hljs-number">0</span>])<span class="hljs-comment">#将字符串中与模式pat匹配的子串都替换为repl</span>escape(string) <span class="hljs-comment">#对字符串中所有的正则表达式特殊字符都进行转义</span></code></pre><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p><img src="/Python/yuanzifu.png"></p><center>↑常用元字符</center>![](Python/xiandingfu.png)<center>↑常用限定符</center>### 实例代码<pre><code class="hljs python"><span class="hljs-keyword">import</span> re<span class="hljs-comment">#定义要匹配的字符串hell</span><span class="hljs-comment"># p = re.compile(&#x27;hell&#x27;)</span><span class="hljs-comment"># print(p.match(&#x27;hello&#x27;)) #&lt;re.Match object; span=(0, 4), match=&#x27;hell&#x27;&gt;</span><span class="hljs-comment"># 一个点 .  --&gt;一个点可以匹配任意一个字符</span>p = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;.&#x27;</span>)print(p.match(<span class="hljs-string">&#x27;a&#x27;</span>)) <span class="hljs-comment">#&lt;re.Match object; span=(0, 1), match=&#x27;a&#x27;&gt;</span>p1 = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;..&#x27;</span>)print(p1.match(<span class="hljs-string">&#x27;baa&#x27;</span>)) <span class="hljs-comment">#&lt;re.Match object; span=(0, 2), match=&#x27;ba&#x27;&gt;</span>p2 = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;.&#123;3&#125;&#x27;</span>)print(p2.match(<span class="hljs-string">&#x27;a12a&#x27;</span>)) <span class="hljs-comment">#&lt;re.Match object; span=(0, 3), match=&#x27;a12&#x27;&gt;</span><span class="hljs-comment"># ^ 从开头向后搜索  p = re.compile(&#x27;^&#x27;)</span><span class="hljs-comment"># $ 从结尾向前扩展  p = re.compile(&#x27;jpg$&#x27;)  匹配到以jpg结尾的图片</span><span class="hljs-comment"># *  --&gt; 匹配*前面的字符 0次或多次</span>p = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;ca*t&#x27;</span>)print(p.match(<span class="hljs-string">&#x27;caaaaaat&#x27;</span>)) <span class="hljs-comment">#&lt;re.Match object; span=(0, 8), match=&#x27;caaaaaat&#x27;&gt;</span><span class="hljs-comment"># +  --&gt; 匹配+前面的字符 1次或多次</span>p = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;ca+t&#x27;</span>)print(p.match(<span class="hljs-string">&#x27;caaaaaat&#x27;</span>)) <span class="hljs-comment">#&lt;re.Match object; span=(0, 8), match=&#x27;caaaaaat&#x27;&gt;</span>print(p.match(<span class="hljs-string">&#x27;ct&#x27;</span>))  <span class="hljs-comment">#None</span><span class="hljs-comment"># ?  --&gt; 匹配?前面的字符 0次或1次</span>p = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;c?t&#x27;</span>)print(p.match(<span class="hljs-string">&#x27;caat&#x27;</span>)) <span class="hljs-comment">#None</span>print(p.match(<span class="hljs-string">&#x27;ctt&#x27;</span>))  <span class="hljs-comment">#&lt;re.Match object; span=(0, 2), match=&#x27;ct&#x27;&gt;</span><span class="hljs-comment"># &#123;n&#125; --&gt; 匹配前面的字符出现n次</span>p = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;ca&#123;4&#125;t&#x27;</span>)print(p.match(<span class="hljs-string">&#x27;caaaat&#x27;</span>)) <span class="hljs-comment">#&lt;re.Match object; span=(0, 6), match=&#x27;caaaat&#x27;&gt;</span>print(p.match(<span class="hljs-string">&#x27;caaaaaat&#x27;</span>)) <span class="hljs-comment">#None</span><span class="hljs-comment"># &#123;m,n&#125; --&gt; 匹配前面的字符出现m~n次之间</span>p = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;ca&#123;4,6&#125;t&#x27;</span>)print(p.match(<span class="hljs-string">&#x27;caaaat&#x27;</span>)) <span class="hljs-comment">#&lt;re.Match object; span=(0, 6), match=&#x27;caaaat&#x27;&gt;</span>print(p.match(<span class="hljs-string">&#x27;caaaaaat&#x27;</span>)) <span class="hljs-comment">#&lt;re.Match object; span=(0, 8), match=&#x27;caaaaaat&#x27;&gt;</span><span class="hljs-comment"># []</span>p = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;c[abc]t&#x27;</span>)print(p.match(<span class="hljs-string">&#x27;cat&#x27;</span>)) <span class="hljs-comment">#&lt;re.Match object; span=(0, 3), match=&#x27;cat&#x27;&gt;</span>print(p.match(<span class="hljs-string">&#x27;cct&#x27;</span>)) <span class="hljs-comment">#&lt;re.Match object; span=(0, 3), match=&#x27;cct&#x27;&gt;</span>print(p.match(<span class="hljs-string">&#x27;cdt&#x27;</span>)) <span class="hljs-comment">#None</span><span class="hljs-comment"># \d --&gt;表示匹配的字符是一串数字</span><span class="hljs-comment"># \D --&gt; 表示匹配不包括这一串数字</span><span class="hljs-comment"># \s --&gt; 表示匹配一串字符串</span><span class="hljs-comment"># () --&gt; 正则分组</span><span class="hljs-comment">#  | --&gt; 表示或者</span><span class="hljs-comment"># ^$  --&gt; 组合在一起，表示这一段是空行</span><span class="hljs-comment"># .*?  --&gt; 不使用贪婪模式</span><span class="hljs-comment"># 正则分组</span>p = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;\d-\d-\d&#x27;</span>)print(p.match(<span class="hljs-string">&#x27;2019-08-24&#x27;</span>)) <span class="hljs-comment">#None</span>p1 = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;(\d+)-(\d+)-(\d+)&#x27;</span>)print(p1.match(<span class="hljs-string">&#x27;2019-08-24&#x27;</span>)) <span class="hljs-comment">#&lt;re.Match object; span=(0, 10), match=&#x27;2019-08-24&#x27;&gt;</span>print(p1.match(<span class="hljs-string">&#x27;2019-08-24&#x27;</span>).group()) <span class="hljs-comment">#2019-08-24</span>print(p1.match(<span class="hljs-string">&#x27;2019-08-24&#x27;</span>).group(<span class="hljs-number">2</span>)) <span class="hljs-comment">#08</span>year, month, day = p1.match(<span class="hljs-string">&#x27;2019-08-24&#x27;</span>).groups()print(year) <span class="hljs-comment">#2019</span><span class="hljs-comment"># 搜索指定的字符串</span>p1 = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;(\d+)-(\d+)-(\d+)&#x27;</span>)print(p1.match(<span class="hljs-string">&#x27;aa2019-08-24nn&#x27;</span>)) <span class="hljs-comment">#None</span>print(p1.search(<span class="hljs-string">&#x27;aa2019-08-24nn&#x27;</span>)) <span class="hljs-comment">#&lt;re.Match object; span=(2, 12), match=&#x27;2019-08-24&#x27;&gt;</span><span class="hljs-comment"># 字符串替换</span>phone = <span class="hljs-string">&#x27;123-456-789 # 这是一串字符串&#x27;</span>p2 = re.sub(<span class="hljs-string">r&#x27;#.*$&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, phone)print(p2) <span class="hljs-comment">#123-456-789</span>p3 = re.sub(<span class="hljs-string">r&#x27;\D&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, p2)print(p3) <span class="hljs-comment">#123456789</span></code></pre><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote><p><a href="https://blog.csdn.net/jamfiy/article/details/88139202">python基础（re模块（正则表达式））</a></p><p><a href="https://www.cnblogs.com/dyfblog/p/5880728.html">python正则表达式详解</a></p></blockquote><h2 id="时间相关的库"><a href="#时间相关的库" class="headerlink" title="时间相关的库"></a>时间相关的库</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> timeprint(time.time()) <span class="hljs-comment">#输出现在与1970年1月1日相差的秒数</span>print(time.localtime()) <span class="hljs-comment">#time.struct_time(tm_year=2019, tm_mon=8, tm_mday=25, tm_hour=9, tm_min=45, tm_sec=9, tm_wday=6, tm_yday=237, tm_isdst=0)</span>print(time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H-%M-%S&#x27;</span>))<span class="hljs-comment">#格式化输出：2019-08-25 09-45-09</span><span class="hljs-keyword">import</span> datetimeprint(datetime.datetime.now()) <span class="hljs-comment">#22019-08-25 09:48:03.377347</span>newTime = datetime.timedelta(minutes=<span class="hljs-number">10</span>)print(datetime.datetime.now() + newTime) <span class="hljs-comment">#2019-08-25 09:58:03.377347</span>one_day = datetime.datetime(<span class="hljs-number">2008</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>)newDate = datetime.timedelta(days=<span class="hljs-number">10</span>)print((one_day + newDate)) <span class="hljs-comment">#2008-10-11 00:00:00</span></code></pre><blockquote><p> 参考链接：<a href="https://www.cnblogs.com/sunshine-blog/p/8477893.html">Python中处理日期时间库的使用方法（转载）</a></p></blockquote><h2 id="random库"><a href="#random库" class="headerlink" title="random库"></a>random库</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<span class="hljs-keyword">import</span> string<span class="hljs-comment"># 随机整数：</span><span class="hljs-built_in">print</span> (random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">50</span>))<span class="hljs-comment"># 随机选取0到100间的偶数：</span><span class="hljs-built_in">print</span> (random.randrange(<span class="hljs-number">0</span>, <span class="hljs-number">101</span>, <span class="hljs-number">2</span>))<span class="hljs-comment"># 随机浮点数：</span><span class="hljs-built_in">print</span> (random.random())<span class="hljs-built_in">print</span> (random.uniform(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))<span class="hljs-comment"># 随机字符：</span><span class="hljs-built_in">print</span> (random.choice(<span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz!@#$%^&amp;*()&#x27;</span>))<span class="hljs-comment"># 多个字符中生成指定数量的随机字符：</span><span class="hljs-built_in">print</span> (random.sample(<span class="hljs-string">&#x27;zyxwvutsrqponmlkjihgfedcba&#x27;</span>,<span class="hljs-number">5</span>))<span class="hljs-comment"># 从a-zA-Z0-9生成指定数量的随机字符：</span>ran_str = <span class="hljs-string">&#x27;&#x27;</span>.join(random.sample(string.ascii_letters + string.digits, <span class="hljs-number">8</span>))<span class="hljs-built_in">print</span> (ran_str)<span class="hljs-comment"># 多个字符中选取指定数量的字符组成新字符串：</span><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;&#x27;</span>.join(random.sample([<span class="hljs-string">&#x27;z&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;k&#x27;</span>,<span class="hljs-string">&#x27;j&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>], <span class="hljs-number">5</span>)))<span class="hljs-comment"># 随机选取字符串：</span><span class="hljs-built_in">print</span> (random.choice([<span class="hljs-string">&#x27;剪刀&#x27;</span>, <span class="hljs-string">&#x27;石头&#x27;</span>, <span class="hljs-string">&#x27;布&#x27;</span>]))<span class="hljs-comment"># 打乱排序</span>items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>]<span class="hljs-built_in">print</span> (random.shuffle(items))</code></pre><h2 id="文件目录操作"><a href="#文件目录操作" class="headerlink" title="文件目录操作"></a>文件目录操作</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> osprint(os.path.abspath(<span class="hljs-string">&#x27;.&#x27;</span>)) <span class="hljs-comment">#获取当前的绝对路径 E:\Code\Python\test</span>print(os.path.exists(<span class="hljs-string">r&#x27;E:\Code\Python\test&#x27;</span>)) <span class="hljs-comment">#判断文件或者目录是否存在</span>print(os.path.isfile(<span class="hljs-string">r&#x27;E:\Code\Python\test&#x27;</span>)) <span class="hljs-comment">#判断是否是文件</span>print(os.path.isdir(<span class="hljs-string">r&#x27;E:\Code\Python\test&#x27;</span>)) <span class="hljs-comment">#判断是否是目录</span>print(os.path.join(<span class="hljs-string">&#x27;/tmp/a&#x27;</span>,<span class="hljs-string">r&#x27;Python\test&#x27;</span>)) <span class="hljs-comment">#连接路径 /tmp/a\Python\test</span><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Pathp = Path(<span class="hljs-string">&#x27;.&#x27;</span>)print(p.resolve()) <span class="hljs-comment">#E:\Code\Python\test</span>q = Path(<span class="hljs-string">r&#x27;E:\Code\Python\test\a&#x27;</span>)Path.mkdir(q, parents=<span class="hljs-literal">True</span>) <span class="hljs-comment">#创建目录</span></code></pre><h2 id="机器学习库"><a href="#机器学习库" class="headerlink" title="机器学习库"></a>机器学习库</h2><h3 id="numpy库"><a href="#numpy库" class="headerlink" title="numpy库"></a><strong>numpy库</strong></h3><p><strong>Numpy</strong>用于高性能科学计算和数据分析，是常用的高级数据分析的基础包。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> nparr1 = np.array([<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])print(arr1)   <span class="hljs-comment">#[2 3 4]</span>print(<span class="hljs-built_in">type</span>(arr1)) <span class="hljs-comment">#&lt;class &#x27;numpy.ndarray&#x27;&gt;</span>print(arr1.dtype) <span class="hljs-comment">#int32</span>arr2 = np.array([<span class="hljs-number">1.2</span>,<span class="hljs-number">2.3</span>,<span class="hljs-number">3.8</span>])print(arr2)print(arr2.dtype) <span class="hljs-comment">#float64</span><span class="hljs-comment">#Numpy的算数运算：两个数组可以可以做算数运算</span>print(arr1+arr2) <span class="hljs-comment">#[3.2 5.3 7.8]</span>print(arr2 * <span class="hljs-number">10</span>) <span class="hljs-comment">#[12. 23. 38.]</span><span class="hljs-comment"># N维数组</span>data = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]arr3 = np.array(data) <span class="hljs-comment">#转化为一个二维矩阵</span>print(arr3)print(arr3.shape) <span class="hljs-comment">#(2, 3)</span>print(arr3.dtype) <span class="hljs-comment">#int32</span><span class="hljs-comment">#生成特殊的值</span>print(np.zeros(<span class="hljs-number">10</span>)) <span class="hljs-comment">#[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]</span>print(np.zeros((<span class="hljs-number">3</span>,<span class="hljs-number">5</span>))) <span class="hljs-comment">#三行五列的矩阵值全为0</span>print(np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">5</span>))) <span class="hljs-comment">#三行五列的矩阵值全为1</span>print( np.empty((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)) )<span class="hljs-comment">#设置为空，会随机填充</span><span class="hljs-comment">#通过下标访问，arange()函数，切片操作</span>arr = np.arange(<span class="hljs-number">10</span>)print(arr)print(arr[<span class="hljs-number">1</span>]) <span class="hljs-comment"># 1</span>print(<span class="hljs-built_in">type</span>(np.arange(<span class="hljs-number">10</span>))) <span class="hljs-comment">#&lt;class &#x27;numpy.ndarray&#x27;&gt;</span>arr4 = np.arange(<span class="hljs-number">10</span>)print(arr4[<span class="hljs-number">5</span>:<span class="hljs-number">8</span>]) <span class="hljs-comment">#[5 6 7]</span><span class="hljs-comment">#复制操作</span>arr_slie = arr4[<span class="hljs-number">3</span>:<span class="hljs-number">9</span>].copy()print(arr_slie) <span class="hljs-comment">#[3 4 5 6 7 8]</span>arr_slie[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>print(arr_slie) <span class="hljs-comment">#[3 0 0 0 7 8]</span>arrs = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]])print(arrs.shape) <span class="hljs-comment">#(3, 3)</span><span class="hljs-comment">#将多维数组转换为一维数组</span>arrs2 = arrs.flatten()print(arrs2)       <span class="hljs-comment">#[1 2 3 4 5 6 7 8 9]</span>print(<span class="hljs-built_in">type</span>(arrs2)) <span class="hljs-comment">#&lt;class &#x27;numpy.ndarray&#x27;&gt;</span></code></pre><blockquote><p>参考链接：</p><p><a href="https://www.cnblogs.com/yuxuefeng/articles/9235431.html">Python入门：Anaconda和Pycharm的安装和配置</a></p><p><a href="https://blog.csdn.net/qq_41149269/article/details/81268482">pycharm如何使用anaconda中的各种包</a></p><p><a href="https://blog.csdn.net/promisexb/article/details/80768874">pycharm使用Anaconda的配置环境</a></p></blockquote><h3 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h3><p><a href="https://www.pypandas.cn/">Pandas</a>是一个强大的分析结构化数据的工具集；它的使用基础是Numpy（提供高性能的矩阵运算）；用于数据挖掘和数据分析，同时也提供数据清洗功能.</p><p><strong>Series</strong>:它是一种类似于一维数组的对象，是由一组数据(各种NumPy数据类型)以及一组与之相关的数据标签(即索引)组成。仅由一组数据也可产生简单的Series对象。</p><p><strong>DataFrame</strong>是Pandas中的一个表格型的数据结构，包含有一组有序的列，每列可以是不同的值类型(数值、字符串、布尔型等)，DataFrame即有行索引也有列索引，可以被看做是由Series组成的字典。</p><h3 id="pandas的Series"><a href="#pandas的Series" class="headerlink" title="pandas的Series"></a>pandas的Series</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> pandas <span class="hljs-keyword">import</span> Series,DataFrame<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pdobj = Series([<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,-<span class="hljs-number">7</span>])print(obj)<span class="hljs-comment"># 会自动添加索引，但是索引可以重复</span><span class="hljs-comment"># 0    4</span><span class="hljs-comment"># 1    5</span><span class="hljs-comment"># 2    6</span><span class="hljs-comment"># 3   -7</span><span class="hljs-comment"># dtype: int64</span>print(obj.index) <span class="hljs-comment">#RangeIndex(start=0, stop=4, step=1)</span>print(obj.values) <span class="hljs-comment">#[ 4  5  6 -7]</span><span class="hljs-comment"># 生成时同时指定索引</span>obj2 = Series([<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>],index=[<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>])print(obj2)<span class="hljs-comment"># d    4</span><span class="hljs-comment"># b    5</span><span class="hljs-comment"># c    6</span><span class="hljs-comment"># a    7</span><span class="hljs-comment"># dtype: int64</span>print(<span class="hljs-built_in">type</span>(obj2)) <span class="hljs-comment">#&lt;class &#x27;pandas.core.series.Series&#x27;&gt;</span><span class="hljs-comment">#通过索引来改变值</span>obj2[<span class="hljs-string">&#x27;c&#x27;</span>] = <span class="hljs-number">2</span>print(obj2)<span class="hljs-comment">#使用 in 操作符判断索引是否在obj2中，但是无法识别value</span>print(<span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">in</span> obj2)<span class="hljs-comment">#将字典转化成</span>stata = &#123;<span class="hljs-string">&#x27;aa&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;bb&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;cc&#x27;</span>:<span class="hljs-number">3</span>&#125;obj3 = Series(stata)print(obj3)<span class="hljs-comment">#重新进行索引排序</span>obj4 = Series([<span class="hljs-number">4.5</span>,<span class="hljs-number">5.3</span>,<span class="hljs-number">1.2</span>,-<span class="hljs-number">3.6</span>], index= [<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>])<span class="hljs-comment"># fill_value=使用这个值进行填充索引存在但值不存在的那些。</span>obj5 = obj4.reindex([<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>], fill_value=<span class="hljs-number">0</span>)print(obj5)obj6 = Series([<span class="hljs-string">&#x27;blue&#x27;</span>,<span class="hljs-string">&#x27;black&#x27;</span>,<span class="hljs-string">&#x27;white&#x27;</span>], index=[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>])<span class="hljs-comment"># method=&#x27;ffill&#x27;是以上面的值作为填充</span>print(obj6.reindex(<span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>) , method=<span class="hljs-string">&#x27;ffill&#x27;</span>))<span class="hljs-comment"># method=&#x27;bfill&#x27;是以下面的值作为填充</span>print(obj6.reindex(<span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>) , method=<span class="hljs-string">&#x27;bfill&#x27;</span>))<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> nan <span class="hljs-keyword">as</span> NAobj7 = Series([<span class="hljs-number">1</span>,NA,<span class="hljs-number">3</span>])print(obj7)<span class="hljs-comment">#删除NaN这个值</span>print(obj7.dropna())<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment">#层次化索引</span>fram5 = Series(np.random.randn(<span class="hljs-number">10</span>),               index=[[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>],                      [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]])print(fram5)print(fram5[<span class="hljs-string">&#x27;b&#x27;</span>])print(fram5[<span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-string">&#x27;c&#x27;</span>])<span class="hljs-comment">#将一维的数据转换为二维数据</span>print(fram5.unstack())<span class="hljs-comment">#将二维的数据转换为一维数据</span>print(fram5.unstack().stack())</code></pre><h3 id="pandas的DataFram"><a href="#pandas的DataFram" class="headerlink" title="pandas的DataFram"></a>pandas的DataFram</h3><pre><code class="hljs python"><span class="hljs-comment">#字典</span>data = &#123;<span class="hljs-string">&#x27;city&#x27;</span>:[<span class="hljs-string">&#x27;shanghai&#x27;</span>,<span class="hljs-string">&#x27;guangdong&#x27;</span>,<span class="hljs-string">&#x27;shenzhen&#x27;</span>,<span class="hljs-string">&#x27;beijing&#x27;</span>],        <span class="hljs-string">&#x27;year&#x27;</span>:[<span class="hljs-number">2013</span>,<span class="hljs-number">2015</span>,<span class="hljs-number">2017</span>,<span class="hljs-number">2019</span>],        <span class="hljs-string">&#x27;pop&#x27;</span>:[<span class="hljs-number">1.1</span>,<span class="hljs-number">1.3</span>,<span class="hljs-number">1.5</span>,<span class="hljs-number">1.7</span>]&#125;fram = DataFrame(data)print(fram)<span class="hljs-comment">#         city  year  pop</span><span class="hljs-comment"># 0   shanghai  2013  1.1</span><span class="hljs-comment"># 1  guangdong  2015  1.3</span><span class="hljs-comment"># 2   shenzhen  2017  1.5</span><span class="hljs-comment"># 3    beijing  2019  1.7</span>print(<span class="hljs-built_in">type</span>(fram)) <span class="hljs-comment">#&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;</span><span class="hljs-comment">#指定表格的排序规则</span>fram2 = DataFrame(data, columns=[<span class="hljs-string">&#x27;year&#x27;</span>,<span class="hljs-string">&#x27;city&#x27;</span>,<span class="hljs-string">&#x27;pop&#x27;</span>])print(fram2)<span class="hljs-comment">#提取数据</span>print(fram[<span class="hljs-string">&#x27;city&#x27;</span>])print(fram.year)<span class="hljs-comment">#增加新的列</span>fram2[<span class="hljs-string">&#x27;new&#x27;</span>] = <span class="hljs-number">100</span>print(fram2)<span class="hljs-comment">#根据其他列来产生新的列</span>fram2[<span class="hljs-string">&#x27;cap&#x27;</span>] = (fram2.city == <span class="hljs-string">&#x27;beijing&#x27;</span>)print(fram2)<span class="hljs-comment">#将字典转化为DataFram</span>pop = &#123;<span class="hljs-string">&#x27;beijing&#x27;</span>:&#123;<span class="hljs-number">2008</span>:<span class="hljs-number">1.5</span>,<span class="hljs-number">2009</span>:<span class="hljs-number">2.0</span>&#125;,       <span class="hljs-string">&#x27;shanghai&#x27;</span>:&#123;<span class="hljs-number">2008</span>:<span class="hljs-number">2.0</span>,<span class="hljs-number">2009</span>:<span class="hljs-number">3.6</span>&#125;&#125;fram3 = DataFrame(pop)print(fram3)<span class="hljs-comment">#       beijing  shanghai</span><span class="hljs-comment"># 2008      1.5       2.0</span><span class="hljs-comment"># 2009      2.0       3.6</span><span class="hljs-comment">#行列互换：行列式转换</span>print(fram3.T)<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> nan <span class="hljs-keyword">as</span> NAfram4 = DataFrame([[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,NA,NA],[NA,NA,NA]])print(fram4)<span class="hljs-comment">#      0    1    2</span><span class="hljs-comment"># 0  1.0  6.0  5.0</span><span class="hljs-comment"># 1  1.0  NaN  NaN</span><span class="hljs-comment"># 2  NaN  NaN  NaN</span><span class="hljs-comment">#删除含有na的行</span>print(fram4.dropna())<span class="hljs-comment">#      0    1    2</span><span class="hljs-comment"># 0  1.0  6.0  5.0</span><span class="hljs-comment">#删除行的值全部都是na的行</span>print(fram4.dropna(how=<span class="hljs-string">&#x27;all&#x27;</span>))<span class="hljs-comment">#      0    1    2</span><span class="hljs-comment"># 0  1.0  6.0  5.0</span><span class="hljs-comment"># 1  1.0  NaN  NaN</span><span class="hljs-comment"># 使第四列的值全为na</span><span class="hljs-comment"># fram4[4] = NA</span><span class="hljs-comment"># print(fram4)</span><span class="hljs-comment">#删除一列全是na的列</span>print(fram4.dropna(axis=<span class="hljs-number">1</span>, how=<span class="hljs-string">&#x27;all&#x27;</span>))<span class="hljs-comment">#将na填充为数字,默认修改时不会改变本身的，但是添加inplace这个参数就可以改变本身</span>print(fram4.fillna(<span class="hljs-number">0</span>, inplace=<span class="hljs-literal">True</span>))print(fram4)</code></pre><h3 id="matplotlib绘图"><a href="#matplotlib绘图" class="headerlink" title="matplotlib绘图"></a>matplotlib绘图</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-comment">#当产生警告时忽略</span><span class="hljs-keyword">import</span> warningswarnings.filterwarnings(<span class="hljs-string">&#x27;ignore&#x27;</span>)<span class="hljs-comment">#绘制简单的曲线</span>plt.plot([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>])plt.show()</code></pre><p><img src="/Python/matplotlib1.png" alt="1567172852560"></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-comment">#当产生警告时忽略</span><span class="hljs-keyword">import</span> warningswarnings.filterwarnings(<span class="hljs-string">&#x27;ignore&#x27;</span>)x = np.linspace(-np.pi,np.pi,<span class="hljs-number">100</span>)<span class="hljs-comment"># x轴的定义域为 -3.14到3.14 中间间隔100个元素</span>plt.plot(x, np.sin(x))plt.show()</code></pre><p><img src="/Python/matplotlib2.png" alt="1567173015230"></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment">#当产生警告时忽略</span><span class="hljs-keyword">import</span> warningswarnings.filterwarnings(<span class="hljs-string">&#x27;ignore&#x27;</span>)x = np.linspace(-np.pi * <span class="hljs-number">2</span>, np.pi * <span class="hljs-number">2</span>, <span class="hljs-number">100</span>)<span class="hljs-comment"># x轴的定义域为 -3.14到3.14 中间间隔100个元素</span>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">50</span>)<span class="hljs-comment">#创建图表1，dpi为精度</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>):    plt.plot(x, np.sin(x/i))plt.show()</code></pre><p><img src="/Python/matplotlib3.png" alt="1567173105787"></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-comment">#当产生警告时忽略</span><span class="hljs-keyword">import</span> warningswarnings.filterwarnings(<span class="hljs-string">&#x27;ignore&#x27;</span>)<span class="hljs-comment">#绘制直方图</span>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">50</span>) <span class="hljs-comment">#创建图表1，dpi表示图片精度</span>data = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>]plt.hist(data) <span class="hljs-comment">#只要传入数据，直方图就会统计数据出现的次数</span>plt.show()</code></pre><p><img src="/Python/matplotlib4.png" alt="1567173208283"></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment">#当产生警告时忽略</span><span class="hljs-keyword">import</span> warningswarnings.filterwarnings(<span class="hljs-string">&#x27;ignore&#x27;</span>)<span class="hljs-comment"># 绘制散点图</span>x = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)y = xfig = plt.figure()plt.scatter(x, y, c=<span class="hljs-string">&#x27;r&#x27;</span>, marker=<span class="hljs-string">&#x27;o&#x27;</span>) <span class="hljs-comment">#c = &#x27;r&#x27;表示散点的颜色为红色，marker表示指定散点的形状为原型</span>plt.show()</code></pre><p><img src="/Python/matplotlib5.png" alt="1567173326484"></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<span class="hljs-comment">#当产生警告时忽略</span><span class="hljs-keyword">import</span> warningswarnings.filterwarnings(<span class="hljs-string">&#x27;ignore&#x27;</span>)<span class="hljs-comment">#读取csv格式文件，绘制散点图</span>iris = pd.read_csv(<span class="hljs-string">&#x27;04.CSV&#x27;</span>)print(iris.head()) <span class="hljs-comment">#打印前五行数据</span><span class="hljs-comment">#绘制散点图</span>iris.plot(kind=<span class="hljs-string">&#x27;scatter&#x27;</span>, x=<span class="hljs-string">&#x27;132&#x27;</span>, y=<span class="hljs-string">&#x27;2840&#x27;</span>)plt.show()<span class="hljs-comment">############</span><span class="hljs-comment"># 采用新的库seaborn绘制</span>iris = pd.read_csv(<span class="hljs-string">&#x27;04.CSV&#x27;</span>)<span class="hljs-comment">#设置样式</span>sns.<span class="hljs-built_in">set</span>(style=<span class="hljs-string">&#x27;white&#x27;</span>, color_codes=<span class="hljs-literal">True</span>)<span class="hljs-comment">#设置绘图格式为散点图</span>sns.jointplot(x=<span class="hljs-string">&#x27;132&#x27;</span>, y=<span class="hljs-string">&#x27;2840&#x27;</span>, data=iris, size=<span class="hljs-number">5</span>)<span class="hljs-comment">#displot绘制曲线</span>sns.distplot(iris[<span class="hljs-string">&#x27;132&#x27;</span>])plt.show()<span class="hljs-comment">## 下图是库seaborn绘制的</span></code></pre><p><img src="/Python/matplotlib6.png" alt="1567173639044"></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<span class="hljs-comment">#当产生警告时忽略</span><span class="hljs-keyword">import</span> warningswarnings.filterwarnings(<span class="hljs-string">&#x27;ignore&#x27;</span>)iris = pd.read_csv(<span class="hljs-string">&#x27;04.CSV&#x27;</span>)<span class="hljs-comment">#设置样式</span>sns.<span class="hljs-built_in">set</span>(style=<span class="hljs-string">&#x27;white&#x27;</span>, color_codes=<span class="hljs-literal">True</span>)<span class="hljs-comment"># #FacetGrid 是一般的绘图函数</span><span class="hljs-comment"># #hue 彩色显示分类0/1/2</span><span class="hljs-comment"># #plt.scatter 绘制散点图</span><span class="hljs-comment"># #add_legend 显示分类的描述信息</span><span class="hljs-comment"># #map用来指定行列</span>sns.FacetGrid(iris, hue=<span class="hljs-string">&#x27;11&#x27;</span>, size=<span class="hljs-number">5</span>).<span class="hljs-built_in">map</span>(plt.scatter, <span class="hljs-string">&#x27;132&#x27;</span>, <span class="hljs-string">&#x27;2840&#x27;</span>).add_legend()plt.show()</code></pre><p><img src="/Python/matplotlib7.png" alt="1567173541444"></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小白文</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim编辑器的使用</title>
    <link href="/linux-vim/"/>
    <url>/linux-vim/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：Linux目录结构，各种颜色的对应文件，文件目录操作命令。</p><a id="more"></a><h2 id="vim的三种工作模式"><a href="#vim的三种工作模式" class="headerlink" title="vim的三种工作模式"></a>vim的三种工作模式</h2><ul><li><p>命令模式</p></li><li><p>编辑模式</p></li><li><p>末行模式</p></li></ul><p><img src="/linux-vim/vim.png"></p><h2 id="vim命令模式下的相关操作"><a href="#vim命令模式下的相关操作" class="headerlink" title="vim命令模式下的相关操作"></a>vim命令模式下的相关操作</h2><ul><li>保存退出： ZZ(即shift+zz)</li><li>代码格式化：gg=G</li></ul><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><ul><li>光标移动：左 – H，右 – L，上 – K，下 – J。</li><li>光标移动到首行：0 (数字零)</li><li>光标移动到末尾：$</li><li>光标移动到文件首部：gg</li><li>光标移动到文件尾部：G</li><li>行跳转到123行：123G</li><li>行号n+回车：当前行向下移动n行</li></ul><h3 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h3><ul><li>删除光标后的字符：X (大写的X)</li><li>删除光标前的字符：x (小写的x)</li><li>删除单词：dw  (删除的整个单词光标应该在单词的最前边)</li><li>删除光标前的字符串：d0 (字母d+数字0)</li><li>删除光标后的字符串：d&amp;/dD</li><li>删除光标所在的行：dd</li><li>删除多行：ndd (n代表行数)</li></ul><h3 id="撤销命令"><a href="#撤销命令" class="headerlink" title="撤销命令"></a>撤销命令</h3><ul><li>撤销：u</li><li>反撤销：ctrl+r</li></ul><h3 id="复制和粘贴"><a href="#复制和粘贴" class="headerlink" title="复制和粘贴"></a>复制和粘贴</h3><ul><li>复制一行：yy</li><li>复制多行：nyy</li><li>粘贴到光标的下边一行：p (小写字母p)</li><li>粘贴到光标的上边一行：P (大写字母P)</li></ul><h3 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h3><ul><li>进入可视模式：v</li><li>移动光标：左 – H，右 – L，上 – K，下 – J。</li><li>复制：y</li><li>删除：d</li><li>粘贴到光标的后边：p (小写字母p)</li><li>粘贴到光标的前边：P (大写字母P)</li></ul><h3 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h3><ul><li>替换一个光标盖住的字符：r</li><li>替换多个，从光标盖住的字符往后开始替换：R</li></ul><h3 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h3><ul><li>/xxx</li><li>?xxx</li><li>xxx代表要查找的内容，使用n/N进行切换操作</li><li>光标移动到待搜索的关键字上面，使用 # 按键搜索。</li></ul><h3 id="查看man文档"><a href="#查看man文档" class="headerlink" title="查看man文档"></a>查看man文档</h3><ul><li>章节号 + K</li></ul><h2 id="vim编辑模式"><a href="#vim编辑模式" class="headerlink" title="vim编辑模式"></a>vim编辑模式</h2><p>在命令模式之下输入下列命令就可以切换到编辑模式。</p><ul><li>从光标后开始插入字符： a</li><li>从光标所在行的末尾插入字符： A</li><li>在光标前插入字符：i (小写的i)</li><li>在光标所在的行首插入字符：I (大写的i)</li><li>在光标下创建新行：o (小写的字母o)</li><li>在光标上创建新行：O (大写字母O)</li><li>删除光标盖住的字符：s (小写的s)</li><li>删除光标所在的行：S (大写S)</li></ul><h2 id="vim末行模式"><a href="#vim末行模式" class="headerlink" title="vim末行模式"></a>vim末行模式</h2><p>在命令模式之下，键盘输入冒号 ( : ) 就可以进入末行模式。</p><h3 id="保存退出"><a href="#保存退出" class="headerlink" title="保存退出"></a>保存退出</h3><ul><li>保存不退出：w</li><li>退出： q</li><li>退出不保存： q!</li><li>保存退出： wq  或者  x</li></ul><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><ul><li>替换光标所在行的字符串： <code>:s/old/new/gc</code><ul><li>old 是要替换的字符串</li><li>new 是新的字符串</li><li>替换当前行所有的old： g</li><li>替换的时候添加提示信息： c</li></ul></li><li>替换一个范围内的字符串： <code>:x,ys/old/new/gc</code><ul><li>x,y是一个行数的范围</li></ul></li><li>替换当前文档所有的字符： <code>:%s/old/new/gc</code></li></ul><h3 id="分屏操作"><a href="#分屏操作" class="headerlink" title="分屏操作"></a>分屏操作</h3><ul><li>对当前文件进行分屏：sp – 水平分屏，vsp – 垂直分屏</li><li>两个屏幕显示不同的文件：<ul><li>水平显示： sp 文件名</li><li>垂直显示： vsp 文件名</li></ul></li><li>屏幕关闭：qall – 关闭所有，wqall – 保存关闭所有</li><li>屏幕的切换：ctrl + w + w</li><li>使用vim打开文件时就分屏<ul><li>水平分屏：vim -on  文件名1  文件名2</li><li>垂直分屏：vim  -On  文件名1  文件名2</li><li>n只分屏的个数，可以省略</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小白文</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一位十进制加减法计算器(电路+连线)|数电课设</title>
    <link href="/e-design/"/>
    <url>/e-design/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：一位十进制加减法计算器的设计思路，Multisim仿真以及最后的实物联接。</p><a id="more"></a><h2 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h2><p>设计一个一位数的十进制的加减法计算器，能够显示输入的数值以及最终的计算结果。</p><p><img src="/e-design/e-design%5Ce-chart.png" alt="电路框图"></p><h2 id="提供器件"><a href="#提供器件" class="headerlink" title="提供器件"></a>提供器件</h2><pre><code class="hljs ada">一片 <span class="hljs-number">74</span>LS04  <span class="hljs-comment">---- 六输入反相器</span>一片 <span class="hljs-number">74</span>LS08  <span class="hljs-comment">---- 二输入四与门</span>三片 <span class="hljs-number">74</span>LS47  <span class="hljs-comment">---- BCD-7段数码管译码器</span>一片 <span class="hljs-number">74</span>LS54  <span class="hljs-comment">---- 与或非门</span>两片 <span class="hljs-number">74</span>LS86  <span class="hljs-comment">---- 二输入四异或门</span>两片 <span class="hljs-number">74</span>LS283 <span class="hljs-comment">---- 四位超前进位加法器</span>四个 共阳极数码管 <span class="hljs-comment">---- 显示数字</span>十个 <span class="hljs-number">5.1</span>千欧电阻五个 <span class="hljs-number">300</span>欧电阻三个 四位拨码开关一个 四节电池盒一块 面包板</code></pre><h2 id="加法运算思路"><a href="#加法运算思路" class="headerlink" title="加法运算思路"></a>加法运算思路</h2><p>两个一位十进制的数相加一共有 <code>0 - 18</code>  这十九种结果。</p><p>输入方式的话只能够选择通过四位拨码开关调整输入，即输入的 <code>0-9</code> 都是二进制代码表示的。</p><p>实验要求要<strong>显示输入的数字</strong>，直接可以 <code>四位拨码开关</code> 直接连接 <code>74LS47</code> 芯片，这个芯片直接连接 <code>共阳极数码管</code> 就可以显示我们输入的每一个数字。</p><p>加法要通过 <code>74LS283</code> 这个芯片求得结果，如果直接把输入的两个数接到 <code>74LS283</code> 的两个四输入端口处的话，计算的结果直接就是 <code>0 - 18</code>  的二进制BCD码，但是与之对应的共阳极数码管就会显示出现问题。</p><p>要求其中的一个数码管 <code>不显示</code> 或者显示 <code>1</code> ，另一个数码管要显示 <code>0 - 9</code> 之间的数。那么设计电路就要根据<strong>两数加和的结果对应的二进制码</strong>以及<strong>数码管显示数字对应的二进制码</strong>之间的关系进行设计。</p><p>以下是两者对应的关系：</p><p><img src="/e-design/e-design%5Csum.png"></p><p>设第二个数码管的四个二进制码使用字母D、C、B、A来进行表示，而两数加和结果的四个二进制码使用S3、S2、S1、S0来表示，进位使用C0来表示。</p><p>那么 <code>0-9</code> 之间的数两者之间的转换方式就是 ： <code>DCBA = S3S2S1S0 + 0000</code>。</p><p>剩余 <code>10-18</code> 之间的数两者之间的转换方式是 :   <code>DCBA = S3S2S1S0 + 0110</code>。</p><p>第一个数码管是否显示使用字母A进行表示，<code>A=1</code>代表显示，<code>A=0</code>代表不显示。</p><p>从上面的关系表中可以推倒得出 <code>A = S3·S2 + S3·S1 + C0</code>。<strong>即当S3、S2都为1，或者S3、S1都为1或者进位的结果C0为1时，第一个数码管需要显示1，其余情况不显示。</strong></p><p>为了便于实现电路，可将计算出的A值带入到上面数字的计算公式。因此结果如下：</p><blockquote><p>那么 <code>0-9</code> 之间的数两者之间的转换方式就是 ： <code>DCBA = S3S2S1S0 + 0AA0</code>。此时A=0</p><p>剩余 <code>10-18</code> 之间的数两者之间的转换方式是 :   <code>DCBA = S3S2S1S0 + 0AA0</code>。此时A=1</p></blockquote><h2 id="共阳极数码管的特殊显示"><a href="#共阳极数码管的特殊显示" class="headerlink" title="共阳极数码管的特殊显示"></a>共阳极数码管的特殊显示</h2><p><img src="/e-design/e-design%5Cled.png"></p><p>注意我的数码管是<strong>顺时针旋转90度</strong>放置的，在Multisim上进行测试，得到了上图的结果.</p><h2 id="加法电路图"><a href="#加法电路图" class="headerlink" title="加法电路图"></a>加法电路图</h2><p><img src="/e-design/e-design%5Cjiafa.png" alt="一位十进制加法计算器"></p><p>图中U2、U3是两个输入的数字的显示器，U9组合U8是最后的结果显示。</p><p>两个四位拨码开关来控制输入的数字，并直接显示输入的数字。</p><p>关于上面控制U9数码管显示的电路连接，是因为给定的器件不能够直接连接，所以变换公式后进行连接。</p><p>做到后面发现因为芯片数量的限制，为完成整个电路图，最好使用74LS54芯片。</p><p><img src="/e-design/e-design%5Cjiafa2.png"></p><h2 id="减法运算思路"><a href="#减法运算思路" class="headerlink" title="减法运算思路"></a>减法运算思路</h2><p>两个一位十进制数的加法运算结果是 <code>-9 ~ 9</code> 这19种结果。</p><p>输入方式依旧是通过四位拨码开关调整输入，即输入的 <code>0-9</code> 都是二进制代码表示的。</p><p>但是减法运算与加法运算有一些不同，减法运算是通过<strong>补码</strong>进行计算的，且最终的计算结果也是补码的形式。也就是说涉及两个过程，一是从原码到补码的运算过程，二是从补码到原码的运算过程。</p><h3 id="原码到补码"><a href="#原码到补码" class="headerlink" title="原码到补码"></a>原码到补码</h3><p>通过<strong>四位拨码开关</strong>调整输入的结果就是原码，原码到补码的运算是 <strong>原码数值位取反，然后加1</strong>。由于数字是0-9之间，9占据了四位二进制码，而且输入的上限也是4位，就不再考虑符号位的事情。</p><p>那么两个数A、B的相减的计算公式就是 <code>A - B = A + B反 + 1</code>.</p><p>则利用已经有的芯片，上述公式中B反可以通过输入<strong>B的每一位与1进行异或</strong>操作取得<code>反码</code>。<code>加1</code>可以通过<code>74LS283</code>芯片的进位输入端C0来设置实现。(虽然提供了反相器，但是只有六个，加上后面的取反操作根本不够使用，同时为了电路设计，使用异或是唯一的选择。)</p><h3 id="补码到原码"><a href="#补码到原码" class="headerlink" title="补码到原码"></a>补码到原码</h3><p>从补码到原码，依旧可以<strong>采用数值为取反，然后加1</strong>。取反操作同样是采用与1异或的操作，<code>加1</code>同样通过<code>74LS283</code>芯片的进位输入端C0来设置实现。</p><p>设计电路就要根据<strong>结果即进位输出和补码</strong>以及<strong>数码管显示数字对应的二进制码</strong>之间的关系进行设计。</p><p><img src="/e-design/e-design%5Csub.png"></p><p>从上图可以看出进行减法操作时，当进位输出<code>C4的结果为0</code>时，第一个数码管要显示<strong>负号</strong>。</p><p>分析从74LS283的运算结果到数码管输出需要的结果，<code>0-9</code>时无需变化，而<code>-1 - -9</code>时则需要从补码转换到原码，即需要<strong>数值为取反再加1</strong>。</p><p>因为取反操作可以通过与1做异或进行操作，而且为了方便电路设计，这里的异或操作可以和<strong>进位输出端C4的取反</strong>进行异或。一举两得。<code>加1</code>通过进位输入端C0进行，即C0端连接第一个74LS283的进位输出端的取反。</p><h2 id="减法电路图"><a href="#减法电路图" class="headerlink" title="减法电路图"></a>减法电路图</h2><p><img src="/e-design/e-design%5Cjianfa.png"></p><p>此电路图是在上面加法电路图的基础上进行修改的。只是删去了加法电路的实现部分，此外增加开关S3，它的开关拨为1时表示<strong>进行减法操作</strong>，同时提供 <code>1</code> 来<strong>给被减数进行异或求反的操作</strong>。</p><h2 id="加减法合并电路图"><a href="#加减法合并电路图" class="headerlink" title="加减法合并电路图"></a>加减法合并电路图</h2><p>加减法的控制是通过开关进行的，组合时要求加法电路和减法电路互相不干扰。</p><ol><li>第二个数减法时要转化成补码，加法时不变，所以需要通过<code>74LS86</code>芯片进行异或，与1异或取反，与0异或不变。可以将<code>74LS86</code>芯片的异或门的一端引脚接加减法开关。</li><li>第一个全加器做加法运算时进位输入C0无任何值，而减法运算时需要通过C0端进行加1操作。</li><li>加法电路中用到的<code>74LS54</code>芯片在加法时应当不起任何作用。</li><li>第二个全加器做加法运算时进位输入C0无任何值，而做减法运算时通过第一个<code>74LS283</code>的结果为负数时，第二处的<code>74LS86</code>芯片应当异或门起作用。</li><li>对于加法来说的第二个74LS283芯片的加<code>0110</code>的操作对减法无效。且第二个74LS283芯片的C0输入加法时一直无效。</li><li>显示第一个结果的共阳极数码在加法和减法时应当显示对应的值。</li></ol><p>以上这一部分融合的时候都是要考虑的。通过控制加减法的开关来影响上述大部分的操作。</p><p><img src="/e-design/e-design%5Cjiajian.png"></p><p>不太会排版，所以非常难看，但是功能全部实现了。</p><p>最后连线的实物结果</p><p><img src="/e-design/e-design%5Cjieguo.jpg"></p><p>连线已经非常努力了😭，从开设设计到最后的实物图连接完成，再到最后的debug阶段，直到最后的成功显示，花了大概三天时间，真的有些累。</p><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p>2020-09-20链接更新</p><p>蓝奏云： <a href="https://colourso.lanzous.com/iGKNMgs8oof">https://colourso.lanzous.com/iGKNMgs8oof</a><br>密码:1qyq</p><p>百度云：<a href="https://pan.baidu.com/s/1WqNTEL1lwBR6H46RXRkC0Q">https://pan.baidu.com/s/1WqNTEL1lwBR6H46RXRkC0Q</a> </p><p>提取码:9675</p><p>内含Multisim电路仿真图以及实际连线时会用到的芯片引脚图。</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件下载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础命令</title>
    <link href="/linux-base/"/>
    <url>/linux-base/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：Linux目录结构，Linux用户与用户组，文件目录操作命令，修改权限，文件查找以及压缩指令。</p><a id="more"></a><p><strong>Linux下一切皆文件。</strong></p><h2 id="Linux的一般文件目录的颜色"><a href="#Linux的一般文件目录的颜色" class="headerlink" title="Linux的一般文件目录的颜色"></a>Linux的一般文件目录的颜色</h2><p>我使用的是<code>ubuntu-18.04.2</code>。</p><pre><code class="hljs ada">白色 <span class="hljs-comment">-- 普通文件</span>绿色 <span class="hljs-comment">-- 可执行文件</span>红色 <span class="hljs-comment">-- 压缩文件</span>蓝色 <span class="hljs-comment">-- 目录文件</span>青色 <span class="hljs-comment">-- 链接文件</span>黄色 <span class="hljs-comment">-- 设备文件</span>灰色 <span class="hljs-comment">-- 其他文件</span></code></pre><h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><p><img src="/linux-base/linux-base%5Clinux-catalog.png"></p><pre><code class="hljs jboss-cli"><span class="hljs-string">/root</span> : Linux超级用户的家目录<span class="hljs-string">/bin</span>: binary，二进制文件，有许多可执行程序。<span class="hljs-string">/dev</span>: device，设备。硬盘显卡等设备被抽象成为文件。<span class="hljs-string">/etc</span>：存放配置文件<span class="hljs-params">(/etc/password 密码文件，/etc/group 当前有哪些用户组)</span><span class="hljs-string">/home</span>: linux操作系统所有用户的家目录。<span class="hljs-params">(/home/colorso 我的宿主目录)</span><span class="hljs-string">/lib</span> : Linux运行时会加载的一些动态库<span class="hljs-string">/mnt</span> : 手动挂载的目录，比如嵌入式挂载U盘。<span class="hljs-string">/media</span> : 外设的自动挂载目录<span class="hljs-string">/usr</span> : unix system resourse 资源目录。里面有个games文件夹😁<span class="hljs-string">/opt</span> ： 安装的第三方应用程序<span class="hljs-string">/tmp</span> ： 存放临时文件，重启电脑时目录会清空</code></pre><p>安装Ubuntu的时候就接触了/etc这个目录🙃</p><h2 id="文件或者目录的相关命令"><a href="#文件或者目录的相关命令" class="headerlink" title="文件或者目录的相关命令"></a>文件或者目录的相关命令</h2><ul><li><strong>ls</strong>  –  查看文件与目录</li></ul><p>ls命令可以查看一个文件夹之内的文件与目录。</p><p>常用命令：</p><pre><code class="hljs stata"><span class="hljs-keyword">ls</span> [<span class="hljs-keyword">dir</span>] 直接显示出<span class="hljs-keyword">dir</span>目录下的文件与文件夹，默认以文件名进行排序。<span class="hljs-keyword">ls</span> -al [<span class="hljs-keyword">dir</span>]  将<span class="hljs-keyword">dir</span>目录下的文件，包括隐藏文件以及各个文件的属性显示出来。</code></pre><ul><li><p><code>ll</code> 命令就是 <code>ls -l</code>  的简写，列出一长串数据，包含文件的属性和权限。</p></li><li><p>cd  –  切换目录</p><pre><code class="hljs shell">cd dir #直接进入对应的目录cd /home/用户名 #进入home目录cd ~  #进入home目录cd #进入home目录，什么也不加</code></pre></li><li><p><strong>cp</strong>  –  复制文件或者目录。</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">cp 要拷贝的文件/目录 到达的位置/文件</span>cp file file1(存在)  #file将会覆盖掉file1cp file file1(不存在)  #创建file1,将file中的内容拷贝到file1中cp file dir(目录、存在)  #拷贝file到dir目录中cp dir(存在) dir1(存在)  #将dir整个拷贝到dir1之中，也包括dir这一层目录cp dir(存在) dir1(不存在)  #创建 dir1这个目录，然后把dir中的内容拷贝到dir1之中，不包括dir。</code></pre></li><li><p><strong>mv</strong> –  改名或者移动文件。</p><pre><code class="hljs shell">mv file(存在) file1(不存在) # file文件改名mv dir(目录) dir1(不存在)   # dir目录改名mv file(文件) dir(存在目录)  # 移动文件file到目录dir中mv dir(目录存在) dir1(目录存在) # 目录dir移动到dir1目录中mv file(文件存在) file1(文件存在) # file文件会覆盖file1文件，并且file文件会被删除掉</code></pre></li><li><p><strong>rm</strong> – 删除文件或者目录，删除目录时加上参数 <code>-r</code>。</p><pre><code class="hljs shell">rm dir -r</code></pre></li><li><p><strong>pwd</strong> – 输出当前所在用户路径</p></li><li><p><strong>mkdir</strong> – 创建目录</p><pre><code class="hljs shell">mkdir dir #创建一个目录mkdir dir/dir1/dir2 #目录不存在或者创建多级目录时加上参数 -p</code></pre></li></ul><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>使用 <code>ll</code> 命令时可以看到每一个文件对应的类型。</p><pre><code class="hljs stylus">-  代表普通文件d  代表目录l  代表符号链接，linkfile,类似于windows的快捷方式<span class="hljs-selector-tag">p</span>  代表管道s  代表套接字 socketc  代表字符设备，例如鼠标键盘<span class="hljs-selector-tag">b</span>  代表块设备，例如U盘硬盘</code></pre><h2 id="用户与用户组"><a href="#用户与用户组" class="headerlink" title="用户与用户组"></a>用户与用户组</h2><p>Linux之下一切都是文件，并且Linux是多用户多任务的系统。</p><p>通过用户身份、与该用户所支持的用户组的概念，可以帮助我们让多任务的Linux环境变得更容易管理。</p><pre><code class="hljs pgsql"><span class="hljs-keyword">user</span>  <span class="hljs-comment">-- 文件所有者</span><span class="hljs-keyword">group</span> <span class="hljs-comment">-- 文件所属组用户</span>others <span class="hljs-comment">-- 其他人</span></code></pre><h2 id="修改文件、目录权限"><a href="#修改文件、目录权限" class="headerlink" title="修改文件、目录权限"></a>修改文件、目录权限</h2><h3 id="chmod-–-文字设定法"><a href="#chmod-–-文字设定法" class="headerlink" title="chmod – 文字设定法"></a>chmod – 文字设定法</h3><pre><code class="hljs brainfuck"><span class="hljs-comment">chmod</span>  <span class="hljs-comment">who</span><span class="hljs-title">[</span><span class="hljs-literal">+</span><span class="hljs-comment">|</span><span class="hljs-literal">-</span><span class="hljs-comment">|=</span><span class="hljs-title">]</span><span class="hljs-comment">mode</span>  <span class="hljs-comment">文件名</span><span class="hljs-comment"></span><span class="hljs-comment">这里的who指三种身份：u</span>--<span class="hljs-comment">代表user</span><span class="hljs-string">,</span><span class="hljs-comment">g</span> -- <span class="hljs-comment">group</span><span class="hljs-string">,</span><span class="hljs-comment">o</span> -- <span class="hljs-comment">other</span><span class="hljs-string">,</span><span class="hljs-comment"></span>  <span class="hljs-comment">a</span> -- <span class="hljs-comment">all</span><span class="hljs-string">,</span><span class="hljs-comment">不写时默认就是all。</span><span class="hljs-comment"></span><span class="hljs-literal">+</span><span class="hljs-comment">、</span><span class="hljs-literal">-</span><span class="hljs-comment">、=，三种操作见名知意</span><span class="hljs-comment">mode指修改的执行权限：r</span> -- <span class="hljs-comment">读，w</span> -- <span class="hljs-comment">写，</span> <span class="hljs-comment">x</span> -- <span class="hljs-comment">执行</span><span class="hljs-comment"></span>   <span class="hljs-literal">-</span> -- <span class="hljs-comment">表示没有任何权限</span></code></pre><p><img src="/linux-base/linux-base%5Cchmod1.png"></p><p>上图表示去除test文件的文件所有者以及其他人的执行权限。</p><ul><li>并列的操作可以使用逗号进行分割：<code>chmod u+x,g-x test</code>.</li></ul><h3 id="chmod-–-数字设定法"><a href="#chmod-–-数字设定法" class="headerlink" title="chmod – 数字设定法"></a>chmod – 数字设定法</h3><pre><code class="hljs brainfuck"><span class="hljs-comment">chmod</span>  <span class="hljs-title">[</span><span class="hljs-literal">+</span><span class="hljs-comment">|</span><span class="hljs-literal">-</span><span class="hljs-comment">|=</span><span class="hljs-title">]</span><span class="hljs-comment">mode</span>  <span class="hljs-comment">文件名</span><span class="hljs-comment"></span><span class="hljs-comment"></span><span class="hljs-literal">+</span><span class="hljs-comment">、</span><span class="hljs-literal">-</span><span class="hljs-comment">、=，三种操作见名知意</span><span class="hljs-comment">mode指修改的执行权限，只不过使用数字来代替：</span><span class="hljs-comment">r</span> -- <span class="hljs-comment">4，w</span> -- <span class="hljs-comment">2</span><span class="hljs-string">,</span> <span class="hljs-comment">x</span> -- <span class="hljs-comment">1，</span> <span class="hljs-literal">-</span> -- <span class="hljs-comment">0</span><span class="hljs-string">.</span></code></pre><ul><li>chmod 777 文件名  就表示为文件<code>加满</code>权限。</li></ul><p><img src="/linux-base/linux-base%5Cchmod2.png"></p><p>上图表示对test文件文件所有者加满权限，用户组和其他人只有执行权限。</p><ul><li><strong>如果一个目录没有执行权限，那么这个目录就无法进入</strong>。</li></ul><h3 id="chown-–-修改文件所有者或所属组"><a href="#chown-–-修改文件所有者或所属组" class="headerlink" title="chown – 修改文件所有者或所属组"></a>chown – 修改文件所有者或所属组</h3><ul><li><code>chown  新的所有者  文件名</code></li><li><code>chown  新的所有者:新的组  文件名</code></li></ul><h3 id="chgrp-–-修改文件所属组"><a href="#chgrp-–-修改文件所属组" class="headerlink" title="chgrp – 修改文件所属组"></a>chgrp – 修改文件所属组</h3><ul><li><code>chgrp  新的组  文件名</code></li></ul><h2 id="文件的查找和检索"><a href="#文件的查找和检索" class="headerlink" title="文件的查找和检索"></a>文件的查找和检索</h2><h3 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a>find指令</h3><ul><li><p>按照文件名进行查找</p><pre><code class="hljs linux">find [dir] -name &quot;[names]&quot;dir -- 表示查找的目录names -- 表示查找的文件名</code></pre></li><li><p>按照文件类型查找，linux一共就有7种文件类型</p><pre><code class="hljs linux">find [dir] -type [types]dir -- 表示查找的目录types -- 表示查找的文件类型但是普通文件的对应符号不再是 ll 命令时看到的&#39;-&#39;，而是&#39;f&#39;，其余都相同</code></pre><p><img src="/linux-base/findtype.png"></p></li><li><p>按照文件大小进行查找</p><pre><code class="hljs lua"><span class="hljs-built_in">find</span> [dir] -size +<span class="hljs-number">10</span>M/<span class="hljs-number">-10</span>k/<span class="hljs-number">10</span>kdir <span class="hljs-comment">-- 表示查找的目录</span>+<span class="hljs-number">10</span>M <span class="hljs-comment">-- 表示查找大于10M的文件，</span><span class="hljs-number">-10</span>k <span class="hljs-comment">-- 表示查找小于10k的文件</span><span class="hljs-number">10</span>k <span class="hljs-comment">-- 表示查找等于10k的文件</span></code></pre><ul><li><p>如何查找大于10k小于100k的文件–区间查找</p><pre><code class="hljs arduino"><span class="hljs-built_in">find</span> -<span class="hljs-built_in">size</span> +<span class="hljs-number">10</span>k -<span class="hljs-built_in">size</span> <span class="hljs-number">-100</span>k</code></pre></li></ul></li><li><p>按照日期查找</p><pre><code class="hljs excel"><span class="hljs-built_in">find</span> [dir] -atime -<span class="hljs-built_in">n</span>/+<span class="hljs-built_in">n</span>创建日期  -ctime -<span class="hljs-built_in">n</span>/+<span class="hljs-built_in">n</span>修改日期  -mtime -<span class="hljs-built_in">n</span>/+<span class="hljs-built_in">n</span>访问日期  -atime -<span class="hljs-built_in">n</span>/+<span class="hljs-built_in">n</span>-<span class="hljs-built_in">n</span>  代表<span class="hljs-built_in">n</span>天之内+<span class="hljs-built_in">n</span>  代表<span class="hljs-built_in">n</span>天之外</code></pre><p><img src="/linux-base/findtime.png"></p></li><li><p>根据目录深度搜索</p></li></ul><pre><code class="hljs lua"><span class="hljs-built_in">find</span> [dir] -maxdepth/mindepth <span class="hljs-number">3</span>dir <span class="hljs-comment">-- 表示查找的目录</span>maxdepth <span class="hljs-number">3</span> <span class="hljs-comment">-- 表示最多搜索三层目录</span>mindepth <span class="hljs-number">3</span> <span class="hljs-comment">-- 表示搜索目录从第三层开始更大的搜索</span></code></pre><p><img src="/linux-base/finddepth2.png"></p><h3 id="grep指令-–-查找文件里的内容"><a href="#grep指令-–-查找文件里的内容" class="headerlink" title="grep指令 – 查找文件里的内容"></a>grep指令 – 查找文件里的内容</h3><pre><code class="hljs excel">grep -r <span class="hljs-string">&quot;查找的内容&quot;</span> [dir] -<span class="hljs-built_in">n</span>-r 如果查询的范围内有目录就加上dir 表示查找的目录-<span class="hljs-built_in">n</span>  会显示找出的文件的内容在对应文件的第几行</code></pre><h2 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h2><p>Linux常见的压缩格式是  <code>.gz</code> 、 <code>.bzip2</code> 。</p><p><code>.gz</code> 是 gzip程序压缩的文件， <code>.bzip2</code>  是bzip2程序压缩的文件。</p><p>直接使用这两个程序可以进行压缩，但是功能不够强大（不能压缩目录）。</p><h3 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h3><pre><code class="hljs css">参数：<span class="hljs-selector-tag">c</span>  <span class="hljs-selector-tag">--</span> 创建压缩文件<span class="hljs-selector-tag">x</span>  <span class="hljs-selector-tag">--</span> 释放压缩文件<span class="hljs-selector-tag">v</span>  <span class="hljs-selector-tag">--</span> 打印提示信息（可不写）<span class="hljs-selector-tag">f</span>  <span class="hljs-selector-tag">--</span> 指定压缩包的名字<span class="hljs-selector-tag">z</span>  <span class="hljs-selector-tag">--</span> 使用<span class="hljs-selector-tag">gzip</span>压缩文件，文件最好命名为：<span class="hljs-selector-tag">-xxx</span><span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span><span class="hljs-selector-tag">j</span>  <span class="hljs-selector-tag">--</span> 使用<span class="hljs-selector-tag">bzip2</span>压缩文件，文件最好命名为：<span class="hljs-selector-tag">-xxx</span><span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.bzip2</span>压缩格式：<span class="hljs-selector-tag">tar</span> <span class="hljs-selector-attr">[参数]</span> <span class="hljs-selector-attr">[压缩包文件名]</span> <span class="hljs-selector-attr">[原材料]</span><span class="hljs-selector-tag">tar</span> <span class="hljs-selector-tag">zcvf</span> <span class="hljs-selector-tag">test</span><span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> <span class="hljs-selector-tag">test</span><span class="hljs-selector-class">.txt</span>解压缩格式：<span class="hljs-selector-tag">tar</span> <span class="hljs-selector-attr">[参数]</span> <span class="hljs-selector-attr">[压缩包文件名]</span> <span class="hljs-selector-tag">tar</span> <span class="hljs-selector-tag">zxcf</span> <span class="hljs-selector-tag">test</span><span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span>其后可接<span class="hljs-selector-tag">-C</span> 解压目录，来指定解压放置的地点</code></pre><p><img src="/linux-base/tar.png"></p><h3 id="rar命令"><a href="#rar命令" class="headerlink" title="rar命令"></a>rar命令</h3><p>需要安装  <code>sudo apt-get install rar</code></p><pre><code class="hljs cmake">压缩：rar a 压缩包名(不用指定后缀) 压缩内容rar a <span class="hljs-keyword">test</span> <span class="hljs-keyword">test</span>.txt如果压缩的内容包括目录，后面接 -r解压缩rar x 压缩包名 解压目录rar x <span class="hljs-keyword">test</span> aa/</code></pre><p><img src="/linux-base/rar.png"></p><h3 id="zip-unzip命令"><a href="#zip-unzip命令" class="headerlink" title="zip/unzip命令"></a>zip/unzip命令</h3><pre><code class="hljs stata">压缩<span class="hljs-keyword">zip</span> 压缩包名(不用指定后缀) 压缩内容<span class="hljs-keyword">zip</span> <span class="hljs-keyword">test</span> <span class="hljs-keyword">test</span>.txt如果压缩的内容包括目录，后面接 -r解压缩unzip 压缩包名unzip <span class="hljs-keyword">test</span>.<span class="hljs-keyword">zip</span>解压至指定目录，后面接-<span class="hljs-keyword">d</span> 指定目录</code></pre><p><img src="/linux-base/zip.png"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux--Ubuntu的安装|(win + linux)双系统</title>
    <link href="/ubuntu-set-up/"/>
    <url>/ubuntu-set-up/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：Ubuntu的安装全过程：U盘启动盘的制作、Windows磁盘分区、安装过程中的选择、Linux各个分区、修改默认启动项。还有联想拯救者系列安装Ubuntu时的一些雷区。</p><a id="more"></a><h2 id="制作U盘启动盘"><a href="#制作U盘启动盘" class="headerlink" title="制作U盘启动盘"></a>制作U盘启动盘</h2><p>首先，先从官网下载Ubuntu的系统镜像。</p><p>建议选择<strong>LTS</strong>的版本(代表着长期支持)，我选用的是Ubuntu 18.04.2 。大概1.85G.</p><blockquote><p>Ubuntu 18.04.2 LTS : <a href="https://ubuntu.com/download/desktop">https://ubuntu.com/download/desktop</a></p></blockquote><p>然后，需要U盘引导盘制作工具。百度有一大堆。这里我使用的是refus。这个工具。</p><blockquote><p>refus U 盘引导盘制作工具：链接：<a href="https://pan.baidu.com/s/1VvCeKzAvFSVZGNkzv3tclw">https://pan.baidu.com/s/1VvCeKzAvFSVZGNkzv3tclw</a> 提取码：5nsl </p><p>写完才发现这个软件的官网：<a href="https://rufus.ie/">https://rufus.ie/</a>，可以自行下载，软件版本已经更新到3.5了。</p></blockquote><p>最后准备一个U盘，开始制作。引导类型选择<strong>镜像文件</strong>，然后点击后面的选择，找到上面下载的镜像文件(.iso)。其他选项默认即可。</p><p>点击开始之后会弹出<strong>提示下载两个文件</strong>，点击确定下载即可。之后选择使用会弹出选择ISO镜像或者DD镜像写入，选择ISO镜像即可。</p><p><img src="/ubuntu-set-up/ubuntu-set-up%5Crefus.png"></p><p>最后会弹出警告，做系统引导盘要<strong>格式化U盘的</strong>！！</p><p><img src="/ubuntu-set-up/ubuntu-set-up%5Crefus-c.png"></p><p>点击确定，然后等待大概5、6分钟就制作好了。</p><h2 id="Windows磁盘分区"><a href="#Windows磁盘分区" class="headerlink" title="Windows磁盘分区"></a>Windows磁盘分区</h2><p>打开磁盘管理。找一个磁盘，右键点击压缩卷，输入压缩空间量。</p><p>这里一般的话50GB就足够使用了，我选择压缩110G😁。变成<strong>未分配的空间</strong>就好了。(后面做了一下实验，又压缩了10G，所以是110G)。</p><p><img src="/ubuntu-set-up/ubuntu-set-up%5Ccapan.png"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>将电脑点击重启，重启中不断按F12进入引导界面。（不同电脑的按键可能不同，详情百度即可）。</p><p><img src="/ubuntu-set-up/ubuntu-set-up%5Cbost_set.jpg"></p><p>如上图，选择<strong>UEFI的USB引导</strong>。键盘上下键翻动，回车键确认。中间可能会有黑屏，多等待几秒。</p><p>然后到了如下的界面，依旧上下键移动，选择第二个install ununtu，回车即可。</p><p><img src="/ubuntu-set-up/ubuntu-set-up%5Cinstall.jpg"></p><p>注意接下来电脑可能会<strong>黑屏一段时间</strong>(我的电脑是的，耐心等待)。之后就会进入安装的详细引导了。</p><p>语言选择简体中文，正常安装。</p><p><img src="/ubuntu-set-up/ubuntu-set-up%5Cinstall1.png"></p><p>然后关键的一步，安装类型选择其他选项，自己创建调整分区。</p><p><img src="/ubuntu-set-up/ubuntu-set-up%5Cinstall2.jpg"></p><h2 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a>Linux分区</h2><p>接上面的进行继续分区操作。注意要计算好空间大小！</p><p>首先要先找到上面分配的<strong>空闲空间</strong>，双击即可进行分区。</p><p><img src="/ubuntu-set-up/ubuntu-set-up%5Cinstall3.jpg"></p><h3 id="分区-主分区"><a href="#分区-主分区" class="headerlink" title="分区-主分区(/.)"></a>分区-主分区(<strong>/.</strong>)</h3><p>用于存放系统，相当于Windows的C盘。一般10G就够了，我这里用了50GB。</p><p>双击空闲的空间，设置如下</p><pre><code class="hljs plain">分区类型 ： 主分区新分区的位置 ： 空间起始位置用于 ： Ext4日志文件系统挂载点 ： &#x2F;</code></pre><p><img src="/ubuntu-set-up/ubuntu-set-up%5Cinstallmain.jpg"></p><h3 id="分区-boot"><a href="#分区-boot" class="headerlink" title="分区-/boot"></a>分区-/boot</h3><p>引导分区，一般200MB就够了，这里我用1000MB。</p><p>双击空闲的空间，设置如下</p><pre><code class="hljs jboss-cli">分区类型 ： 逻辑分区新分区的位置 ： 空间起始位置用于 ： Ext4日志文件系统挂载点 ： <span class="hljs-string">/boot</span></code></pre><p><img src="/ubuntu-set-up/ubuntu-set-up%5Cinstallboot.jpg"></p><h3 id="分区-home"><a href="#分区-home" class="headerlink" title="分区-/home"></a>分区-/home</h3><p>主要是用户存储数据。空间尽可能的大。这里我用50GB。</p><p>双击空闲的空间，设置如下</p><pre><code class="hljs arduino">分区类型 ： 逻辑分区新分区的位置 ： 空间起始位置用于 ： Ext4日志文件系统挂载点 ： /<span class="hljs-built_in">home</span></code></pre><p><img src="/ubuntu-set-up/ubuntu-set-up%5Cinstallhome.jpg"></p><h3 id="分区-交换空间"><a href="#分区-交换空间" class="headerlink" title="分区-交换空间"></a>分区-交换空间</h3><p>交换区，即操作系统的虚拟内存。和电脑内存大小相同即可，但我的电脑内存只有4G，把原来分区的110G最后剩余的空间全部给了交换空间。</p><p>双击空闲的空间，设置如下</p><pre><code class="hljs plain">分区类型 ： 逻辑分区新分区的位置 ： 空间起始位置用于 ： 交换空间</code></pre><p><img src="/ubuntu-set-up/ubuntu-set-up%5Cinstallswap.jpg"></p><h3 id="安装启动引导器的设备"><a href="#安装启动引导器的设备" class="headerlink" title="安装启动引导器的设备"></a>安装启动引导器的设备</h3><p>上面四个区做好之后，要选择安装启动引导器的设备，注意，<strong>这里要选择你<code>/boot</code>区的位置！</strong>。如图，我的<code>/boot</code>对应<code>/dev/sda6</code>。</p><p><img src="/ubuntu-set-up/ubuntu-set-up%5Cinstalldev.jpg"></p><p>之后点击现在安装。</p><p><img src="/ubuntu-set-up/ubuntu-set-up%5Cinstall7.jpg"></p><p>点击继续。之后是选择所在地，选择中国上海。之后设置用户名密码。密码是必须设置的，最好记住。图片太大就不做展示了。</p><p>之后静静等待，等待安装完成。按照提示操作就好了。</p><h2 id="如何修改默认启动项"><a href="#如何修改默认启动项" class="headerlink" title="如何修改默认启动项"></a>如何修改默认启动项</h2><p>由于是双系统，grub引导，电脑默认启动项目是Ubuntu，但是日常使用Windows比较多，如果开机之后不留意可能就会直接进入Ubuntu，还得重启等待，比较麻烦。</p><p>可以尝试在Ubuntu系统中修改它的grub文件，来达到开机之后默认光标定位问题。</p><blockquote><p>一、启动系统时，记下将要修改为默认启动系统的顺序号（从上往下从0开始数，第1项是0项，第2项是1项……）。</p><p>二、启动进入ubuntu系统后，Ctrl-Alt-T进入终端。</p><p>​    输入并执行以下命令行</p><p>​    sudo gedit /etc/default/grub</p><p>​    输入root密码后进入gedit编辑器编辑grub文件</p><p>​    在GRUB_DEFAULT=0处将0改为之前记下的顺序号（从0开始数的个数）</p><p>​    在GRUB_TIMEOUT=10处将10改为你需要设置的选项默认等待的时间（秒数），如15。</p><p>​    点击gedit窗口左上角的X号保存退出。</p><p>三、回到终端窗口，输入并执行以下命令行</p><p>​    sudo update-grub</p><p>​    执行完毕后大功告成。重启就可以看到效果了。</p></blockquote><p>除此之外还可以修改GRUB引导菜单的背景图片。</p><blockquote><p>1、首先准备一张想要的照片，文件名是啥无所谓，只要格式是*.jpg *.JPG *.jpeg *.JPEG *.png *.PNG *.tga *.TGA都行，都能自动找到，如果有多个，那么显示第一个找到的图片。<br>例如名字为命名为：xihuan.jpg<br>复制到grub目录 /boot/grub/<br>root@ubuntu:~# cp -v xihuan.jpg  /boot/grub/</p><p>2、改变一下启动界面的分辨率<br>root@ubuntu:~# vi /etc/default/grub</p><p>找到#GRUB_GFXMODE=640x480<br>更改为 GRUB_GFXMODE=1920x1080     #这里的分辨率改成自己电脑的分辨率</p><p>3、重新生成GRUB的启动菜单配置文件(/boot/grub/grub.cfg)<br>root@ubuntu:~# update-grub</p></blockquote><p>参考链接：<a href="https://blog.csdn.net/Pipcie/article/details/84955169">Ubuntu18.04 更改GRUB引导菜单背景图片和默认启动项</a></p><h2 id="联想拯救者系列雷区"><a href="#联想拯救者系列雷区" class="headerlink" title="联想拯救者系列雷区"></a>联想拯救者系列雷区</h2><p>我的笔记本是联想拯救者Y7000。安装过程中碰到了一些它独有的问题。</p><h3 id="1-显卡驱动"><a href="#1-显卡驱动" class="headerlink" title="1.显卡驱动"></a>1.显卡驱动</h3><p>我的电脑显卡是<code>GTX 1050Ti</code></p><p>安装完Ubuntu之后会碰到一系列奇葩的问题：<strong>Ubuntu图形界面非常的卡顿</strong>、<strong>开机之后可能会变成紫屏</strong>、<strong>点击重启或者关机按钮会卡死</strong></p><p>原因个人不太清楚，大致是因为Ubuntu使用的是电脑的核显，而这个核显性能一般。Ubuntu没有找到电脑独显的驱动，需要手动去安装。</p><blockquote><p>说一下我的做法：仅供参考，当初解决之后忘记及时写博客了，所以只是大致的印象</p><p>1.因为拯救者的无线模块也不能使用，所以就用手机开启USB网络共享到笔记本电脑上，然后更换软件源为阿里云，更新驱动</p><p>2.会有一个N卡驱动，点击下载，安装</p><p>3.会让你设置一个8位以上的密码，写好，记住，然后有个重启选项，选择重启</p><p>4.貌似接下来会进入蓝色屏幕，有一些选项忘记是什么了，继续往下之后会有安装选项，然后之后会有一个文本框，填上你刚才设置的密码。貌似密码不会显示出来</p><p>5.填完之后确认再次进入Ubuntu系统，这时查看显卡驱动就是N卡了</p><p>6.除此之外的开机grub界面。我也按’e’修改了一点内容，见底下的链接</p><p>7.据说Ubuntu之后的版本19.xxx解决了这个问题，不知道是不是真的。</p></blockquote><p>参看链接：</p><p><a href="https://blog.csdn.net/Dod_Jdi/article/details/78635126?utm_source=app">https://blog.csdn.net/Dod_Jdi/article/details/78635126?utm_source=app</a></p><p> <a href="https://blog.csdn.net/fu6543210/article/details/80104491?utm_source=app">https://blog.csdn.net/fu6543210/article/details/80104491?utm_source=app</a> </p><h3 id="2-无线模块"><a href="#2-无线模块" class="headerlink" title="2.无线模块"></a>2.无线模块</h3><p>无线模块我找了好几个教程都没有解决。无奈之下使用了无线网卡，暂时解决上网问题。</p><h2 id="如何清除Ubuntu系统？"><a href="#如何清除Ubuntu系统？" class="headerlink" title="如何清除Ubuntu系统？"></a>如何清除Ubuntu系统？</h2><p>最简单粗暴的方法，在Windows系统里进入<strong>磁盘管理</strong>，把原来Ubuntu占用的空间全部清除掉就可以了。</p><p>但是开机的引导还没有修复，开机后会弹出下面的图片的这种情况。输入<code>exit</code>就可以进入Windows了。</p><p><img src="/ubuntu-set-up/ubuntu-set-up%5Cgrub.jpg"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/liuxiaodong400/article/details/80946225">Ubuntu-18.04-LTS安装指南（ubuntu-16.04同）</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>SOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VS开发C++的一些问题——VS项目工程文件、Debug与Relase模式、字符集问题以及_T()宏</title>
    <link href="/vs-use/"/>
    <url>/vs-use/</url>
    
    <content type="html"><![CDATA[<p><strong>简介</strong>：VS工程项目相关文件，如何让自己编好的程序在其他电脑上运行，字符集</p><a id="more"></a><h2 id="VS工程项目相关文件"><a href="#VS工程项目相关文件" class="headerlink" title="VS工程项目相关文件"></a>VS工程项目相关文件</h2><p>VS是使用<strong>解决方案</strong>来管理项目的，同一个解决方案之下就可以添加多个项目。</p><p><img src="/vs-use/vs-use%5Csolution.png"></p><p>而在多个项目的时候，一般编译调试都是执行的第一个创建的项目，此时可以选择 <code>右键“解决方案”--&gt;设置启动项目--&gt;通用属性里的启动项目--&gt;选定当前选定内容。</code> </p><p>总的来说解决方案会对应一个文件夹，文件夹里会有不同的项目文件夹。</p><p><img src="/vs-use/wenjianjia.png"></p><p><strong>sdf文件</strong>是一个<strong>数据库文件</strong>，记录了解决方案的各种信息。</p><p><strong>opensdf文件</strong>是项目被打开时才会出现的，项目关闭后此文件也会消失，估计是sdf文件的临时文件。</p><p><strong>sln文件</strong>是整个<strong>解决方案的配置文件</strong>，（Microsoft Visual Studio Solution），通过VS2013打开sln文件就可以将整个解决方案导入到VS中打开。</p><blockquote><p>sln（Visual Studio.Solution）通过为环境提供对项目、项目项和解决方案在磁盘上的位置的引用，可以将他们组织到解决方案中。</p></blockquote><p><strong>suo文件</strong>（Visual Studio Solution User Options）是<strong>解决方案用户选项</strong>。</p><blockquote><p>suo 解决方案用户选项，记录所有将与解决方案建立关联的选项，存储了用户对界面的自定义配置，包括布局、断点、打开的文件等。</p></blockquote><p>在Project1中写一个HelloWorld语句之后，Project1项目文件夹如下所示</p><p><img src="/vs-use/project1.png"></p><p><strong>vcxproj文件</strong>是项目文件，<strong>保存了整个项目的配置信息</strong>。经过测试可以通过打开这个文件来直接打开这个项目以及解决方案。</p><blockquote><p>vc5,6的工程文件是.dsp</p><p>vc2002-2008工程文件是vcproj</p><p>vc2010之后是vcxproj</p><p>vcproj和vcxproj都是xml格式的。</p></blockquote><p><strong>vcxproj.filters文件</strong>是文件存放工程的<strong>虚拟目录信息</strong>，也就是在解决方案浏览器中的目录结构信息。</p><p><strong>cpp文件</strong>就不用多说了🙃</p><p>Debug文件夹是VS在 <code>Debug</code> 模式下编译链接执行后生成的文件夹， 与之相对应的是 <code>Release</code>  模式，在此模式下就会生成Release文件夹。</p><p><img src="/vs-use/debug.png"></p><p>打开Debug文件夹，其内有上述这些文件。</p><p><strong>log文件</strong>是主要记录<strong>编译过程中的输出信息、日志</strong>。可以打开看看，内容和执行时的内容差不多。</p><p><strong>pdb文件</strong>是<strong>调试的符号文件</strong>，程序数据库 (PDB) 文件保存着调试和项目状态信息，使用这些信息可以对程序的调试配置。</p><p><strong>obj文件</strong>是C、CPP编译后的二进制文件。</p><p><strong>VS执行生成的可执行文件放在解决方案目录里的Debug目录里。</strong></p><p><img src="/vs-use/Debug1.png"></p><p><strong>exe文件</strong>是编译链接后产生的<strong>可执行文件</strong>。</p><p><strong>ilk文件</strong> 增量编译（incremental linking）</p><blockquote><p>取消增量编译可以不生成这种文件，对于大工程来说可能会变慢。</p></blockquote><p>最后摘抄一段话</p><blockquote><p>一般情况下，如果我们要把源码共享到github中，只需要提交工程相关的配置文件，不提交用户个人偏好相关的配置文件。所谓的个人偏好相关，是指根据用户个人的VS使用习惯而保存的配置信息，比如选择了查看所有文件选项，打开了某一个文件。而工程相关的配置是指工程建立相关的信息，不受用户偏好的影响，比如解决方案的名字是什么，这个解决方案下面有哪些project。所以，我们只需要上传sln配置文件、vcxproj和vcxproj.filters配置文件就可以了，当然还包括源码。</p></blockquote><p>本文参考链接：</p><blockquote><p><a href="https://blog.csdn.net/u012175089/article/details/55050617">Visual Studio项目目录和文件说明</a></p><p><a href="https://blog.csdn.net/xu_fengyu/article/details/81841877">Visual Studio 项目各类文件概述</a></p><p><a href="https://blog.csdn.net/sinat_41852207/article/details/86742940">vs2017的文件组成</a></p><p><a href="https://blog.csdn.net/afanaily/article/details/41247899">VS各种文件作用详解</a></p><p><a href="https://blog.csdn.net/liangyihuai/article/details/88762804">Visual Studio 2017工程项目的几个重要文件解析</a></p><p><a href="https://blog.csdn.net/qq_20828983/article/details/75593441">sln、db、opendb、vcxproj、filters、user文件跟踪说明</a></p><p><a href="https://blog.csdn.net/langb2014/article/details/50933956?_t_t_t=0.7164025432757872">VS2013如何打包生成安装文件</a></p></blockquote><h2 id="如何让自己编好的程序在其他电脑上运行"><a href="#如何让自己编好的程序在其他电脑上运行" class="headerlink" title="如何让自己编好的程序在其他电脑上运行"></a>如何让自己编好的程序在其他电脑上运行</h2><h3 id="两种模式：Debug与Relaese的区别"><a href="#两种模式：Debug与Relaese的区别" class="headerlink" title="两种模式：Debug与Relaese的区别"></a>两种模式：Debug与Relaese的区别</h3><blockquote><p>Debug 通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序。</p><p>Release 称为<strong>发布版本</strong>，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。</p><p>参考链接：<a href="https://baike.baidu.com/item/Release%E7%89%88%E6%9C%AC/6497294?fr=aladdin">百度百科</a></p></blockquote><h3 id="发布可执行程序"><a href="#发布可执行程序" class="headerlink" title="发布可执行程序"></a>发布可执行程序</h3><p>VC2013 默认编写的 .exe 使用<strong>动态链接方式链接的运行时库</strong>，所以，编写的程序要在别的电脑上运行，需要在其它电脑安装 <strong>VC2013 的运行时库</strong>，然后就可以完美运行你的 .exe 程序。</p><p>当然，如果你觉得安装运行时库很麻烦，你可以用<strong>静态链接</strong>的形式编译你的 .exe 程序。</p><blockquote><p>中文版 Visual Studio 2013 的操作方法：</p><ol><li><p>打开 Visual Studio 2013，创建 Win32 控制台应用程序（或者 Win32 项目）。</p></li><li><p>编写程序。</p></li><li><p>项目编译模式默认分为 Debug 和 Release 两种模式。Debug 模式带有各种调试信息，方便排查错误，使用的调试版本库。Release 模式删除了调试信息，使得编译的文件更小，执行速度更快。因此，在调试程序的时候，要用 Debug 模式。在调试完毕需要发布程序的时候，用 Release 模式。两种模式有不同的编译设置，我们现在需要将完成的程序发给别人，因此需要将项目设置为 Release 模式。</p></li><li><p>在 解决方案资源管理器 区域中，选中你的 项目（通常第一行是 解决方案，第二行是 项目），右击，选 属性。</p></li><li><p>左侧类别中选择“配置属性 -&gt; C/C++ -&gt; 代码生成”，右侧将“运行时库”设置为“多线程(/MT)”。</p></li><li><p>如果你希望你的程序可以运行在 WinXP 中，还需要设置“配置属性 -&gt; 常规 -&gt; 平台工具集”为“Visual Studio 2013 - Windows XP (v120_xp)”。</p></li><li><p>编译程序。在项目文件夹的 Release 文件夹里面，可以找到最终编译的 .exe 文件，拷贝出来即可在别的电脑上运行。</p></li></ol></blockquote><p>采用上面的方法就可以发布Release模式的exe可执行文件，可以拷贝出来在其他电脑上运行。</p><p>参考链接：<a href="https://codeabc.cn/yangw/">慢羊羊村长</a>的博客：<a href="https://codeabc.cn/yangw/post/make-a-program-written-by-vc-run-on-another-computer">使 VC2013 编写的程序运行在其它电脑上</a></p><h2 id="VS字符集的问题"><a href="#VS字符集的问题" class="headerlink" title="VS字符集的问题"></a>VS字符集的问题</h2><p>在VS里面右击项目名称，最后一项是”属性“，点进去就可以看到字符集设置的问题。</p><p><img src="/vs-use/charset.png" alt="项目字符集"></p><p>主要有两种选择，一种是<code>Unicode字符集</code>，另一种是<code>多字节字符集</code>。</p><p>Windows是使用两种字符集：ANSI 和 Unicode编码。</p><p>ANSI是通常使用的单字节处理方式，所有字符都通过一个字节进行表示，这样对于处理中文这样的双字节字符非常不友好。</p><blockquote><p>在最初的时候，Internet上只有一种字符集——ANSI的ASCII字符集，它使用7 bits来表示一个字符，总共表示128个字符，其中包括了英文字母、数字、标点符号等常用字符。之后，又进行扩展，使用8 bits表示一个字符，可以表示256个字符，主要在原来的7 bits字符集的基础上加入了一些特殊符号例如制表符。 </p><p>后来，由于各国语言的加入，ASCII已经不能满足信息交流的需要，因此，为了能够表示其它国家的文字，各国在ASCII的基础上制定了自己的字符集，这些从ANSI标准派生的字符集被习惯的统称为ANSI字符集，它们正式的名称应该是<strong>MBCS</strong>(Multi-Byte Chactacter System，即<strong>多字节字符系统</strong>)。这些派生字符集的特点是以ASCII 127 bits为基础，兼容ASCII 127，他们使用大于128的编码作为一个Leading Byte，紧跟在Leading Byte后的第二（甚至第三）个字符与Leading Byte一起作为实际的编码。这样的字符集有很多，我们常见的GB-2312就是其中之一。</p></blockquote><p>Unicode编码是双字节编码。</p><blockquote><p>由于每种语言都制定了自己的字符集，导致最后存在的各种字符集实在太多，在国际交流中要经常转换字符集非常不便。因此，提出了Unicode字符集，它固定使用16 bits（两个字节、一个字）来表示一个字符，共可以表示65536个字符。<strong>将世界上几乎所有语言的常用字符收录其中，方便了信息交流</strong>。标准的Unicode称为UTF-16。后来为了双字节的Unicode能够在现存的处理单字节的系统上正确传输，出现了UTF-8，使用类似MBCS的方式对Unicode进行编码。注意UTF-8是编码，它属于Unicode字符集。Unicode字符集有多种编码形式，而ASCII只有一种，大多数MBCS（包括GB-2312）也只有一种。Unicode的最初目标，是用1个16位的编码来为超过65000字符提供映射。但这还不够，它不能覆盖全部历史上的文字，也不能解决传输的问题 (implantation head-ache’s)，尤其在那些基于网络的应用中。已有的软件必须做大量的工作来程序16位的数据。因此，Unicode用一些基本的保留字符制定了三套编码方式。它们分别是UTF-8,UTF-16和UTF-32。正如名字所示，在UTF－8中，字符是以8位序列来编码的，用一个或几个字节来表示一个字符。这种方式的最大好处，是<strong>UTF－8保留了ASCII字符的编码做为它的一部分</strong>，例如，在UTF－8和ASCII中，“A”的编码都是0x41.UTF－16和UTF－32分别是Unicode的16位和32位编码方式。考虑到最初的目的，通常说的Unicode就是指UTF-16。 </p></blockquote><p>两种编码集推荐使用Unicode编码:</p><blockquote><p>（1） 可以很容易地<strong>在不同语言之间进行数据交换</strong>。<br>（2） 使你能够<strong>分配支持所有语言的单个二进制.exe文件或DLL文件</strong>。<br>（3） 提高应用程序的<strong>运行效率</strong>。</p></blockquote><p>以上引用的内容均来自博客：<a href="https://blog.csdn.net/stephen1315/article/details/7476236">Unicode字符集和多字节字符集关系</a>，此外博客还有许多内容可以学习哦~</p><h3 id="C-T-与L宏"><a href="#C-T-与L宏" class="headerlink" title="C++ _T()与L宏"></a>C++ _T()与L宏</h3><p>然后就又关于字符串保存的问题，有两种方式，一种是 <code>_T( )</code> 的形式，另一种是 <code>L&quot; &quot;</code> 的形式。</p><pre><code class="hljs c++">TCHAR s[] = _T(<span class="hljs-string">&quot;你好啊！&quot;</span>);TCHAR s[] = <span class="hljs-string">L&quot;你也是！&quot;</span>;</code></pre><p>先暂时忽略<code>TCHAR</code> ，上面的代码是两种字符串保存的方式。</p><blockquote><p>当工程是Unicode编码时，_T将括号内的字符串以Unicode方式保存；</p><p>当工程是多字节编码时，_T将括号内的字符串以ANSI方式保存。</p><p>关键字“L”，则是不管编码环境是什么，都是将其后面的字符串以Unicode方式保存。</p><p>Unicode字符是LPCWSTR</p><p>ASCII字符是LPCSTR</p><p>通过强制转换是无法完成的，需要<strong>用_T()和L()来完成转换</strong></p><p>参看博客：<a href="https://blog.csdn.net/qq_26145629/article/details/80782234">C++ _T()和L()宏</a></p></blockquote><h3 id="各种字符类型😱"><a href="#各种字符类型😱" class="headerlink" title="各种字符类型😱"></a>各种字符类型😱</h3><p><img src="/vs-use/str.png"></p><p>🤧😷😱</p><p>上图来自博客：<a href="https://www.cnblogs.com/jmliao/p/6031818.html">C++字符类型总结区别wchar_t,char,WCHAR</a>  emmm,就是有非常丰富的类型。具体内容可以参看超链接里的那篇博客。</p><blockquote><p>其他参看博客：<a href="https://www.cnblogs.com/lanhaicode/p/10574260.html">宽字符wchar_t和窄字符char——putwchar、wprintf</a></p></blockquote><h2 id="VS快捷键"><a href="#VS快捷键" class="headerlink" title="VS快捷键"></a>VS快捷键</h2><ul><li><p>多行注释：选中，然后Ctrl+K，然后Ctrl+C即可注释。</p></li><li><p>取消注释：选中，然后Ctrl+K，然后Ctrl+U即可取消注释。</p></li></ul><h2 id="VS使用中碰到的问题"><a href="#VS使用中碰到的问题" class="headerlink" title="VS使用中碰到的问题"></a>VS使用中碰到的问题</h2><h3 id="模块对于-SAFESEH-映像是不安全的。"><a href="#模块对于-SAFESEH-映像是不安全的。" class="headerlink" title="模块对于 SAFESEH 映像是不安全的。"></a>模块对于 SAFESEH 映像是不安全的。</h3><p>解决方法：属性 –&gt; 链接器 –&gt; 命令行，然后在其他选项这个框中，填入<code>/SAFESEH:NO</code>，就好了。</p><h3 id="提示函数过时或者不安全"><a href="#提示函数过时或者不安全" class="headerlink" title="提示函数过时或者不安全"></a>提示函数过时或者不安全</h3><p>一种方式是将函数修改为VS建议的函数。</p><p>另一种方式是添加<code>_CRT_SECURE_NO_WARNINGS</code>来让VS忽略这些问题，一种添加是在文件开头添加宏<code>#define _CRT_SECURE_NO_WARNINGS</code>，另一种方式是在属性页 –&gt; C/C++ –&gt; 预处理器 –&gt; 预处理器定义，添加<code>_CRT_SECURE_NO_WARNINGS</code>即可。</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>SOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基于EasyX制作贪吃蛇游戏（二）第一版代码与程序</title>
    <link href="/c-snake-pro1/"/>
    <url>/c-snake-pro1/</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.colourso.top/c-snake-pro0/">上一篇博客</a>写了贪吃蛇的文档，这一篇博客就把第一版本的贪吃蛇代码展示一下，附带源码与可执行文件的下载。</p><a id="more"></a><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>工具： VS2013</p><p>依赖： EasyX Library for C++ (Ver:20180727(beta)</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;graphics.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-comment">//蛇头方向预定义</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UP 1<span class="hljs-comment">//↑</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RIGHT 2 <span class="hljs-comment">//→</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DOWN 3  <span class="hljs-comment">//↓</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LEFT 4  <span class="hljs-comment">//←</span></span><span class="hljs-comment">/*-------------结构体定义---------------*/</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> //蛇的节点</span><span class="hljs-class">&#123;</span><span class="hljs-keyword">int</span> x;   <span class="hljs-comment">//横左边</span><span class="hljs-keyword">int</span> y;   <span class="hljs-comment">//纵坐标</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//指向下一个节点的指针</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">pre</span>;</span>  <span class="hljs-comment">//指向前一个节点的指针</span>&#125; * LinkNode;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Snake</span> //蛇的结构体</span><span class="hljs-class">&#123;</span>LinkNode head; <span class="hljs-comment">//指向头节点的指针</span>LinkNode tail; <span class="hljs-comment">//指向尾节点的指针</span><span class="hljs-keyword">int</span> direction; <span class="hljs-comment">//蛇头方向</span><span class="hljs-keyword">int</span> num;   <span class="hljs-comment">//节点数目</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Food</span> //食物结构体</span><span class="hljs-class">&#123;</span><span class="hljs-keyword">int</span> x;<span class="hljs-comment">//横坐标</span><span class="hljs-keyword">int</span> y;<span class="hljs-comment">//纵坐标</span><span class="hljs-keyword">bool</span> exist; <span class="hljs-comment">//是否存在，1表示存在</span>&#125;;<span class="hljs-comment">/*-------------全局变量---------------*/</span><span class="hljs-keyword">int</span> g_score = <span class="hljs-number">0</span>; <span class="hljs-comment">//获得分数</span>Snake snake; <span class="hljs-comment">//游戏中的蛇本体</span>Food food; <span class="hljs-comment">//食物</span><span class="hljs-comment">/*-------------函数声明---------------*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//初始化</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawgame</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//绘制界面</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gameplay</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//开始游戏</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//释放资源</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawfood</span><span class="hljs-params">(Food food)</span></span>;  <span class="hljs-comment">//绘制食物</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawsnake</span><span class="hljs-params">(Snake snake)</span></span>;  <span class="hljs-comment">//绘制蛇</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawsnakenode</span><span class="hljs-params">(Node node)</span></span>;<span class="hljs-comment">//绘制蛇的结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearsnakenode</span><span class="hljs-params">(Node node)</span></span>;   <span class="hljs-comment">//清除蛇的结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">snakebodymove</span><span class="hljs-params">(Snake &amp;snake)</span></span>; <span class="hljs-comment">//蛇身体结点向前复制</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">collidesnake</span><span class="hljs-params">(Snake snake)</span></span>;   <span class="hljs-comment">//碰撞自身检测</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawscore</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//绘制分数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearscore</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//清除分数</span><span class="hljs-comment">/*-------------程序入口---------------*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;init();drawgame();gameplay();close();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*-------------函数实现---------------*/</span><span class="hljs-comment">//初始化</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;initgraph(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>);   <span class="hljs-comment">//初始化窗口</span>setorigin(<span class="hljs-number">0</span>, <span class="hljs-number">480</span>); <span class="hljs-comment">//设置坐标原点</span>setaspectratio(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>); <span class="hljs-comment">//使y轴向上为正</span><span class="hljs-comment">//蛇与食物初始化</span><span class="hljs-comment">//食物初始坐标为(310,230)</span>food.x = <span class="hljs-number">310</span>;food.y = <span class="hljs-number">230</span>;food.exist = <span class="hljs-literal">true</span>;<span class="hljs-comment">//蛇初始长度为3，蛇头坐标为(210,230)</span><span class="hljs-comment">//在堆上开辟空间，防止此函数的生命周期结束后结点全部被释放掉</span>LinkNode nodes2 = (LinkNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));nodes2-&gt;x = <span class="hljs-number">170</span>;nodes2-&gt;y = <span class="hljs-number">230</span>;nodes2-&gt;next = <span class="hljs-literal">nullptr</span>;LinkNode nodes1 = (LinkNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));nodes1-&gt;x = <span class="hljs-number">190</span>;nodes1-&gt;y = <span class="hljs-number">230</span>;nodes1-&gt;next = nodes2;LinkNode nodes0 = (LinkNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));nodes0-&gt;x = <span class="hljs-number">210</span>;nodes0-&gt;y = <span class="hljs-number">230</span>;nodes0-&gt;next = nodes1;nodes2-&gt;pre = nodes1;nodes1-&gt;pre = nodes0;nodes0-&gt;pre = <span class="hljs-literal">nullptr</span>;snake.head = nodes0;snake.tail = nodes2;snake.direction = RIGHT;snake.num = <span class="hljs-number">3</span>;<span class="hljs-comment">//初始分数</span>g_score = (snake.num - <span class="hljs-number">3</span>) * <span class="hljs-number">10</span>;&#125;<span class="hljs-comment">//绘制界面</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawgame</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//画宽度为2的棕色实线，分割区域</span>setlinecolor(BROWN);setlinestyle(PS_SOLID, <span class="hljs-number">2</span>);line(<span class="hljs-number">482</span>, <span class="hljs-number">0</span>, <span class="hljs-number">482</span>, <span class="hljs-number">480</span>);<span class="hljs-comment">//绘制食物</span>drawfood(food);<span class="hljs-comment">//绘制蛇</span>drawsnake(snake);<span class="hljs-comment">//绘制分数</span>drawscore();&#125;<span class="hljs-comment">//开始游戏</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gameplay</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;Node ends; <span class="hljs-comment">//末尾结点</span><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;ends.x = snake.tail-&gt;x;ends.y = snake.tail-&gt;y;<span class="hljs-keyword">if</span> (!food.exist)&#123;<span class="hljs-keyword">int</span> x;<span class="hljs-keyword">int</span> y;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;srand(time(<span class="hljs-number">0</span>));x = (rand() % <span class="hljs-number">24</span>) * <span class="hljs-number">20</span> + <span class="hljs-number">10</span>;y = (rand() % <span class="hljs-number">24</span>) * <span class="hljs-number">20</span> + <span class="hljs-number">10</span>;<span class="hljs-comment">//食物位置检测算法</span>LinkNode linknode = snake.head;<span class="hljs-keyword">bool</span> cont = <span class="hljs-literal">true</span>;<span class="hljs-keyword">while</span> (linknode != snake.tail-&gt;next)&#123;<span class="hljs-keyword">if</span> (linknode-&gt;x == x &amp;&amp; linknode-&gt;y == y)&#123;cont = <span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;linknode = linknode-&gt;next;&#125;<span class="hljs-keyword">if</span> (cont)&#123;<span class="hljs-keyword">break</span>;&#125;&#125;food.x = x;food.y = y;food.exist = <span class="hljs-literal">true</span>;drawfood(food);&#125;<span class="hljs-comment">//按键</span><span class="hljs-keyword">if</span> (_kbhit())&#123;<span class="hljs-keyword">char</span> key = _getch();<span class="hljs-keyword">switch</span> (key)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">72</span>: <span class="hljs-comment">//↑</span><span class="hljs-keyword">if</span> (snake.direction != UP &amp;&amp; snake.direction != DOWN)snake.direction = UP;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">80</span>: <span class="hljs-comment">//↓</span><span class="hljs-keyword">if</span> (snake.direction != UP &amp;&amp; snake.direction != DOWN)snake.direction = DOWN;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">75</span>: <span class="hljs-comment">//←</span><span class="hljs-keyword">if</span> (snake.direction != LEFT &amp;&amp; snake.direction != RIGHT)snake.direction = LEFT;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">77</span>: <span class="hljs-comment">//→</span><span class="hljs-keyword">if</span> (snake.direction != LEFT &amp;&amp; snake.direction != RIGHT)snake.direction = RIGHT;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-comment">//前进</span><span class="hljs-keyword">switch</span> (snake.direction)&#123;<span class="hljs-keyword">case</span> UP:&#123;<span class="hljs-comment">//头部y+20,x不变</span>snakebodymove(snake);snake.head-&gt;y += <span class="hljs-number">20</span>;drawsnakenode(*(snake.head));<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> RIGHT:&#123;<span class="hljs-comment">//头部x+20,y不变</span>snakebodymove(snake);snake.head-&gt;x += <span class="hljs-number">20</span>;drawsnakenode(*(snake.head));<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> DOWN:&#123;<span class="hljs-comment">//头部y-20,x不变</span>snakebodymove(snake);snake.head-&gt;y -= <span class="hljs-number">20</span>;drawsnakenode(*(snake.head));<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">case</span> LEFT:&#123;<span class="hljs-comment">//头部x-20,y不变</span>snakebodymove(snake);snake.head-&gt;x -= <span class="hljs-number">20</span>;drawsnakenode(*(snake.head));<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-comment">//消除走过的结点</span>clearsnakenode(ends);<span class="hljs-comment">//蛇吃食物</span><span class="hljs-keyword">if</span> (snake.head-&gt;x == food.x &amp;&amp; snake.head-&gt;y == food.y &amp;&amp; food.exist)&#123;food.exist = <span class="hljs-literal">false</span>;<span class="hljs-comment">//isClear = false;</span><span class="hljs-comment">//分数变化</span>g_score += <span class="hljs-number">10</span>;<span class="hljs-comment">//在末尾增加新的结点，维护双向链表的关系</span>LinkNode nodes = (LinkNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));nodes-&gt;x = ends.x;nodes-&gt;y = ends.y;nodes-&gt;next = snake.tail-&gt;next;nodes-&gt;pre = snake.tail;snake.tail-&gt;next = nodes;snake.tail = nodes;++snake.num;drawsnakenode(ends);clearscore();drawscore();&#125;<span class="hljs-comment">//碰撞判断</span><span class="hljs-keyword">bool</span> collidewall = snake.head-&gt;x &lt; <span class="hljs-number">10</span> || snake.head-&gt;x &gt; <span class="hljs-number">470</span> || snake.head-&gt;y &lt; <span class="hljs-number">10</span> || snake.head-&gt;y &gt; <span class="hljs-number">470</span>;<span class="hljs-keyword">if</span> (collidewall || collidesnake(snake))&#123;cleardevice();TCHAR s[] = _T(<span class="hljs-string">&quot;game over&quot;</span>);settextstyle(<span class="hljs-number">48</span>, <span class="hljs-number">0</span>, _T(<span class="hljs-string">&quot;黑体&quot;</span>));outtextxy(<span class="hljs-number">230</span>, <span class="hljs-number">280</span>, s);<span class="hljs-keyword">break</span>;&#125;Sleep(<span class="hljs-number">150</span>);&#125;&#125;<span class="hljs-comment">//释放资源</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;_getch();closegraph();&#125;<span class="hljs-comment">//绘制食物</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawfood</span><span class="hljs-params">(Food food)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//红色，全填充，无边框的圆</span>setfillcolor(RED);setfillstyle(BS_SOLID);solidcircle(food.x, food.y, <span class="hljs-number">8</span>);&#125;<span class="hljs-comment">//绘制蛇的结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawsnakenode</span><span class="hljs-params">(Node node)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//绿色，全填充，无边框的正方形</span>setfillcolor(GREEN);setfillstyle(BS_SOLID);solidrectangle(node.x - <span class="hljs-number">9</span>, node.y + <span class="hljs-number">9</span>, node.x + <span class="hljs-number">9</span>, node.y - <span class="hljs-number">9</span>);&#125;<span class="hljs-comment">//清除蛇的结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearsnakenode</span><span class="hljs-params">(Node node)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//黑色，全填充，无边框的正方形</span>setfillcolor(BLACK);setfillstyle(BS_SOLID);solidrectangle(node.x - <span class="hljs-number">9</span>, node.y + <span class="hljs-number">9</span>, node.x + <span class="hljs-number">9</span>, node.y - <span class="hljs-number">9</span>);&#125;<span class="hljs-comment">//绘制蛇</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawsnake</span><span class="hljs-params">(Snake snake)</span></span><span class="hljs-function"></span>&#123;LinkNode linknode = snake.head;<span class="hljs-keyword">while</span> (linknode != snake.tail-&gt;next)&#123;drawsnakenode(*linknode);linknode = linknode-&gt;next;&#125;&#125;<span class="hljs-comment">//蛇身体结点向前复制</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">snakebodymove</span><span class="hljs-params">(Snake &amp;snake)</span></span><span class="hljs-function"></span>&#123;LinkNode linknode = snake.tail;<span class="hljs-keyword">while</span> (linknode != snake.head)&#123;linknode-&gt;x = linknode-&gt;pre-&gt;x;linknode-&gt;y = linknode-&gt;pre-&gt;y;linknode = linknode-&gt;pre;&#125;&#125;<span class="hljs-comment">//碰撞自身检测</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">collidesnake</span><span class="hljs-params">(Snake snake)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (snake.num &lt;= <span class="hljs-number">3</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;LinkNode node = snake.head-&gt;next;<span class="hljs-keyword">while</span> (node != snake.tail-&gt;next)&#123;<span class="hljs-keyword">if</span> (node-&gt;x == snake.head-&gt;x &amp;&amp; node-&gt;y == snake.head-&gt;y)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;node = node-&gt;next;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-comment">//绘制分数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawscore</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;TCHAR s[] = _T(<span class="hljs-string">&quot;获得分数：&quot;</span>);settextstyle(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>, _T(<span class="hljs-string">&quot;黑体&quot;</span>));outtextxy(<span class="hljs-number">485</span>, <span class="hljs-number">300</span>, s);TCHAR t[<span class="hljs-number">5</span>];_stprintf_s(t, _T(<span class="hljs-string">&quot;%d&quot;</span>), g_score); <span class="hljs-comment">// 高版本 VC 推荐使用 _stprintf_s 函数</span>outtextxy(<span class="hljs-number">560</span>, <span class="hljs-number">300</span>, t);&#125;<span class="hljs-comment">//清除分数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearscore</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//黑色，全填充，无边框的正方形</span>setfillcolor(BLACK);setfillstyle(BS_SOLID);solidrectangle(<span class="hljs-number">485</span>, <span class="hljs-number">480</span>, <span class="hljs-number">640</span>, <span class="hljs-number">300</span>);&#125;</code></pre><h2 id="程序展示"><a href="#程序展示" class="headerlink" title="程序展示"></a>程序展示</h2><p><img src="/c-snake-pro1/c-snake-pro1%5C1.gif"></p><p>看个大概吧，没有找到好的截图软件录制gif图片。</p><p><img src="/c-snake-pro1/c-snake-pro1%5C2.png"></p><p>字是反的，因为刚开始的时候设置了坐标轴和原点的位置导致的一个坑，没办法改过来。</p><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><p>百度网盘：链接：<a href="https://pan.baidu.com/s/1O3EqtcAeciukwt2uixC7RQ">https://pan.baidu.com/s/1O3EqtcAeciukwt2uixC7RQ</a><br>提取码：tm95</p><p><img src="/c-snake-pro1/c-snake-pro1%5C3.png"></p><p>Github地址：<a href="https://github.com/Colourso/Simple-CPP-project-by-Colourso/">https://github.com/Colourso/Simple-CPP-project-by-Colourso/</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于上述程序之中的一些问题，比如使用vs生成的文件结构、字符集设置的问题，还有<code>_T()</code>是什么意思在下一篇博客之中展示 – <a href="http://www.colourso.top/vs-use/">VS开发C++的一些问题——VS项目工程文件、Debug与Relase模式、字符集问题以及_T()宏</a>。</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>文件下载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基于EasyX制作贪吃蛇游戏（一）文档</title>
    <link href="/c-snake-pro0/"/>
    <url>/c-snake-pro0/</url>
    
    <content type="html"><![CDATA[<p>很早就想制作一个贪吃蛇游戏，老是写了一点就半途而废，终于狠下心来花了半天的时间写完了第一版本的贪吃蛇游戏，虽然因为坐标设置的原因导致有些小失败，但依旧完成了主要的功能模块，记录一下。</p><a id="more"></a><h2 id="前提：EasyX"><a href="#前提：EasyX" class="headerlink" title="前提：EasyX"></a>前提：EasyX</h2><blockquote><p>EasyX 是针对 C++ 的图形库，可以帮助 C 语言初学者快速上手图形和游戏编程。</p></blockquote><p>官网链接：<a href="https://easyx.cn/">https://easyx.cn/</a></p><h2 id="制作流程"><a href="#制作流程" class="headerlink" title="制作流程"></a>制作流程</h2><p>先开始写文档，分析要实现哪些功能，然后对功能进行细分，梳理操作。以下80%的内容都是当时写贪吃蛇的文档，后期整理一下发博客记录。</p><h2 id="草稿：想要实现的功能"><a href="#草稿：想要实现的功能" class="headerlink" title="草稿：想要实现的功能"></a>草稿：想要实现的功能</h2><p>贪吃蛇游戏的简单版本实现</p><ol><li>贪吃蛇吃食物身体加长</li><li>食物被吃后随机出现(不能够出现在蛇的身上)</li><li>无操作时贪吃蛇自动向蛇头方向前进</li><li>上下左右移动位置</li><li>撞到身体或者墙壁死亡</li><li>显示时间与分数</li></ol><h2 id="功能梳理"><a href="#功能梳理" class="headerlink" title="功能梳理"></a>功能梳理</h2><h3 id="蛇的操作"><a href="#蛇的操作" class="headerlink" title="蛇的操作"></a>蛇的操作</h3><ol><li>上下左右四个按键控制蛇头的朝向。当按键方向与蛇头方向相同或者相反时无反应。</li><li>不受操作时蛇自动按照蛇头方向前行</li><li>蛇头吃到食物之后，身体加长</li><li>蛇头撞到自身或者墙壁后死亡</li><li>蛇头控制方向，其余结点均是复制前一个结点的坐标。</li></ol><h3 id="食物的操作"><a href="#食物的操作" class="headerlink" title="食物的操作"></a>食物的操作</h3><ol><li>初始时刻食物出现在某个固定位置</li><li>食物被吃掉后随机出现在其他地方，但是不能够出现在蛇的身上。</li></ol><h3 id="界面显示"><a href="#界面显示" class="headerlink" title="界面显示"></a>界面显示</h3><ol><li>分为游戏区与功能区，游戏区展现蛇与食物，功能区展示时间、分数、玩法介绍以及作者信息</li><li>蛇使用方块表示，蛇头与蛇身容易区分。食物使用圆形表示。</li><li>游戏结束后，显示“GAME OVER”，然后显示游戏时长以及游戏分数。</li></ol><h3 id="界面大小设置"><a href="#界面大小设置" class="headerlink" title="界面大小设置"></a>界面大小设置</h3><ol><li>坐标系。这是一个纯2D游戏，一般来说坐标都是在最左上角，为了便于计算(个人习惯)，将坐标原点放置在左下角，x轴向右，y轴向上。</li></ol><blockquote><p>实际上游戏的坐标都是采用原点在左上角，这里因为我设置了坐标轴的原因导致了<strong>后面文字摆放无法放置正确</strong>，也是因为这个原因，要重写了第二版代码。</p></blockquote><ol start="2"><li>整体界面大小为：长640px，宽480px。游戏区为 480 * 480的正方形区域，位居界面左侧。功能区为 160 * 480的区域，位居界面右侧。</li><li>游戏区全部分为20 * 20 px的小正方形区域，便于蛇与食物的放置即坐标计算。蛇使用方块，食物使用圆形。采取图形中心点代表整个图形的方式，即(10,10)表示一个图形。为了防止边界的图像颜色干扰，设置蛇的方块中心点到四边的距离为9px，食物的半径为8px。</li></ol><h2 id="变量结构设置"><a href="#变量结构设置" class="headerlink" title="变量结构设置"></a>变量结构设置</h2><h3 id="食物结构体设置"><a href="#食物结构体设置" class="headerlink" title="食物结构体设置"></a>食物结构体设置</h3><p>对于食物而言，一次只会出现一个食物，只需要保存它的坐标位置，以及存在状态即可。</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Food</span>//食物结构体</span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> x;<span class="hljs-comment">//横坐标</span>    <span class="hljs-keyword">int</span> y;<span class="hljs-comment">//纵坐标</span>    <span class="hljs-keyword">bool</span> exist;<span class="hljs-comment">//是否存在，1表示存在</span>&#125;;</code></pre><h3 id="蛇结构体设置"><a href="#蛇结构体设置" class="headerlink" title="蛇结构体设置"></a>蛇结构体设置</h3><p>对于蛇而言，蛇是由一个个节点构成的，每吃一个食物就会增加一个节点。并且所有节点都连接起来，采用链表是一个不错的选择。</p><p>结构体设置模仿自<strong>严蔚敏老师的数据结构</strong>链表的设置。定义蛇节点结构体，然后定义蛇的结构体。</p><blockquote><ol><li><p>本来采用的单向链表，但后续处理<strong>蛇的移动算法</strong>时发现需要从后向前复制节点的操作，于是改成了双向链表。</p></li><li><p>这里也可以采用数组啦，STL的vector容器啦来处理蛇的结构体。采用链表复习复习数据结构。</p></li></ol></blockquote><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>//蛇的节点</span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> x;<span class="hljs-comment">//横坐标</span>    <span class="hljs-keyword">int</span> y;<span class="hljs-comment">//纵坐标</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向下一个节点的指针</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">pre</span>;</span><span class="hljs-comment">//指向前一个节点的指针</span>&#125;* LinkNode;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Snake</span>//蛇的结构体</span><span class="hljs-class">&#123;</span>LinkNode head;<span class="hljs-comment">//指向头节点的指针</span>    LinkNode tail;<span class="hljs-comment">//指向尾节点的指针</span>    <span class="hljs-keyword">int</span> direction;<span class="hljs-comment">//蛇头方向</span>    <span class="hljs-keyword">int</span> num;<span class="hljs-comment">//节点数目</span>&#125;;</code></pre><h2 id="游戏核心算法"><a href="#游戏核心算法" class="headerlink" title="游戏核心算法"></a>游戏核心算法</h2><h3 id="蛇身移动算法"><a href="#蛇身移动算法" class="headerlink" title="蛇身移动算法"></a>蛇身移动算法</h3><p>贪吃蛇的移动完全是复制头部节点，蛇头控制方向与前进，其他节点均是重复前一个节点的行为。</p><p>而在处理蛇移动的时候，先要用后面节点的保存了它的前一个节点的坐标信息。故蛇身移动的算法，是从最后一个节点(tail)向前复制前一个节点的坐标，达成移动效果。</p><blockquote><p>想到这里就把蛇的结构体改为双向链表。便于我的操作。</p></blockquote><pre><code class="hljs xl">LinkNode linknode = snake.tail;<span class="hljs-keyword">while</span> (linknode != snake.head)&#123;<span class="hljs-function"><span class="hljs-title">linknode</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">x</span> = linknode-&gt;</span><span class="hljs-function"><span class="hljs-title">pre</span>-&gt;</span>x;<span class="hljs-function"><span class="hljs-title">linknode</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">y</span> = linknode-&gt;</span><span class="hljs-function"><span class="hljs-title">pre</span>-&gt;</span>y;<span class="hljs-function"><span class="hljs-title">linknode</span> = linknode-&gt;</span>pre;&#125;</code></pre><h3 id="食物生成算法"><a href="#食物生成算法" class="headerlink" title="食物生成算法"></a>食物生成算法</h3><p>食物生成要具有随机性，并且要求食物不能够生成在蛇的身体上。</p><p>随机数函数rand()产生随机数，rand()函数需要的头文件是：&lt;stdlib.h&gt;。</p><blockquote><p>rand()会返回一个范围在0到RAND_MAX（32767）之间的伪随机数（整数）。</p><p>在调用rand()函数之前，可以使用srand()函数设置随机数种子，如果没有设置随机数种子，rand()函数在调用时，自动设计随机数种子为1。随机种子相同，每次产生的随机数也会相同。</p><p>srand( usigned int seed)函数用来设置rand()产生随机数时的随机数种子。参数seed是整数，通常可以利用time(0)的返回值作为seed。srand()函数需要的头文件是：&lt;stdlib.h&gt;</p><p>例如：生成0-6之间的任意一个随机数</p><p>srand(time(0));</p><p>int num = (rand()%7)//<strong>模求余</strong></p></blockquote><p>食物不能够在蛇的身体上，即生成坐标之后遍历蛇的节点进行匹配，若有对应的就直接重新生成一次。</p><pre><code class="hljs gml">int <span class="hljs-symbol">x</span>;int <span class="hljs-symbol">y</span>;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;srand(time(<span class="hljs-number">0</span>));<span class="hljs-symbol">x</span> = (rand() % <span class="hljs-number">24</span>) * <span class="hljs-number">20</span> + <span class="hljs-number">10</span>;<span class="hljs-symbol">y</span> = (rand() % <span class="hljs-number">24</span>) * <span class="hljs-number">20</span> + <span class="hljs-number">10</span>;<span class="hljs-comment">//食物位置检测算法</span>LinkNode linknode = snake.head;bool cont = <span class="hljs-literal">true</span>;<span class="hljs-keyword">while</span> (linknode != snake.tail-&gt;next)<span class="hljs-comment">//从头遍历到尾巴</span>&#123;<span class="hljs-keyword">if</span> (linknode-&gt;<span class="hljs-symbol">x</span> == <span class="hljs-symbol">x</span> &amp;&amp; linknode-&gt;<span class="hljs-symbol">y</span> == <span class="hljs-symbol">y</span>)&#123;cont = <span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;linknode = linknode-&gt;next;&#125;<span class="hljs-keyword">if</span> (cont)&#123;<span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果食物不在蛇的身体上，就break退出循环</span>&#125;&#125;food.<span class="hljs-symbol">x</span> = <span class="hljs-symbol">x</span>;food.<span class="hljs-symbol">y</span> = <span class="hljs-symbol">y</span>;food.exist = <span class="hljs-literal">true</span>;</code></pre><h2 id="按键处理问题"><a href="#按键处理问题" class="headerlink" title="按键处理问题"></a>按键处理问题</h2><p><code>_khbit()</code>函数用来检测是否有键盘输入。如果有按键被按下，会返回一个1，否则返回值为0.它是一个<strong>非阻塞函数</strong>，无论有没有按键被按下，他都会立即返回结果。可以用来做循环的条件判断是否有按键，或者等待输入。</p><p><code>_getch()</code>函数作用是从控制台获取输入的字符，并返回获取到的字符值。而且这个函数是<strong>阻塞性函数</strong>，必须要获取输入字符后才会返回。</p><p><code>_kbhit()</code>与<code>_getch()</code>都是位于<code>conio.h</code>头文件中。(console IO)</p><pre><code class="hljs q"><span class="hljs-type">int</span> <span class="hljs-built_in">keys</span> = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> <span class="hljs-built_in">key</span>;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;if (<span class="hljs-built_in">keys</span> = _kbhit())&#123;<span class="hljs-built_in">key</span> = _getch();cout &lt;&lt; <span class="hljs-string">&quot;按键的值key:&quot;</span> &lt;&lt; <span class="hljs-built_in">key</span> &lt;&lt; endl;&#125;&#125;</code></pre><p>由此可以测的我们按键对应的键值是多少。</p><p>方向键↑ 对应值为72。</p><p>方向键↓ 对应值为80。</p><p>方向键← 对应值为75。</p><p>方向键→ 对应值为77。</p><p><strong>但是相信执行这一段代码会发现按一次键会有两个key被打印出来。但是写switch语句(代码中的按键处理模块)时却完全和第一个key值无关。这个问题暂时还没有解决！路过的大佬欢迎留言~</strong></p><p>这个方法我是从某潭某州的公开广告课上学到的。</p><blockquote><p>其他参考链接：<a href="https://blog.csdn.net/hou09tian/article/details/86668083">C++中_kbhit()函数与_getch()函数</a></p></blockquote><h2 id="伪流程"><a href="#伪流程" class="headerlink" title="伪流程"></a>伪流程</h2><pre><code class="hljs isbl"><span class="hljs-variable">int</span> <span class="hljs-function"><span class="hljs-title">main</span>()</span>&#123;    初始化资源；    绘制界面；    开始游戏:    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-number">1</span>)</span>    &#123;    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-variable">!</span>食物存在)</span>    &#123;            刷新食物并显示    &#125;        <span class="hljs-function"><span class="hljs-title">if</span>(按键)</span>    &#123;            相应操作：蛇头方向：上下左右    &#125;            向蛇头方向前进<span class="hljs-number">1</span>格。绘制蛇头        (<span class="hljs-variable">switch</span> <span class="hljs-variable">case</span>结构)                消除蛇尾图像。                <span class="hljs-function"><span class="hljs-title">judge</span>(蛇头吃食物)</span>        &#123;            蛇结点+<span class="hljs-number">1</span>，尾巴加长并显示出来            分数增加            食物状态刷新        &#125;        <span class="hljs-function"><span class="hljs-title">judge</span>(撞墙<span class="hljs-variable"><span class="hljs-keyword">or</span></span>撞自己)</span>        &#123;            死亡            <span class="hljs-variable">game</span> <span class="hljs-variable">over</span>            <span class="hljs-variable">break</span>        &#125;        <span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">sleep</span></span>(<span class="hljs-number">200</span>)</span>    &#125;    结束 回收资源；&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言（七）--中断程序设计</title>
    <link href="/assembly-language-7/"/>
    <url>/assembly-language-7/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：中断的概念、分类，CPU如何得知中断，中断的过程，中断向量表，自定义中断</p><a id="more"></a><h2 id="中断的概念和分类"><a href="#中断的概念和分类" class="headerlink" title="中断的概念和分类"></a>中断的概念和分类</h2><p>中断就是指CPU在执行指令的过程中，收到了中断请求，于是终止正在执行的程序去处理中断，处理完之后返回被终止的程序继续执行。</p><p>中断分为两大类：<strong>软件中断</strong>（内中断）与<strong>硬件中断</strong>（外中断）</p><h3 id="软件中断"><a href="#软件中断" class="headerlink" title="软件中断"></a>软件中断</h3><ol><li><p><strong>中断指令 int n</strong>。<br> ·比如DOS功能 INT 21H</p></li><li><p><strong>CPU遇到了某些运算错误</strong>。<br> 除法错中断（中断类型号 0）:执行除法指令时，若发现除数为0或超过了寄存器所能表达的范围，则立即产生一个类型为0的中断。(自己写的div 0之后运行就会卡住)<br> 溢出中断（中断类型号 4）:若溢出标志OF置1，由中断指令INTO来处理发生溢出的中断操作；若OF为0，则INTO指令不产生中断，CPU继续运行原程序。  </p></li><li><p><strong>debug程序时设置的中断</strong>。<br> 单步中断（中断类型号 1）:在DEBUG下执行<strong>T命令（或P命令）</strong>时，陷阱标志TF置为1，CPU自动产生类型为1的单步中断。产生单步中断时，CPU自动地将PSW、CS和IP的内容入栈保存，然后清除TF、IF。<br> 断点中断(中断类型号 3):断点中断也是供DEBUG调试程序使用的。在调试程序时，当CPU执行到断点时便产生中断(<strong>G命令</strong>)，这时显示出各寄存器及相关标志，可以查看寄存器或存储单元的内容。设置断点实际上是把一条断点指令INT 3插入到程序中，CPU每执行到断点处的INT 3指令，便产生一个中断。       </p></li></ol><h3 id="硬件中断"><a href="#硬件中断" class="headerlink" title="硬件中断"></a>硬件中断</h3><p>硬件中断是由输入/输出外设发出中断请求引起的中断。</p><ol><li><p><strong>不可屏蔽中断</strong>。<br> 通常是遇到故障时，比如电源故障、奇偶检验错、I/O通道校验错等紧急情况时系统自动产生的。<br> 这些不可屏蔽中断请求信号会接到CPU的NMI引脚上，不可屏蔽中断的中断类型号为2。<br> NMI (Non Maskable Interrupt)——不可屏蔽中断(即CPU不能屏蔽)无论状态寄存器中 IF 位的状态如何,CPU收到有效的NMI必须进行响应。</p></li><li><p><strong>可屏蔽中断</strong>。<br> 可屏蔽中断是键盘、显示器、打印机、磁盘、串行口/并行口等外设发出的。由于可屏蔽中断种类较多，各种处理要求不一样，因此系统专门用<strong>8259中断控制器</strong>来管理这些中断。<br> 可屏蔽是指可以使用软件设置允许或者禁止CPU进行响应。因为除了本身是否发出中断请求之外，该请求是否执行还要看CPU的IF标志的控制。</p></li></ol><p>不可屏蔽中断CPU必须立刻响应，而可屏蔽中断可以选择响应或者不响应，或者按照优先级排序处理。</p><blockquote><p>典型的非屏蔽中断源的例子是电源掉电，一旦出现，必须立即无条件地响应，否则进行其他任何工作都是没有意义的。</p><p>典型的可屏蔽中断源的例子是打印机中断，CPU对打印机中断请求的响应可以快一些，也可以慢一些，因为让打印机等待儿是完全可以的。 </p></blockquote><h2 id="CPU处理中断"><a href="#CPU处理中断" class="headerlink" title="CPU处理中断"></a>CPU处理中断</h2><p>80X86系统中所有的中断请求都会有与之相对应的<strong>中断处理子程序</strong>。CPU响应中断之后会跳转到中断处理子程序，执行完之后会回到原来程序执行的断点处继续执行。</p><h3 id="中断类型"><a href="#中断类型" class="headerlink" title="中断类型"></a>中断类型</h3><p>80X86系统一共提供了256个中断类型，类型号为0–FFH。</p><p>但是系统只使用了一部分类型号。</p><h3 id="中断向量与中断向量表"><a href="#中断向量与中断向量表" class="headerlink" title="中断向量与中断向量表"></a>中断向量与中断向量表</h3><p>CPU要跳转执行中断处理子程序就需要知道它存放在那里，有入口地址才能够跳转执行。这个入口地址称之为中断向量（段地址+偏移地址）。</p><p>中断向量表，80X86系统建立的保存中断向量的地址区域，位于内存最低地址区中0号单元开始的1KB单元之中。</p><p>一个中断向量占用2个字即四个字节，高字单元根据放段地址，低字单元放偏移地址。</p><p>由于从0号单元开始，根据中断类型号码，乘以四就可以得到内存向量。</p><p><img src="/assembly-language-7/assembly-language-14%5Ci-table.png" alt="中断向量表"></p><h3 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h3><p>内部中断优先级最高，其次是非屏蔽中断，优先级最低的是单步中断。</p><p><img src="/assembly-language-7/assembly-language-14%5Cyouxian.jpg" alt="中断优先级"></p><h3 id="CPU中断过程"><a href="#CPU中断过程" class="headerlink" title="CPU中断过程"></a>CPU中断过程</h3><ol><li><p><strong>中断响应条件</strong>。<br> （1）  当前的指令周期结束；<br> （2）  采样到有效的中断请求信号；<br> （3）  如果是可屏蔽中断请求INTR，检查中断允许标志IF是否为1，即中断开放；<br> （4） CPU正在执行的程序不是中断服务程序，或者是中断优先级较低的中断服务程序。<br> 此外，特殊情况CPU不会响应中断。<br> （1） 当执行到STI指令时，CPU不会马上响应中断。STI指令是开中断指令，要求在开放中断后再执行后续的一条指令后才能响应中断；<br> （2） IRET指令是中断子程序返回指令，它也要求再执行一条后续指令后才能响应中断。这样做的目的是保护系统能够正常运行；<br> （3）当执行MOV SS,AX指令，即向SS段寄存器传送数据时，即使发生了中断，CPU也不会响应；直到本条执行完后，接着再执行一条指令才响应中断。<br> 所以遇到非屏蔽中断时，这些特殊情况怎么做？？？</p></li><li><p><strong>中断响应过程</strong>。<br> (1)首先将标志寄存器FLAGS压入堆栈，将陷阱标志TF存入暂存器；<br> (2)将IF和TF清零；<br> (3)将正在运行程序的断点的CS和IP压入堆栈；<br> (4)从中断向量表中取出中断向量高两个字节的内容送入CS，取出低两个字节的内容送到IP；<br> (5)转到相应中断源的中断服务程序入口，执行中断处理服务程序。<br> 简单来说：就是先保护现场，然后更换CS:IP的内容，执行。</p></li><li><p><strong>中断处理</strong>。<br> 即执行中断处理子程序。<br> 中断之中可以嵌套中断，如果新的中断优先级高于现在处理的中断，CPU就会转去执行新的中断。</p></li><li><p><strong>中断返回</strong>。<br> 中断子程序的结尾为<strong>IRET</strong>。即中断返回，恢复现场。<br> 将保存在堆栈中断点的偏移地址和段地址弹出，修改IP和CS寄存器；再把保存在堆栈中的PSW各标志位弹到FLAGS寄存器中，然后返回到被中断的程序去继续执行。</p></li></ol><p>在中断发生时，<strong>CPU自动清除了IF位和TF位</strong>。使执行中断处理过程中，避免再次发生外部中断的干扰。 </p><h2 id="定制自己的中断程序"><a href="#定制自己的中断程序" class="headerlink" title="定制自己的中断程序"></a>定制自己的中断程序</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>保护现场</li><li>STI 开中断指令（IF=1）</li><li>处理中断</li><li>CLI 关中断指令（IF=0）</li><li>恢复现场</li><li>IRET 指令，返回被中断的程序</li></ol><p>从应用程序进入中断子程序时，IF、TF都被清除，此时CPU在中断子程序中不会再响应其他的外部中断请求。</p><p>但如果这个中断子程序允许被打断或者优先级不高的话，设计中断子程序时就要开放中断标志，允许被打断。</p><p>IRET指令和RET指令都是返回原调用程序，但是<strong>IRET指令还要弹出保存的标志寄存器的值</strong>。</p><h3 id="中断的设置"><a href="#中断的设置" class="headerlink" title="中断的设置"></a>中断的设置</h3><ol><li><p><strong>设置中断向量</strong>。<br> DOS中断INT 21H的25H号功能。将DS:DX中的中断向量写入中断向量表。<br> DS存储中断子程序名的段地址，DX存储中断子程序名的偏移地址。</p><p>AH=25H<br>AL=中断类型号码<br>DS:DX=中断向量<br>INT 21H</p></li><li><p><strong>取出中断向量</strong>。<br> DOS中断INT 21H的35H号功能。从中断向量表中取出中断向量放入ES:BX。<br> ES存储中断子程序名的段地址，BX存储中断子程序名的偏移地址。</p><p>AH=35H<br>AL=中断类型号码<br>INT 21H</p></li><li><p><strong>中断驻留</strong>。<br> 特殊的退出程序，在退出前保留程序占用的内存，使得程序的内存不会被其他程序占据或覆盖，从而让此<strong>中断程序驻留在内存</strong>，从而其他程序也可以调用此中断。</p><p>AH=31H<br>AL=0;表示返回码<br>DX=驻留程序的长度<br>INT 21H</p><p>附：<strong>驻留程序的长度</strong><br>中断子程序<br>mail proc far            ;中断子程序名<br>smail:                ;子程序开始标号<br>……                ;子程序内容<br>iret<br>smaisl:nop         ;标号的结尾，Nop表示无操作的意思。<br>mail endp<br>故驻留程序的长度为：DX=smaisl-smail+16。两个标号名字不同，最后记得+16.</p></li></ol><h3 id="案例：7ch号功能，显示一段字符"><a href="#案例：7ch号功能，显示一段字符" class="headerlink" title="案例：7ch号功能，显示一段字符"></a>案例：7ch号功能，显示一段字符</h3><pre><code>  ;7ch号中断处理程序的功能是在屏幕上输出自己的班级，班级序号，学号，姓名。  ;例如：1706 1 20177004 xuhaoyong  ;并在另外一个程序程序中调用7ch号中断。  data segment      mess db 0ah,0dh,&#39;1701 5 20170000 colourso $&#39;      mess1 db 0ah,0dh,&#39;Trigger interrupt, display information $&#39;      mess2 db 0ah,0dh,&#39;Continue or Quit(c/q): $&#39;  data ends  stack segment stack      db 256 dup(?)  stack ends  code segment      assume cs:code,ds:data      start:      ;mov ax,data      ;mov ds,ax  ;主程序  main proc far  mov ax,seg show  mov ds,ax        ;将子程序的段地址给ds  mov dx,offset show;偏移地址  mov ah,25h  mov al,7ch        ;中断类型号  int 21h            ;写入中断向量表  ;调用7ch号中断  con:  mov ax,data  mov ds,ax  mov dx,offset mess1  mov ah,9  int 21h    ;输出  int 7ch  mov dx,offset mess2  mov ah,9  int 21h    ;输出  mov ah,1  int 21h  cmp al,&#39;c&#39;  je con  ;退出的话将子程序中断驻留  mov ah,31h  mov al,0  mov dx,showend-showstart+16  int 21h  mov ah,4ch  int 21h  main endp  ;中断子程序  show proc far  showstart:      sti;开中断      mov ax,data  mov ds,ax  mov dx,offset mess  mov ah,9  int 21h    ;输出  cli    ;关中断  iret  showend:nop  show endp  code ends      end start</code></pre><p>向量表的位置：7ch *4h = 1f0h。故在0000:01f0处查看int 7ch的中断向量表。</p><p>  <img src="/assembly-language-7/assembly-language-14%5Cint7ch.jpg" alt="INT 7CH中断"></p>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言（六）--中断程序设计</title>
    <link href="/assembly-language-14/"/>
    <url>/assembly-language-14/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：中断的概念、分类，CPU如何得知中断，中断的过程，中断向量表，自定义中断</p><a id="more"></a><h2 id="中断的概念和分类"><a href="#中断的概念和分类" class="headerlink" title="中断的概念和分类"></a>中断的概念和分类</h2><p>中断就是指CPU在执行指令的过程中，收到了中断请求，于是终止正在执行的程序去处理中断，处理完之后返回被终止的程序继续执行。</p><p>中断分为两大类：<strong>软件中断</strong>（内中断）与<strong>硬件中断</strong>（外中断）</p><h3 id="软件中断"><a href="#软件中断" class="headerlink" title="软件中断"></a>软件中断</h3><ol><li><p><strong>中断指令 int n</strong>。<br> ·比如DOS功能 INT 21H</p></li><li><p><strong>CPU遇到了某些运算错误</strong>。<br> 除法错中断（中断类型号 0）:执行除法指令时，若发现除数为0或超过了寄存器所能表达的范围，则立即产生一个类型为0的中断。(自己写的div 0之后运行就会卡住)<br> 溢出中断（中断类型号 4）:若溢出标志OF置1，由中断指令INTO来处理发生溢出的中断操作；若OF为0，则INTO指令不产生中断，CPU继续运行原程序。  </p></li><li><p><strong>debug程序时设置的中断</strong>。<br> 单步中断（中断类型号 1）:在DEBUG下执行<strong>T命令（或P命令）</strong>时，陷阱标志TF置为1，CPU自动产生类型为1的单步中断。产生单步中断时，CPU自动地将PSW、CS和IP的内容入栈保存，然后清除TF、IF。<br> 断点中断(中断类型号 3):断点中断也是供DEBUG调试程序使用的。在调试程序时，当CPU执行到断点时便产生中断(<strong>G命令</strong>)，这时显示出各寄存器及相关标志，可以查看寄存器或存储单元的内容。设置断点实际上是把一条断点指令INT 3插入到程序中，CPU每执行到断点处的INT 3指令，便产生一个中断。       </p></li></ol><h3 id="硬件中断"><a href="#硬件中断" class="headerlink" title="硬件中断"></a>硬件中断</h3><p>硬件中断是由输入/输出外设发出中断请求引起的中断。</p><ol><li><p><strong>不可屏蔽中断</strong>。<br> 通常是遇到故障时，比如电源故障、奇偶检验错、I/O通道校验错等紧急情况时系统自动产生的。<br> 这些不可屏蔽中断请求信号会接到CPU的NMI引脚上，不可屏蔽中断的中断类型号为2。<br> NMI (Non Maskable Interrupt)——不可屏蔽中断(即CPU不能屏蔽)无论状态寄存器中 IF 位的状态如何,CPU收到有效的NMI必须进行响应。</p></li><li><p><strong>可屏蔽中断</strong>。<br> 可屏蔽中断是键盘、显示器、打印机、磁盘、串行口/并行口等外设发出的。由于可屏蔽中断种类较多，各种处理要求不一样，因此系统专门用<strong>8259中断控制器</strong>来管理这些中断。<br> 可屏蔽是指可以使用软件设置允许或者禁止CPU进行响应。因为除了本身是否发出中断请求之外，该请求是否执行还要看CPU的IF标志的控制。</p></li></ol><p>不可屏蔽中断CPU必须立刻响应，而可屏蔽中断可以选择响应或者不响应，或者按照优先级排序处理。</p><blockquote><p>典型的非屏蔽中断源的例子是电源掉电，一旦出现，必须立即无条件地响应，否则进行其他任何工作都是没有意义的。</p><p>典型的可屏蔽中断源的例子是打印机中断，CPU对打印机中断请求的响应可以快一些，也可以慢一些，因为让打印机等待儿是完全可以的。 </p></blockquote><h2 id="CPU处理中断"><a href="#CPU处理中断" class="headerlink" title="CPU处理中断"></a>CPU处理中断</h2><p>80X86系统中所有的中断请求都会有与之相对应的<strong>中断处理子程序</strong>。CPU响应中断之后会跳转到中断处理子程序，执行完之后会回到原来程序执行的断点处继续执行。</p><h3 id="中断类型"><a href="#中断类型" class="headerlink" title="中断类型"></a>中断类型</h3><p>80X86系统一共提供了256个中断类型，类型号为0–FFH。</p><p>但是系统只使用了一部分类型号。</p><h3 id="中断向量与中断向量表"><a href="#中断向量与中断向量表" class="headerlink" title="中断向量与中断向量表"></a>中断向量与中断向量表</h3><p>CPU要跳转执行中断处理子程序就需要知道它存放在那里，有入口地址才能够跳转执行。这个入口地址称之为中断向量（段地址+偏移地址）。</p><p>中断向量表，80X86系统建立的保存中断向量的地址区域，位于内存最低地址区中0号单元开始的1KB单元之中。</p><p>一个中断向量占用2个字即四个字节，高字单元根据放段地址，低字单元放偏移地址。</p><p>由于从0号单元开始，根据中断类型号码，乘以四就可以得到内存向量。</p><p><img src="/assembly-language-14/assembly-language-14%5Ci-table.png" alt="中断向量表"></p><h3 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h3><p>内部中断优先级最高，其次是非屏蔽中断，优先级最低的是单步中断。</p><p><img src="/assembly-language-14/assembly-language-14%5Cyouxian.jpg" alt="中断优先级"></p><h3 id="CPU中断过程"><a href="#CPU中断过程" class="headerlink" title="CPU中断过程"></a>CPU中断过程</h3><ol><li><p><strong>中断响应条件</strong>。<br> （1）  当前的指令周期结束；<br> （2）  采样到有效的中断请求信号；<br> （3）  如果是可屏蔽中断请求INTR，检查中断允许标志IF是否为1，即中断开放；<br> （4） CPU正在执行的程序不是中断服务程序，或者是中断优先级较低的中断服务程序。<br> 此外，特殊情况CPU不会响应中断。<br> （1） 当执行到STI指令时，CPU不会马上响应中断。STI指令是开中断指令，要求在开放中断后再执行后续的一条指令后才能响应中断；<br> （2） IRET指令是中断子程序返回指令，它也要求再执行一条后续指令后才能响应中断。这样做的目的是保护系统能够正常运行；<br> （3）当执行MOV SS,AX指令，即向SS段寄存器传送数据时，即使发生了中断，CPU也不会响应；直到本条执行完后，接着再执行一条指令才响应中断。<br> 所以遇到非屏蔽中断时，这些特殊情况怎么做？？？</p></li><li><p><strong>中断响应过程</strong>。<br> (1)首先将标志寄存器FLAGS压入堆栈，将陷阱标志TF存入暂存器；<br> (2)将IF和TF清零；<br> (3)将正在运行程序的断点的CS和IP压入堆栈；<br> (4)从中断向量表中取出中断向量高两个字节的内容送入CS，取出低两个字节的内容送到IP；<br> (5)转到相应中断源的中断服务程序入口，执行中断处理服务程序。<br> 简单来说：就是先保护现场，然后更换CS:IP的内容，执行。</p></li><li><p><strong>中断处理</strong>。<br> 即执行中断处理子程序。<br> 中断之中可以嵌套中断，如果新的中断优先级高于现在处理的中断，CPU就会转去执行新的中断。</p></li><li><p><strong>中断返回</strong>。<br> 中断子程序的结尾为<strong>IRET</strong>。即中断返回，恢复现场。<br> 将保存在堆栈中断点的偏移地址和段地址弹出，修改IP和CS寄存器；再把保存在堆栈中的PSW各标志位弹到FLAGS寄存器中，然后返回到被中断的程序去继续执行。</p></li></ol><p>在中断发生时，<strong>CPU自动清除了IF位和TF位</strong>。使执行中断处理过程中，避免再次发生外部中断的干扰。 </p><h2 id="定制自己的中断程序"><a href="#定制自己的中断程序" class="headerlink" title="定制自己的中断程序"></a>定制自己的中断程序</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>保护现场</li><li>STI 开中断指令（IF=1）</li><li>处理中断</li><li>CLI 关中断指令（IF=0）</li><li>恢复现场</li><li>IRET 指令，返回被中断的程序</li></ol><p>从应用程序进入中断子程序时，IF、TF都被清除，此时CPU在中断子程序中不会再响应其他的外部中断请求。</p><p>但如果这个中断子程序允许被打断或者优先级不高的话，设计中断子程序时就要开放中断标志，允许被打断。</p><p>IRET指令和RET指令都是返回原调用程序，但是<strong>IRET指令还要弹出保存的标志寄存器的值</strong>。</p><h3 id="中断的设置"><a href="#中断的设置" class="headerlink" title="中断的设置"></a>中断的设置</h3><ol><li><p><strong>设置中断向量</strong>。<br> DOS中断INT 21H的25H号功能。将DS:DX中的中断向量写入中断向量表。<br> DS存储中断子程序名的段地址，DX存储中断子程序名的偏移地址。</p><p>AH=25H<br>AL=中断类型号码<br>DS:DX=中断向量<br>INT 21H</p></li><li><p><strong>取出中断向量</strong>。<br> DOS中断INT 21H的35H号功能。从中断向量表中取出中断向量放入ES:BX。<br> ES存储中断子程序名的段地址，BX存储中断子程序名的偏移地址。</p><p>AH=35H<br>AL=中断类型号码<br>INT 21H</p></li><li><p><strong>中断驻留</strong>。<br> 特殊的退出程序，在退出前保留程序占用的内存，使得程序的内存不会被其他程序占据或覆盖，从而让此<strong>中断程序驻留在内存</strong>，从而其他程序也可以调用此中断。</p><p>AH=31H<br>AL=0;表示返回码<br>DX=驻留程序的长度<br>INT 21H</p><p>附：<strong>驻留程序的长度</strong><br>中断子程序<br>mail proc far            ;中断子程序名<br>smail:                ;子程序开始标号<br>……                ;子程序内容<br>iret<br>smaisl:nop         ;标号的结尾，Nop表示无操作的意思。<br>mail endp<br>故驻留程序的长度为：DX=smaisl-smail+16。两个标号名字不同，最后记得+16.</p></li></ol><h3 id="案例：7ch号功能，显示一段字符"><a href="#案例：7ch号功能，显示一段字符" class="headerlink" title="案例：7ch号功能，显示一段字符"></a>案例：7ch号功能，显示一段字符</h3><pre><code>  ;7ch号中断处理程序的功能是在屏幕上输出自己的班级，班级序号，学号，姓名。  ;例如：1706 1 20177004 xuhaoyong  ;并在另外一个程序程序中调用7ch号中断。  data segment      mess db 0ah,0dh,&#39;1701 5 20170000 colourso $&#39;      mess1 db 0ah,0dh,&#39;Trigger interrupt, display information $&#39;      mess2 db 0ah,0dh,&#39;Continue or Quit(c/q): $&#39;  data ends  stack segment stack      db 256 dup(?)  stack ends  code segment      assume cs:code,ds:data      start:      ;mov ax,data      ;mov ds,ax  ;主程序  main proc far  mov ax,seg show  mov ds,ax        ;将子程序的段地址给ds  mov dx,offset show;偏移地址  mov ah,25h  mov al,7ch        ;中断类型号  int 21h            ;写入中断向量表  ;调用7ch号中断  con:  mov ax,data  mov ds,ax  mov dx,offset mess1  mov ah,9  int 21h    ;输出  int 7ch  mov dx,offset mess2  mov ah,9  int 21h    ;输出  mov ah,1  int 21h  cmp al,&#39;c&#39;  je con  ;退出的话将子程序中断驻留  mov ah,31h  mov al,0  mov dx,showend-showstart+16  int 21h  mov ah,4ch  int 21h  main endp  ;中断子程序  show proc far  showstart:      sti;开中断      mov ax,data  mov ds,ax  mov dx,offset mess  mov ah,9  int 21h    ;输出  cli    ;关中断  iret  showend:nop  show endp  code ends      end start</code></pre><p>向量表的位置：7ch *4h = 1f0h。故在0000:01f0处查看int 7ch的中断向量表。</p><p>  <img src="/assembly-language-14/assembly-language-14%5Cint7ch.jpg" alt="INT 7CH中断"></p>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言（五）--基本伪指令</title>
    <link href="/assembly-language-5/"/>
    <url>/assembly-language-5/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：常用的一些伪指令的用法和作用记录。</p><a id="more"></a><h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p>所谓伪指令，就是不能够像汇编指令那样生成可执行的二进制机器代码，而是在汇编程序(MASM)对源程序(.ASM)进行汇编时<strong>由汇编程序执行的</strong>。</p><h2 id="段定义伪指令"><a href="#段定义伪指令" class="headerlink" title="段定义伪指令"></a>段定义伪指令</h2><h3 id="1-段定义"><a href="#1-段定义" class="headerlink" title="1.段定义"></a>1.段定义</h3><pre><code class="hljs livecodeserver">段名 <span class="hljs-keyword">segment</span> [参数类型]……段名 <span class="hljs-keyword">ends</span></code></pre><p>segment与ends必须成对使用，表示段的开始与结尾。而8086中一共有四个段。</p><h3 id="2-assume"><a href="#2-assume" class="headerlink" title="2.assume"></a>2.assume</h3><p>assume用于将段寄存器与段关联起来，<strong>指明段寄存器与段的对应关系</strong>。</p><pre><code class="hljs ada">assume 段名 : 段寄存器，段名 : 段寄存器</code></pre><h3 id="3-段寄存器的赋值方式"><a href="#3-段寄存器的赋值方式" class="headerlink" title="3.段寄存器的赋值方式"></a>3.段寄存器的赋值方式</h3><ul><li>代码段寄存器CS是<strong>不能</strong>够使用MOV指令来赋值的。其他都可以用MOV初始化</li><li>段地址<strong>不能</strong>够直接传送给段寄存器。如<code>mov ds,data </code>   data是定义的数据段，这样是错误的！</li><li>段寄存器赋值方式：<code>段地址  --&gt;  一般寄存器  --&gt;  段寄存器</code></li></ul><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span></code></pre><h3 id="4-实例"><a href="#4-实例" class="headerlink" title="4.实例"></a>4.实例</h3><pre><code class="hljs x86asm">DATA  <span class="hljs-meta">SEGMENT</span>    ；数据段定义伪指令……DATA  ENDS    ；数据段结束                             EXTRA <span class="hljs-meta">SEGMENT</span>；附加段定义伪指令……EXTRA ENDS；附加段结束STACK <span class="hljs-meta">SEGMENT</span> STACK<span class="hljs-comment">;定义堆栈段，第一个STACK为自定义堆栈段的名称，第二个为表示定义的段为堆栈段</span>……STACK ENDS；堆栈段结束CODE  <span class="hljs-meta">SEGMENT</span>     ；代码段定义伪指令    <span class="hljs-meta">ASSUME</span> <span class="hljs-built_in">CS</span>:CODE,<span class="hljs-built_in">DS</span>:DATA,<span class="hljs-built_in">ES</span>:EXTRA,<span class="hljs-built_in">SS</span>:STACK    ；指定段寄存器与对应段名<span class="hljs-symbol">START:</span><span class="hljs-keyword">MOV</span>  <span class="hljs-built_in">AX</span>,DATA <span class="hljs-keyword">MOV</span>  <span class="hljs-built_in">DS</span>,<span class="hljs-built_in">AX</span>        ；将数据段段地址送入<span class="hljs-built_in">DS</span><span class="hljs-keyword">MOV</span>  <span class="hljs-built_in">AX</span>,EXTRA<span class="hljs-keyword">MOV</span>  <span class="hljs-built_in">ES</span>,<span class="hljs-built_in">AX</span>；将附加段段地址送入<span class="hljs-built_in">ES</span><span class="hljs-keyword">MOV</span>  <span class="hljs-built_in">AX</span>,STACK<span class="hljs-keyword">MOV</span>  <span class="hljs-built_in">SS</span>,<span class="hljs-built_in">AX</span>；将堆栈段段地址送入<span class="hljs-built_in">SS</span>……<span class="hljs-keyword">MOV</span>  <span class="hljs-number">AH</span>,<span class="hljs-number">4CH</span>        ；此两句为结束程序，返回DOS<span class="hljs-keyword">INT</span>  <span class="hljs-number">21H</span>   CODE  ENDS               ；代码段结束    END  START               ；整个程序结束伪指令</code></pre><h2 id="数据定义伪指令"><a href="#数据定义伪指令" class="headerlink" title="数据定义伪指令"></a>数据定义伪指令</h2><h2 id="其他伪指令"><a href="#其他伪指令" class="headerlink" title="其他伪指令"></a>其他伪指令</h2><h3 id="赋值伪指令"><a href="#赋值伪指令" class="headerlink" title="赋值伪指令"></a>赋值伪指令</h3><h3 id="地址计数器"><a href="#地址计数器" class="headerlink" title="地址计数器"></a>地址计数器</h3><h3 id="设置偏移地址"><a href="#设置偏移地址" class="headerlink" title="设置偏移地址"></a>设置偏移地址</h3><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>未完待续……</p>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL Server-- 表(table)的定义、删除与修改</title>
    <link href="/sql-server-2/"/>
    <url>/sql-server-2/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：SQL Server的基本表的定义、删除与修改。</p><a id="more"></a><blockquote><p><strong>参考学习书籍：数据库系统概论(第五版) 王珊、萨师煊编著</strong></p><p><strong>使用数据库版本：Microsoft SQL Server 2017 (RTM) - 14.0.1000.169 (X64)</strong></p><p><strong>管理工具：Microsoft SQL Server Managment Studio 17</strong></p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>基本格式：</p><pre><code>create table 表名(            列名1 数据类型 [列级完整性条件约束],            列名1 数据类型 [列级完整性条件约束],            列名1 数据类型 [列级完整性条件约束],            ...            [表级完整性条件约束]);</code></pre><p>建表的同时可以定义该表的完整性约束条件。如果该约束条件涉及该表的多个列的话，必须得定义为表级的约束条件。</p><p>例子：</p><pre><code>create table student(    Sno CHAR(9) PRIMARY KEY,/*Sno是主码*/    Sname CHAR(20) UNIQUE,E,/*Sname取唯一值*/    Ssex CHAR(2),    Sage SMALLINT,    Sdept CHAR(20));</code></pre><p>含有外码的情况：</p><pre><code>create table sc(    Sno CHAR(9),    Cno CHAR(4),    Grade SMALLINT,    PRIMARY KEY(Sno,Cno),/*主码为两个属性构成，必须作为表级完整性田间约束定义*/    FOREIGN KEY (Sno) REFERENCES student(Sno),/*Sno是外码，被参照表是Student*/    FOREIGN KEY (Cno) REFERENCES course(Cno));</code></pre><blockquote><p><strong>primary</strong> 美: [‘praɪm(ə)ri]  adj.    主要的；最重要的</p><p><strong>foreign</strong> 美: [‘fɔrən] adj.外来的；对外的</p><p><strong>reference</strong> 美: [‘ref(ə)rəns] n.    参考；</p></blockquote><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>定义表的各个属性时要指明其数据类型及长度。</p><p><img src="/sql-server-2/sqlserverdataset.png" alt="sql-server数据类型"></p><p>图片来自于<a href="http://www.w3school.com.cn/sql/sql_datatypes.asp"><strong>W3SCHOOL</strong></a></p><blockquote><p>参看链接：<a href="https://www.cnblogs.com/fttbfttb/articles/1510386.html">SQLServer数据类型及使用分析</a></p></blockquote><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>alter table 表名</p><h3 id="ADD子句"><a href="#ADD子句" class="headerlink" title="ADD子句"></a>ADD子句</h3><p>用于增加新列、新的列级完整性约束和新的表级完整性约束。</p><p>alter table 表名<br>add 新列名 数据类型 [列级完整性约束]</p><p>增加入学时间列，数据类型为DATE。</p><pre><code>alter table student add Sentrance DATE</code></pre><p>增加课程名称取唯一值的约束。</p><pre><code>alter table course add UNIQUE(Cname)</code></pre><h3 id="DROP-COLUMN语句"><a href="#DROP-COLUMN语句" class="headerlink" title="DROP COLUMN语句"></a>DROP COLUMN语句</h3><blockquote><p><strong>column</strong> 美: [‘kɑləm] n.纵队,列；</p></blockquote><p>删除表的列</p><blockquote><p>课本上依旧有RESTRICT(限制)以及CASCADE(级联)两种可选方式进行删除，与模式删除时类似的作用，SQLServer2017不能够使用。</p></blockquote><p>删除学生表的Sentrance列。</p><pre><code>alter table student drop column Sentrance</code></pre><h3 id="DROP-CONSTRAINT语句"><a href="#DROP-CONSTRAINT语句" class="headerlink" title="DROP CONSTRAINT语句"></a>DROP CONSTRAINT语句</h3><blockquote><p><strong>constraint</strong> 美: [kən’streɪnt] n.    约束；限制</p></blockquote><p>用于删除指定的完整性约束</p><blockquote><p>参看链接：<a href="https://blog.csdn.net/ccsuxwz/article/details/61435056">SQL中的几种约束的创建与删除</a></p></blockquote><h3 id="ALTER-CONSTRAINT语句"><a href="#ALTER-CONSTRAINT语句" class="headerlink" title="ALTER CONSTRAINT语句"></a>ALTER CONSTRAINT语句</h3><p>修改原有的列定义，包括修改列名和数据类型</p><p>将Sage的类型修改为INT型。</p><pre><code>alter table student alter column Sage int</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><pre><code>drop table 表名 </code></pre><blockquote><p>课本上依旧有RESTRICT(限制)以及CASCADE(级联)两种可选方式进行删除，与模式删除时类似的作用，SQLServer2017不能够使用。</p></blockquote><pre><code>drop table course/*error:无法删除对象 &#39;course&#39;，因为该对象正由一个 FOREIGN KEY 约束引用*/</code></pre><h2 id="SQL-Server-“DROP-TABLE-表名-CASCADE”-显示”CASCADE”附近有语法错误的原因"><a href="#SQL-Server-“DROP-TABLE-表名-CASCADE”-显示”CASCADE”附近有语法错误的原因" class="headerlink" title="SQL Server “DROP TABLE 表名 CASCADE” 显示”CASCADE”附近有语法错误的原因"></a>SQL Server “DROP TABLE 表名 CASCADE” 显示”CASCADE”附近有语法错误的原因</h2><blockquote><p>SQL Server在删除表时并不区分RESTRICT或是CASCADE。</p><p>既然不支持，那为何又能识别CASCADE为关键字呢？</p><p>事实上在SQL Server中CASCADE关键字用于在建表操作时预先建立级联关系（通常和DENY关键字配合使用，所以报有语法错），建表后执行DROP操作时就不需要用户再指定删除模式了。</p></blockquote><blockquote><p>参看链接：<a href="https://blog.csdn.net/Bthsky/article/details/78180591?locationNum=7&fps=1">SQL Server “DROP TABLE 表名 CASCADE” 显示”CASCADE”附近有语法错误的原因</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQLServer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL Server-- 模式(schema)</title>
    <link href="/sql-server-1/"/>
    <url>/sql-server-1/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：SQL Server的模式定义与删除。</p><a id="more"></a><blockquote><p><strong>参考学习书籍：数据库系统概论(第五版) 王珊、萨师煊编著</strong></p><p><strong>使用数据库版本：Microsoft SQL Server 2017 (RTM) - 14.0.1000.169 (X64)</strong></p><p><strong>管理工具：Microsoft SQL Server Managment Studio 17</strong></p></blockquote><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>定义模式就相当定义一个<strong>命名空间</strong>，在该空间内可以进一步定义该模式包含的数据库对象，如基本表、视图、索引等。</p><p><strong>一个数据库中可以建立多个模式</strong>，一个模式通常包括多个表、视图和索引等数据库对象。</p><p>正常使用的SQL Server在数据库内创建的表都是<code>dbo</code>开头的。因为我们正常使用的数据库用户名是<code>dbo</code>。如下图所示。</p><p><img src="/sql-server-1/schema1.png" alt="引图"></p><h2 id="模式创建"><a href="#模式创建" class="headerlink" title="模式创建"></a>模式创建</h2><blockquote><p>创建模式定义时，调用该命令的用户必须拥有管理员权限，否则无法创建。而且不能为登录名创建模式，必须是具体的数据库的用名。</p><p><strong>管理员权限才能创建，必须使用数据库用户名</strong></p><p>参考链接：<a href="https://blog.csdn.net/stay_zezo/article/details/78305849">sql-server(模式创建)</a></p></blockquote><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>你的当前数据库下/安全性/用户，在此用户下，右键新建用户，我选择的是<code>不带登录名的用户</code>，只填写了用户名。</p><p><img src="/sql-server-1/schema2.png" alt="引图"></p><h3 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h3><p>创建模式：<code> create schema 模式名 authorization 用户名</code></p><p>当然模式名可以省略，省略时模式名默认为用户名。</p><pre><code>create schema cc authorization colourso</code></pre><p>执行成功后，右键用户名查看其属性，查看拥有的架构即可看到定义的模式<code>cc</code>。</p><p><img src="/sql-server-1/schema3.png" alt="引图"></p><blockquote><p><strong>authorization</strong> 美: [.ɔθərɪ’zeɪʃ(ə)n]  n.    授权；批准</p></blockquote><h2 id="使用模式创建表"><a href="#使用模式创建表" class="headerlink" title="使用模式创建表"></a>使用模式创建表</h2><p>创建表时要加上指定的模式，即 <code>模式.表名</code>。</p><pre><code>create table cc.Stu(Sname char(20),Sno char(10) primary key);</code></pre><p><img src="/sql-server-1/schema4.png" alt="引图"></p><p>这样就可以创建表名相同，但是模式不同的表了。</p><h2 id="删除模式-课本"><a href="#删除模式-课本" class="headerlink" title="删除模式(课本)"></a>删除模式(课本)</h2><pre><code>drop schema 模式名 cascade/restrict </code></pre><p>cascade(级联)/restrict(限制)两者必须二选一。</p><p>**cascade(级联)**：在删除模式时同时把该模式的所有数据库对象都删除</p><p>**restrict(限制)**： 如果该模式已经定义了下属的数据库对象，则该删除指令无法执行。</p><blockquote><p><strong>cascade</strong>  英: [kæ’skeɪd] n.级联；阶梯；</p><p><strong>restrict</strong> 美: [rɪ’strɪkt] v.    限制；约束；</p></blockquote><h2 id="删除模式"><a href="#删除模式" class="headerlink" title="删除模式"></a>删除模式</h2><p>上面的代码在SQLServer中貌似并不能执行使用。百度了有人说‘SQL Server里drop schema语句并不支持cascade关键字’，不知道是不是真的😂。</p><pre><code>drop schema 模式名</code></pre><p>在SQLServer中直接使用上面语句进行删除，如果该模式没被使用就可以直接删除，否则需要先删除该模式的数据库对象才能删除。</p><blockquote><p>参考链接：CSDN-<strong>₩※※:-)逆行</strong>:<a href="https://blog.csdn.net/stay_zezo/article/details/78305849">sql-server(模式创建)</a></p></blockquote><h2 id="SQL-Server-“DROP-TABLE-表名-CASCADE”-显示”CASCADE”附近有语法错误的原因"><a href="#SQL-Server-“DROP-TABLE-表名-CASCADE”-显示”CASCADE”附近有语法错误的原因" class="headerlink" title="SQL Server “DROP TABLE 表名 CASCADE” 显示”CASCADE”附近有语法错误的原因"></a>SQL Server “DROP TABLE 表名 CASCADE” 显示”CASCADE”附近有语法错误的原因</h2><blockquote><p>SQL Server在删除表时并不区分RESTRICT或是CASCADE。</p><p>既然不支持，那为何又能识别CASCADE为关键字呢？</p><p>事实上在SQL Server中CASCADE关键字用于在建表操作时预先建立级联关系（通常和DENY关键字配合使用，所以报有语法错），建表后执行DROP操作时就不需要用户再指定删除模式了。</p></blockquote><blockquote><p>参看链接：<a href="https://blog.csdn.net/Bthsky/article/details/78180591?locationNum=7&fps=1">SQL Server “DROP TABLE 表名 CASCADE” 显示”CASCADE”附近有语法错误的原因</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQLServer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL Server 2017与SQL Server Management Studio的安装(非实操)</title>
    <link href="/sql-server-0/"/>
    <url>/sql-server-0/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：SQL Server 2017与SQL Server Management Studio的安装，当初安装时没记录，所以只是一些参考过的链接记录，说实话根本看不懂哪些需要还是不需要，头大。</p><a id="more"></a><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><strong>SQL Server 2017</strong>：<a href="https://www.microsoft.com/zh-cn/sql-server/sql-server-downloads">https://www.microsoft.com/zh-cn/sql-server/sql-server-downloads</a></p><p>**SQL Server Management Studio **：<a href="https://docs.microsoft.com/zh-cn/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017">https://docs.microsoft.com/zh-cn/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017</a></p><h2 id="安装参考链接"><a href="#安装参考链接" class="headerlink" title="安装参考链接"></a>安装参考链接</h2><ol><li>逍遥小丸子：SQL Server数据库基础：SQL Server 2017安装教程：<a href="https://blog.csdn.net/dnruanjian/article/details/85235139">https://blog.csdn.net/dnruanjian/article/details/85235139</a></li></ol><p>首先看的他的教程。</p><ol start="2"><li>软件安装管家：<a href="https://mp.weixin.qq.com/s/PHPnLGh-SEP5HkHdWtoZHg">https://mp.weixin.qq.com/s/PHPnLGh-SEP5HkHdWtoZHg</a></li></ol><p>java环境搭建的部分可以忽略，虽然是2016版本的，但是其他步骤按照这个安装没啥问题。</p><ol start="3"><li>开山怪-SQL server 2016 安装步骤：<a href="https://www.cnblogs.com/ksguai/p/5869558.html">https://www.cnblogs.com/ksguai/p/5869558.html</a></li></ol><p>也是2016版本的安装，基本步骤没啥问题。</p><ol start="4"><li>SQL Server 2017 安装过程中的一点说明（有点意思）：<a href="https://blog.csdn.net/a_222850215/article/details/80602723">https://blog.csdn.net/a_222850215/article/details/80602723</a></li></ol><p>这里面有个关于数据库功能-机器学习方面的内容，可以做做参考。</p><h2 id="我的安装"><a href="#我的安装" class="headerlink" title="我的安装"></a>我的安装</h2><p>印象中功能选择是那个机器学习服务，关于R和Python的那一部分我是没有勾选的，因为那会感觉对我没啥用，就没安装。</p><p><img src="/sql-server-0/sql.png" alt="引图"></p><p>建议安装的时候多百度吧。。。</p><h2 id="查询SQLServer安装版本"><a href="#查询SQLServer安装版本" class="headerlink" title="查询SQLServer安装版本"></a>查询SQLServer安装版本</h2><p>在<strong>Microsoft SQL Server Managment Studio</strong>中新建查询，输入 <code>select @@version</code> 然后执行即可看到安装版本。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQLServer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言（四）--指令的‘与数据有关的’寻址方式</title>
    <link href="/assembly-language-4/"/>
    <url>/assembly-language-4/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：三种与数据有关的寻址方式。</p><a id="more"></a><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>寻址方式就是指令中提供操作数或者操作数地址的方式，即寻找操作数地址的方法。</p><p>寻址方式分为<strong>与数据有关的寻址方式</strong>和<strong>与转移地址有关的寻址方式</strong>。</p><p>与转移地址有关的寻址方式如 jmp la1，这样的转移指令、循环指令、子程序调用指令等与转移地址有关。其余指令的寻址方式都与数据有关。</p><h2 id="数据操作数"><a href="#数据操作数" class="headerlink" title="数据操作数"></a>数据操作数</h2><p>数据有可能放在内存中，有可能放在CPU的寄存器中，还有可能直接写在指令中。</p><p>如果不在内存中存放，操作数就没有逻辑地址的概念，CPU不用访问存储器就能够得到操作数。</p><p>如果操作数在内存中，那么操作数的偏移地址以有效地址EA来表示。</p><h2 id="寻址方式分类"><a href="#寻址方式分类" class="headerlink" title="寻址方式分类"></a>寻址方式分类</h2><p><img src="/assembly-language-4/address-kinds.png" alt="引图"></p><h2 id="立即寻址方式"><a href="#立即寻址方式" class="headerlink" title="立即寻址方式"></a>立即寻址方式</h2><p>所要找的操作数(即<strong>立即数</strong>)直接写在指令中。</p><p>立即数只能够出现在<strong>源操作数</strong>的地方！</p><p>立即数的类型必须要和<strong>目的操作数的类型</strong>相一致！</p><p>当然立即数是存在于指令中的，而指令是存在于代码段的。</p><pre><code>mov ax,3060Hmov al,21H</code></pre><h2 id="寄存器寻址方式"><a href="#寄存器寻址方式" class="headerlink" title="寄存器寻址方式"></a>寄存器寻址方式</h2><p>操作数在寄存器中，在指令中指定寄存器名即可完成。</p><p>CPU在寄存器中直接得到操作数，不用访问内存，这种寻址方式指令短，速度快，但是可用资源少。</p><p>8位寄存器：AH、AL，BH、BL、CH、CL、DH、DL</p><p>16位寄存器：AX、BX、CX、DX、SI、DI、BP、SP</p><pre><code>mov ax,bx    ;都是16位，寄存器寻址mov al,ch    ;都是8位，寄存器寻址mov ax,4650H;目的操作数寄存器寻址，源操作数立即寻址</code></pre><h2 id="存储器寻址方式"><a href="#存储器寻址方式" class="headerlink" title="存储器寻址方式"></a>存储器寻址方式</h2><p>操作数存放在内存中，想要得到操作数，CPU必须要经过系统总线访问存储器。</p><p>而编写汇编程序时采用的时逻辑地址形式，故要计算<strong>有效地址EA</strong>(即逻辑地址里的<strong>偏移地址</strong>部分)。</p><p>且对于双操作数指令，两个操作数不允许同时使用存储器寻址方式，即不允许两个操作数都是存储单元。？？</p><h3 id="有效地址EA-–即逻辑地址里的偏移地址"><a href="#有效地址EA-–即逻辑地址里的偏移地址" class="headerlink" title="有效地址EA  –即逻辑地址里的偏移地址"></a>有效地址EA  –即逻辑地址里的偏移地址</h3><h3 id="直接寻址方式"><a href="#直接寻址方式" class="headerlink" title="直接寻址方式"></a>直接寻址方式</h3><pre><code>mov ax,ds:[2000H]</code></pre><p><code>[]</code>内的数据为操作数的偏移地址，前缀<code>DS:</code>表示该单元在数据段。</p><blockquote><p>在用<strong>MASM工具</strong>汇编时，不写前面的前缀只写<code>[2000H]</code>，汇编会认为是立即数而非偏移地址！</p><p>而在<strong>DEBUG工具</strong>中，使用A命令来写就不需要加前缀，默认是数据段。</p></blockquote><p>操作数的有效地址EA直接存放在指令中，CPU在取指令时直接取得操作数的有效地址，–故为直接寻址。</p><h4 id="1-存储器读操作"><a href="#1-存储器读操作" class="headerlink" title="1.存储器读操作"></a>1.存储器读操作</h4><pre><code>MOV AX,DS:[2000H]</code></pre><p>表示从数据段的2000H单元读一个字送入AX。</p><p>有效地址EA = 2000H。物理地址 DS*10H + EA。</p><p><img src="/assembly-language-4/read-m.png" alt="read memory"></p><h4 id="2-存储器写操作"><a href="#2-存储器写操作" class="headerlink" title="2.存储器写操作"></a>2.存储器写操作</h4><pre><code>MOV DS:[4000H],AX</code></pre><p>将AX中的字写入数据段的4000H单元。</p><p>有效地址EA = 4000H。物理地址 DS*10H + EA。</p><p><img src="/assembly-language-4/write-m.png" alt="write memory"></p><h4 id="3-符号地址"><a href="#3-符号地址" class="headerlink" title="3.符号地址"></a>3.符号地址</h4><p>除了直接使用数值作为EA，还可以使用<strong>符号地址</strong>的形式，–<strong>即给存储单元起一个名字</strong>。</p><p>在程序中使用符号地址，方便记忆和修改。</p><pre><code>VALUE DW 2345H    ;使用DW定义一个字的符号VALUE=2345HMOV AX,VALUE    ;这里用不用中括号括起来都可以，段地址默认都是DSMOV AX,[VALUE]    ;</code></pre><p>注意：使用EQU伪指令来指定符号地址，必须要加前缀指明哪个段！</p><h4 id="4-段超越"><a href="#4-段超越" class="headerlink" title="4.段超越"></a>4.段超越</h4><p>即与存储器有关的寻址方式，默认段是数据段，但也可以放在其他三个段，这种就叫段超越。</p><p>需要在指令中用前缀指出是哪个段！</p><pre><code>VALUE EQU 1000H        ;EQU伪指令符号，表示VALUE=1000HMOV AX,DS:[VALUE]    ;指出存储单元在DSMOV AX,ES:[VALUE]    ;指出存储单元在ES</code></pre><h3 id="寄存器间接寻址方式"><a href="#寄存器间接寻址方式" class="headerlink" title="寄存器间接寻址方式"></a>寄存器间接寻址方式</h3><pre><code>mov ax,[bx]</code></pre><p>操作数放在内存中，但是操作数的EA在寄存器BX、BP、SI、DI之中，且操作数的段地址存放于DS或者SS。</p><p>其中若有效地址由BX、SI、DI指出，则默认对应于数据段DS。</p><p>若有效地址由BP指出，则对应于堆栈段SS。</p><p><img src="/assembly-language-4/indirect.png" alt="indirect"></p><p>EA是从寄存器中得到的，所以叫寄存器间接寻址方式。并且<strong>8086CPU只允许BX、BP、SI、DI这四个寄存器作为间址寄存器</strong>。</p><pre><code>MOV AX,[CX]    ;错误</code></pre><p>寄存器间接寻址方式适用于<strong>简单的表格处理</strong>。</p><h3 id="寄存器相对寻址方式"><a href="#寄存器相对寻址方式" class="headerlink" title="寄存器相对寻址方式"></a>寄存器相对寻址方式</h3><pre><code>MOV AX,[BX+1234H]</code></pre><p>操作数放在内存中，但是操作数的EA在寄存器的内容上再加上一个8位或者16位的位移量。</p><p>同样，还是有效地址由BX、SI、DI指出，则默认对应于数据段DS。若由BP指出，则对应于堆栈段SS。</p><p><img src="/assembly-language-4/relative.png" alt="relative"></p><p>寄存器相对寻址方式常用于<strong>查表操作</strong>。</p><h4 id="寄存器相对寻址方式的四种写法"><a href="#寄存器相对寻址方式的四种写法" class="headerlink" title="寄存器相对寻址方式的四种写法"></a>寄存器相对寻址方式的四种写法</h4><pre><code>MOV AX,[BX+1234H]    ;MOV AX,[BX+TOP]        ;TOP是符号地址，位移量MOV AX,[BX].1234H    ;位移量可用.连接MOV AX,TOP[BX]        ;TOP是符号地址，位移量</code></pre><h3 id="基址变址寻址方式"><a href="#基址变址寻址方式" class="headerlink" title="基址变址寻址方式"></a>基址变址寻址方式</h3><pre><code>MOV AX,[BX+SI]</code></pre><p>操作数存放在内存中，操作数的EA为一个基址寄存器(BX、BP)和变址寄存器(SI、DI)的和。</p><p>故共有四种情况。</p><p><img src="/assembly-language-4/base.png" alt="base"></p><pre><code>MOV AH,ES:[SI+BX]    ;MOV AH,ES:[SI][BX]    ;两种写法都是可以的！MOV [BP+SI],CXMOV DL,SS:[BX+SI]</code></pre><p>基址变址寻址方式可用于<strong>二维表的处理</strong>。</p><h3 id="相对基址变址寻址方式"><a href="#相对基址变址寻址方式" class="headerlink" title="相对基址变址寻址方式"></a>相对基址变址寻址方式</h3><pre><code>MOV AX,[BX+SI+1234H]</code></pre><p>操作数存放在内存中，操作数的EA为一个基址寄存器(BX、BP)与变址寄存器(SI、DI)以及一个位移量的和。</p><p><img src="/assembly-language-4/relativebase.png" alt="relativebase"></p><p>相对基址变址寻址方式可用于<strong>二维表的查找</strong>和<strong>栈处理</strong>。</p><h4 id="相对基址变址寻址方式的几种写法"><a href="#相对基址变址寻址方式的几种写法" class="headerlink" title="相对基址变址寻址方式的几种写法"></a>相对基址变址寻址方式的几种写法</h4><pre><code>MOV AX,[BX+SI+1234H]    ;MOV AX,[BX+SI+TOP]        ;TOP是符号地址，位移量MOV AX,TOP[BX+SI]        ;TOP是符号地址，位移量MOV AX,TOP[BX][SI]        ;TOP是符号地址，位移量MOV AX,[BX+SI].1234H    ;位移量可用.连接</code></pre>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言（三）--汇编指令与段的综述</title>
    <link href="/assembly-language-3/"/>
    <url>/assembly-language-3/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：取指令过程、数据存取以及栈的概览，段的综述。</p><a id="more"></a><h2 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h2><p>机器指令也叫代码指令，是计算机能识别的一组<strong>二进制代码</strong>。</p><p>形如</p><pre><code>1011 0000 0000 0111 B</code></pre><p>把数“7”送到AL中</p><h2 id="汇编语言指令"><a href="#汇编语言指令" class="headerlink" title="汇编语言指令"></a>汇编语言指令</h2><p>汇编语言有三种指令形式，分别是<strong>汇编指令、伪指令、宏指令</strong>。</p><p>并且汇编指令是从机器指令演化而来的，与机器密切相关。</p><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><p>汇编指令由<strong>操作码字段</strong>和<strong>操作数字段</strong>构成。</p><p><strong>格式： 操作码字段 操作数字段</strong></p><p>操作数字段可以是0个，1个，2个，3个。</p><h3 id="双操作数"><a href="#双操作数" class="headerlink" title="双操作数"></a>双操作数</h3><pre><code>MOV AX,BX</code></pre><p><strong>格式：操作码 目的操作数，源操作数</strong></p><p>目的操作数也是操作后的<strong>结果</strong>。</p><h2 id="指令存取"><a href="#指令存取" class="headerlink" title="指令存取"></a>指令存取</h2><pre><code>CS : IP</code></pre><p>这是8086CPU中最关键的寄存器，指出了CPU当前要读取指令的地址。</p><p><strong>CS</strong>: 代码段寄存器，存放代码的段地址</p><p><strong>IP</strong>: 指令指针寄存器，存放代码的偏移地址</p><h3 id="8086取指过程"><a href="#8086取指过程" class="headerlink" title="8086取指过程"></a>8086取指过程</h3><ol><li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲区。</li><li>IP=IP+所读取指令的长度，从而指向下一条指令。</li><li>执行指令，转到步骤1，重复此过程。</li></ol><h3 id="CPU区分指令与数据"><a href="#CPU区分指令与数据" class="headerlink" title="CPU区分指令与数据"></a>CPU区分指令与数据</h3><p>内存中的指令与数据没有任何区别，都是二进制信息。CPU是将CS:IP指向的内存单元中的内容看做指令。</p><p>CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。</p><h3 id="修改CS、IP指令"><a href="#修改CS、IP指令" class="headerlink" title="修改CS、IP指令"></a>修改CS、IP指令</h3><p>在CPU中，程序员能够通过指令读写的部件只有寄存器，程序员通过改变寄存器中的内容实现对CPU的控制。</p><p>mov指令不能用于设置CS、IP的值，8086CPU没有提供这样的功能。</p><p>转移指令-jmp指令可以修改，用指令中给出的段地址修改CS，偏移地址修改IP。</p><p><strong>格式：jmp 段地址:偏移地址</strong></p><pre><code>jmp 2AE3:3</code></pre><h3 id="仅修改IP指令"><a href="#仅修改IP指令" class="headerlink" title="仅修改IP指令"></a>仅修改IP指令</h3><p>用寄存器中的值修改IP。</p><p><strong>格式：jmp 某一合法寄存器</strong></p><pre><code>jmp ax</code></pre><h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><p>将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU 并不会由于这种安排，就自动地将我们定义得代码段中的指令当作指令来执行。</p><p><strong>CPU 只认被 CS:IP 指向的内存单元中的内容为指令，所以要将CS:IP指向所定义的代码段中的第一条指令的首地址</strong>。</p><h2 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h2><h3 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h3><pre><code>mov bx,1000hmov ds,bxmov al,[0]；将10000H（1000:0）中的数据读到al中。</code></pre><ol><li>将数据直接送入寄存器；</li><li>将一个寄存器中的内容送入另一个寄存器中。</li><li>将一个内存单元中的内容送入一个寄存器。</li></ol><p><strong>格式：mov 寄存器名，内存单元地址</strong></p><p><strong>“[…]”表示一个内存单元</strong>， “[…]”中的数字表示内存单元的偏移地址，其段地址是DS。</p><p>mov指令中的[]说明操作对象是一个内存单元，[]中的0说明这个内存单元的偏移地址是0，它的<strong>段地址默认放在ds中</strong>。</p><h3 id="将数据送入段寄存器"><a href="#将数据送入段寄存器" class="headerlink" title="将数据送入段寄存器"></a>将数据送入段寄存器</h3><pre><code>mov ds,1000H;非法！</code></pre><p><strong>8086CPU不支持将数据直接送入段寄存器的操作！</strong>（硬件的问题）</p><p><strong>数据-&gt;一般寄存器-&gt;段寄存器</strong>。</p><h3 id="字的传送"><a href="#字的传送" class="headerlink" title="字的传送"></a>字的传送</h3><p><img src="/assembly-language-3/wordtrans.png" alt="引图"></p><p>如图所示，内存里一个存储单元只能存放一个字节(8位)，而寄存器是16位的。</p><p><img src="/assembly-language-3/wordtransend.png" alt="引图"></p><h3 id="add、sub指令"><a href="#add、sub指令" class="headerlink" title="add、sub指令"></a>add、sub指令</h3><p><img src="/assembly-language-3/addsub.png" alt="引图"></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>Last In First Out 后进先出</p><p>入栈：将一个新的元素放到栈顶；</p><p>出栈：从栈顶取出一个元素。</p><p>8086CPU的入栈和出栈操作都是<strong>以字为单位</strong>进行的。</p><pre><code>push ax;将寄存器ax中的数据送入栈中pop ax;从栈顶取出数据送入ax</code></pre><h3 id="CPU如何判断栈"><a href="#CPU如何判断栈" class="headerlink" title="CPU如何判断栈"></a>CPU如何判断栈</h3><p>寄存器CS和IP中存放着当前指令的段地址和偏移地址。</p><p><strong>SS</strong>： 段寄存器，存放栈顶的段地址<br><strong>SP</strong>：堆栈指针寄存器，存放栈顶的偏移地址</p><p>任意时刻，SS:SP指向栈顶元素</p><h3 id="push指令执行过程"><a href="#push指令执行过程" class="headerlink" title="push指令执行过程"></a>push指令执行过程</h3><ol><li>SP=SP-2</li><li>将ax的值放入SS:SP指向的内存单元</li></ol><p><img src="/assembly-language-3/push.png" alt="引图"></p><h3 id="栈为空时，SS-SP的状态"><a href="#栈为空时，SS-SP的状态" class="headerlink" title="栈为空时，SS:SP的状态"></a>栈为空时，SS:SP的状态</h3><p>我们将 <code>10000H~1000FH</code> 这段空间当作栈段，SS=1000H，栈空间大小为<strong>16 字节</strong> ，栈最底部的<strong>字单元地址</strong>为<code>1000:000E</code>。</p><p>任意时刻，SS:SP指向栈顶，当栈中<strong>只有一个元素的时候</strong>，SS = 1000H，SP=000EH。　</p><p><strong>栈为空，就相当于栈中唯一的元素出栈</strong>，出栈后，SP=SP+2 ，SP 原来为 000EH，加 2 后SP=10H，所以，当栈为空的时候，SS=1000H，SP=0010H。</p><p>当栈为空时，栈中没有元素，也就不存在栈顶元素，所以SS:SP只能够指向栈的最底部单元下面的单元，即栈最底部的字单元的偏移地址+2.</p><h3 id="pop指令执行过程"><a href="#pop指令执行过程" class="headerlink" title="pop指令执行过程"></a>pop指令执行过程</h3><ol><li>将SS:SP指向的内存单元的值放入ax</li><li>SP=SP+2</li></ol><p><img src="/assembly-language-3/pop.png" alt="引图"></p><p>执行指令后原栈顶的那个数据依旧存在于那个内存单元，只是它不在属于栈了。当执行push之后。它将会被覆盖掉。</p><h3 id="栈顶超界问题"><a href="#栈顶超界问题" class="headerlink" title="栈顶超界问题"></a>栈顶超界问题</h3><p>当栈满的时候Push以及栈空的时候pop都会发生栈顶超界问题。</p><p>而且8086CPU不保证栈的操作不会超界，即8086CPU只知道栈顶的位置。</p><p>所以只能使用的时候进行注意了！</p><h3 id="8086CPU的工作机理"><a href="#8086CPU的工作机理" class="headerlink" title="8086CPU的工作机理"></a>8086CPU的工作机理</h3><p>只考虑当前的情况：<br>当前栈顶在何处；<br>当前要执行的指令是哪一条。</p><p>8086CPU只记录栈顶，栈空间的大小我们要自己管理。</p><h3 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h3><p>我们自己将一段连续的内存单元当做栈段，仅仅是自己的安排，CPU不会自动的将我们自定义的栈段当做栈空间来使用。我们应当将SS:SP指向我们自定义的栈段。</p><h3 id="栈为空时，SS-SP的状态-1"><a href="#栈为空时，SS-SP的状态-1" class="headerlink" title="栈为空时，SS:SP的状态"></a>栈为空时，SS:SP的状态</h3><p>如果我们将10000H~1FFFFH这段空间当作栈段，初始状态是空的，栈空间大小为64KB，栈最底部的字单元地址为1000:FFFE。</p><p>SP原来为FFFEH，加2后SP=0，所以，当栈为空的时候，SS=1000H，SP=0。</p><h3 id="一个栈段最大可以设置为多少？"><a href="#一个栈段最大可以设置为多少？" class="headerlink" title="一个栈段最大可以设置为多少？"></a>一个栈段最大可以设置为多少？</h3><p>从栈的操作指令来看，push、pop只能够修改SP的值，即只能修改偏移地址。</p><p>故栈顶的变化范围就是0-FFFFH，从栈空时候的SP=0，一直压栈，直到栈满时SP=0。</p><p>所以一个栈段的容量最大为64k，2的16次方。</p><h2 id="段的综述"><a href="#段的综述" class="headerlink" title="段的综述"></a>段的综述</h2><p>我们可以自由的将一段内存定义为一个段，随意的存放数据、代码或者当做栈来使用。但是若要是让CPU来按照我们的安排，就要把我们定义的段的段地址放入对应的CS、DS、SS，将偏移地址放入对应的地址寄存器，这样才可以使用。</p><p>不管我们怎么安排，CPU把某段内存当做代码段，就是因为我们让CS:IP指向了那里。</p><p>一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。</p><p>关键在于CPU中寄存器的设置，即：CS、IP、SS、SP、DS的指向。</p>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言（二）--80X86CPU基础</title>
    <link href="/assembly-language-1/"/>
    <url>/assembly-language-1/</url>
    
    <content type="html"><![CDATA[<p><strong>概览</strong>：80X86CPU寄存器，内存地址与存储器分段的概念。</p><a id="more"></a><h2 id="微处理器"><a href="#微处理器" class="headerlink" title="微处理器"></a>微处理器</h2><p>个人计算机也叫做微型计算机。其核心是<strong>中央处理器(CPU)**，也称为</strong>微处理器**。</p><p>微处理器是微型计算机的核心，由<strong>运算器</strong>和<strong>控制器</strong>两部分组成。</p><p>底下是Intel 8086/8088的微处器结构。</p><p>微处理器结构上进行划分的话分为<strong>执行部件(EU)**和</strong>总线接口部件(BIU)**。</p><p><img src="/assembly-language-1/assembly-language-1%5C8086-8088.png" alt="Intel 8086/8088结构图"></p><h2 id="8086寄存器组"><a href="#8086寄存器组" class="headerlink" title="8086寄存器组"></a>8086寄存器组</h2><h3 id="字长"><a href="#字长" class="headerlink" title="字长"></a>字长</h3><p>微型计算机的字长与微处理器<strong>寄存器位数</strong>有关。</p><p>Intel 80X86系列微处理器中，8086/8088、80286这些微机的字长是16位的，所以其寄存器都是16位的。</p><p>现如今(2019.06.04)我们使用的电脑基本都是64位的了。</p><p>整个博客围绕的都是8086CPU来学习的，8086寄存器都是16位的寄存器。</p><p><strong>对于8086CPU来说，一个字节(Byte)为8位，即8位二进制数。一个字(Word)为16位，即两个字节</strong>。</p><h3 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h3><p>包括AX、BX、CX、DX四个通用寄存器，都是16位。主要用于<strong>存放计算过程中的信息和数据</strong>。</p><p>这四个的首要功能是存放数据，其次才是如下的具体功能。</p><ul><li><p><strong>AX</strong>（Accumulator）作为累加器用，算术运算的主要寄存器</p></li><li><p><strong>BX</strong> （Base）基址寄存器</p></li><li><p><strong>CX</strong> （Count ）计数器</p></li><li><p><strong>DX</strong> （Data ）双精度运算时与AX一起存放双操作数(32位)。这时DX放高的16位，AX放低的16位。</p></li></ul><p>此外每一个数据寄存器又可分为两个8位寄存器，AH、AL、BH、BL……</p><p>H(High)表示高8位(8-15)，L(Low)表示低8位(0-7)。</p><p>例：AX寄存器存放一个字1234H。符号表示为 (AX)=1234H.高字节放在AH，低字节放在AL。</p><p><img src="/assembly-language-1/assembly-language-1%5Cax.png" alt="(AX)=1234H"></p><p>例：使用DX、AX保存双精度数(32位) 23456789H。表示形式：  (DX)=2345H，(AX)=6789H.</p><p><img src="/assembly-language-1/assembly-language-1%5Cdx.png"></p><h3 id="地址寄存器"><a href="#地址寄存器" class="headerlink" title="地址寄存器"></a>地址寄存器</h3><p>包括SI、DI、SP、BP四个16为寄存器。主要用于<strong>存放存储器操作数的偏移地址</strong>。</p><ul><li><p><strong>SI</strong> (Source Index) 源变址寄存器，可用于存放源缓冲区的偏移地址。</p></li><li><p><strong>DI</strong> (Destination Index)  目的变址寄存器，可用于存放目的缓冲区的偏移地址。</p></li><li><p><strong>SP</strong> (Stack Pointer)  堆栈指针寄存器，用于指出堆栈区的栈顶的偏移地址。</p></li><li><p>**BP **(Base Pointer) 基址指针寄存器，用于指出堆栈区的某个单元的偏移地址。</p></li></ul><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>包括CS、DS、ES、SS四个16位段寄存器。指明<strong>数据的类型</strong>，位于哪个段就是什么类型的数据。</p><ul><li>CS  (Code Segment) 代码段寄存器，用于指出<strong>存放程序</strong>的代码段的段地址。</li><li>DS  (Data Segment) 数据段寄存器，用于指出<strong>存放数据</strong>的数据段的段地址。</li><li>ES  (Extra Segment) 附加段寄存器，用于指出<strong>存放附加数据</strong>的附加段的段地址。</li><li>SS  (Stack Segment) 堆栈段寄存器，用于指出<strong>堆栈区的堆栈段</strong>的段地址。</li></ul><h3 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h3><p>包括IP和FLAGS两个16位寄存器，用于<strong>控制程序的执行</strong>。</p><ul><li><strong>IP</strong> 指令指针寄存器：用来存放代码段(CS)中的偏移地址，指出当前正在执行指令的下一条指令所在单元的偏移地址。</li><li><strong>FLAGS</strong>标志寄存器：其中的某位代表CPU的一个标志。8086CPU的标志寄存器共有9个标志，分别为6条件码标志和3控制标志。</li></ul><p><img src="/assembly-language-1/assembly-language-1%5Cflags.png" alt="FLAGS标志寄存器"></p><p>比较重要的几个：</p><p>CF 进位标志，当指令执行结果的最高位向前有进位时，CF=1，否则CF=0。</p><p>ZF 零标志，执行结果为零时，ZF=1，否则ZF=0。</p><p>SF 符号标志，当指令的结果为负时，SF=1，否则SF=0。</p><p>OF 溢出标志，结果溢出时OF=1，否则OF=0。</p><p>IF (Interrupt Flag)中断标志，IF=1，为CPU允许响应可屏蔽中断。</p><p>在debug状态下可以查看到除了陷阱标志TF之外的其他标志，他们会用字母缩写的形式表示自己的状态。</p><p><img src="/assembly-language-1/assembly-language-1%5Cflagss.png" alt="各个标志缩写形式"></p><p>debug状态下，使用R指令查看。</p><p><img src="/assembly-language-1/assembly-language-1%5Cdebug.png" alt="Flags的状态"></p><p>例：10011010B+01001011B = 11100101B</p><p>根据计算结果，CPU会把标致位设置为：CF = 0，SF = 1，ZF = 0，OF = 0。即无进位，结果为负，结果不为零，无溢出。</p><h2 id="内存地址与存储单元"><a href="#内存地址与存储单元" class="headerlink" title="内存地址与存储单元"></a>内存地址与存储单元</h2><p>内存储器即<strong>内存</strong>，也称为<strong>主存</strong>。在汇编语言中，<strong>用于存储计算机当前正在运行的程序，正在处理的原始数据、中间数据以及最终结果</strong>，故我们与内存的交互是非常频繁的。</p><p>内存是使用<strong>字节</strong>为单位编址的，即80X86实际的存储单元为8位二进制数的大小。</p><h3 id="CPU如何对内存进行读写？"><a href="#CPU如何对内存进行读写？" class="headerlink" title="CPU如何对内存进行读写？"></a>CPU如何对内存进行读写？</h3><p>通过<strong>系统总线</strong>来进行读写。系统总线包括<strong>地址总线</strong>、<strong>数据总线</strong>、<strong>控制总线</strong>三大类。</p><p>CPU要想进行数据读或者写的操作，需要知道三大类信息：</p><ul><li>地址信息：存储单元的地址</li><li>控制信息：器件的选择以及读或者写的命令 </li><li>数据信息：要读或者写的数据 </li></ul><p><img src="/assembly-language-1/assembly-language-1%5Ccpu.png" alt="CPU对存储器的读写"></p><h3 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h3><p>8086CPU的地址总线为20位。</p><p>CPU对内存的访问是通过地址总线进行的，地址总线的二进制组态对应着一个内存单元，而这个二进制组态就可以作为该内存单元的地址。</p><p>比如有两根总线 A0、A1，二进制组态就有00、01、10、11四种，表示地址为0 - 3的存储单元。</p><p>也就是说地址总线能传达多少个不同的信息(即二进制组态有多少种)，CPU就可以对多少个存储单元进行寻址。</p><p>地址总线位数为n位，即地址总线的宽度为n，CPU就可以寻找<strong>2的N次方个内存单元</strong>。</p><p>8086CPU有20跟地址总线，故存储空间就是2的20次方 = <strong>1MB</strong>。</p><h3 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h3><p>CPU对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。</p><p>有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU对外部器件的控制能力。</p><h3 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h3><p>CPU与内存或其它器件之间的数据传送是通过数据总线来进行的。</p><p>数据总线的宽度决定了CPU和外界的数据传送速度。</p><p>8086CPU的数据总线为16位，即一次性可以传送16位数据。</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>在内存之中，每一个存储单元都有一个编号用来<strong>标识这个存储单元</strong>，这就是地址。地址是从0开始编号的。(看地址总线那一部分)</p><p>地址有两种表示方式，物理地址和逻辑地址。</p><h3 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h3><p>物理地址是内存单元的真实地址，且每一个存储单元的物理地址都是唯一的。CPU访问内存必须使用物理地址。</p><p>8086CPU有20跟地址总线，故存储空间就是2的20次方 = <strong>1MB</strong>。物理地址的范围是 00000H - FFFFFH。</p><h3 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h3><p>逻辑地址是方便用户编程而使用的地址。它由段地址和偏移地址两部分构成。</p><p>形式： 逻辑地址 =  <strong>段地址 :  偏移地址</strong></p><p>因为我们将内存地址划分为多个逻辑段每段都由一部分存储单元构成。</p><p>段地址指出是哪一段，偏移地址标明是哪段中的哪个单元。且段地址和偏移地址都是<strong>16位的二进制数</strong>。</p><h3 id="逻辑地址转换物理地址"><a href="#逻辑地址转换物理地址" class="headerlink" title="逻辑地址转换物理地址"></a>逻辑地址转换物理地址</h3><p>因为逻辑地址是编程人员使用的，而物理地址是CPU访问内存必须使用的。程序猿写的程序采用的逻辑地址在CPU执行时要转换成为物理地址。这个操作由<strong>CPU中的地址加法器</strong>来实现。</p><p>实现：段地址左移四位(相当于乘以10H)，加上偏移地址。</p><p>​    *<em>物理地址 = 段地址  *  10H  +   偏移地址*</em></p><p>例：逻辑地址为： 3020:055AH。则其物理地址 = 3020H * 10H + 055AH = 3075AH。</p><h3 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h3><h2 id="存储器分段"><a href="#存储器分段" class="headerlink" title="存储器分段"></a>存储器分段</h2>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言（一）--DOSBox与DEBUG工具的安装</title>
    <link href="/assembly-language-0/"/>
    <url>/assembly-language-0/</url>
    
    <content type="html"><![CDATA[<p>现如今大部分电脑都是64位，没有DEBUG工具了。所以需要安装DOSBox以及DEBUG工具来进入debug模式。</p><a id="more"></a><h2 id="DOSBox软件下载"><a href="#DOSBox软件下载" class="headerlink" title="DOSBox软件下载"></a>DOSBox软件下载</h2><p>链接：<a href="https://pan.baidu.com/s/1mwh1jF6fGPJ9AGa_vsnpTg">https://pan.baidu.com/s/1mwh1jF6fGPJ9AGa_vsnpTg</a><br>提取码：4cqc </p><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><p>下载好软件之后进行解压，这里面的这个DOSBox可以直接点击使用，无需安装，所以最好要记得解压后放置的路径。</p><p>找到路径 <code>DOSBox-0.74\masm</code> ，这里面有debug的可执行程序，还有其他后续学习会用到的程序比如<code>link.exe</code>等等。把整个 <code>masm文件夹</code> 拷贝至 D盘或者E盘(任何一个盘符都可以)，这里我放在了E盘。</p><p>回到 <code>DOSBox-0.74</code>的路径下，执行 <code>DOSBox.exe</code> 文件。会同时打开两个窗口。</p><p><img src="/assembly-language-0/DOSBox.png" alt="引图"></p><p>然后进行<strong>挂载</strong>操作，输入 <code>mount C E:/masm</code> .这里大小写随意，后面的路径就是你放置 <code>masm文件夹</code> 的位置。</p><p>然后会弹出<code>Drive C is mounted as local directory e:/masm\</code>这句话，表示挂载成功。其实意思就是把 <code>e:/masm</code> 这里当成了虚拟的C盘来进行使用。</p><p>之后输入 <code>c:</code> 进入刚弄好的虚拟的c盘,输入 <code>debug</code> 即可进入debug。</p><p><img src="/assembly-language-0/DOSBox2.png" alt="引图"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>使用mount命令之后<font color="red">一定要先进入C盘再使用debug</font>，不然会显示 <code>Illegal command: debug</code> 哦！</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p><strong>CSDN:Hanniel</strong>–<a href="https://blog.csdn.net/hanniel/article/details/79506003" title="Windows64位系统进入debug模式">Windows64位系统进入debug模式</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第十届蓝桥杯大赛省赛C/C++A组真题</title>
    <link href="/lanqiao-end/"/>
    <url>/lanqiao-end/</url>
    
    <content type="html"><![CDATA[<p><img src="/lanqiao-end/8.jpg" alt="引图"></p><center>被锤爆了，难受</center><a id="more"></a><h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>今天，2019年3月24日，我参加了河北省的第十届蓝桥杯省赛，大赛共10道题，5道结果填空，5道编程大题。然后历时4个小时，我只做出了4道题，还不知道对错😭。</p><p>总体来说就是准备的太不充分了，直到开赛前两天才开始看历届的蓝桥杯真题，然后做到自闭，丧失信心了。还有就是一些掌握的方法，练过好几遍，结果到比赛忘记了怎么写，尤其是dfs算法，纠结那个模板的正确性。还有就是sort函数自定义结构体排序，。。。临场忘记了怎么写，结果写了半天不得不换一种方法去做题。印象最深的是那个第三题，做法取最大的中位数，我傻乎乎的直接套上dfs模板，然后程序跑了一个多小时都没出结果。。。(光是dfs的执行次数就达到了49的阶乘，真可怕)。</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯-DFS深度应用与模板</title>
    <link href="/lanqiao-dfs/"/>
    <url>/lanqiao-dfs/</url>
    
    <content type="html"><![CDATA[<p><img src="/lanqiao-dfs/7.jpg" alt="引图"></p><center>着实头大</center><a id="more"></a><p>学习视频来源 <a href="https://study.163.com/course/courseMain.htm?courseId=1004996013" title="2018NEUQ-ACM蓝桥杯培训">网易云课堂：2018NEUQ-ACM蓝桥杯培训</a></p><hr><p><strong>DFS——Depth Fiest Search</strong></p><p>对每一个可能的路径深入到不能深入为止，且每一个节点只能访问一次。</p><h2 id="案列：1-n的全排列"><a href="#案列：1-n的全排列" class="headerlink" title="案列：1-n的全排列"></a>案列：1-n的全排列</h2><p>如1-3的全排列为 123、132、213、231、312、321</p><p>类似于n个标号为1-n的小球放入标号1-n的盒子中，共有多少种方法？</p><h3 id="如何往盒子中放球？"><a href="#如何往盒子中放球？" class="headerlink" title="如何往盒子中放球？"></a>如何往盒子中放球？</h3><pre><code class="hljs CPP"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;a[step]=i;&#125;</code></pre><p>a数组表示盒子，step表示第几个盒子，上述表示将第i个球放入第step个盒子中。</p><h3 id="如何判断哪些球被放过了？"><a href="#如何判断哪些球被放过了？" class="headerlink" title="如何判断哪些球被放过了？"></a>如何判断哪些球被放过了？</h3><pre><code class="hljs CPP"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-keyword">if</span>(book[i]==<span class="hljs-number">0</span>)&#123;a[step]=i;book[i]=<span class="hljs-number">1</span>;&#125;&#125;</code></pre><p>增加<strong>标记数组</strong>来标记哪些小球被放过了。</p><h3 id="如何继续处理下一个盒子？"><a href="#如何继续处理下一个盒子？" class="headerlink" title="如何继续处理下一个盒子？"></a>如何继续处理下一个盒子？</h3><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> step)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-keyword">if</span>(book[i]==<span class="hljs-number">0</span>)&#123;a[step]=i;book[i]=<span class="hljs-number">1</span>;dfs(step+<span class="hljs-number">1</span>);book[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//将盒子中的球收回，如果不进行收回，无法进行下一次摆放</span>&#125;&#125;<span class="hljs-keyword">return</span>;&#125;</code></pre><p>封装为函数，使用<strong>递归</strong>进行处理。</p><h3 id="如何判断一次排列的结束？"><a href="#如何判断一次排列的结束？" class="headerlink" title="如何判断一次排列的结束？"></a>如何判断一次排列的结束？</h3><pre><code class="hljs CPP"><span class="hljs-keyword">if</span>(step==n+<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">cout</span>&lt;&lt;a[i];<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;</code></pre><p>如果站在第i+1个盒子面前时，说明前n个盒子已经放好球了。则结束</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> a[<span class="hljs-number">1000</span>],book[<span class="hljs-number">1000</span>],n;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> step)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(step==n+<span class="hljs-number">1</span>)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-built_in">cout</span>&lt;&lt;a[i];        &#125;        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span>(book[i]==<span class="hljs-number">0</span>)<span class="hljs-comment">//如果第i个球没被放过，就放入，然后改变状态</span>        &#123;            a[step] = i;            book[i] = <span class="hljs-number">1</span>;            dfs(step+<span class="hljs-number">1</span>);            book[i]=<span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;n;    dfs(<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="蓝桥杯真题——方格填数"><a href="#蓝桥杯真题——方格填数" class="headerlink" title="蓝桥杯真题——方格填数"></a>蓝桥杯真题——方格填数</h2><blockquote><p><strong>题目描述</strong>：</p><p>如下的10个格子</p><p><img src="/lanqiao-dfs/fangge.jpg" alt="方格填数图"></p><p>填入0~9的数字。要求：连续的两个数字不能相邻。<br>（左右、上下、对角都算相邻）</p><p>一共有多少种可能的填数方案？</p><p>请填写表示方案数目的整数。<br>注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。</p></blockquote><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>读题目即是0-9的全排列，然后根据特定情况筛选。为了方便使用，把0-9换为1-10的序列。</p><p>根据上面的模板，数值赋值部分不变，只需要改变逻辑判断的部分，用来方格填数的逻辑判断。</p><p><img src="/lanqiao-dfs/fangge-1.jpg" alt="方格填数图"></p><p>参照底下逻辑判断的代码，非常容易理解。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> a[<span class="hljs-number">15</span>],book[<span class="hljs-number">15</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> step)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">bool</span> isa = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">if</span>(step == <span class="hljs-number">11</span>)    &#123;        <span class="hljs-comment">//judge</span>        <span class="hljs-comment">//左右相邻两数之间不连续</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">2</span>;j++)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[j]-a[j+<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span>) isa = <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">4</span>;j&lt;=<span class="hljs-number">6</span>;j++)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[j]-a[j+<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span>) isa = <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">8</span>;j&lt;=<span class="hljs-number">9</span>;j++)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[j]-a[j+<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span>) isa = <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-comment">//上下两数之间不连续</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">6</span>;j++)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[j]-a[j+<span class="hljs-number">4</span>]) == <span class="hljs-number">1</span>) isa = <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-comment">//斜对角/这种不连续</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">3</span>;j++)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[j]-a[j+<span class="hljs-number">3</span>]) == <span class="hljs-number">1</span>) isa = <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">5</span>;j&lt;=<span class="hljs-number">7</span>;j++)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[j]-a[j+<span class="hljs-number">3</span>]) == <span class="hljs-number">1</span>) isa = <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-comment">//斜对角\这种不连续·</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">2</span>;j++)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[j]-a[j+<span class="hljs-number">5</span>]) == <span class="hljs-number">1</span>) isa = <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">4</span>;j&lt;=<span class="hljs-number">5</span>;j++)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[j]-a[j+<span class="hljs-number">5</span>]) == <span class="hljs-number">1</span>) isa = <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span>(isa == <span class="hljs-literal">true</span>) ++cnt;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10</span>;i++)    &#123;        <span class="hljs-keyword">if</span>(book[i]==<span class="hljs-number">0</span>)        &#123;            a[step] = i;            book[i] = <span class="hljs-number">1</span>;            dfs(step+<span class="hljs-number">1</span>);            book[i] = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    dfs(<span class="hljs-number">1</span>);    <span class="hljs-built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><p>1580种</p><h2 id="蓝桥杯真题——方格分割"><a href="#蓝桥杯真题——方格分割" class="headerlink" title="蓝桥杯真题——方格分割"></a>蓝桥杯真题——方格分割</h2><blockquote><p><strong>题目描述</strong>：</p><p>6x6的方格，沿着格子的边线剪开成两部分。<br>要求这两部分的形状完全相同。</p><p>如图：</p><p><img src="/lanqiao-dfs/fang.png" alt="方格填数图"></p><p>就是可行的分割法。</p><p>试计算：<br>包括这3种分法在内，一共有多少种不同的分割方法。<br>注意：旋转对称的属于同一种分割法。<br>请提交该整数，不要填写任何多余的内容或说明文字。</p></blockquote><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>6x6的方格，剪为两部分，一定会经过中心点，并且中心对称。要计算出所有的可能，就需要DFS。<br>当然需要注意两点，<strong>以中心点为出发点向周围进行dfs，所以中心点的状态是被访问过的。<br>另外由于是正方形，且中心对称，最后的结果要除以4</strong>。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> book[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<span class="hljs-comment">//标记数组</span><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> dir = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//方向数组</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>||x==<span class="hljs-number">6</span>||y==<span class="hljs-number">0</span>||y==<span class="hljs-number">6</span>)<span class="hljs-comment">//如若到达边境</span>    &#123;        ++cnt;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)    &#123;        <span class="hljs-keyword">int</span> nx = x+dir[i][<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> ny = y+dir[i][<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span>(nx&lt;<span class="hljs-number">0</span>||nx&gt;<span class="hljs-number">6</span>||ny&lt;<span class="hljs-number">0</span>||ny&gt;<span class="hljs-number">6</span>) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span>(book[nx][ny]==<span class="hljs-number">0</span>)        &#123;            book[nx][ny]=<span class="hljs-number">1</span>;            book[<span class="hljs-number">6</span>-nx][<span class="hljs-number">6</span>-ny]=<span class="hljs-number">1</span>;            dfs(nx,ny);            book[nx][ny]=<span class="hljs-number">0</span>;            book[<span class="hljs-number">6</span>-nx][<span class="hljs-number">6</span>-ny]=<span class="hljs-number">0</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    book[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;    dfs(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>);    <span class="hljs-built_in">cout</span> &lt;&lt; cnt/<span class="hljs-number">4</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h4><blockquote><p>509</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL专题-stack、queue 栈与队列</title>
    <link href="/lanqiao-6/"/>
    <url>/lanqiao-6/</url>
    
    <content type="html"><![CDATA[<p><img src="/lanqiao-6/6.jpg" alt="引图"></p><center>栈与队列😁</center><a id="more"></a><p>学习视频来源 <a href="https://study.163.com/course/courseMain.htm?courseId=1004996013" title="2018NEUQ-ACM蓝桥杯培训">网易云课堂：2018NEUQ-ACM蓝桥杯培训</a></p><hr><h2 id="stack——栈"><a href="#stack——栈" class="headerlink" title="stack——栈"></a>stack——栈</h2><p>头文件 <code>#include &lt;stack&gt;</code></p><p>栈是实现了先进后出的一种容器，元素的插入与删除都只能在栈的顶部来完成</p><h3 id="stack的构造"><a href="#stack的构造" class="headerlink" title="stack的构造"></a>stack的构造</h3><pre><code>stack&lt;TYPE&gt; stkName;//其中TYPE可以是任何类型，包括自定义类型与指针类型</code></pre><p>拷贝构造</p><pre><code>stack&lt;int&gt; s1;stack&lt;int&gt; s2(s1);    //拷贝s1并构造s2stack&lt;int&gt; s3;s3 = s1;        //将s1的值赋给s3</code></pre><h3 id="stack的函数"><a href="#stack的函数" class="headerlink" title="stack的函数"></a>stack的函数</h3><ul><li><p>empty() 堆栈为空，则返回真 </p></li><li><p>pop() 移除栈顶元素 </p></li><li><p>push(elem) 在栈顶增加元素elem </p></li><li><p>size() 返回栈中元素数目 </p></li><li><p>top() 返回栈顶元素 </p></li></ul><p>注意：对一个空栈执行pop操作会导致程序异常而结束，所以要先用empty进行判断。</p><h3 id="stack的应用"><a href="#stack的应用" class="headerlink" title="stack的应用"></a>stack的应用</h3><ol><li><p>递归算法</p></li><li><p>括号匹配检测</p></li><li><p>DFS算法</p></li></ol><h2 id="queue——队列"><a href="#queue——队列" class="headerlink" title="queue——队列"></a>queue——队列</h2><p>头文件 <code>#include &lt;queue&gt;</code></p><p>队列是一种先进先出的容器，元素的插入在队尾进行，元素的删除在队首进行，类似于日常生活中的排队。</p><h3 id="queue的构造"><a href="#queue的构造" class="headerlink" title="queue的构造"></a>queue的构造</h3><pre><code>queue&lt;TYPE&gt; quName;//其中TYPE可以是任何类型，包括自定义类型与指针类型</code></pre><p>构造方法与stack相同。</p><h3 id="queue的函数"><a href="#queue的函数" class="headerlink" title="queue的函数"></a>queue的函数</h3><ul><li><p>back() 返回最后一个元素 </p></li><li><p>empty() 如果队列空则返回真 </p></li><li><p>front() 返回第一个元素 </p></li><li><p>pop() 删除第一个元素 </p></li><li><p>push(elem) 在末尾加入一个元素 </p></li><li><p>size() 返回队列中元素的个数 </p></li></ul><p>注意：对一个空队列执行pop操作会导致程序异常而结束，所以要先用empty进行判断。</p><h3 id="queue的应用"><a href="#queue的应用" class="headerlink" title="queue的应用"></a>queue的应用</h3><ol><li><p>BFS算法</p></li><li><p>保存暂时不用的数据</p></li></ol><h2 id="例题：NEUQOJ-1689-火车调度问题-截止现在此题目无法做"><a href="#例题：NEUQOJ-1689-火车调度问题-截止现在此题目无法做" class="headerlink" title="例题：NEUQOJ-1689 火车调度问题(截止现在此题目无法做)"></a>例题：NEUQOJ-1689 火车调度问题(截止现在此题目无法做)</h2><blockquote><p><strong>题目描述</strong>：</p><p>粗心的塔学长现在是火车站的调度员，看看现在的惨状吧，列车车厢的顺序竟然完全是乱的！为避免塔学长登上明天的UC头条，车站划分给塔塔一段如图所示的铁路，你能帮助塔塔把车厢的顺序调整好吗？</p><p>其中，A为入口，B为出口，S为中转盲端。所有铁道均为单轨单向式：列车行驶的方向只能是从A到S，再从S到B；另外，不允许超车。因为车厢可在S中驻留，所以它们从B端驶出的次序，可能与从A端驶入的次序不同。不过S的容量有限，同时驻留的车厢不得超过m节。</p><p>列车由编号依次为{1, 2, …, n}的n节车厢组成。塔塔希望知道，按照以上交通规则，这些车厢能否以{a1, a2, …, an}的次序，重新排列后从B端驶出。如果可行，应该以怎样的次序操作?</p><p><img src="/lanqiao-6/stack.png" alt="引图"></p><p><strong>输入</strong>：</p><p>共两行。<br>第一行为两个整数n，m。<br>第二行为以空格分隔的n个整数，保证为{1, 2, …, n}的一个排列，表示待判断可行性的驶出序列{a1，a2，…，an}。</p><p><strong>输出</strong>：</p><p>若驶出序列可行，则输出操作序列，其中push表示车厢从A进入S，pop表示车厢从S进入B，每个操作占一行。<br>若不可行，则输出“震惊！昨天小汤河火车站竟然。。。”。</p><p><strong>样例输入</strong></p><p>5 2</p><p>1 2 3 5 4<br><strong>样例输出</strong></p><p>push<br>pop<br>push<br>pop<br>push<br>pop<br>push<br>push<br>pop<br>pop</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目就是一道对栈进行操作的问题，给定初始状态A与最终状态B，限定栈的大小，来判断是否实现该操作。核心问题在于如何进行判断，这一部分的逻辑不容易处理。</p><ol><li><p>设置两个变量来表示对A，B的判断进度，然后判断当前A与B的首元是否相同，如果相同并且栈不满的话，push再pop达成目标。</p></li><li><p>不满足上述条件的话，判断当前栈顶元素是否与B的首元相同，相同的话pop。</p></li><li><p>还不满足上述条件的话，将A的首元去入栈，push。</p></li><li><p>上述三种条件都不满足的话，无法达成目标，结束。</p></li></ol><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code class="hljs CPP"><span class="hljs-comment">//仅是个人思路，因OJ这道题无法做，故未经程序检验</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n，m;<span class="hljs-comment">//接收火车数量以及栈的大小</span>    <span class="hljs-keyword">int</span> a[<span class="hljs-number">1000</span>];<span class="hljs-comment">//接收火车调度后的状态</span>    <span class="hljs-keyword">int</span> a1[<span class="hljs-number">1000</span>];<span class="hljs-comment">//接收栈的操作状态，1表示Push。0表示pop</span>    <span class="hljs-keyword">int</span> ntp = <span class="hljs-number">0</span>;<span class="hljs-comment">//计数栈的操作步数</span>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s;<span class="hljs-comment">//构造栈</span>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">cin</span>&gt;&gt;a[i];    &#125;    <span class="hljs-keyword">int</span> A = <span class="hljs-number">1</span>;<span class="hljs-comment">//原始火车的判断进度</span>    <span class="hljs-keyword">int</span> B = <span class="hljs-number">1</span>;<span class="hljs-comment">//结束后火车的判断进度</span>    <span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>;<span class="hljs-comment">//判断条件</span>    <span class="hljs-keyword">while</span>(B&lt;=n &amp;&amp; flag)    &#123;        <span class="hljs-keyword">if</span>(A == a[B]&amp;&amp;s.size()&lt;m)        &#123;            ++A;++B;            a1[ntp++] = <span class="hljs-number">1</span>;            a1[ntp++] = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!s.empty()&amp;&amp;s.top()==a[B])        &#123;            s.pop();            a1[ntp++] = <span class="hljs-number">0</span>;            ++B;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(A&lt;=n &amp;&amp; s.size()&lt;m)        &#123;            s.push(A++);            a1[ntp++] = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span> flag = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;震惊！昨天小汤河火车站竟然。。。&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> q = <span class="hljs-number">0</span>;q&lt;ntp;q++)        &#123;            <span class="hljs-keyword">if</span>(a1[q] == <span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;push&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;pop&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>蓝桥杯</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL专题-set 集合</title>
    <link href="/lanqiao-5/"/>
    <url>/lanqiao-5/</url>
    
    <content type="html"><![CDATA[<p><img src="/lanqiao-5/5.jpg" alt="引图"></p><center>set👍</center><a id="more"></a><p>学习视频来源 <a href="https://study.163.com/course/courseMain.htm?courseId=1004996013" title="2018NEUQ-ACM蓝桥杯培训">网易云课堂：2018NEUQ-ACM蓝桥杯培训</a></p><hr><h2 id="set——集合"><a href="#set——集合" class="headerlink" title="set——集合"></a>set——集合</h2><p>头文件 <code>#include &lt;map&gt;</code></p><ul><li><p>set，是一种关联式容器，底层使用平衡的搜索树——红黑树实现，插入删除操作时仅仅需要指针操作节点即可完成，不涉及到内存移动和拷贝，所以效率比较高。容器中的数据不能重复，即每个数据都是唯一的，并且会对存进去的数据进行自动<strong>升序</strong>排序。</p></li><li><p>构造set集合的主要目的是为了快速检索，去重与排序。</p></li></ul><h2 id="set函数"><a href="#set函数" class="headerlink" title="set函数"></a>set函数</h2><p><img src="/lanqiao-5/set_function.png" alt="set_function"></p><h3 id="find函数"><a href="#find函数" class="headerlink" title="find函数"></a>find函数</h3><p>find(const key_type &amp;key)函数用于查找与key值相同的元素，并返回其位置的迭代器。而<strong>如果没有找到将会返回end()指向的迭代器</strong>。</p><p><strong>关联式容器不支持iterator+n的操作，n为1也不行，只能使用iter++这种操作。</strong></p><h3 id="顺序遍历"><a href="#顺序遍历" class="headerlink" title="顺序遍历"></a>顺序遍历</h3><pre><code class="hljs CPP"><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; a;<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator iter = a.begin();<span class="hljs-keyword">for</span>(;iter!=a.end();iter++)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;*iter&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;</code></pre><h3 id="逆序遍历"><a href="#逆序遍历" class="headerlink" title="逆序遍历"></a>逆序遍历</h3><pre><code class="hljs CPP"><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; a;<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::reverse_iterator iter = a.rbegin();<span class="hljs-keyword">for</span>(;iter!=a.rend();iter++)&#123;<span class="hljs-built_in">cout</span>&lt;&lt;*iter&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;</code></pre><p>注意迭代器的写法，反向遍历使用reverse_iterator来定义迭代器，函数使用rbegin()与rend()方法！</p><h2 id="set基本操作"><a href="#set基本操作" class="headerlink" title="set基本操作"></a>set基本操作</h2><h3 id="创建set对象"><a href="#创建set对象" class="headerlink" title="创建set对象"></a>创建set对象</h3><p>set&lt;类型&gt; 对象名，set<int> a;</int></p><p>set&lt;类型，比较结构体&gt; 对象名，set&lt;int,myComp&gt; a;</p><p>set&lt;const set&amp;&gt; set自带拷贝构造函数</p><p>set&lt;类型&gt; a(first,last);使用[first,last)所指的对象。</p><h3 id="添加元素-insert"><a href="#添加元素-insert" class="headerlink" title="添加元素 insert"></a>添加元素 insert</h3><p>insert(value); 将某一值插入set中，返回值是 <code>pair&lt;set&lt;int&gt;::iterator,bool&gt;</code> ，即返回插入的位置的迭代器以及是否插入成功。</p><p>重复的值是不会被插入的，返回的位置是原先元素的位置，同时bool值为false。</p><h2 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h2><blockquote><p>set容器在判定已有元素a和新插入元素b是否相等时有以下两个步骤。</p><ol><li><p>将a作为做操作数，b作为右操作数，调用比较函数，并返回比较值。</p></li><li><p>将b作为做操作数，a作为右操作数，再调用比较函数，并返回比较值。</p></li></ol><p>也就是说，假设有f(x,y)比较函数，先进行f(a,b)然后再进行f(b,a)，返回两个bool值。</p><p>如果返回值都是false，则认为a、b是相等的，b不会被插入。如果第一个是true，第二个是false，则b要排在a后面，繁殖b要排在a前面。如果返回值都是true，则可能发生未知行为。 </p></blockquote><ol><li>自定义比较结构体，重载’()’操作符</li></ol><pre><code class="hljs CPP"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span>&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> a&gt;b;<span class="hljs-comment">//类似于sort算法，这样的‘&gt;’是从大到小</span>    &#125;&#125;;<span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">45</span>,<span class="hljs-number">44</span>,<span class="hljs-number">25</span>,<span class="hljs-number">35</span>,<span class="hljs-number">14</span>,<span class="hljs-number">03</span>&#125;;set&lt;int,cmp&gt; i_set(a,a+9);<span class="hljs-comment">//遍历</span><span class="hljs-keyword">for</span>(<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator iter = i_set.begin();iter!=i_set.end();iter++)&#123;     <span class="hljs-built_in">cout</span>&lt;&lt;*iter&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;&#125;</code></pre><ol start="2"><li>重载‘&lt;’操作符</li></ol><pre><code class="hljs CPP"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span></span><span class="hljs-class">&#123;</span><span class="hljs-built_in">string</span> name;<span class="hljs-keyword">int</span> num;<span class="hljs-keyword">double</span> grade;<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Student &amp; another)&#123;<span class="hljs-keyword">if</span>(num == another.num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//表明根据num进行去重</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> num&gt;another.num;<span class="hljs-comment">//否则按照num从大到小进行排序</span>&#125;&#125;;</code></pre><h2 id="蓝桥杯真题——错误票据"><a href="#蓝桥杯真题——错误票据" class="headerlink" title="蓝桥杯真题——错误票据"></a>蓝桥杯真题——错误票据</h2><blockquote><p><strong>题目描述</strong>：</p><p>某涉密单位下发了某种票据，并要在年终全部收回。每张票据有唯一的ID号。全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。</p><p>因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。你的任务是通过编程，找出断号的ID和重号的ID。</p><p>假设断号不可能发生在最大和最小号。</p><p>要求程序首先输入一个整数N(N&lt;100)表示后面数据行数。</p><p>接着读入N行数据。</p><p>每行数据长度不等，是用空格分开的若干个（不大于100个）正整数（不大于100000）</p><p>每个整数代表一个ID号。</p><p>要求程序输出1行，含两个整数m n，用空格分隔。</p><p>其中，m表示断号ID，n表示重号ID</p><p><strong>输入</strong>：<br>要求程序首先输入一个整数N(N&lt;100)表示后面数据行数。</p><p>接着读入N行数据。</p><p>每行数据长度不等，是用空格分开的若干个（不大于100个）正整数（不大于100000）</p><p>每个整数代表一个ID号。</p><p><strong>输出</strong>：</p><p>要求程序输出1行，含两个整数m n，用空格分隔。</p><p>其中，m表示断号ID，n表示重号ID</p><p><strong>样例输入</strong></p><p>2<br>5 6 8 11 9<br>10 12 9</p><p><strong>样例输出</strong></p><p>7 9</p></blockquote><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>题目意思很清楚，将会给出一连串被打乱的数字，数字连续，只是有一个数字重复了两次，这个可以使用set中的insert方法，它会返回一个pair(pair中是迭代器与bool值)，通过bool值来进行去重。（见上方insert函数）而找断号的数据进行从头开始遍历判断即可。</p><p>另:题目要求输入n行，每行数据不等，采用while(scanf(“%d”,&amp;a)!=EOF)来进行收集数据好一些。</p><blockquote><p>详细参见：<a href="http://www.colourso.top/lanqiao-0/">蓝桥杯——一些零碎的注意事项</a></p></blockquote><pre><code class="hljs CPP"><span class="hljs-comment">//测试环境 Code::Blocks 17.12</span><span class="hljs-comment">//本代码已经通过了蓝桥杯练习系统的测试</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,nums;    <span class="hljs-keyword">int</span> duan,chong;<span class="hljs-comment">//断的数，重复的数</span>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<span class="hljs-comment">//等待输入几行，对于while(scanf(&quot;%d&quot;,&amp;nums)!=EOF)这种方法来说此数据无意义。</span>    <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; i_set;    <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator iter;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;nums)!=EOF)    &#123;        <span class="hljs-keyword">if</span>(i_set.insert(nums).second == <span class="hljs-literal">false</span>) chong = nums;    &#125;    <span class="hljs-keyword">int</span> first = *(i_set.begin());    <span class="hljs-keyword">int</span> ends = *(--i_set.end());    iter = i_set.begin();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = first;i!=ends;i++)    &#123;        <span class="hljs-keyword">if</span>(i == (*iter)<span class="hljs-number">-1</span>)        &#123;            duan = i;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">else</span> iter++;    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;duan&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;chong&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>蓝桥杯</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL专题-map 映射</title>
    <link href="/lanqiao-4/"/>
    <url>/lanqiao-4/</url>
    
    <content type="html"><![CDATA[<p><img src="/lanqiao-4/4.jpg" alt="引图"></p><center>map👍</center><a id="more"></a><p>学习视频来源 <a href="https://study.163.com/course/courseMain.htm?courseId=1004996013" title="2018NEUQ-ACM蓝桥杯培训">网易云课堂：2018NEUQ-ACM蓝桥杯培训</a></p><h2 id="map——映射"><a href="#map——映射" class="headerlink" title="map——映射"></a>map——映射</h2><p>头文件 <code>#include &lt;map&gt;</code></p><ul><li><p>map是一个关联式容器，可以建立 <code>key(即first)</code> 到 <code>value(即second)</code> 的<strong>一对一的映射关系</strong>，由key映射到value。类似于函数的x到y，一对一。</p></li><li><p>map内部自建了一颗<strong>红黑二叉树</strong>，可以对数据进行<strong>自动排序</strong>，默认排序方式为字典序(从小到大)，故map内的数据都是<strong>有序</strong>的。</p></li></ul><h3 id="map声明与初始化"><a href="#map声明与初始化" class="headerlink" title="map声明与初始化"></a>map声明与初始化</h3><p>构造</p><pre><code>map&lt;int,string&gt; map_student;</code></pre><p>这里构造了一个由int映射到string的map。这里key与value可以是任意数据类型，包括自定义的。</p><p>插入数据</p><pre><code>//方法1.类似数组的方式插入map_student[1] = &quot;liming&quot;; //1-&gt;&quot;liming&quot;//方法2.insert()函数map_student.insert(map&lt;int,string&gt;::value_type(2,&quot;zhangsan&quot;));//方法3.insert()函数map_student.insert(make_pair(3,&quot;lisi&quot;));//方法4.insert()函数map_student.insert(pair&lt;int,string&gt;(4,&quot;wangwu&quot;));//方法2、方法3、方法4返回值都是pair&lt;iterator,bool&gt;类型的值，通过返回值.second可查看是否插入成功。</code></pre><p><strong>注意</strong></p><p>insert()函数可以体现映射一一对应的特性，<strong>当map中的key值已经存在时，就不能再使用insert()插入数据了</strong>，即使代码存在也不会覆盖，但是使用数组的方式是可以<strong>覆盖原数据</strong>的。两种方式混合赋值时也是如此，数组方式可以覆盖。</p><p>并且如果通过数组方式即直接map_student[5]这中方式去访问不存在的值的话，map会<strong>自动把这个访问的key插入到map容器中</strong>，而对应的value值则取其的默认值。</p><h3 id="map基本操作"><a href="#map基本操作" class="headerlink" title="map基本操作"></a>map基本操作</h3><ul><li><p>begin()——返回首部迭代器</p></li><li><p>end()——返回尾部的下一位置的迭代器</p></li><li><p>size()——返回容器内的元素个数</p></li><li><p>empty()——判空，空返回1，非空返回0；</p></li><li><p>find(n)——返回指向元素n的迭代器，未找到返回end()指向的迭代器</p></li><li><p>count(n)——统计n的出现次数(0或者1)</p></li></ul><h3 id="map遍历操作"><a href="#map遍历操作" class="headerlink" title="map遍历操作"></a>map遍历操作</h3><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt; map_student;   <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt;::iterator iter;   map_student[<span class="hljs-string">&quot;zhao&quot;</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//[]内这样放也可以</span>   map_student[<span class="hljs-string">&quot;qian&quot;</span>] = <span class="hljs-number">1</span>;   map_student[<span class="hljs-string">&quot;sun&quot;</span>] = <span class="hljs-number">2</span>;   map_student.insert(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt;::value_type(<span class="hljs-string">&quot;sun&quot;</span>,<span class="hljs-number">3</span>));<span class="hljs-comment">//不会覆盖</span>   <span class="hljs-keyword">for</span>(iter = map_student.begin();iter!=map_student.end();iter++)   &#123;       <span class="hljs-built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="hljs-string">&quot;--&gt;&quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="hljs-built_in">endl</span>;       <span class="hljs-comment">//cout&lt;&lt;iter-&gt;key&lt;&lt;&quot;--&gt;&quot;&lt;&lt;iter-&gt;value&lt;&lt;endl;map中没有key与value这两个变量！</span>   &#125;   <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;---&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;   <span class="hljs-built_in">cout</span>&lt;&lt;map_student.find(<span class="hljs-string">&quot;sun&quot;</span>)-&gt;first&lt;&lt;<span class="hljs-string">&quot;--&gt;&quot;</span>&lt;&lt;map_student.find(<span class="hljs-string">&quot;sun&quot;</span>)-&gt;second&lt;&lt;<span class="hljs-built_in">endl</span>;   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//输出结果</span>qian--&gt;<span class="hljs-number">1</span>sun--&gt;<span class="hljs-number">2</span>zhao--&gt;<span class="hljs-number">0</span>---sun--&gt;<span class="hljs-number">2</span></code></pre><h3 id="map应用"><a href="#map应用" class="headerlink" title="map应用"></a>map应用</h3><h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><p>利用映射一一对应的特性，将可能出现的<strong>重复数据设置为key值</strong>以达到去重的目的。</p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>map&lt;&gt;中有三个变量，第三个就是排序方式。如若不指定排序方式的话，map会默认按照<code>less&lt;Key&gt;</code>进行排序.</p><p>进行<strong>降序排序</strong>输出</p><pre><code class="hljs CPP"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>,greater&lt;<span class="hljs-built_in">string</span>&gt; &gt;map_student;map_student[<span class="hljs-string">&quot;zhao&quot;</span>] = <span class="hljs-number">0</span>;map_student[<span class="hljs-string">&quot;qian&quot;</span>] = <span class="hljs-number">1</span>;map_student[<span class="hljs-string">&quot;sun&quot;</span>] = <span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(iter = map_student.begin();iter!=map_student.end();iter++)&#123;    <span class="hljs-built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="hljs-string">&quot;--&gt;&quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//输出结果</span>zhao--&gt;<span class="hljs-number">0</span>sun--&gt;<span class="hljs-number">2</span>qian--&gt;<span class="hljs-number">1</span></code></pre><p>自定义按照string的长短进行输出</p><pre><code class="hljs CPP"><span class="hljs-comment">//与自定义sort()的方法类似</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">string</span> a,<span class="hljs-built_in">string</span> b)</span></span><span class="hljs-function">    </span>&#123;          <span class="hljs-keyword">if</span>(a.length()!=b.length())          &#123;              <span class="hljs-keyword">return</span> a.length()&lt;b.length();<span class="hljs-comment">//从小到大</span>          &#125;        <span class="hljs-keyword">return</span> a&lt;b;    &#125;&#125;;<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>,cmp&gt; map_student;map_student[<span class="hljs-string">&quot;zhao&quot;</span>] = <span class="hljs-number">0</span>;map_student[<span class="hljs-string">&quot;qian&quot;</span>] = <span class="hljs-number">1</span>;map_student[<span class="hljs-string">&quot;sun&quot;</span>] = <span class="hljs-number">2</span>;<span class="hljs-keyword">for</span>(iter = map_student.begin();iter!=map_student.end();iter++)&#123;    <span class="hljs-built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="hljs-string">&quot;--&gt;&quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//输出结果</span>sun--&gt;<span class="hljs-number">2</span>qian--&gt;<span class="hljs-number">1</span>zhao--&gt;<span class="hljs-number">0</span></code></pre><h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><p>假设定义<code>map&lt;string,int&gt; s_map;</code>输入一个数据s，就可以将其对应的<code>map[s]++</code>。通过这样来进行计数。</p><h3 id="map特点与使用场景"><a href="#map特点与使用场景" class="headerlink" title="map特点与使用场景"></a>map特点与使用场景</h3><ol><li><p>自动建立key-&gt;value的对应关系，key与value可以使任何数据类型。</p></li><li><p>可以快速查找、删除记录，根据key值查找的复杂度很低。</p></li><li><p>key与value一一对应的关系可以用于去重操作。</p></li></ol><p>可用于去重计数类题目，可打乱重新排列的问题，以及有清晰的一对一关系的问题。</p><h2 id="例题：蓝桥杯2015年-密文搜索"><a href="#例题：蓝桥杯2015年-密文搜索" class="headerlink" title="例题：蓝桥杯2015年-密文搜索"></a>例题：蓝桥杯2015年-密文搜索</h2><blockquote><p><strong>题目描述</strong>：</p><p>福尔摩斯从X星收到一份资料，全部是小写字母组成。<br>他的助手提供了另一份资料：许多长度为8的密码列表。福尔摩斯发现，这些密码是被打乱后隐藏在先前那份资料中的。<br>请你编写一个程序，从第一份资料中搜索可能隐藏密码的位置。要考虑密码的所有排列可能性。</p><p><strong>输入</strong>：</p><p>输入第一行：一个字符串s，全部由小写字母组成，长度小于1024*1024<br>紧接着一行是一个整数n,表示以下有n行密码，1&lt;=n&lt;=1000<br>紧接着是n行字符串，都是小写字母组成，长度都为8</p><p><strong>输出</strong>：</p><p>一个整数, 表示每行密码的所有排列在s中匹配次数的总和。</p><p><strong>样例输入</strong>：</p><p>aaaabbbbaabbcccc</p><p>2</p><p>aaaabbbb</p><p>abcabccc</p><p><strong>样例输出</strong>：</p><p>4</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目意思是对后面输入的密码进行打乱重组，只要能与原串的代码的连续的一部分相匹配就合格。考虑两点</p><ol><li><p>提取主串连续的8位去构建新的字符串。</p><p> string( string &amp;str, size_type index, size_type length );<br> //构建一个新的字符串，从str中的以index为索引开始的子串，长度为length</p></li><li><p>两处字符串相互匹配。以为只要保证输入的密码能重组成为前面的资料(原串)就可以，所以不妨直接sort()排序，再比较两者的差异。</p></li><li><p>对输入的密码存储入 map&lt;string,int&gt; 之中，便于计数。</p></li></ol><pre><code class="hljs CPP"><span class="hljs-comment">//测试环境 Code::Blocks 17.12</span><span class="hljs-comment">//本代码没有在OJ测试过，因为找不到。。。</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">string</span> s;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-comment">//最后的和值</span>    <span class="hljs-built_in">string</span> nstr[<span class="hljs-number">1000</span>];    <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt; s_map;    <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt;::iterator iter;    <span class="hljs-built_in">cin</span>&gt;&gt;s;<span class="hljs-comment">//输入首串字母</span>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<span class="hljs-comment">//输入密码数量</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-built_in">cin</span>&gt;&gt;nstr[i];        s_map[nstr[i]] = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;s.length()<span class="hljs-number">-8</span>+<span class="hljs-number">1</span>;i++)    &#123;        <span class="hljs-built_in">string</span> s1 = <span class="hljs-built_in">string</span>(s,i,<span class="hljs-number">8</span>);<span class="hljs-comment">//截取部分string构建新的字符串</span>        sort(s1.begin(),s1.end());        <span class="hljs-keyword">for</span>(iter = s_map.begin();iter!=s_map.end();iter++)        &#123;            <span class="hljs-built_in">string</span> s2 = iter-&gt;first;            sort(s2.begin(),s2.end());            <span class="hljs-keyword">if</span>(s1 == s2) s_map[iter-&gt;first]++;        &#125;    &#125;    <span class="hljs-keyword">for</span>(iter = s_map.begin();iter!=s_map.end();iter++)    &#123;        sum += s_map[iter-&gt;first];    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>蓝桥杯</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++操作符重载 operator</title>
    <link href="/operator/"/>
    <url>/operator/</url>
    
    <content type="html"><![CDATA[<p><img src="/operator/4.jpg" alt="引图"></p><center>重载详细解析😋</center><a id="more"></a><hr><p>对运算符进行重载可以重新定义该运算符的含义，方便我们实现更多的功能。</p><p>例如：想要对自己穿件的虚数类进行相加，普通的‘+’无法使用，此时可以选择穿件类的成员函数实现虚数相加，或者是重载‘+’，是其可以实现两个虚数相加。</p><pre><code class="hljs CPP"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span>&#123;</span><span class="hljs-keyword">public</span>:    Complex <span class="hljs-keyword">operator</span>+(Complex another)    &#123;        <span class="hljs-function">Complex <span class="hljs-title">temp</span><span class="hljs-params">(a+another.a,b+another.b)</span></span>;        <span class="hljs-keyword">return</span> temp;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> a;<span class="hljs-comment">//实部</span>    <span class="hljs-keyword">int</span> b;<span class="hljs-comment">//虚部</span>&#125;;</code></pre><p>使用方式</p><pre><code class="hljs CPP"><span class="hljs-function">Complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<span class="hljs-function">Complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span></span>;Complex c3 = c1 + c2;<span class="hljs-comment">//等价 Complex c3 = c1.operator+(c2);</span></code></pre><p>实际上，重载的运算符其实就是<strong>具有特殊名字的函数</strong>，也可以直接像正常函数那样去使用它们。</p><h2 id="操作符重载规则"><a href="#操作符重载规则" class="headerlink" title="操作符重载规则"></a>操作符重载规则</h2><ol><li><p>不允许用户自己定义新的运算符，只能够对已有的运算符进行重载。</p></li><li><p>C++中绝大部分运算符都是可以重载的。</p></li></ol><p><img src="/operator/1.png" alt="引图"></p><p>不可以被重载的运算符：</p><blockquote><p>.     成员选择符</p><p>.*    成员对象选择符</p><p>::    域解析操作符</p><p>?:    条件操作符</p><p>sizeof 长度运算符</p></blockquote><ol start="3"><li><p>重载不能改变运算符的操作个数</p></li><li><p>重载不能改变运算符的优先级别</p></li><li><p>重载不能改变运算符的结合性</p><p> 如：‘=’是自右向左，重载后仍然还是自右向左</p></li><li><p>重载运算符的函数不能有默认参数</p></li><li><p>重载的运算符必须和用户自定义类型的对象一起使用，其参数<strong>至少有一个是类对象</strong>。</p></li></ol><p>因为系统不会允许用户去把两个int类型的‘+’运算改成‘-’运算。</p><ol start="8"><li><p>用于类对象的运算符一般必须重载，但两个例外，‘=’和‘&amp;’不必用户重载。</p><p> ‘=’可以用于每一个类对象，可以使用它在同类之间相互赋值，因为<strong>系统早已经为每一个新声明的类重载了一个赋值运算符</strong>。而如果类中有指针或者需要涉及new或者malloc时需要我们手动重写去重载等号操作符。成员地址运算符‘&amp;’也不必重载，它可以返回类对象在内存中的起始地址。</p></li><li><p>应当使重载运算符的功能类似于该运算符作用于标准运算符数据时那样的功能。</p></li><li><p>运算符重载函数可以是类的成员函数，也可以是类的友元函数，还可以是既非友元又非类的成员函数的普通函数。</p></li><li><p>通常情况下，不应该重载逗号，取地址，逻辑与，逻辑或运算符。否则代码中使用这些的代码行为将会异于常态。——《C++ Primer》</p></li></ol><h2 id="递增递减运算符（前置与后置的特殊）"><a href="#递增递减运算符（前置与后置的特殊）" class="headerlink" title="递增递减运算符（前置与后置的特殊）"></a>递增递减运算符（前置与后置的特殊）</h2><p><strong>注意：定义递增与递减运算符的类应该同时定义前置版本与后置版本，且建议这些运算符被定义为类的成员</strong>。</p><h3 id="前置递增运算符"><a href="#前置递增运算符" class="headerlink" title="前置递增运算符"></a>前置递增运算符</h3><pre><code class="hljs CPP">Class Comlpex&#123;<span class="hljs-keyword">public</span>:Complex&amp; <span class="hljs-keyword">operator</span>++()&#123;++<span class="hljs-keyword">this</span>-&gt;a;++<span class="hljs-keyword">this</span>-&gt;b;<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;&#125;;</code></pre><p>注意：为了与内置版本的运算符一致，前置运算符应当<strong>返回递增后对象的引用</strong>。</p><h3 id="后置递增运算符"><a href="#后置递增运算符" class="headerlink" title="后置递增运算符"></a>后置递增运算符</h3><p>因为前置与后置版本符号相同，就意味着重载的名字与运算对象的数量、类型都是相同的。所以为解决这个问题，后置版本要接受一个不被使用的int类型的形参。</p><pre><code class="hljs CPP">Class Comlpex&#123;<span class="hljs-keyword">public</span>:Complex <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>)&#123;Complex ret = *<span class="hljs-keyword">this</span>;++<span class="hljs-keyword">this</span>-&gt;a;++<span class="hljs-keyword">this</span>-&gt;b;<span class="hljs-keyword">return</span> ret;&#125;&#125;;</code></pre><p>注意：</p><ol><li><p>为了与内置版本的运算符保持一致一致，后置运算符应当<strong>返回对象的原值</strong>，返回的是一个值而非引用。</p></li><li><p>对于后置版本来说，在递增对象之前需要首先记录对象的状态。</p></li></ol><h3 id="显式的调用重载函数"><a href="#显式的调用重载函数" class="headerlink" title="显式的调用重载函数"></a>显式的调用重载函数</h3><pre><code class="hljs CPP"><span class="hljs-function">Complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>;c1.<span class="hljs-keyword">operator</span>++();<span class="hljs-comment">//前置版本</span>c1.<span class="hljs-keyword">operator</span>++(<span class="hljs-number">0</span>);<span class="hljs-comment">//后置版本，传入的值仅仅便于编译器区分</span></code></pre><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><pre><code class="hljs CPP"><span class="hljs-comment">//运行环境Code::Blocks 17.12</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span>&#123;</span><span class="hljs-keyword">public</span>:    Complex()&#123;&#125;    Complex(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)    &#123;        <span class="hljs-keyword">this</span>-&gt;a = a;        <span class="hljs-keyword">this</span>-&gt;b = b;    &#125;    Complex(<span class="hljs-keyword">const</span> Complex &amp; another)    &#123;        <span class="hljs-keyword">this</span>-&gt;a = another.a;        <span class="hljs-keyword">this</span>-&gt;b = another.b;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintComplex</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;(&quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;a&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;b&lt;&lt;<span class="hljs-string">&quot;)&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//前置递增</span>    Complex &amp; <span class="hljs-keyword">operator</span>++()    &#123;        ++<span class="hljs-keyword">this</span>-&gt;a;        ++<span class="hljs-keyword">this</span>-&gt;b;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//后置递增</span>    Complex <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>)    &#123;        Complex rec = *<span class="hljs-keyword">this</span>;        ++<span class="hljs-keyword">this</span>-&gt;a;        ++<span class="hljs-keyword">this</span>-&gt;b;        <span class="hljs-keyword">return</span> rec;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> a;<span class="hljs-comment">//实部</span>    <span class="hljs-keyword">int</span> b;<span class="hljs-comment">//虚部</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">Complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)</span></span>;    <span class="hljs-function">Complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)</span></span>;    c1.PrintComplex();<span class="hljs-comment">//(1,3)</span>    c2.PrintComplex();<span class="hljs-comment">//(2,4)</span>    ++c1;    c1.PrintComplex();<span class="hljs-comment">//(2,4)</span>    Complex c3 = c2++;    c3.PrintComplex();<span class="hljs-comment">//(2,4)</span>    c2.PrintComplex();<span class="hljs-comment">//(3,5)</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="输入输出运算符"><a href="#输入输出运算符" class="headerlink" title="输入输出运算符"></a>输入输出运算符</h2><h3 id="输出运算符-lt-lt"><a href="#输出运算符-lt-lt" class="headerlink" title="输出运算符 &lt;&lt;"></a>输出运算符 &lt;&lt;</h3><p>一句正常的<code>cout&lt;&lt;&quot;hello world&quot;&lt;&lt;&quot;!&quot;;</code>之中，**<code>&lt;&lt;</code> 运算符接受两个运算对象，左侧运算对象必须是一个ostream对象，右侧的运算对象是要打印的值<strong>。&lt;&lt;运算符的作用是</strong>将给定的值写到给定的ostream对象中<strong>，输出结果就是其左侧运算符对象。即</strong>计算的结果就是那个ostream对象**。</p><p>通常情况下，输出运算符的第一个形参是一个非常量的ostream对象的<strong>引用</strong>，(向流写入内容会改变其状态)，第二个形参是一个常量的引用，是要打印的类类型。故重载函数为 </p><pre><code>ostream&amp; operator&lt;&lt;(ostream &amp;os,const MyClass &amp;item);</code></pre><p>通常输出时主要负责打印内容而非控制格式，所以尽量不要打印换行符。</p><pre><code class="hljs CPP"><span class="hljs-comment">//类外的全局函数</span>ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os,<span class="hljs-keyword">const</span> Complexs &amp;c)&#123;    os&lt;&lt;<span class="hljs-string">&quot;(&quot;</span>&lt;&lt;c.a&lt;&lt;<span class="hljs-string">&quot; , &quot;</span>&lt;&lt;c.b&lt;&lt;<span class="hljs-string">&quot;)&quot;</span>;    <span class="hljs-keyword">return</span> os;&#125;<span class="hljs-comment">//使用测试</span><span class="hljs-function">Complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<span class="hljs-function">Complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>;<span class="hljs-built_in">cout</span>&lt;&lt;c1&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">cout</span>,c1),c2);----------<span class="hljs-comment">//类内的成员函数</span>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os)&#123;    os&lt;&lt;<span class="hljs-string">&quot;(&quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;a&lt;&lt;<span class="hljs-string">&quot; , &quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;b&lt;&lt;<span class="hljs-string">&quot;)&quot;</span>;    <span class="hljs-keyword">return</span> os;&#125;<span class="hljs-comment">//使用测试</span><span class="hljs-function">Complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<span class="hljs-function">Complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>;c1&lt;&lt;<span class="hljs-built_in">cout</span>;<span class="hljs-comment">//看下面的解释</span>c2&lt;&lt;(c1&lt;&lt;<span class="hljs-built_in">cout</span>);</code></pre><h3 id="输入输出运算符必须是非成员函数！"><a href="#输入输出运算符必须是非成员函数！" class="headerlink" title="输入输出运算符必须是非成员函数！"></a>输入输出运算符必须是非成员函数！</h3><p>当&lt;&lt;重载函数是类的成员函数时，使用方式是<code>对象.函数</code>的形式，也就意味着左侧运算符对象是我们自定义类的对象，导致错乱，虽然可以使用，但不建议这么做。</p><p>所以当我们希望为类自定义IO运算符时，必须将其定义为非成员函数，而且IO运算符通常需要读写类的非公有成员，故IO运算符一般被声明为友元类。</p><h3 id="输入运算符-gt-gt"><a href="#输入运算符-gt-gt" class="headerlink" title="输入运算符 &gt;&gt;"></a>输入运算符 &gt;&gt;</h3><p>输出运算符与输入运算符同理，输入运算符的第一个形参是一个非常量的istream对象的<strong>引用</strong>，，第二个形参是将要读入到的对象的引用。</p><p>重载函数为</p><pre><code>istream&amp; operator&gt;&gt;(istream &amp;is,MyClass &amp;item);</code></pre><p>注意：<strong>输入运算符必须处理输入可能失败的情况</strong>！</p><pre><code class="hljs CPP">istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is,Complexs &amp;c)&#123;    <span class="hljs-keyword">int</span> a,b;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;a:&quot;</span>;    is&gt;&gt;a;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;b:&quot;</span>;    is&gt;&gt;b;    <span class="hljs-keyword">if</span>(is)<span class="hljs-comment">//检查是否输入成功</span>    &#123;        c.a = a;        c.b = b;    &#125;    <span class="hljs-keyword">else</span>        c = Complexs();<span class="hljs-comment">//输入失败，对象赋予默认状态</span>    <span class="hljs-keyword">return</span> is;&#125;</code></pre><h2 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h2><p>普通情况下，系统会为每一个新声明的类去重载赋值运算符，其作用是逐个复制类的数据成员。然而如果涉及指针，简单的复制将会导致出错(即深拷贝与浅拷贝的问题)，这个时候就应当程序员去重写重载赋值运算符的代码。</p><p>为了与内置类型的赋值保持一致，重载赋值运算符应当返回一个指向其左侧运算对象的引用。</p><pre><code>MyClass &amp; operator=(const MyClass &amp; another);</code></pre><h2 id="重载——定义仿函数"><a href="#重载——定义仿函数" class="headerlink" title="()重载——定义仿函数"></a>()重载——定义仿函数</h2><p>仿函数就是使一个类的使用看上去像一个函数，实际上就是类中实现了operator()，于是这个类就有了类似函数的行为。</p><p><strong>重载()也叫重载函数调用运算符</strong>。</p><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">absInt</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">abs</span>)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>&lt;<span class="hljs-number">0</span>?-<span class="hljs-built_in">abs</span>:<span class="hljs-built_in">abs</span>;<span class="hljs-comment">//返回数的绝对值</span>    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">-8</span>;    absInt <span class="hljs-built_in">abs</span>;    <span class="hljs-keyword">int</span> b = <span class="hljs-built_in">abs</span>(a);    <span class="hljs-built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//b为8</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>上面代码中abs只是一个对象而非函数，但我们依旧可以调用该对象，这种对象称为<strong>函数对象</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯——一些零碎的注意事项</title>
    <link href="/lanqiao-0/"/>
    <url>/lanqiao-0/</url>
    
    <content type="html"><![CDATA[<p><img src="/lanqiao-0/0.jpg" alt="引图"></p><center>备战蓝桥杯！加油🙌</center><a id="more"></a><h2 id="C语言中-d-2d-2d-02d的区别"><a href="#C语言中-d-2d-2d-02d的区别" class="headerlink" title="C语言中%d %.2d %2d %02d的区别"></a>C语言中%d %.2d %2d %02d的区别</h2><blockquote><p>%d就是普通的输出了</p><p>%2d是将数字按宽度为2，采用右对齐方式输出，若数据位数不到2位，则左边补空格。</p><p>%02d，和%2d差不多，只不过左边补0</p><p>%.2d从执行效果来看，和% 02d一样</p><p>参考链接：<a href="http://blog.sina.com.cn/s/blog_68eb8fa50102vdv2.html">C语言中%d %.2d %2d %02d的区别</a></p></blockquote><h2 id="while-scanf-“-d”-amp-a-EOF-是什么意思？"><a href="#while-scanf-“-d”-amp-a-EOF-是什么意思？" class="headerlink" title="while(scanf(“%d”,&amp;a)!=EOF)是什么意思？"></a>while(scanf(“%d”,&amp;a)!=EOF)是什么意思？</h2><p>EOF是End Of File的简称，在C语言中EOF常被作为文件结束的标志。通过这种方法，可以持续读入数据，直到结束。</p><p>在Windows本地上，输完数据，然后<strong>换行</strong>，然后<strong>Ctrl+Z</strong>，会显示‘<strong>^Z</strong>’这种符号，然后回车就可以结束输入了。</p><p>while(scanf(“%d”,&amp;a)!=EOF)也可以写成while(~scanf(“%d”,&amp;a))这种。</p><p>在做题中，可用这种方式来避免一些麻烦的输入方式。例子：<a href="http://www.colourso.top/lanqiao-5/">蓝桥杯真题——错误票据</a></p><blockquote><p>参考链接：</p><p><a href="https://blog.csdn.net/Geecky/article/details/52066355">从while(scanf() != EOF)说到ACM OnlineJuge的评判原理</a></p><p><a href="https://blog.csdn.net/littlebeat123/article/details/9698045">C++如何判断输入的结束 ACM中无输入结束提示时如何判断到达EOF</a></p></blockquote><h2 id="getchar-与getline"><a href="#getchar-与getline" class="headerlink" title="getchar()与getline()"></a>getchar()与getline()</h2><p>getchar()用于接收一个字符，如char a = getchar();也可以用于接收一个回车。</p><p>string str;<br>getline(cin,str)用于接收输入的一行然后然后赋值给str，其中可以有空格。</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL专题-iterator和vector</title>
    <link href="/lanqiao-3/"/>
    <url>/lanqiao-3/</url>
    
    <content type="html"><![CDATA[<p><img src="/lanqiao-3/3.jpg" alt="引图"></p><center>序列容器vector😄</center><a id="more"></a><blockquote><p>学习视频来源 <a href="https://study.163.com/course/courseMain.htm?courseId=1004996013" title="2018NEUQ-ACM蓝桥杯培训">网易云课堂：2018NEUQ-ACM蓝桥杯培训</a></p><p>以及《C++ Primer》(第五版)</p></blockquote><h2 id="iterator——迭代器"><a href="#iterator——迭代器" class="headerlink" title="iterator——迭代器"></a>iterator——迭代器</h2><p>迭代器与指针类似，可以访问顺序容器与关联容器中的元素。</p><h3 id="声明方法"><a href="#声明方法" class="headerlink" title="声明方法"></a>声明方法</h3><p>容器名::iterator 变量名    //由此声名该容器的迭代器。</p><pre><code>vector&lt;int&gt;::iterator iter;//声明了一个名为iter的变量</code></pre><h3 id="begin与end迭代器"><a href="#begin与end迭代器" class="headerlink" title="begin与end迭代器"></a>begin与end迭代器</h3><p>每种容器都定义了<code>begin</code>与<code>end</code>的函数，用于返回迭代器。</p><ul><li><p>begin用于返回指向第一个元素的迭代器</p><p>  vector<int>::iterator iter = vec.begin();//iter指向vec[0]</int></p></li><li><p>end用于返回指向末端元素的下一个的迭代器，称为“超出末端迭代器”，即指向一个不存在的元素。</p></li></ul><p><strong>应用</strong>：遍历容器操作</p><pre><code>for(iter=vec.begin();iter!=vec.end();iter++)&#123;    cout&lt;&lt;*iter&lt;&lt;endl;&#125;</code></pre><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><p>指针上的操作iterator基本上都是全部满足的。而两个迭代器相减返回的是两迭代器在容器内的差值。</p><h2 id="vector——动态数组"><a href="#vector——动态数组" class="headerlink" title="vector——动态数组"></a>vector——动态数组</h2><p>头文件 <code>#include&lt;vector&gt;</code></p><ul><li><p>vector是一种<strong>可变大小数组</strong>的序列容器，采用连续的存储空间来存储元素，可以使用<strong>数组下标</strong>的方式访问vector的元素。</p></li><li><p><strong>动态存储</strong>：刚开始vector会自动分配一段连续的内存空间，当存储元素超过预配空间之后，vector会重新分配空间，元素移动，释放旧内存。</p></li><li><p>vector可以高效访问元素、在末尾添加元素和删除元素，但vector对元素操作的复杂度是根据到末尾的距离成正比。</p></li></ul><h3 id="vector的声明与初始化"><a href="#vector的声明与初始化" class="headerlink" title="vector的声明与初始化"></a>vector的声明与初始化</h3><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec;<span class="hljs-comment">//声明了一个int型的空vector</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(vec)</span></span>;<span class="hljs-comment">//v2包含了vec所有元素的副本</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v3 = vec;<span class="hljs-comment">//等价于v3(vec)这种形式</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<span class="hljs-comment">//声明了一个初始大小为5的，且都是默认值的vector</span><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//声明了一个int型的初始大小为10的并且值都是1的vector</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec&#123;a,b,c...&#125;;<span class="hljs-comment">//声明并用这些值对应每个位置进行初始化</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec =&#123;a,b,c&#125;;<span class="hljs-comment">//等价于vec&#123;a,b,c...&#125;;</span></code></pre><h3 id="vector作函数返回值时"><a href="#vector作函数返回值时" class="headerlink" title="vector作函数返回值时"></a>vector作函数返回值时</h3><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> &#123;i,j&#125;;&#125;</code></pre><p>直接返回<code>&#123;&#125;</code>这种形式也是可以的。</p><h3 id="vector的基本操作"><a href="#vector的基本操作" class="headerlink" title="vector的基本操作"></a>vector的基本操作</h3><ul><li>begin()——返回首部迭代器</li><li>end()——返回尾部的下一位置的迭代器</li><li>**push_back()**——向末尾添加元素。(据说效率很高)</li><li>**pop_back()**——末尾删除元素</li><li>size()——返回容器内的元素个数</li><li>empty()——判空，空返回1，非空返回0；</li><li>**insert(pos,elem)**——在pos位置插入一个值elem，返回新数据的位置</li><li>insert(pos,begin,end)——在pos位置插入[begin,end)区间内的数据，无返回值。</li><li>clear()——清空容器</li><li><strong>vector可使用数组下标的形式访问对应索引位置的元素，但是不能使用下标形式添加元素。</strong></li></ul><h3 id="好处与使用情景"><a href="#好处与使用情景" class="headerlink" title="好处与使用情景"></a>好处与使用情景</h3><p>无需考虑容器大小与数组越界的问题</p><p>有丰富的操作（reverse、push_back、insert等）</p><hr><ul><li>2020-05-23 增加内容</li></ul>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>蓝桥杯</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL专题-sort、reverse</title>
    <link href="/lanqiao-2/"/>
    <url>/lanqiao-2/</url>
    
    <content type="html"><![CDATA[<p><img src="/lanqiao-2/2.jpg" alt="引图"></p><center>sort大法好👍</center><a id="more"></a><p>学习视频来源 <a href="https://study.163.com/course/courseMain.htm?courseId=1004996013" title="2018NEUQ-ACM蓝桥杯培训">网易云课堂：2018NEUQ-ACM蓝桥杯培训</a></p><h2 id="sort——排序"><a href="#sort——排序" class="headerlink" title="sort——排序"></a>sort——排序</h2><p>sort函数是用于给定区间所有元素进行<strong>排序</strong>的函数，排序算法类似于快排，**时间复杂度<code>n*log2(n)</code>**，执行效率较高。</p><p>所在头文件 <code>#include &lt;algorithm&gt;</code></p><p>sort函数：sort(first,last,cmp)</p><p>sort函数会对[first,last)区间内的数据按照cmp的方式进行排序。当不写cmp时按照<strong>默认排序方式——由小到大</strong>。</p><h3 id="自定义排序方法1——自定义比较函数cmp"><a href="#自定义排序方法1——自定义比较函数cmp" class="headerlink" title="自定义排序方法1——自定义比较函数cmp"></a>自定义排序方法1——自定义比较函数cmp</h3><p>自定义比较函数cmp，要求形参类型要与排序的类型相一致。</p><ul><li><p><strong>由小到大</strong>(默认排序方式)：如果认为第一个参数比第二个参数小，也就是第一个参数要排在第二个参数之前时返回true。</p><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> a&lt;b;&#125;</code></pre></li><li><p><strong>由大到小</strong>：没什么记忆诀窍😭，就看自定义返回值的大于号还是小于号记忆吧。</p><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> a&gt;b;&#125;</code></pre></li></ul><h3 id="自定义排序方法2——重载比较运算符“-lt-”"><a href="#自定义排序方法2——重载比较运算符“-lt-”" class="headerlink" title="自定义排序方法2——重载比较运算符“&lt;”"></a>自定义排序方法2——重载比较运算符“&lt;”</h3><pre><code class="hljs CPP"><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(Student s1,Student s2)&#123;    <span class="hljs-keyword">if</span>(s1.name!=s2.name) <span class="hljs-keyword">return</span> s1.name&lt;s2.name;    <span class="hljs-keyword">return</span> s1.age&lt;s2.age;&#125;</code></pre><h3 id="自定义排序方法3——声明比较类"><a href="#自定义排序方法3——声明比较类" class="headerlink" title="自定义排序方法3——声明比较类"></a>自定义排序方法3——声明比较类</h3><p><img src="/lanqiao-2/fangfa3.png" alt="引图"></p><p>👍暂时不太理解。</p><h2 id="例题-蓝桥杯——日期问题"><a href="#例题-蓝桥杯——日期问题" class="headerlink" title="例题 蓝桥杯——日期问题"></a>例题 蓝桥杯——日期问题</h2><blockquote><p><strong>问题描述</strong></p><p>　　小明正在整理一批历史文献。这些历史文献中出现了很多日期。小明知道这些日期都在1960年1月1日至2059年12月31日。令小明头疼的是，这些日期采用的格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的。更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。</p><p>　　比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。</p><p>　　给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？</p><p><strong>输入格式</strong><br>　　一个日期，格式是”AA/BB/CC”。 (0 &lt;= A, B, C &lt;= 9)</p><p><strong>输出格式</strong><br>　　输出若干个不相同的日期，每个日期一行，格式是”yyyy-MM-dd”。多个日期按从早到晚排列。</p><p><strong>样例输入</strong><br>   02/03/04</p><p><strong>样例输出</strong></p><p>2002-03-04</p><p>2004-02-03</p><p>2004-03-02</p><p><strong>数据规模和约定</strong><br>　　峰值内存消耗（含虚拟机） &lt; 256M<br>　　<br>　　CPU消耗 &lt; 1000ms</p></blockquote><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><ol><li>日期格式有年月日、月日年、日月年三种，而每种格式将日期扩展都会有19XX年和20XX年两种情况，也就是说输入一次会有六种日期生成。</li><li>生成日期会有不符合正常情况的日子存在，比如<strong>不在题目要求范围</strong>内，或者是<strong>闰年特殊的2月29日</strong>。</li><li><strong>闰年：能被4整除但不能被100整除的普通闰年，以及能被400整除的世纪闰年两种</strong>。</li><li>输入格式是”AA/BB/CC”，注意读取数据的方式。可以采用<code>scanf(&quot;%d/%d/%d&quot;,&amp;AA,&amp;BB,&amp;CC);</code>记得scanf的‘&amp;’符号！</li><li>输出格式要求”yyyy-MM-dd”，即要求<strong>月份与日期必须是两位数</strong>。可以采用C++ iomanip控制输出格式(<code>cout &lt;&lt; date[i].year &lt;&lt; &quot;-&quot; &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; date[i].month &lt;&lt; &quot;-&quot; &lt;&lt;setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt;date[i].day &lt;&lt; endl;</code>)，或者采用<code>printf(&quot;%d-%02d-%02d\n&quot;,date[i].year,date[i].month,date[i].day)</code>的方式。</li><li>去除不合理的日期也会有可能出现重复的日期，记得去重。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Date</span>&#123;</span><span class="hljs-keyword">int</span> year;<span class="hljs-keyword">int</span> month;<span class="hljs-keyword">int</span> day;&#125;;<span class="hljs-comment">//全局变量</span>Date date[<span class="hljs-number">10</span>];<span class="hljs-keyword">int</span> nums = <span class="hljs-number">0</span>;<span class="hljs-comment">//用于记录有几个正确日期</span><span class="hljs-comment">//重载‘&lt;’</span><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(Date d1, Date d2)&#123;<span class="hljs-comment">//日期从小到大</span><span class="hljs-keyword">if</span> (d1.year != d2.year) <span class="hljs-keyword">return</span> d1.year &lt; d2.year;<span class="hljs-keyword">if</span> (d1.month != d2.month) <span class="hljs-keyword">return</span> d1.month &lt; d2.month;<span class="hljs-keyword">return</span> d1.day &lt; d2.day;&#125;<span class="hljs-comment">//判断日期是否合理</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(Date d)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//创建月份数组，方便比较</span><span class="hljs-keyword">int</span> mon[<span class="hljs-number">12</span>] = &#123; <span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span> &#125;;<span class="hljs-keyword">if</span> (d.year &lt; <span class="hljs-number">1960</span> || d.year&gt;<span class="hljs-number">2059</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d.month &lt;= <span class="hljs-number">0</span> || d.month &gt; <span class="hljs-number">12</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((d.year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>) || (d.year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; d.year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>))&#123;<span class="hljs-comment">//闰年的判断方法</span><span class="hljs-keyword">if</span> (d.month == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> d.day &lt;= <span class="hljs-number">29</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> d.day &lt;= mon[d.month - <span class="hljs-number">1</span>] &amp;&amp; d.day&gt;<span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> d.day &lt;= mon[d.month - <span class="hljs-number">1</span>] &amp;&amp; d.day&gt;<span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//转换日期</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span></span><span class="hljs-function"></span>&#123;Date d;d.year = a; d.month = b; d.day = c;<span class="hljs-keyword">if</span> (judge(d))&#123;date[nums] = d;nums++;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b=<span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;scanf_s(<span class="hljs-string">&quot;%d/%d/%d&quot;</span>, &amp;a, &amp;b, &amp;c);<span class="hljs-comment">//按照格式读取</span><span class="hljs-comment">//年月日</span>change(<span class="hljs-number">1900</span> + a, b, c);change(<span class="hljs-number">2000</span> + a, b, c);<span class="hljs-comment">//日月年</span>change(<span class="hljs-number">1900</span> + c, b, a);change(<span class="hljs-number">2000</span> + c, b, a);<span class="hljs-comment">//月日年</span>change(<span class="hljs-number">1900</span> + c, a, b);change(<span class="hljs-number">2000</span> + c, a, b);<span class="hljs-comment">//排序</span>sort(date, date + nums);<span class="hljs-comment">//去重输出，也可用set等容器存储，不用再去重</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums; i++)&#123;<span class="hljs-keyword">if</span> (date[i].year != date[i - <span class="hljs-number">1</span>].year || date[i].month != date[i - <span class="hljs-number">1</span>].month || date[i].day != date[i - <span class="hljs-number">1</span>].day)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; date[i].year &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; setw(<span class="hljs-number">2</span>) &lt;&lt; setfill(<span class="hljs-string">&#x27;0&#x27;</span>) &lt;&lt; date[i].month &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt;setw(<span class="hljs-number">2</span>) &lt;&lt; setfill(<span class="hljs-string">&#x27;0&#x27;</span>) &lt;&lt;date[i].day &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//或者printf(&quot;%d-%02d-%02d\n&quot;,date[i].year,date[i].month,date[i].day);这样更加方便</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="reverse——逆序"><a href="#reverse——逆序" class="headerlink" title="reverse——逆序"></a>reverse——逆序</h2><p>属于C++头文件</p><pre><code>#include &lt;algorithm&gt;</code></pre><p>函数原型：</p><pre><code>void reverse(first,end);</code></pre><p>reverse函数用于反转在[first,last)范围内的顺序（包括first指向的元素，不包括last指向的元素）。</p><blockquote><p>参考链接：<a href="https://cloud.tencent.com/developer/article/1150743">C++ reverse函数的用法</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>蓝桥杯</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯省赛备战--Fibonacci数列、iomanip控制输出精度、类型转换</title>
    <link href="/lanqiao-1/"/>
    <url>/lanqiao-1/</url>
    
    <content type="html"><![CDATA[<p><img src="/lanqiao-1/1.jpg" alt="引图"></p><center>备战蓝桥杯！加油🙌</center><a id="more"></a><h2 id="蓝桥杯-入门训练-Fibonacci数列"><a href="#蓝桥杯-入门训练-Fibonacci数列" class="headerlink" title="蓝桥杯-入门训练 Fibonacci数列"></a>蓝桥杯-入门训练 Fibonacci数列</h2><p>问题描述<br>Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。</p><p>当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。</p><p>说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。</p><p>样例输入<br>22</p><p>样例输出<br>7704</p><p>数据规模与约定<br>1 &lt;= n &lt;= 1,000,000。</p><hr><p>有关Fibonacci数列的题目，瞬间想到要用递归，二话不说直接上手写了提交。然后就<strong>运行超时</strong>了，虽然是第一题，貌似也没那么简单。</p><p>以下是我的原本代码，外加 <code>GetTickCount</code> 来测试使用时间，结果看底下图片。</p><pre><code class="hljs CPP"><span class="hljs-comment">//运行环境VS2013</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;DWORD t1, t2;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> fibonacci(n - <span class="hljs-number">1</span>) + fibonacci(n - <span class="hljs-number">2</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">int</span> n;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Cin&gt;&gt;&quot;</span>;<span class="hljs-built_in">cin</span> &gt;&gt; n;t1 = GetTickCount();<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;The result : &quot;</span> &lt;&lt; <span class="hljs-keyword">int</span>(fibonacci(n) % <span class="hljs-number">10007</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;t2 = GetTickCount();<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Spend time: &quot;</span> &lt;&lt; t2 - t1 &lt;&lt; <span class="hljs-string">&quot; ms&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;system(<span class="hljs-string">&quot;pause&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>运行结果：</p><p><img src="/lanqiao-1/result1.png" alt="Fibonacci数列结果"></p><p>当我随机输入到44时，耗费时间长达16s😭。当然题目直接就说了不需要推算出这个值再计算它的余数，当n越大时，Fibonacci值越大，外加递归肯定耗费时间。</p><h3 id="本题核心算法"><a href="#本题核心算法" class="headerlink" title="本题核心算法"></a>本题核心算法</h3><blockquote><p><strong>Fn = F(n-1) + F(n-2);</strong></p><p><strong>Fn % 10007 = (F(n-1) + F(n-2)) % 10007;</strong></p><p>一目了然，然后使用<strong>数组存取计算的值</strong>，省的使用递归一遍遍计算了。</p></blockquote><p>更新代码：</p><pre><code class="hljs CPP"><span class="hljs-comment">//运行环境VS2013</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> n, i;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Cin&gt;&gt;&quot;</span>;<span class="hljs-built_in">cin</span> &gt;&gt; n;<span class="hljs-keyword">int</span> f[<span class="hljs-number">1000000</span>];<span class="hljs-comment">//这里VS2013不会通过，注意该小点</span>f[<span class="hljs-number">1</span>] = f[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">3</span>; i &lt;= n; i++)&#123;f[i] = (f[i - <span class="hljs-number">1</span>] + f[i - <span class="hljs-number">2</span>]) % <span class="hljs-number">10007</span>;&#125;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;The result : &quot;</span> &lt;&lt; f[n] &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><img src="/lanqiao-1/result2.png" alt="Fibonacci数列结果"></p><p>当输入值较大时运行时间还是很快的。</p><h3 id="本题感悟"><a href="#本题感悟" class="headerlink" title="本题感悟"></a>本题感悟</h3><ol><li><p>要多注意题目提示，<strong>注意题目给出的数据规模</strong>。</p></li><li><p>当遇到类似<code>Fibonacci数列</code>反复使用前面的值时，使用数组存取。</p></li></ol><h2 id="蓝桥杯-入门训练-圆的面积"><a href="#蓝桥杯-入门训练-圆的面积" class="headerlink" title="蓝桥杯-入门训练 圆的面积"></a>蓝桥杯-入门训练 圆的面积</h2><p><img src="/lanqiao-1/timu2.png" alt="圆的面积题目"></p><p>本题目主要考察使用C++头文件<code>iomanip</code>来控制<strong>输出精度</strong>。题目专门提到四舍五入保留7位小数。</p><h3 id="本题要点"><a href="#本题要点" class="headerlink" title="本题要点"></a>本题要点</h3><p><strong>iomanip的应用</strong></p><ul><li><p>setiosflags(ios::fixed) 设置浮点数以固定的小数位数显示。</p></li><li><p>setiosflags(ios::scientific) 设置浮点数以科学计数法的形式（指数）显示。</p></li><li><p>setprecision(n) 设置浮点数的精度为n位。使用一般十进制输出时，n代表有效数字。而使用上面的fixed或者scientific形式输出时，n为小数的个数。</p></li><li><p>当然这些会<strong>自动四舍五入</strong>。</p></li></ul><blockquote><p>参考链接： <a href="https://blog.csdn.net/lcg910978041/article/details/77777421">C++ iostream 输入输出流格式控制</a></p></blockquote><p>程序示例</p><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> a = <span class="hljs-number">3.123456971261</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//3.12346。  默认格式输出（6位有效数字）</span>    <span class="hljs-built_in">cout</span>&lt;&lt;setprecision(<span class="hljs-number">4</span>)&lt;&lt;a&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//3.123。  4位有效数字</span>    <span class="hljs-built_in">cout</span>&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(<span class="hljs-number">5</span>)&lt;&lt;a&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//3.12346。  5位小数部分</span>    <span class="hljs-built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="hljs-number">5</span>)&lt;&lt;a&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//3.12346。  5位小数部分。与上一部同样的表示</span>    <span class="hljs-built_in">cout</span>&lt;&lt;setiosflags(ios::scientific)&lt;&lt;setprecision(<span class="hljs-number">2</span>)&lt;&lt;a&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="蓝桥杯-入门训练-序列求和"><a href="#蓝桥杯-入门训练-序列求和" class="headerlink" title="蓝桥杯-入门训练 序列求和"></a>蓝桥杯-入门训练 序列求和</h2><p>问题描述：</p><p>求1+2+3+…+n的值。</p><p>数据规模与约定</p><p>1 &lt;= n &lt;= 1,000,000,000。</p><h3 id="本题要点-1"><a href="#本题要点-1" class="headerlink" title="本题要点"></a>本题要点</h3><ol><li><p>这里显然要使用等差数列的求和公式。 <strong><code>Sn = n*a1 + n*(n-1)*d/2</code></strong></p></li><li><p>同时由于数据规模非常大，int类型是无法存储的（int类型一般最大是2^31-1 大约2亿的一个值)。所以结果要使用<strong>long long类型</strong>。</p></li><li><p><strong>int类型的值采用求和公式计算，其结果永远都只能是<code>int类型</code>，不可能越变到<code>long long型</code>。</strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新东方实习-高三辅导员体验</title>
    <link href="/XDF-taste/"/>
    <url>/XDF-taste/</url>
    
    <content type="html"><![CDATA[<p><img src="/XDF-taste/%E5%90%88%E7%85%A71.jpg" alt="Colourso_and_friend"></p><p>很荣幸有机会在北京新东方经历为期9天的辅导员生活，感谢相遇，谢谢这份不一般的经历。</p><a id="more"></a><h2 id="源起出发"><a href="#源起出发" class="headerlink" title="源起出发"></a>源起出发</h2><p>能有这份经历非常感谢同一个工作室的大佬@<a href="https://ljwangxing.github.io/" title="ljwangxing&#39;s blog"><strong>ljwangxing</strong></a>，谢谢他推荐这份实习，更要感谢的是他亲自陪我去北京参加培训与面试😘。（实际上他压根不需要去北京的，当时直接带着还在犹豫的我离开了学校，说走就走很是佩服🤞）。</p><p>两天时间接受培训，了解辅导员这个职业，制作PPT答辩，小组集体讨论集体展示，最后接受三位导师的建议。这份经历至少这在我的大学周末之中都是少有的事情，经历完之后感受到原来两天可以做这么多事情，甚至跨越几个城市。原来说走就走这么简单，背起包就可以直接出发。（当然经济基础也是非常重要的😭）。</p><p><img src="/XDF-taste/%E7%8E%8B%E5%85%B4.jpg" alt="Colourso_and_ljwangxing"></p><center>把大佬挂上去留念(我的拍照技术好渣😂)</center><h2 id="辅导员体验"><a href="#辅导员体验" class="headerlink" title="辅导员体验"></a>辅导员体验</h2><p>我从<code>2019年1月22日</code>离开学校达到北京，到<code>2019年2月3日</code>凌晨乘做火车离开北京，一共在北京待了11天。</p><p>我与另一位辅导员<strong>周导</strong>一起搭班，共同管理有35位小可爱的政史地三科的班级。班级内都是高三的文科考生，(28位来自山东，2位来自黑龙江，1位来自北京，1位来自河南，1位来自内蒙古，1位来自辽宁，1位来自广东。30个女生，5个男生，标准文科班😄)。</p><blockquote><p>时间：2019年1月24日晚 – 2019年2月2日下午</p><p>地点：北京王府学校</p><p>班级名称：ZGLYW19105</p><p>科目：历史、政治、地理</p></blockquote><p>我们在这9天的上课时间之内，是以“老师”的身份自居，协调学校与家长、学生与老师之间的关系，在家长群内用图片与视频的形式反馈学生们上课的状态，帮助任课老师批改进门测出门测的成绩，维持自习时间的纪律，照顾好在这里上学的每一位同学。这就是我们辅导员的任务，当然还有一些其他的就不提了。</p><p>这是一份非常锻炼与人交际沟通的工作，涉及到与不同年龄段、不同社会背景、不同身份的人，会遇到正值高三的青春期男女、同是大学生的辅导员群体、激情满满的新东方名师以及为人父母的家长。与不同的人进行交涉尤其是对我这种内向腼腆的人来说非常有用，遇到问题就要及时处理，问老师、问组长、问班里的学生。</p><p>记得刚开始开班大会的时候我和周导都特别的尴尬，要开三个小时的班会，我们要对着35位学生讲三个小时，尽管事先准备了PPT，但毕竟还是第一次讲这么长时间，没有经验，节奏把握的不太好，周导前面的话讲的太多了（好多话都有些自相矛盾了），因为协商不到位，班级成员自我介绍的时间拉的太长，导致准备的破冰游戏无法继续。但毕竟是开班的第一天，班级成员也不会太注意这些细节，因为接下来都是他们的上课的时间，而且人们往往都会忘记当初说过什么，保留的都是最后形成的印象。(比如我也记不太清楚了，只是感觉比较尬😂)</p><p>之后时间里的晚自习我们两位辅导员和35位同学都交谈过了一遍，少数几个是在课下，大部分都是在晚自习叫出教室聊的，聊的都很开心，当然班里氛围也是越来越好，因为周导说他发现自己原来可以这么不要脸😂，到后面我也和班里一部分同学熟悉了起来，渐渐聊的来了。</p><p>期间我和我高中哥们打过一个电话，扯到了我们班里的那些同学，他问我感觉怎么样，我当时说我们班里的同学都特别可爱。是啊，的确特别可爱，有说自己喜欢‘女孩子’的佳雯cool_girl，有东北味道的心语，在试卷上画海绵宝宝的松瑞，还有‘有1G流量交情的’小涵狗狗，还有戴宇辰啦这位几乎没干过活的班长，“你今天真好看”哈哈哈哈，还有‘怎么变的这么娘’的瑞昕，会开车的、和我用老年表情包斗图的范爷(可怕)、非常稳的伊林、把自己表情包发给我的可爱函臻……真的是回忆满满啊。当然肯定还有会拍照当过兵的骚气周导，宿舍里最骚的辰先森，以及卡丁车老王，还有一只被我叫做生活老师的班主任郭老师hhhhhhhhh</p><p>记得中午送别提前走的几位同学的时候，那会是真的不舍，静静看他们拉着皮箱的背景消失在校门口，我还朝他们的背影挥了挥手…周导说看来你还是很少经历离别啊，我当兵的一年经历了四次更大的离别…记得周导说咱们只是短暂的幸会了9天，双方都留下好印象已经非常好了，我们不会在他们的人生中留下太多的东西，有这么一个好印象，有可以随时联系的微信就足够了，以后回想起来也是一份美好的回忆…</p><p>那就再见了ZGLYW19105班的各位，35位小可爱，2位辅导员，1位班主任，3位任课老师，1位助教衷心的祝福各位未来的日子能够继续拼搏向上、无所畏惧。祝愿各位前程似锦，未来NB(破音~)</p><center>🧡💛💙💚💜🖤💕💞💓💗💖💘💝💟💌</center>![新东方王府学校ZGLYW19105班级合照](XDF-taste/新东方王府学校ZGLYW19105班级合照.jpg)<center><font size="2px">ZGLYW19105班级合照</font></center><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>培训时宇哥说过：一切的问题都是沟通的问题。虽然一直不太认同，但是也认识到沟通交流表达的重要性(貌似一直都知道💔)。怎样能变得更加不紧张，面对一堆几乎同龄的人怎样把一场开班班会以及结营晚会办好，还是值得再摸索摸索的。</p><p>看着新东方老师上课，他们都有几个共同的特点。<strong>幽默</strong>，上课特别有氛围，老师会用自身的经历或者自己科目的有趣故事吸引同学们上课的注意力，我采纳同学们的反馈意见的时候，都是一致好评，比自己老师讲的有意思多了。<strong>激情</strong>，新东方老师看那架势都有连续讲3个小时不休息不喝水的干劲，真的着实佩服。<strong>负责</strong>，老师会专门给迟来报到的两位同学补她们没有听的课程，连着上一天的课本来就很累，但老师还是抽出时间去专门补课，着实佩服他们。</p><p>总体感觉自己处理问题的方式想的不太周到，尤其是遇到别人比较强势的时候更加容易失去自我思考的能力，还有大佬说我的问题，优柔寡断，总是缺少一份底气。还有我比较害羞，班里学生甚至问我我为什么这么害羞😔…</p><p>总之谢谢这一份不一样的经历，提前认识外面的世界，也在考研还是直接就业的问题上犹豫了一下…过完年了，接下来还是努力学习吧！</p><p>想起那天发给佳雯的话：</p><blockquote><p>《时间之书》里说，年轻人，你的职责是平整土地，而非焦虑时光。你做三四月的事，在八九月自有答案。</p></blockquote><p>但行好事，莫问前程。自己的专业基础要打好鸭！继续加油吧~👍</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言内存四区模型详解(未完成)</title>
    <link href="/C-memory-layout/"/>
    <url>/C-memory-layout/</url>
    
    <content type="html"><![CDATA[<p>本文是关于C语言的内存四区分布，并未从书上找到相关内容，所以本文的内容依据主要来自 <font color="#f79649"><strong>传智播客-黑马程序猿</strong></font> 的教学视频，以及参考自众多博客，会在文末统一附出链接地址。</p><a id="more"></a><h2 id="内存四区模型"><a href="#内存四区模型" class="headerlink" title="内存四区模型"></a>内存四区模型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>C语言程序在被执行过程中，操作系统将程序所占用的内存分为四个区域：栈、堆、全局区以及代码区。每一个程序占用的内存都会有这四个区域。而设计内存四区的目的，就像公司分不同的职位与部分，便于更好的管理，提高工作执行的效率，同时不同区域的变量以及常量的生命周期不同，我们可以根据我们的需要，灵活运用去编程。</p><p><img src="/C-memory-layout/00_%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA.png" alt="C语言内存四区"></p><center><font size="2px">上图来自 <font color="#f79649">**传智播客-黑马程序猿**</font> 的教学视频。</font></center><p><img src="/C-memory-layout/01_%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png" alt="C语言内存四区"></p><center><font size="2px">上图来自 **[堆、栈、全局区静态区、文字常量区、程序代码区](https://blog.csdn.net/peeno/article/details/52808686 "堆、栈、全局区静态区、文字常量区、程序代码区")** 的博客中</font></center>### 功能介绍<blockquote><ol><li><font color="#f79649"><strong>栈区</strong>(stack)</font>： 存放函数参数、局部变量等，由编译器自动分配释放。</li><li><font color="#f79649"><strong>堆区</strong>(heap)</font>：存放动态分配的数据(malloc/new)，由程序猿手动分配释放，程序结束时也会有操作系统自动回收。</li><li><font color="#f79649"><strong>全局区</strong>(global)</font>：包含常量、全局变量、静态变量等，文字常量区也包含在内。程序结束后由操作系统释放。</li><li><font color="#f79649"><strong>代码区</strong>(code)</font>：存放函数体的二进制代码。</li></ol></blockquote><h2 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h2><h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><h2 id="全局区"><a href="#全局区" class="headerlink" title="全局区"></a>全局区</h2><p>全局区包含常量，静态变量等等。以文字常量区为例。文字常量是只读的，不可以修改。当要使用一段字符串时，会现在文字常量区进行查找，如果有就使用，没有的话就创建。</p><p>例子：通过打印地址来验证</p><pre><code class="hljs CPP"><span class="hljs-comment">//测试环境VS2013</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">get_str1</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> * p = <span class="hljs-string">&quot;I Love CPP&quot;</span>;<span class="hljs-keyword">return</span> p;&#125;<span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">get_str2</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> * q = <span class="hljs-string">&quot;I Love CPP&quot;</span>;<span class="hljs-keyword">return</span> q;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> * p = <span class="hljs-literal">nullptr</span>;<span class="hljs-keyword">char</span> * q = <span class="hljs-literal">nullptr</span>;p = get_str1();q = get_str2();<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p : %s,p的地址为：%d \n&quot;</span>, p, p);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;q : %s,q的地址为：%d \n&quot;</span>, q, q);system(<span class="hljs-string">&quot;pause&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>输出结果</p><p><img src="/C-memory-layout/02_%E5%85%A8%E5%B1%80%E5%8C%BA%E6%B5%8B%E8%AF%95.png" alt="C语言文字常量区"></p><p><strong>地址相同,说明一旦文字常量区存在字符串，就不需要再被创建。</strong></p><h2 id="以字符串字符数组为例综合说明内存四区分布"><a href="#以字符串字符数组为例综合说明内存四区分布" class="headerlink" title="以字符串字符数组为例综合说明内存四区分布"></a>以字符串字符数组为例综合说明内存四区分布</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p>CSDN博客： <a href="https://blog.csdn.net/ic_tv/article/details/46718907" title="ic_tv：C语言程序内存四区(栈区,堆区,全局区,代码区)">C语言程序内存四区(栈区,堆区,全局区,代码区)</a></p><p>CSDN博客： <a href="https://blog.csdn.net/yitian20000/article/details/6358837" title="栈区，堆区，全局区，文字常量区，程序代码区 详解">栈区，堆区，全局区，文字常量区，程序代码区 详解</a>（实际上主要内容是栈和堆的知识）</p><p><a href="https://blog.csdn.net/qq_37764129/article/details/80784845">https://blog.csdn.net/qq_37764129/article/details/80784845</a></p><p><a href="https://www.cnblogs.com/letben/p/5236674.html">https://www.cnblogs.com/letben/p/5236674.html</a></p><p><a href="https://www.cnblogs.com/shijiaqi1066/p/6146865.html">https://www.cnblogs.com/shijiaqi1066/p/6146865.html</a></p><p><a href="https://www.jianshu.com/p/98cb5f584a31">https://www.jianshu.com/p/98cb5f584a31</a></p><p><a href="https://blog.csdn.net/helloyurenjie/article/details/79795059">https://blog.csdn.net/helloyurenjie/article/details/79795059</a></p><p><a href="https://blog.csdn.net/dajiabudongdao/article/details/51945041">https://blog.csdn.net/dajiabudongdao/article/details/51945041</a></p><p><a href="https://blog.csdn.net/ic_tv/article/details/46718907">https://blog.csdn.net/ic_tv/article/details/46718907</a></p><p><a href="https://blog.csdn.net/wu5215080/article/details/38899259">https://blog.csdn.net/wu5215080/article/details/38899259</a></p><p><a href="https://www.cnblogs.com/crazyzhang/p/5727822.html">https://www.cnblogs.com/crazyzhang/p/5727822.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Hexo+Github搭建博客与优化扩展</title>
    <link href="/set-up-blog/"/>
    <url>/set-up-blog/</url>
    
    <content type="html"><![CDATA[<p>博客搭建好也有三个月了，踩过一些坑，一步步达到了现在的博客。因为网络上关于 <code>Hexo+Github</code> 搭建博客的教程太多了，也没有必要重写一份新的教程，😜。我就收集一下我搭建博客过程中遇到了一些好的教程，供大家参考。遇到困难百度就能解决大部分的问题哦。</p><a id="more"></a><h2 id="搭建教程"><a href="#搭建教程" class="headerlink" title="搭建教程"></a>搭建教程</h2><blockquote><p>@<a href="http://www.nomango.cn/" title="拒绝芒果工作室"><strong>拒绝芒果工作室</strong></a> ：<a href="http://www.nomango.cn/2016/10/09/161009-one-hour-build-your-blog/" title="一小时快速搭建个人静态博客">一小时快速搭建个人静态博客</a> （👈本博客搭建的所有流程均参看自这篇博客）。</p><p>@<a href="http://visugar.com/" title="张小花"><strong>张小花</strong></a> ：<a href="http://visugar.com/2017/05/04/20170504SetUpHexoBlog/" title="hexo从零开始到搭建完整">hexo从零开始到搭建完整</a></p><p>@<a href="https://haoji.me/" title="好记么"><strong>小茗同学</strong></a> ：<a href="http://blog.haoji.me/build-blog-website-by-hexo-github.html" title="使用hexo+github搭建个人博客详细教程">使用hexo+github搭建免费个人博客详细教程</a> （👈非常详细的一篇博客，有提到原理，可以去看看）。</p></blockquote><h2 id="主题选择-优化"><a href="#主题选择-优化" class="headerlink" title="主题选择+优化"></a>主题选择+优化</h2><p>本站选择的是NexT主题，这也应该是最流行的一款主题，越流行的主题遇到问题越容易百度的到，你懂的😀。</p><blockquote><p><a href="http://theme-next.iissnan.com/" title="NexT"><strong>NexT官方文档</strong></a></p><p>@<strong><a href="https://www.jianshu.com/u/439a6eee60e1" title="简书">Alvabill</a></strong> ：<a href="https://www.jianshu.com/p/1f8107a8778c">hexo搭建个人博客–NexT主题优化</a> （👈本博客优化内容参看了这篇博客）。</p><p>@**<a href="http://shenzekun.cn/" title="Moorez">Moorez</a>**：<a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html#more" title="hexo的next主题个性化教程:打造炫酷网站">hexo的next主题个性化教程:打造炫酷网站</a> （👈本博客优化内容参看了这篇博客）。</p><p>@<strong><a href="https://www.jianshu.com/u/ab646e469afd" title="简书">wangwlj</a></strong> ：<a href="https://www.jianshu.com/p/7debbf85f437?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation" title="https://www.jianshu.com/p/7debbf85f437?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">hexo搭建的Github博客之优化 </a></p><p>@<strong><a href="http://www.lzblog.cn/" title="lizhen">lizhen</a></strong><a href="http://www.lzblog.cn/2016/04/07/Hexo%E7%AB%99%E7%82%B9%E3%80%81NexT%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E5%85%A8%E8%AE%B0%E5%BD%95/" title="http://www.lzblog.cn/2016/04/07/Hexo%E7%AB%99%E7%82%B9%E3%80%81NexT%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E5%85%A8%E8%AE%B0%E5%BD%95/">：Hexo站点、NexT主题修改全记录 </a></p></blockquote><h2 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h2><p>也百度到过各种网站添加评论功能，结果总是有问题，其中一个网站连注册功能都出现错误，一直无法注册。在得知 <code>NexT</code> 主题里支持 <code>Valine</code> 评论之后果断就采用了这个评论，虽然说有些局限，但对于这个简单博客来说够用了。😁</p><blockquote><p>@**<a href="https://blog.csdn.net/blue_zy" title="blue_zy">blue_zy</a>**：<a href="https://blog.csdn.net/blue_zy/article/details/79071414">为你的Hexo加上评论系统-Valine</a> （👈本博客添加参看了这篇博客）。</p><p>@**<a href="https://www.bigwin.ml/">桃源阡墨，Bigwin</a>**：<a href="https://www.bigwin.ml/2018/11/29/valine-for-next/">在Hexo博客的next主题中启用Valine评论</a></p></blockquote><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><blockquote><p><a href="https://www.cnblogs.com/codehome/p/8428738.html?utm_source=debugrun&utm_medium=referral" title="Hexo添加本地图片">Hexo添加本地图片</a> （👈本博客插入图片功能采用了这篇博客的第一种方法）。</p></blockquote><h2 id="添加live2d看板娘"><a href="#添加live2d看板娘" class="headerlink" title="添加live2d看板娘"></a>添加live2d看板娘</h2><blockquote><p><strong>掘金文章</strong>： <a href="https://juejin.im/post/5bebfe51e51d45332a456de0#heading-27">https://juejin.im/post/5bebfe51e51d45332a456de0#heading-27</a> （👈很长的一篇文章，添加方法在60%左右）。</p></blockquote><p>但是移除这个东西没有什么好的办法，惨~~。</p><h2 id="书写博客"><a href="#书写博客" class="headerlink" title="书写博客"></a>书写博客</h2><p>写博客采用的是 <font color="#00ffff">Markdown</font> 来进行书写，hexo会转换成为 <code>HTML</code> 页面。至于 <code>Markdown</code> 语法非常的简单，仿照一篇文章写一遍就非常的清楚了。以下链接有<code>Markdown</code>语法介绍，还有一个在线版的书写<code>Markdown</code> 的网站，时时渲染转换，非常的清晰。另外还有一款软件叫做 <code>MarkdownPad2</code> ，大家也可以去下载哦，非常的好用。</p><blockquote><p><a href="https://www.appinn.com/markdown/" title="Markdown语法">在线文档：Markdown 语法</a></p><p><a href="https://blog.csdn.net/qcx321/article/details/53780672">Markdown 语法大全 包括设置字体 颜色</a></p><p><a href="https://www.zybuluo.com/mdeditor" title="Cmd Markdown 编辑阅读器">在线网站：Cmd Markdown 编辑阅读器</a></p><p><a href="http://markdownpad.com/" title="The Markdown Editor for Windows">电脑软件：MarkdownPad2</a></p></blockquote><p>目前就这儿多了，后期继续补充！</p><p>现在我主要使用的是<a href="https://typora.io/">Typora</a>，非常好用哦~推荐使用。</p><h2 id="2019-07-16增加功能"><a href="#2019-07-16增加功能" class="headerlink" title="2019.07.16增加功能"></a>2019.07.16增加功能</h2><blockquote><p>增加打赏功能：<a href="https://www.zhyong.cn/posts/20ec/">hexo-next 添加酷炫打赏二维码</a></p><p>增加文章置顶功能：<a href="https://www.zhyong.cn/posts/fc22/">hexo-next 添加文章置顶功能和评分功能等</a></p><pre><code class="hljs bash">$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save</code></pre><p>文章指定使用：在文章头部添加<code>top: true</code>。</p></blockquote><h2 id="Connection-reset-by-13-250-177-223-port-22"><a href="#Connection-reset-by-13-250-177-223-port-22" class="headerlink" title="Connection reset by 13.250.177.223 port 22"></a>Connection reset by 13.250.177.223 port 22</h2><p>电脑重装之后重新建立博客，提交仓库时出错。</p><p>解决方法：在host文件里添加下面两行。</p><pre><code class="hljs accesslog"><span class="hljs-number">192.30.255.112</span>  github.com git <span class="hljs-number">185.31.16.184</span>   github.global.ssl.fastly.net</code></pre><blockquote><p><a href="https://blog.csdn.net/Boring_Wednesday/article/details/80072446">git push时出现ssh_dispatch_run_fatal</a></p></blockquote><p>要是这样也没用的话，尝试是否可以在浏览器上访问Github，或者Ping一下github.com。如果无法访问，那就搭梯子科学上网吧。</p><hr><p>2020年2月7日，上传博客时再次出现了类似的问题，但是修改host文件也没有用了，不搭梯子的话，无法用浏览器打开github，使用梯子之后可以打开，但是本地PING github时还是连接超时，太诡异了。</p><p>这次搭上梯子都不管用了。</p><blockquote><p>参考链接：<a href="https://blog.csdn.net/nightwishh/article/details/99647545">git报错ssh: connect to host github.com port 22: Connection timed out</a></p></blockquote><p>参照这篇博客，先在命令行输入了<code>ssh -T git@github.com</code>命令来检查，如果出现了<code>ssh: connect to host github.com port 22: Connection timed out</code>的话就找到当初搭建博客时存放ssh目录的地方，我的存放于<code>C:\Users\colou\.ssh</code>。colou是电脑的用户名。</p><p>在那里新建一个文件<code>config</code>，然后输入下面的内容。</p><pre><code class="hljs stylus">Host github.comUser YourEmail@<span class="hljs-number">163</span>.comHostname ssh<span class="hljs-selector-class">.github</span>.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort <span class="hljs-number">443</span></code></pre><p>记得把邮箱替换成你的github的邮箱，然后重新上传博客，就会弹出相关的问题，输入yes就好了。</p><h2 id="2020-01-28增加功能"><a href="#2020-01-28增加功能" class="headerlink" title="2020.01.28增加功能"></a>2020.01.28增加功能</h2><blockquote><p>增加折叠代码块的功能： <a href="https://www.cnblogs.com/woshimrf/p/hexo-fold-block.html">Hexo next博客添加折叠块功能添加折叠代码块</a> </p></blockquote><p>不过因为增加之后不太明显，我就额外增加了一点颜色加以区分。</p><p>位置在：<code>themes/next/source/css/_custom/custom.styl</code></p><pre><code class="hljs css"><span class="hljs-selector-class">.hider_title</span>&#123;    <span class="hljs-attribute">cursor</span>: pointer;<span class="hljs-attribute">color</span>:<span class="hljs-number">#87CEEB</span>;<span class="hljs-attribute">font-weight</span>:bold;&#125;<span class="hljs-selector-class">.close</span><span class="hljs-selector-pseudo">:after</span>&#123;    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;▼&quot;</span>;<span class="hljs-attribute">color</span>:<span class="hljs-number">#00EE00</span>;&#125;<span class="hljs-selector-class">.open</span><span class="hljs-selector-pseudo">:after</span>&#123;    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;▲&quot;</span>;<span class="hljs-attribute">color</span>:<span class="hljs-number">#FF11FF</span>;&#125;</code></pre><hr><h2 id="2020-02-27更换主题"><a href="#2020-02-27更换主题" class="headerlink" title="2020.02.27更换主题"></a>2020.02.27更换主题</h2><p>新主题：Fluid</p><p>链接：<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p>参考文档：<a href="https://hexo.fluid-dev.com/docs/">https://hexo.fluid-dev.com/docs/</a></p><h3 id="更换主题后遇到的一些问题"><a href="#更换主题后遇到的一些问题" class="headerlink" title="更换主题后遇到的一些问题"></a>更换主题后遇到的一些问题</h3><p>由于我是重装了系统，所以博客重新配置了一遍。在配置完成之后，生成本地预览的时候，发现无法加载出图片，（我的图片是放在本地的，只有几张使用的图床），查看源码可以发现图片的链接异常，我这里出现了<code>\.com\\1.png</code>这样的图片链接，百度到了一些问题，有的说是Hexo3以上的版本使用Markdown的图片语法<code>![]()</code>会出现问题，解决方法是更换图片的文章链接方式，有的说是更新插件。</p><blockquote><p>参考链接：<a href="https://blog.csdn.net/xjm850552586/article/details/84101345">hexo引用本地图片无法显示</a></p></blockquote><p>参考上面的链接，我发现是我配置文件<code>_config.yml</code>中的<code>url</code>那一栏填写错误导致的，最后改成我的博客的地址<code>http://colourso.github.io</code>，然后<code>hexo clean</code>之后重新生成预览，就正常了。</p><h3 id="第二次遇到这个问题——这次忘记装插件了"><a href="#第二次遇到这个问题——这次忘记装插件了" class="headerlink" title="第二次遇到这个问题——这次忘记装插件了"></a>第二次遇到这个问题——这次忘记装插件了</h3><p>现在本地博客根目录执行下面语句</p><pre><code class="hljs maxima">npm install hexo-asset-<span class="hljs-built_in">image</span> --<span class="hljs-built_in">save</span></code></pre><p>修改hexo配置文件<code>_config.yml</code>，找到<code>post_asset_folder</code>修改为true.</p><p>打开<code>/node_modules/hexo-asset-image/index.js</code>将整个文件用下面的代码替换：</p><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<span class="hljs-keyword">var</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cheerio&#x27;</span>);<span class="hljs-comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPosition</span>(<span class="hljs-params">str, m, i</span>) </span>&#123;  <span class="hljs-keyword">return</span> str.split(m, i).join(m).length;&#125;<span class="hljs-keyword">var</span> version = <span class="hljs-built_in">String</span>(hexo.version).split(<span class="hljs-string">&#x27;.&#x27;</span>);hexo.extend.filter.register(<span class="hljs-string">&#x27;after_post_render&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;  <span class="hljs-keyword">var</span> config = hexo.config;  <span class="hljs-keyword">if</span>(config.post_asset_folder)&#123;    <span class="hljs-keyword">var</span> link = data.permalink;<span class="hljs-keyword">if</span>(version.length &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">Number</span>(version[<span class="hljs-number">0</span>]) == <span class="hljs-number">3</span>)   <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span>   <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">3</span>) + <span class="hljs-number">1</span>;<span class="hljs-comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span><span class="hljs-keyword">var</span> endPos = link.lastIndexOf(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-number">1</span>;    link = link.substring(beginPos, endPos);    <span class="hljs-keyword">var</span> toprocess = [<span class="hljs-string">&#x27;excerpt&#x27;</span>, <span class="hljs-string">&#x27;more&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; toprocess.length; i++)&#123;      <span class="hljs-keyword">var</span> key = toprocess[i];       <span class="hljs-keyword">var</span> $ = cheerio.load(data[key], &#123;        ignoreWhitespace: <span class="hljs-literal">false</span>,        xmlMode: <span class="hljs-literal">false</span>,        lowerCaseTags: <span class="hljs-literal">false</span>,        decodeEntities: <span class="hljs-literal">false</span>      &#125;);      $(<span class="hljs-string">&#x27;img&#x27;</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">if</span> ($(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>))&#123;<span class="hljs-comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span><span class="hljs-keyword">var</span> src = $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>).replace(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<span class="hljs-keyword">if</span>(!<span class="hljs-regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;   !<span class="hljs-regexp">/^\s*\//</span>.test(src)) &#123;  <span class="hljs-comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span>  <span class="hljs-comment">// In addition, to support multi-level local directory.</span>  <span class="hljs-keyword">var</span> linkArray = link.split(<span class="hljs-string">&#x27;/&#x27;</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span>;  &#125;);  <span class="hljs-keyword">var</span> srcArray = src.split(<span class="hljs-string">&#x27;/&#x27;</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="hljs-string">&#x27;.&#x27;</span>;  &#125;);  <span class="hljs-keyword">if</span>(srcArray.length &gt; <span class="hljs-number">1</span>)srcArray.shift();  src = srcArray.join(<span class="hljs-string">&#x27;/&#x27;</span>);  $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>, config.root + link + src);  <span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;no src attr, skipped...&quot;</span>);<span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info($(<span class="hljs-built_in">this</span>));&#125;      &#125;);      data[key] = $.html();    &#125;  &#125;&#125;);</code></pre><p>然后clean之后再次生成就好了。</p><h2 id="2020-05-27更新主题"><a href="#2020-05-27更新主题" class="headerlink" title="2020.05.27更新主题"></a>2020.05.27更新主题</h2><p>更新的是1.8.0版本之后的一次<code>develop</code>分支的内容，主要新功能是支持LeanCloud的计数功能。</p><p>主题文件中主要修改替换一下<code>layout\_partial\footer.ejs</code>中的内容，用于修改底部显示内容。</p><p>后期准备更新数学公式渲染。</p><h2 id="2020-07-31引入B站视频"><a href="#2020-07-31引入B站视频" class="headerlink" title="2020.07.31引入B站视频"></a>2020.07.31引入B站视频</h2><p>原因是做了贪吃蛇小游戏，录制GIF展示文件太大，加上Github对图片的加载本来就不好，很容易加载不出来。于是模仿廖雪峰大神的网站，演示视频放在B站，然后本地博客引入链接就好了。</p><p>插入代码：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//player.bilibili.com/player.html?aid=371573766&amp;bvid=BV1fZ4y1T7xo&amp;cid=218646009&amp;page=1&quot;</span> <span class="hljs-attr">scrolling</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">framespacing</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">allowfullscreen</span>=<span class="hljs-string">&quot;true&quot;</span>    <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 430px; max-width: 100%&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span></code></pre><p><code>src</code>里面的内容来自于B站网页视频底部的“分享”，然后“嵌入代码”，其他的细节还是按照上述的设定吧，勉强能用。</p><blockquote><p>未用到但是效果很好的链接：<a href="https://oneboke.com/3045.html">https://oneboke.com/3045.html</a></p></blockquote><h2 id="2020-08-31增加数学公式渲染"><a href="#2020-08-31增加数学公式渲染" class="headerlink" title="2020.08.31增加数学公式渲染"></a>2020.08.31增加数学公式渲染</h2><p>主题版本没有更换。</p><blockquote><p>LaTeX 数学公式<br>当需要使用 LaTeX 语法的数学公式时，可手动开启本功能，需要完成三步操作：</p><ol><li>设置主题配置</li></ol><p>post:<br>  math:<br>    enable: true<br>    specific: false<br>    engine: mathjax<br>specific: 建议开启。当为 true 时，只有在文章 Front-matter 里指定 math: true 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度。</p><p>engine: 公式渲染引擎，目前支持 mathjax 或 katex。</p><ol start="2"><li>更换 Markdown 渲染器</li></ol><p>由于 Hexo 默认的 Markdown 渲染器不支持复杂公式，所以必须更换渲染器。</p><p>先卸载原有渲染器：</p><p>npm uninstall hexo-renderer-marked –save</p><p>然后根据上方配置不同的 engine，推荐更换如下渲染器：</p><p>mathjax: npm install hexo-renderer-kramed –save</p><p>katex: npm install @upupming/hexo-renderer-markdown-it-plus –save</p><ol start="3"><li>安装完成后执行 hexo clean</li></ol><p>链接：<a href="https://hexo.fluid-dev.com/docs/guide/#latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">https://hexo.fluid-dev.com/docs/guide/#latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F</a></p></blockquote><p>引擎选用了mathjax，但是不得不说有的渲染错误……</p><p>渲染错误原因是这个引擎对换行的Latex公式支持的不好， 于是我就把我博客中的Latex拆分成了一行一行的……</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SOP</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构课课设———四维数组</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AF%BE%E8%AE%BE%E2%80%94%E2%80%94%E2%80%94%E5%9B%9B%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AF%BE%E8%AE%BE%E2%80%94%E2%80%94%E2%80%94%E5%9B%9B%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>这是我的数据结构课程设计，搬运至博客做一份保存，也把弄清楚的一些知识记录下来。</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol><li>按照行优先顺序将输入的数据建成4维数组，按照列优先顺序输出结果；</li><li>给出任意处的元素值，并给出对应的一维数组中的序号；</li><li>用 <code>squeeze</code> 函数来消除数组中的”孤维”，即大小等于1的维，从而起到降维的作用；</li><li>用 <code>sub2ind</code> 函数将下标转换为单一索引数值；</li><li>用 <code>ind2sub</code> 函数将数组的单一索引数值转换为数组的下标。</li></ol><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="1-行优先存储与列优先存储"><a href="#1-行优先存储与列优先存储" class="headerlink" title="1.行优先存储与列优先存储"></a>1.行优先存储与列优先存储</h3><p>说到存储，计算机的存储方式只有两种，<strong>物理结构</strong>——顺序存储结构和链式存储结构。而一切数据结构中的类型，如栈、队列、二叉树、图等都是使用这两种存储结构进行实现与表示的，这些结构都是<strong>逻辑上的结构</strong>，同样的，数组，无论多少维度都是采用这两种物理结构实现的，其在内存之中都只是一堆连续或者不连续的数据。</p><p>对于多维数组来说，存储的顺序可以不同，因为其下标不止一个，存储数据的先后次序也就可以不一样。</p><p>举个栗子，二维数组。行优先存储，优先存储每一行，依次向后，对应的下标变换为<code>a[0][0]</code>至<code>a[0][1]</code>至<code>a[0][2]</code>…。低下标先开始变化，直至结束。因此，<strong>以行序为主序存储方式也称为低下标优先</strong>。C语言采用的就是这种方式。</p><p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AF%BE%E8%AE%BE%E2%80%94%E2%80%94%E2%80%94%E5%9B%9B%E7%BB%B4%E6%95%B0%E7%BB%84/%E4%BD%8E%E4%B8%8B%E6%A0%87%E4%BC%98%E5%85%88.png" alt="低下标优先"></p><p>列优先存储，优先存储每一列，依次向后，对应的下标变换为<code>a[0][0]</code>至<code>a[1][0]</code>至<code>a[2][0]</code>…。高下标先开始变化，直至结束。因此，<strong>以列序为主序存储方式也称为高下标优先</strong>。Matlab采用的就是这种方式。</p><p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AF%BE%E8%AE%BE%E2%80%94%E2%80%94%E2%80%94%E5%9B%9B%E7%BB%B4%E6%95%B0%E7%BB%84/%E9%AB%98%E4%B8%8B%E6%A0%87%E4%BC%98%E5%85%88.png" alt="高下标优先"></p><p>参考链接</p><blockquote><p><a href="https://blog.csdn.net/baiyu9821179/article/details/74852984">行优先存储和列优先存储</a></p><p><a href="https://blog.csdn.net/Canhui_WANG/article/details/52242496">行优先和列优先的原则问题——Matlab</a></p></blockquote><h3 id="2-C语言多维数组的理解"><a href="#2-C语言多维数组的理解" class="headerlink" title="2.C语言多维数组的理解"></a>2.C语言多维数组的理解</h3><p>C语言数组，是一个用于存储固定大小的相同类型元素的集合。</p><pre><code>int a[4] = &#123;0,1,2,3&#125;;int b[2][4] = &#123;                &#123;0,1,2,3&#125;,                &#123;4,5,6,7&#125;              &#125;;</code></pre><p>如上所示的一维数组，基本元素是<code>int</code>类型的数据，这个数组可称为<strong>int类型数据的数组</strong>。而二维数组，基本元素是<code>int</code>类型数据的数组，这个数组可称为<strong>一维数组的数组</strong>。同理，n维数组的基本元素就是n-1维数组。</p><p>声明数组 <code>int c[3][4][5];</code> 表示数组 c 包含三个元素: <code>c[0],c[1],c[2]</code> ，而这每一个元素又都是二维数组，而每一个二维数组又包含四个元素——一维数组。</p><p>参考链接</p><blockquote><p><a href="http://c.biancheng.net/view/356.html">C语言多维数组，以及多维数组中的二维数组</a></p></blockquote><h3 id="3-几个名词：维度、维界与孤维（未找到定义，自己的理解）"><a href="#3-几个名词：维度、维界与孤维（未找到定义，自己的理解）" class="headerlink" title="3.几个名词：维度、维界与孤维（未找到定义，自己的理解）"></a>3.几个名词：维度、维界与孤维（未找到定义，自己的理解）</h3><ul><li><p>维度：几维数组对应的维度就是几。如 <code>int c[3][4][5];</code> 是三维数组。</p></li><li><p>维界：对应每一个维度的范围，一般下界为0。如 <code>int c[3][4][5];</code> ，其第三维维界为0至2。</p></li><li><p>孤维，就是维界只能存储数量为1的维度，如 <code>int c[3][1][5];</code> ，共能存放15个数据，而<code>int c[3][5];</code> 也是存放15个数据，故可以消除孤维，来简化多维数组。</p></li></ul><h2 id="数据结构与核心算法"><a href="#数据结构与核心算法" class="headerlink" title="数据结构与核心算法"></a>数据结构与核心算法</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>采用<strong>顺序存储</strong>的方式来存储数组：</p><ol><li>一旦建立数组，数组存储的数量和结构中的元素之间的关系不需要再发生变化。</li><li>不需要插入和删除操作，还需要实现随机存取（<code>时间复杂度为O(1)</code>）。</li></ol><pre><code class="hljs CPP"><span class="hljs-comment">//参考自《数据结构》清华大学出版社 严蔚敏</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>ElemType * base;<span class="hljs-comment">//元素基址,ElemType为此数组要存储的数据类型</span><span class="hljs-keyword">int</span> dim;<span class="hljs-comment">//维数</span><span class="hljs-keyword">int</span> elemtotal;<span class="hljs-comment">//总数</span><span class="hljs-keyword">int</span> * bounds;<span class="hljs-comment">//数组各个维界</span><span class="hljs-keyword">int</span> * constants;<span class="hljs-comment">//映像函数常量基址，参看映像函数⬇</span>&#125;Array;</code></pre> <h3 id="核心算法——映像函数"><a href="#核心算法——映像函数" class="headerlink" title="核心算法——映像函数"></a>核心算法——映像函数</h3><p>映像函数是为了便于计算多维下标对应的内存基址。由于四维数组只是逻辑上的四维数组，其在内存上的真实分配情况也只是顺序存储结构，为了实现四维数组随机存取的特点，就要使用映像函数求得其地址。故上述结构体中 <code>int * constants</code> 的存在就是为了使得计算方便。</p><p>例如：<code>int c[3][4][5]</code> 这个三维数组，按照行优先存储，下标(1,2,3)对应的基址如何求得呢？<br><code>LOC(1，2，3) = 首元素基址 + 1 * 4 * 5 + 2 * 5 + 5 * 1</code> 。而这里的 <code>int * constants</code> 就是把<strong>每一个维度能存储的元素个数</strong>存储了下来。对于 <code>int c[3][4][5]</code> 它的第三维包含三个元素 <code>c[0][4][5]、c[1][4][5]、c[2][4][5]</code>，每个元素都能存储 <code>4 * 5 = 20</code> 个元素，第三维下标为1，故<code>1 * 4 *5 = 20</code> ,其余同理。</p><p>故使用 <code>int * constants</code> 来作为映像函数常量基址，每个 <code>A.constands[i]</code> 代表比 <code>dim - i</code> 低一维的所有元素的个数。</p><pre><code class="hljs CPP">A.constants = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(A.dim * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));A.constants[A.dim - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = A.dim - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i)&#123;A.constants[i] = A.bounds[i + <span class="hljs-number">1</span>] * A.constants[i + <span class="hljs-number">1</span>];&#125;</code></pre> <p>映像函数如下图<br><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AF%BE%E8%AE%BE%E2%80%94%E2%80%94%E2%80%94%E5%9B%9B%E7%BB%B4%E6%95%B0%E7%BB%84/%E6%98%A0%E5%83%8F%E5%87%BD%E6%95%B0.png" alt="映像函数"></p><p>计算方法，求四维下标(a,b,c,d)对应的基址：</p><pre><code class="hljs CPP">ind = base + A.constants[<span class="hljs-number">0</span>] * a + A.constants[<span class="hljs-number">1</span>] * b + A.constants[<span class="hljs-number">2</span>] * c + A.constants[<span class="hljs-number">3</span>] * d;</code></pre> <p>参考链接</p><blockquote><p><a href="https://zhidao.baidu.com/question/121166265.html" title="百度知道">C语言中什么是数组映像函数常量基址</a></p></blockquote><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>我的代码分文件编程，<code>Array.h</code> 是关于数据结构的定义与声明，<code>Array.cpp</code> 是关于<code>Array.h</code> 内函数的实现，<code>main.cpp</code> 是运用这些函数进行流程控制之后的演示。编译环境是<code>VS2013</code>。</p><h3 id="Array-h"><a href="#Array-h" class="headerlink" title="Array.h"></a>Array.h</h3><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once<span class="hljs-comment">//防止头文件重复</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OVERFLO -1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 8<span class="hljs-comment">//维界最大值为8</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;conio.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Status;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>ElemType * base;<span class="hljs-comment">//元素基址</span><span class="hljs-keyword">int</span> dim;<span class="hljs-comment">//维数</span><span class="hljs-keyword">int</span> elemtotal;<span class="hljs-comment">//总数</span><span class="hljs-keyword">int</span> * bounds;<span class="hljs-comment">//数组各个维界</span><span class="hljs-keyword">int</span> * constants;<span class="hljs-comment">//映像函数常量基址</span>&#125;Array;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><span class="hljs-keyword">int</span> a;<span class="hljs-keyword">int</span> b;<span class="hljs-keyword">int</span> c;<span class="hljs-keyword">int</span> d;&#125;Sub;<span class="hljs-comment">//四维数组下标结构体</span><span class="hljs-comment">//1.建立数组</span><span class="hljs-function">Status <span class="hljs-title">InitArray</span><span class="hljs-params">(Array &amp;A, <span class="hljs-keyword">int</span> dim, <span class="hljs-keyword">int</span> *boundary)</span></span>;<span class="hljs-comment">//2.按照行优先顺序存储数据</span><span class="hljs-function">Status <span class="hljs-title">ValueArray</span><span class="hljs-params">(Array &amp;A)</span></span>;<span class="hljs-comment">//3.行优先顺序输出结果</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintArrayByRow</span><span class="hljs-params">(Array &amp;A)</span></span>;<span class="hljs-comment">//4.列优先顺序输出结果</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintArrayByCol</span><span class="hljs-params">(Array &amp;A)</span></span>;<span class="hljs-comment">//5.给定下标求取对应下标的元素</span><span class="hljs-function">Status <span class="hljs-title">GetValue</span><span class="hljs-params">(Array A, Sub sub,ElemType &amp;elem)</span></span>;<span class="hljs-comment">//6.给定下标求取对应一维数组的序号（sub2ind）</span><span class="hljs-function">Status <span class="hljs-title">sub2ind</span><span class="hljs-params">(Array A,Sub sub,<span class="hljs-keyword">int</span> &amp;ind)</span></span>;<span class="hljs-comment">//7.给定一位数组的单一索引值抓换成数组下标（ind2sub）</span><span class="hljs-function">Status <span class="hljs-title">ind2sub</span><span class="hljs-params">(Array A, <span class="hljs-keyword">int</span> ind, Sub &amp;sub)</span></span>;<span class="hljs-comment">//8.消除孤维（squeeze）</span><span class="hljs-function">Status <span class="hljs-title">squeeze</span><span class="hljs-params">(Array A, Array &amp;B)</span></span>;<span class="hljs-comment">//9.显示当前数组信息</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowDate</span><span class="hljs-params">(Array A)</span></span>;<span class="hljs-comment">//10.销毁数组</span><span class="hljs-function">Status <span class="hljs-title">DestroyArray</span><span class="hljs-params">(Array &amp;A)</span></span>;</code></pre> <h3 id="Array-cpp"><a href="#Array-cpp" class="headerlink" title="Array.cpp"></a>Array.cpp</h3><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Array.h&quot;</span></span><span class="hljs-comment">//1.建立数组</span><span class="hljs-function">Status <span class="hljs-title">InitArray</span><span class="hljs-params">(Array &amp;A, <span class="hljs-keyword">int</span> dim, <span class="hljs-keyword">int</span> *boundary)</span><span class="hljs-comment">//此处的boundary形参为数组，便于在main函数中检验数据是否正常，便于传参。</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (dim&lt;<span class="hljs-number">0</span> || dim&gt;MAX) <span class="hljs-keyword">return</span> ERROR;A.dim = dim;A.bounds = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(dim*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<span class="hljs-keyword">if</span> (!A.bounds) <span class="hljs-built_in">exit</span>(OVERFLO);A.elemtotal = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dim; ++i)&#123;A.bounds[i] = boundary[i];A.elemtotal *= A.bounds[i];&#125;A.base = (ElemType *)<span class="hljs-built_in">malloc</span>(A.elemtotal * <span class="hljs-keyword">sizeof</span>(ElemType));<span class="hljs-keyword">if</span> (!A.base) <span class="hljs-built_in">exit</span>(OVERFLO);A.constants = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(A.dim * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<span class="hljs-keyword">if</span> (!A.constants) <span class="hljs-built_in">exit</span>(OVERFLO);A.constants[A.dim - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = A.dim - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i)&#123;A.constants[i] = A.bounds[i + <span class="hljs-number">1</span>] * A.constants[i + <span class="hljs-number">1</span>];&#125;<span class="hljs-keyword">return</span> OK;&#125;<span class="hljs-comment">//2.按照行优先顺序存储数据</span><span class="hljs-function">Status <span class="hljs-title">ValueArray</span><span class="hljs-params">(Array &amp;A)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;您一共要输入 &quot;</span> &lt;&lt; A.elemtotal &lt;&lt; <span class="hljs-string">&quot; 个数据（int类型）&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.elemtotal; ++i)&#123;<span class="hljs-built_in">cin</span> &gt;&gt; A.base[i];&#125;<span class="hljs-keyword">return</span> OK;&#125;<span class="hljs-comment">//3.行优先顺序输出结果</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintArrayByRow</span><span class="hljs-params">(Array &amp;A)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;按照行优先顺序输出结果&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.elemtotal; ++i)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; A.base[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;&#125;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//4.列优先顺序输出结果</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintArrayByCol</span><span class="hljs-params">(Array &amp;A)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//本程序采用的是行优先存储方式创建的，对于所谓的列优先输出，因为列优先也就是高下标优先，所以按照高下标的遍历方式，依次将四维下标转换成一维基址(sub2ind函数)，然后输出。</span><span class="hljs-keyword">int</span> ind;Sub sub;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;按照列优先顺序输出结果&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">for</span> (sub.d = <span class="hljs-number">0</span>; sub.d &lt; A.bounds[<span class="hljs-number">3</span>]; ++sub.d)&#123;<span class="hljs-keyword">for</span> (sub.c = <span class="hljs-number">0</span>; sub.c &lt; A.bounds[<span class="hljs-number">2</span>]; ++sub.c)&#123;<span class="hljs-keyword">for</span> (sub.b = <span class="hljs-number">0</span>; sub.b &lt; A.bounds[<span class="hljs-number">1</span>]; ++sub.b)&#123;<span class="hljs-keyword">for</span> (sub.a = <span class="hljs-number">0</span>; sub.a &lt; A.bounds[<span class="hljs-number">0</span>]; ++sub.a)&#123;sub2ind(A, sub, ind);<span class="hljs-built_in">cout</span> &lt;&lt; A.base[ind] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;&#125;&#125;&#125;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//5.给定下标求取对应下标的元素</span><span class="hljs-function">Status <span class="hljs-title">GetValue</span><span class="hljs-params">(Array A, Sub sub, ElemType &amp;elem)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> ((sub.a&lt;<span class="hljs-number">0</span> || sub.a&gt;A.bounds[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>) || (sub.b&lt;<span class="hljs-number">0</span> || sub.b&gt;A.bounds[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) || (sub.c&lt;<span class="hljs-number">0</span> || sub.c&gt;A.bounds[<span class="hljs-number">2</span>] - <span class="hljs-number">1</span>) || (sub.d&lt;<span class="hljs-number">0</span> || sub.d&gt;A.bounds[<span class="hljs-number">3</span>] - <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> ERROR;<span class="hljs-keyword">int</span> ind;sub2ind(A, sub, ind);elem = A.base[ind];<span class="hljs-keyword">return</span> OK;&#125;<span class="hljs-comment">//6.给定下标求取对应一维数组的序号（sub2ind）</span><span class="hljs-function">Status <span class="hljs-title">sub2ind</span><span class="hljs-params">(Array A, Sub sub, <span class="hljs-keyword">int</span> &amp;ind)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> ((sub.a&lt;<span class="hljs-number">0</span> || sub.a&gt;A.bounds[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>) || (sub.b&lt;<span class="hljs-number">0</span> || sub.b&gt;A.bounds[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) || (sub.c&lt;<span class="hljs-number">0</span> || sub.c&gt;A.bounds[<span class="hljs-number">2</span>] - <span class="hljs-number">1</span>) || (sub.d&lt;<span class="hljs-number">0</span> || sub.d&gt;A.bounds[<span class="hljs-number">3</span>] - <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> ERROR;ind = <span class="hljs-number">0</span>;ind += A.constants[<span class="hljs-number">0</span>] * sub.a;ind += A.constants[<span class="hljs-number">1</span>] * sub.b;ind += A.constants[<span class="hljs-number">2</span>] * sub.c;ind += A.constants[<span class="hljs-number">3</span>] * sub.d;<span class="hljs-keyword">return</span> OK;&#125;<span class="hljs-comment">//7.给定一位数组的单一索引值抓换成数组下标（ind2sub）</span><span class="hljs-function">Status <span class="hljs-title">ind2sub</span><span class="hljs-params">(Array A, <span class="hljs-keyword">int</span> ind, Sub &amp;sub)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//相关解释请参看底下注意事项第7条</span><span class="hljs-keyword">if</span> (ind&lt;<span class="hljs-number">0</span> || ind&gt;A.elemtotal - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ERROR;sub.a = ind / A.constants[<span class="hljs-number">0</span>];sub.b = (ind % A.constants[<span class="hljs-number">0</span>]) / (A.constants[<span class="hljs-number">1</span>]);sub.c = ((ind % A.constants[<span class="hljs-number">0</span>]) % (A.constants[<span class="hljs-number">1</span>])) / A.constants[<span class="hljs-number">2</span>];sub.d = (((ind % A.constants[<span class="hljs-number">0</span>]) % (A.constants[<span class="hljs-number">1</span>])) % A.constants[<span class="hljs-number">2</span>]) % A.constants[<span class="hljs-number">2</span>];<span class="hljs-keyword">return</span> OK;&#125;<span class="hljs-comment">//8.消除孤维（squeeze）</span><span class="hljs-function">Status <span class="hljs-title">squeeze</span><span class="hljs-params">(Array A,Array &amp;B)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">bool</span> is = <span class="hljs-literal">false</span>;<span class="hljs-keyword">int</span> dim = A.dim;<span class="hljs-keyword">int</span> boundary[MAX];<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.dim; ++i)&#123;<span class="hljs-keyword">if</span> (A.bounds[i] == <span class="hljs-number">1</span>)&#123;is = <span class="hljs-literal">true</span>;--dim;&#125;<span class="hljs-keyword">else</span>&#123;boundary[j] = A.bounds[i];++j;&#125;&#125;<span class="hljs-keyword">if</span> (!is) <span class="hljs-keyword">return</span> ERROR;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (dim == <span class="hljs-number">0</span>) <span class="hljs-comment">//防止全是1维界的情况</span>&#123;dim = <span class="hljs-number">1</span>;boundary[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;&#125;InitArray(B, dim, boundary);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.elemtotal; ++i)&#123;B.base[i] = A.base[i];&#125;<span class="hljs-keyword">return</span> OK;&#125;&#125;<span class="hljs-comment">//9.显示当前数组信息</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowDate</span><span class="hljs-params">(Array A)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;-------------------------------------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;                当前数组信息                  &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\t维数：&quot;</span> &lt;&lt; A.dim &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\t形如A[a][b][c][d]这样的形式，当前数组对应的各维维度是&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.dim; ++i)&#123;<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>&lt;&lt; <span class="hljs-keyword">char</span>(<span class="hljs-string">&#x27;a&#x27;</span> + i) &lt;&lt; <span class="hljs-string">&quot; :&quot;</span> &lt;&lt; A.bounds[i] &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\t数据总数是&quot;</span> &lt;&lt; A.elemtotal &lt;&lt; <span class="hljs-built_in">endl</span>&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;PrintArrayByRow(A);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;----------------------END------------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//10.销毁数组</span><span class="hljs-function">Status <span class="hljs-title">DestroyArray</span><span class="hljs-params">(Array &amp;A)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (!A.base) <span class="hljs-keyword">return</span> ERROR;<span class="hljs-built_in">free</span>(A.base); A.base = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">if</span> (!A.bounds) <span class="hljs-keyword">return</span> ERROR;<span class="hljs-built_in">free</span>(A.bounds); A.bounds = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">if</span> (!A.constants) <span class="hljs-keyword">return</span> ERROR;<span class="hljs-built_in">free</span>(A.constants); A.constants = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">return</span> OK;&#125;</code></pre> <h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Array.h&quot;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;system(<span class="hljs-string">&quot;color 3E&quot;</span>);<span class="hljs-comment">//设置控制台背景颜色和字体颜色</span><span class="hljs-keyword">int</span> inso;<span class="hljs-comment">//需要输入的值，用于流程控制</span><span class="hljs-keyword">int</span> inso1;<span class="hljs-comment">//需要输入的值，用于流程控制</span><span class="hljs-keyword">char</span> ch;<span class="hljs-comment">//需要输入的值，用于流程控制</span>Array A;A.elemtotal = <span class="hljs-number">0</span>;<span class="hljs-comment">//用于判断是否创建了四维数组，便于流程控制</span>Array B;Sub sub;<span class="hljs-comment">//定义一个四维数据</span><span class="hljs-keyword">int</span> ind;<span class="hljs-comment">//定义一个一维数据</span><span class="hljs-keyword">bool</span> creat = <span class="hljs-literal">false</span>;<span class="hljs-comment">//用于判断降维数组是否成功</span>ElemType elem;<span class="hljs-comment">//定义一个数组元素类型的数据</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\t欢迎使用四维数组程序&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;+------------------------------------------+&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|\t1.创建四维数组                     |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|\t2.查看四维数组信息                 |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|\t3.输入下标查看四维数组值           |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|\t4.按照行优先顺序打印               |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|\t5.按照列优先顺序打印               |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|\t6.将下标转换为单一索引数值；       |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|\t7.将单一索引数值转换为数组的下标； |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|\t8.降维\t\t                   |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|\t9.退出\t\t                   |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;+------------------------------------------+&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入相关序号执行操作&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Input:&quot;</span>;<span class="hljs-built_in">cin</span> &gt;&gt; inso;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span> (inso == <span class="hljs-number">1</span>)&#123;system(<span class="hljs-string">&quot;cls&quot;</span>);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;将创建形如 A[a][b][c][d] 形式的四维数组，请依次输入个维度对应的维界值\n各维对应的值应当大于零！请严格输入&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">int</span> boundary[MAX];<span class="hljs-comment">//存放各个维度对应的维界</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; <span class="hljs-keyword">char</span>(<span class="hljs-string">&#x27;a&#x27;</span> + i) &lt;&lt; <span class="hljs-string">&quot; :&quot;</span>;too: <span class="hljs-built_in">cin</span> &gt;&gt; inso1;<span class="hljs-keyword">if</span> (inso1 &lt;= <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;输入错误，不符合要求，请重新输入:&quot;</span>;<span class="hljs-keyword">goto</span> too;&#125;boundary[i] = inso1;&#125;InitArray(A, <span class="hljs-number">4</span>, boundary);<span class="hljs-comment">//数组作为参数传入</span>ValueArray(A);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;-----四维数组创建成功!-----&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inso == <span class="hljs-number">2</span>)&#123;system(<span class="hljs-string">&quot;cls&quot;</span>);<span class="hljs-keyword">if</span> (A.elemtotal == <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; 四维数组还未创建，请您前去创建四维数组！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span> ShowDate(A);<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(inso == <span class="hljs-number">3</span>)&#123;system(<span class="hljs-string">&quot;cls&quot;</span>);<span class="hljs-keyword">if</span> (A.elemtotal == <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; 四维数组还未创建，请您前去创建四维数组！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; 请输入你要查看的下标值，共四个数据&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; 形如 A[a][b][c][d] ，各个下标对应的取值范围&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; a: 0 - &quot;</span> &lt;&lt; A.bounds[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; b: 0 - &quot;</span> &lt;&lt; A.bounds[<span class="hljs-number">1</span>]<span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; c: 0 - &quot;</span> &lt;&lt; A.bounds[<span class="hljs-number">2</span>]<span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; d: 0 - &quot;</span> &lt;&lt; A.bounds[<span class="hljs-number">3</span>]<span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cin</span> &gt;&gt; sub.a &gt;&gt; sub.b &gt;&gt; sub.c &gt;&gt; sub.d;<span class="hljs-keyword">if</span> (GetValue(A, sub, elem))&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; 下标 A[&quot;</span> &lt;&lt; sub.a &lt;&lt; <span class="hljs-string">&quot;][&quot;</span> &lt;&lt; sub.b &lt;&lt; <span class="hljs-string">&quot;][&quot;</span> &lt;&lt; sub.c &lt;&lt; <span class="hljs-string">&quot;][&quot;</span> &lt;&lt; sub.d &lt;&lt; <span class="hljs-string">&quot;]对应的值为: &quot;</span> &lt;&lt; elem &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;是否继续查看？（N键退出查看，其余键继续）:&quot;</span>;<span class="hljs-built_in">cin</span> &gt;&gt; ch;<span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;n&#x27;</span> || ch == <span class="hljs-string">&#x27;N&#x27;</span>)<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; 您输入的数据有误，请重新输入&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inso == <span class="hljs-number">4</span>)&#123;system(<span class="hljs-string">&quot;cls&quot;</span>);<span class="hljs-keyword">if</span> (A.elemtotal == <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; 四维数组还未创建，请您前去创建四维数组！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span>&#123;PrintArrayByRow(A);<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inso == <span class="hljs-number">5</span>)&#123;system(<span class="hljs-string">&quot;cls&quot;</span>);<span class="hljs-keyword">if</span> (A.elemtotal == <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; 四维数组还未创建，请您前去创建四维数组！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span>&#123;PrintArrayByCol(A);<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inso == <span class="hljs-number">6</span>)&#123;system(<span class="hljs-string">&quot;cls&quot;</span>);<span class="hljs-keyword">if</span> (A.elemtotal == <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; 四维数组还未创建，请您前去创建四维数组！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; 请输入你要转换的下标值，共四个数据&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; 形如 A[a][b][c][d] ，各个下标对应的取值范围&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; a: 0 - &quot;</span> &lt;&lt; A.bounds[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; b: 0 - &quot;</span> &lt;&lt; A.bounds[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; c: 0 - &quot;</span> &lt;&lt; A.bounds[<span class="hljs-number">2</span>] - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; d: 0 - &quot;</span> &lt;&lt; A.bounds[<span class="hljs-number">3</span>] - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cin</span> &gt;&gt; sub.a &gt;&gt; sub.b &gt;&gt; sub.c &gt;&gt; sub.d;<span class="hljs-keyword">if</span> (sub2ind(A, sub, ind) == OK)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; 下标 A[&quot;</span> &lt;&lt; sub.a &lt;&lt; <span class="hljs-string">&quot;][&quot;</span> &lt;&lt; sub.b &lt;&lt; <span class="hljs-string">&quot;][&quot;</span> &lt;&lt; sub.c &lt;&lt; <span class="hljs-string">&quot;][&quot;</span> &lt;&lt; sub.d &lt;&lt; <span class="hljs-string">&quot;]对应的索引值为: &quot;</span> &lt;&lt; ind &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;是否继续转换？（N键退出转换，其余键继续）:&quot;</span>;<span class="hljs-built_in">cin</span> &gt;&gt; ch;<span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;n&#x27;</span> || ch == <span class="hljs-string">&#x27;N&#x27;</span>)<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; 您输入的下标值不符合要求，请重新输入&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inso == <span class="hljs-number">7</span>)&#123;system(<span class="hljs-string">&quot;cls&quot;</span>);<span class="hljs-keyword">if</span> (A.elemtotal == <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; 四维数组还未创建，请您前去创建四维数组！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; 请输入你要转换的索引值，范围： 0 - &quot;</span> &lt;&lt;A.elemtotal<span class="hljs-number">-1</span>&lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cin</span> &gt;&gt; ind;<span class="hljs-keyword">if</span> (ind2sub(A, ind, sub) == OK)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; 索引值: &quot;</span> &lt;&lt; ind &lt;&lt; <span class="hljs-string">&quot; 对应的下标未 A[&quot;</span> &lt;&lt; sub.a &lt;&lt; <span class="hljs-string">&quot;][&quot;</span> &lt;&lt; sub.b &lt;&lt; <span class="hljs-string">&quot;][&quot;</span> &lt;&lt; sub.c &lt;&lt; <span class="hljs-string">&quot;][&quot;</span> &lt;&lt; sub.d &lt;&lt; <span class="hljs-string">&quot;] &quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;是否继续转换？（N键退出转换，其余键继续）:&quot;</span>;<span class="hljs-built_in">cin</span> &gt;&gt; ch;<span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;n&#x27;</span> || ch == <span class="hljs-string">&#x27;N&#x27;</span>)<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;您输入的索引值不符合范围，请重新输入&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inso == <span class="hljs-number">8</span>)&#123;system(<span class="hljs-string">&quot;cls&quot;</span>);<span class="hljs-keyword">if</span> (A.elemtotal == <span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot; 四维数组还未创建，请您前去创建四维数组！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;执行降维操作&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">if</span> (squeeze(A, B) == ERROR) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;本数组无维数为1的维度，无法降维&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">else</span>&#123;creat = <span class="hljs-literal">true</span>;ShowDate(B);&#125;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inso == <span class="hljs-number">9</span>)&#123;<span class="hljs-keyword">if</span> (A.elemtotal != <span class="hljs-number">0</span>)&#123;DestroyArray(A);&#125;<span class="hljs-keyword">if</span> (creat == <span class="hljs-literal">true</span>)&#123;DestroyArray(B);&#125;system(<span class="hljs-string">&quot;cls&quot;</span>);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;  谢谢使用，再见！\n按任意键继续....&quot;</span>;_getch();<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;您输入的字符有误，请重新输入&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;</code></pre> <h3 id="另：一些注意事项"><a href="#另：一些注意事项" class="headerlink" title="另：一些注意事项"></a>另：一些注意事项</h3><ol><li>数组的维界是严格大于0的，所以维界值要格外注意。</li><li>本程序采用的是行优先存储方式创建的，对于所谓的列优先输出，因为列优先也就是高下标优先，所以按照高下标的遍历方式，依次将四维下标转换成一维基址(<code>sub2ind函数</code>)，然后输出。</li><li>销毁空间时，如果那段空间本来就没有被 <code>malloc</code> 分配内存，就会报错，所以 <code>main.cpp</code> 中的流程9有两个判断语句。</li><li>Array.h里定义的大部分函数返回值都是 <code>Status</code> ，这是为了便于 <code>main.cpp</code> 里的流程控制，因为判断数据是否正确写在 <code>main.cpp</code> 里回过于冗杂，也为了不让计算产生莫名奇妙的值，所以这些函数刚开始都是判断数据是否合理，不合理就不会继续进行计算。</li><li>本程序的大部分函数都不可扩展，参数直接写死了，只能对四维坐标进行操作，尤其是数组被降维之后，对应 低于四维数组 的操作函数寥寥无几，设计函数是应当注意！</li><li>消除孤维的时候要注意，如果都是1维，就要最后保留一个维度，为1维。</li><li>关于 <code>ind2sub函数</code>（单一索引值转换成四维数组下标）的计算问题。刚开始稀里糊涂的写了上去，发现没啥问题，也没细想，写博客的时候又觉得有点不对劲，现在终于弄明白了。参看<code>函数sub2ind</code>的计算，简化式<code>ind = A * (constants[0]) + B * (constants[1]) + C*(constants[2]) + D *(constants[3]);</code>ABCD为四维数组下标。由此进行逆推，<code>A = ind / constants[0]; </code>，那是因为其余部分的值<code>B * (constants[1]) + C*(constants[2]) + D *(constants[3])</code>除以 <code>constants[0]</code> 都要小于1。</li></ol><h2 id="功能展示"><a href="#功能展示" class="headerlink" title="功能展示"></a>功能展示</h2><p>比较辣鸡，展示部分功能。</p><h3 id="起始界面"><a href="#起始界面" class="headerlink" title="起始界面"></a>起始界面</h3><p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AF%BE%E8%AE%BE%E2%80%94%E2%80%94%E2%80%94%E5%9B%9B%E7%BB%B4%E6%95%B0%E7%BB%84/%E8%B5%B7%E5%A7%8B%E7%95%8C%E9%9D%A2.png" alt="起始界面"></p><h3 id="创建四维数组"><a href="#创建四维数组" class="headerlink" title="创建四维数组"></a>创建四维数组</h3><p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AF%BE%E8%AE%BE%E2%80%94%E2%80%94%E2%80%94%E5%9B%9B%E7%BB%B4%E6%95%B0%E7%BB%84/%E5%88%9B%E5%BB%BA%E5%9B%9B%E7%BB%B4%E6%95%B0%E7%BB%84.png" alt="创建四维数组"></p><h3 id="查看当前数组信息"><a href="#查看当前数组信息" class="headerlink" title="查看当前数组信息"></a>查看当前数组信息</h3><p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AF%BE%E8%AE%BE%E2%80%94%E2%80%94%E2%80%94%E5%9B%9B%E7%BB%B4%E6%95%B0%E7%BB%84/%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E6%95%B0%E7%BB%84%E4%BF%A1%E6%81%AF.png" alt="查看当前数组信息"></p><h3 id="下标转换为索引值"><a href="#下标转换为索引值" class="headerlink" title="下标转换为索引值"></a>下标转换为索引值</h3><p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AF%BE%E8%AE%BE%E2%80%94%E2%80%94%E2%80%94%E5%9B%9B%E7%BB%B4%E6%95%B0%E7%BB%84/%E4%B8%8B%E6%A0%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%A2%E5%BC%95%E5%80%BC.png" alt="下标转换为索引值"></p><h3 id="降维操作"><a href="#降维操作" class="headerlink" title="降维操作"></a>降维操作</h3><p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AF%BE%E8%AE%BE%E2%80%94%E2%80%94%E2%80%94%E5%9B%9B%E7%BB%B4%E6%95%B0%E7%BB%84/%E9%99%8D%E7%BB%B4%E6%93%8D%E4%BD%9C.png" alt="降维操作"></p><h2 id="完结感言"><a href="#完结感言" class="headerlink" title="完结感言"></a>完结感言</h2><p>本次课设的难度一般，想清楚该怎么做后，几个小时就可以做完。但与之相比，课设的报告书，还有这篇博客都是非常的费时间。自己也挺菜的，函数写成了那个样子，没法复用，也得感谢严蔚敏老师的《数据结构》提供了非常好的数据结构与方法，但是为了一些操作的方便就没有使用原书中的用到的<code>stdarg.h</code> 和变参方法。太菜了，继续努力吧！</p><h2 id="END-2019-1-11-22-24-36"><a href="#END-2019-1-11-22-24-36" class="headerlink" title="END! 2019/1/11 22:24:36"></a>END! 2019/1/11 22:24:36</h2><hr>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++一些相关知识（慢慢补充）</title>
    <link href="/C++%E5%8E%86%E5%8F%B2/"/>
    <url>/C++%E5%8E%86%E5%8F%B2/</url>
    
    <content type="html"><![CDATA[<p>接触C++有一段时间了，收集整理了一下相关信息，如果有什么相关错误请指正。</p><a id="more"></a><h2 id="ANSI、ISO和GUN计划"><a href="#ANSI、ISO和GUN计划" class="headerlink" title="ANSI、ISO和GUN计划"></a>ANSI、ISO和GUN计划</h2><ul><li><a href="https://baike.baidu.com/item/ANSI%E6%A0%87%E5%87%86/3127116?fr=aladdin">ANSI</a> 美国国家标准学会，系非赢利性质的民间标准化团体。但它实际上已成为国家标准化中心；各界标准化活动都围绕着它进行。</li><li><a href="https://baike.baidu.com/item/%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86%E5%8C%96%E7%BB%84%E7%BB%87/779832?fromtitle=iso&fromid=10400" title="ISO-百度百科">ISO</a> 国际标准化组织，是一个全球性的非政府组织。是世界上最大的非政府性标准化专门机构，是国际标准化领域中一个十分重要的组织。</li><li><a href="https://baike.baidu.com/item/GNU%E8%AE%A1%E5%88%92/981157?fr=aladdin" title="GUN计划-百度百科">GUN计划</a> 又译为“革奴计划”，是由理查德·斯托曼在1983年9月27日公开发起的，它的目标是创建一套完全自由的操作系统。<code>GUN——Gun&#39;s Not Unix</code>，“重现当年软件界合作互助的团结精神”。</li></ul><p>相关链接：</p><blockquote><p><a href="http://blog.chinaunix.net/uid-29084017-id-4887641.html">漫谈GUN与Linux历史</a></p><p><a href="https://www.gnu.org/gnu/linux-and-gnu.html">Linux和GNU系统</a></p></blockquote><h2 id="GUN-C、ANSI-C和标准C"><a href="#GUN-C、ANSI-C和标准C" class="headerlink" title="GUN C、ANSI C和标准C"></a>GUN C、ANSI C和标准C</h2><p>GUN组织在编写Linux的时候自己制作了一个标准成为<code>GNU C标准</code>。ANSI（美国国家标准协会）对C做的标准 <code>ANSI C标准</code> 后来被ISO（国际标准协会）接收成为 <code>标准C</code>。 所以 <code>ANSI C</code> 和<code>标准C</code>是一个概念。总体来说现在Linux也支持<code>标准C</code>，以后<strong>标准C可以跨平台</strong>，而<code>GUN c</code> 一般只在Linux c下应用。</p><blockquote><p>以上内容来自 <a href="https://blog.csdn.net/rheostat/article/details/7614524">https://blog.csdn.net/rheostat/article/details/7614524</a></p></blockquote><h2 id="gcc、g-以及MinGW"><a href="#gcc、g-以及MinGW" class="headerlink" title="gcc、g++以及MinGW"></a>gcc、g++以及MinGW</h2><p><code>gcc</code> 和 <code>g++</code>分别是 GNU 的<code>c</code> 和 <code>c++</code>编译器。</p><p><code>MinGW</code>，是<code>Minimalist GNUfor Windows</code>的缩写。它是一个可自由使用和自由发布的Windows特定头文件和使用GNU工具集导入库的集合，允许你在GNU/Linux和Windows平台生成本地的Windows程序而不需要第三方C运行时（C Runtime）库。貌似 <a href="http://www.codeblocks.org/">CodeBlocks</a> 就使用的这个。——来自<a href="https://baike.baidu.com/item/mingw/1777782?fr=aladdin">百度百科</a></p><p>MinGW是是将GCC编译器和GNU Binutils移植到Win32平台下的产物，包括一系列头文件（Win32API）、库和可执行文件。——来自<a href="https://zh.wikipedia.org/wiki/MinGW">维基百科</a></p><p>相关链接：</p><blockquote><p><a href="https://www.cnblogs.com/qcssmd/p/5302052.html">MinGW的安装和使用</a></p><p><a href="http://www.cnblogs.com/wb118115/p/5969775.html">g++和gcc的区别</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>char* 、char[]、与string 的区别，以及求取字符串长度</title>
    <link href="/charAndStrign/"/>
    <url>/charAndStrign/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="普通char-数组的使用"><a href="#普通char-数组的使用" class="headerlink" title="普通char[]数组的使用"></a>普通char[]数组的使用</h2><p>看一个小案例</p><pre><code class="hljs c++"><span class="hljs-comment">//运行环境 VS2017</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> as[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;123456789&quot;</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;数组内容：&quot;</span>&lt;&lt;as &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;输入数组内容：&quot;</span>;<span class="hljs-built_in">cin</span> &gt;&gt; as;<span class="hljs-comment">//这样赋值是可以的</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;新的数组内容：&quot;</span> &lt;&lt; as;&#125;</code></pre><p>执行结果：</p><pre><code class="hljs dns">数组内容：<span class="hljs-number">123456789</span>输入数组内容：fox新的数组内容：fox</code></pre><ol><li>char数组的赋值语句中，“123456789”这一串长度为</li><li><code>cin&gt;&gt;as</code>这样的输入数组的方式是可以的，但是一旦长度超过了9(\0是在输入中默认填充的)，就会引发异常，至少Windows平台的VS2017是如此，这样的输入方式非常的不安全，慎用。</li></ol><blockquote><p><a href="https://blog.csdn.net/ksws0292756/article/details/79432329">https://blog.csdn.net/ksws0292756/article/details/79432329</a></p></blockquote><h2 id="一个常见的错误——指针与元素"><a href="#一个常见的错误——指针与元素" class="headerlink" title="一个常见的错误——指针与元素"></a>一个常见的错误——指针与元素</h2><p>问题出在我上数据结构对串进行操作时需要对一段字符串的长度进行计算，当时卡住了壳，之后再次回顾时发现还是自己粗心大意，基础太差，所以再这里做一个总结归纳。<br>这是我当初的代码</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *p)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> length=<span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span>(;p!=<span class="hljs-string">&#x27;\0&#x27;</span>;p++)<span class="hljs-comment">//p是一个指针</span>     length++;   <span class="hljs-keyword">return</span> length;  &#125;</code></pre><p>我实际上调用的时<code>getLength(&quot;asdfg&quot;);</code>然后程序运行了好长一段时间，结果是一个巨大的负值。事实上是for循环的判断条件出错了。p是指针，直接用指针与字符<code>‘\0’</code>作比较会出现问题，所以会有这样的结果。<br>所以实际上可以说是少写了一个符号<code>*</code>导致的。所以正确的代码是</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *p)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> length=<span class="hljs-number">0</span>;   <span class="hljs-keyword">for</span>(;*p!=<span class="hljs-string">&#x27;\0&#x27;</span>;p++)<span class="hljs-comment">//这里的*是解引用符，表示取出地址对应的元素</span>     length++;   <span class="hljs-keyword">return</span> length;  &#125;</code></pre><h2 id="char-、char-的区别"><a href="#char-、char-的区别" class="headerlink" title="char* 、char[]的区别"></a>char* 、char[]的区别</h2><ul><li>char* 是字符型指针类型，用来声明一个变量是字符指针类型的。</li><li>char[]则是一个字符数组，使用一段连续的内存空间存储多个字符。</li></ul><p>他们两个在普通地方差别挺明显的，而对于函数形参来说几乎没有区别。</p><h3 id="普通位置时"><a href="#普通位置时" class="headerlink" title="普通位置时"></a>普通位置时</h3><pre><code class="hljs c++"><span class="hljs-comment">/*-----编译环境VC2010-----*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> a[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<span class="hljs-keyword">char</span> * b = <span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="hljs-built_in">endl</span>;a[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;s&#x27;</span>;b[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;s&#x27;</span>;system(<span class="hljs-string">&quot;pause&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>代码会在<code>b[0] = &#39;s&#39;;</code>处停止运行，发生错误，原因在于<code>char []</code> 与<code>char *</code>内存分区是不同的。字符数组<code>char[]</code>存放于_栈区_，_是可以进行读写操作的_。而<code>char *</code>所指向的字符串<code>abc</code>是存放于_文字常量区_的,_文字常量区_是不能更改的，_是只读区域_。所以尝试对其进行修改时就会报错。</p><h3 id="作为函数参数时"><a href="#作为函数参数时" class="headerlink" title="作为函数参数时"></a>作为函数参数时</h3><blockquote><p>当数组作为函数参数时，实际上传递的是数组首元素的地址。<br>即C++只是把形参数组名作为一个指针变量来处理，用来接收从实参传过来的地址。<br>——（谭浩强-C++程序设计第三版）</p></blockquote><pre><code class="hljs c++"><span class="hljs-comment">//所以对于以下两个函数，完全的等价</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">char</span> a[])</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">char</span>* a)</span></span></code></pre><p>看一个示例：实现<code>atoi()</code>函数 ——字符串与Int类型的转换。</p><pre><code class="hljs c++"><span class="hljs-comment">/*-----编译环境VS2019-----*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">my_atoi</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* tmp = str;    <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<span class="hljs-comment">//0表示正数，1表示负数</span>    <span class="hljs-keyword">if</span> (*tmp == <span class="hljs-string">&#x27;-&#x27;</span>)    &#123;        flag = <span class="hljs-number">1</span>;        tmp = tmp + <span class="hljs-number">1</span>;<span class="hljs-comment">//负数从第二个字符开始转化</span>    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*tmp == <span class="hljs-string">&#x27;+&#x27;</span>)    &#123;        tmp = tmp + <span class="hljs-number">1</span>;<span class="hljs-comment">//带符号的正数也从第二个字符转化</span>    &#125;        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (*tmp != <span class="hljs-string">&#x27;\0&#x27;</span>)    &#123;        num = num * <span class="hljs-number">10</span> + (*tmp - <span class="hljs-string">&#x27;0&#x27;</span>);        tmp++;    &#125;    <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> num;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> (<span class="hljs-number">-1</span>) * num;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; my_atoi(<span class="hljs-string">&quot;+123&quot;</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; my_atoi(<span class="hljs-string">&quot;-456&quot;</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; my_atoi(<span class="hljs-string">&quot;789&quot;</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="char-c-“agdbh”-存储的是字符串的首地址吗？"><a href="#char-c-“agdbh”-存储的是字符串的首地址吗？" class="headerlink" title="char *c = “agdbh”; 存储的是字符串的首地址吗？"></a>char *c = “agdbh”; 存储的是字符串的首地址吗？</h2><h2 id="C风格字符数组-p109"><a href="#C风格字符数组-p109" class="headerlink" title="C风格字符数组 p109"></a>C风格字符数组 p109</h2>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/hello-world/"/>
    <url>/hello-world/</url>
    
    <content type="html"><![CDATA[<p>欢迎来访 <a href="https://colourso.github.io/">Colourso’s Blog</a>! 这是原<a href="https://hexo.io/">Hexo</a>自动产生的第一篇博文，在此我来做一些修改。</p><a id="more"></a><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;iostream&gt;</span>using namespace std;int main()&#123;cout&lt;&lt;<span class="hljs-string">&quot;Hello World!&quot;</span>;<span class="hljs-built_in">return</span> 0;&#125;</code></pre><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><pre><code class="hljs bash">public class <span class="hljs-function"><span class="hljs-title">Main</span></span>()&#123;public static void main(String[] args)&#123;System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);&#125;&#125;</code></pre><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><pre><code class="hljs bash">alert(<span class="hljs-string">&quot;Hello World!&quot;</span>);</code></pre><p>未完待续。。。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
