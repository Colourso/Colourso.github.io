<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.jpg">
  <link rel="icon" type="image/png" href="/img/colourso-logo.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Colourso">
  <meta name="keywords" content="">
  <title>C++面向对象（一) —— C++类的基础知识 - Colourso</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">




<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Colourso</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/collection/">
                <i class="iconfont icon-note"></i>
                collection
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('https://s2.ax1x.com/2020/02/27/3wrCM4.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-04-03 16:09">
      星期五, 四月 3日 2020, 4:09 下午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      87
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-post-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-post-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p><strong>概览</strong>：C++类的基础知识，包括构造函数、初始值列表、拷贝构造函数、重载赋值运算符、深拷贝与浅拷贝、static、const、new以及友元。</p>
<a id="more"></a>

<hr>
<blockquote>
<p>代码全部运行于VS2019</p>
<p>为简化考虑，部分源码省略了<code>#include&lt;iostream&gt;</code>以及<code>using namespace std</code>。</p>
<p>博客后续会持续更新补充。</p>
</blockquote>
<h2 id="C-类的demo"><a href="#C-类的demo" class="headerlink" title="C++类的demo"></a>C++类的demo</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Sex</span>&#123;</span>MALE=<span class="hljs-number">0</span>,FEMALE&#125;;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span></span>
<span class="hljs-class">&#123;</span>
<span class="hljs-keyword">public</span>:
    Cat() :name(<span class="hljs-string">&quot;unname&quot;</span>), age(<span class="hljs-number">0</span>),sex(Sex::MALE)&#123;&#125;
    
    Cat(<span class="hljs-built_in">string</span> name, <span class="hljs-keyword">int</span> age, Sex sex) :
        name(name), age(age), sex(sex) &#123;&#125;
    <span class="hljs-comment">//拷贝构造</span>
    Cat(<span class="hljs-keyword">const</span> Cat&amp; other);
    <span class="hljs-comment">//拷贝赋值运算符重载</span>
    Cat&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Cat&amp; other);

    ~Cat() &#123;&#125;

    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>;
    <span class="hljs-function">Sex <span class="hljs-title">getSex</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">getPetOwner</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrtOwner</span><span class="hljs-params">(<span class="hljs-built_in">string</span> owner)</span></span>;

    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">string</span> name;
    <span class="hljs-keyword">int</span> age;
    Sex sex;
    <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> petOwner;
&#125;;

<span class="hljs-built_in">string</span> Cat::petOwner = <span class="hljs-string">&quot;Colourso&quot;</span>;

Cat::Cat(<span class="hljs-keyword">const</span> Cat&amp; other)
&#123;
    <span class="hljs-keyword">this</span>-&gt;name = other.name;
    <span class="hljs-keyword">this</span>-&gt;age = other.age;
    <span class="hljs-keyword">this</span>-&gt;sex = other.sex;
&#125;

Cat&amp; Cat::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Cat&amp; other)
&#123;
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;other)<span class="hljs-comment">//自赋值</span>
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    
    <span class="hljs-keyword">this</span>-&gt;name = other.name;
    <span class="hljs-keyword">this</span>-&gt;age = other.age;
    <span class="hljs-keyword">this</span>-&gt;sex = other.sex;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
&#125;

<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">Cat::getName</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;name;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Cat::setName</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">this</span>-&gt;name = str;
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Cat::getAge</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;age;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Cat::setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">this</span>-&gt;age = num;
&#125;

<span class="hljs-function">Sex <span class="hljs-title">Cat::getSex</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;sex;
&#125;

<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">Cat::getPetOwner</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> petOwner;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Cat::setPrtOwner</span><span class="hljs-params">(<span class="hljs-built_in">string</span> owner)</span></span>
<span class="hljs-function"></span>&#123;
    petOwner = owner;
&#125;

<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">Cat::toString</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">stringstream</span> ss;
    ss &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span>;
    ss &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name;
    ss &lt;&lt; <span class="hljs-string">&quot;,age: &quot;</span>;
    ss &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age;
    ss &lt;&lt; <span class="hljs-string">&quot;,sex: &quot;</span>;
    ss &lt;&lt; (<span class="hljs-keyword">this</span>-&gt;sex ? <span class="hljs-string">&quot;male&quot;</span> : <span class="hljs-string">&quot;female&quot;</span>);
    ss &lt;&lt; <span class="hljs-string">&quot;. Owner: &quot;</span>;
    ss &lt;&lt; petOwner;
    <span class="hljs-keyword">return</span> ss.str();
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    Cat* a = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;Kelly&quot;</span>, <span class="hljs-number">4</span>, Sex::FEMALE);
    <span class="hljs-built_in">cout</span> &lt;&lt; a-&gt;toString()&lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-function">Cat <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;Bob&quot;</span>,<span class="hljs-number">3</span>,Sex::MALE)</span></span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; b.getName()&lt;&lt;<span class="hljs-string">&quot; love his owner: &quot;</span>&lt;&lt;Cat::getPetOwner()&lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">if</span> (b.getAge() &lt; a-&gt;getAge())
        b.setAge(a-&gt;getAge() + <span class="hljs-number">2</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; b.toString() &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">delete</span> a;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<hr>
<h2 id="class与struct"><a href="#class与struct" class="headerlink" title="class与struct"></a>class与struct</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span>
<span class="hljs-class">&#123;</span>
<span class="hljs-keyword">public</span>:
    Dog(<span class="hljs-built_in">string</span> name) 
    &#123;
        <span class="hljs-keyword">this</span>-&gt;name = name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">&quot;Dog &quot;</span>&lt;&lt; <span class="hljs-keyword">this</span>-&gt;name &lt;&lt;<span class="hljs-string">&quot; walk.&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    &#125;
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">string</span> name;
&#125;;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Cat</span></span>
<span class="hljs-class">&#123;</span>
    <span class="hljs-built_in">string</span> name;
    Cat(<span class="hljs-built_in">string</span> name)
    &#123;
        <span class="hljs-keyword">this</span>-&gt;name = name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Cat &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name &lt;&lt; <span class="hljs-string">&quot; walk.&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    &#125;
&#125;;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-function">Dog <span class="hljs-title">wang</span><span class="hljs-params">(<span class="hljs-string">&quot;meow&quot;</span>)</span></span>;
    wang.walk();<span class="hljs-comment">//Dog meow walk.</span>

    <span class="hljs-function">Cat <span class="hljs-title">hua</span><span class="hljs-params">(<span class="hljs-string">&quot;wang&quot;</span>)</span></span>;
    hua.walk();<span class="hljs-comment">//Cat wang walk.</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<p>如上所示，在C++中，我们可以使用<code>class</code>关键字或者<code>struct</code>关键字进行类的定义。</p>
<p>两者唯一的区别在于<code>struct</code>与<code>class</code>的默认访问权限不同。</p>
<ul>
<li><strong>struct</strong>默认访问权限为public。</li>
<li><strong>class</strong>默认访问权限为private。</li>
</ul>
<h2 id="在类的外部实现类的成员函数——类的分文件编写"><a href="#在类的外部实现类的成员函数——类的分文件编写" class="headerlink" title="在类的外部实现类的成员函数——类的分文件编写"></a>在类的外部实现类的成员函数——类的分文件编写</h2><p><strong>Student.h</strong></p>
<pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> STUDENT_H__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STUDENT_H__</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>
<span class="hljs-class">&#123;</span>
<span class="hljs-keyword">public</span>:
	Student();
	Student(<span class="hljs-built_in">string</span> name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">bool</span> sex);

	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
	<span class="hljs-built_in">string</span> name;
	<span class="hljs-keyword">int</span> age;
	<span class="hljs-keyword">bool</span> sex;
&#125;;

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre>
<p><strong>Student.cpp</strong></p>
<pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Student.h&quot;</span></span>

Student::Student()
&#123;

&#125;

Student::Student(<span class="hljs-built_in">string</span> name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">bool</span> sex)
&#123;
	<span class="hljs-keyword">this</span>-&gt;name = name;
	<span class="hljs-keyword">this</span>-&gt;age = age;
	<span class="hljs-keyword">this</span>-&gt;sex = sex;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Student::show</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name &lt;&lt; <span class="hljs-string">&quot;: age:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age &lt;&lt; <span class="hljs-string">&quot;, sex:&quot;</span> &lt;&lt; (<span class="hljs-keyword">this</span>-&gt;sex ? <span class="hljs-string">&quot;male&quot;</span> : <span class="hljs-string">&quot;female&quot;</span>);
&#125;</code></pre>
<h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>
<span class="hljs-class">&#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">string</span> name;

<span class="hljs-keyword">protected</span>:
    <span class="hljs-keyword">bool</span> sex;

<span class="hljs-keyword">public</span>:
    Student()&#123;&#125;
    Student(<span class="hljs-built_in">string</span> name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">bool</span> sex)
    &#123;
        <span class="hljs-keyword">this</span>-&gt;name = name;
        <span class="hljs-keyword">this</span>-&gt;age = age;
        <span class="hljs-keyword">this</span>-&gt;sex = sex;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowMessage</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name &lt;&lt; <span class="hljs-string">&quot;: age:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age &lt;&lt; <span class="hljs-string">&quot;,sex:&quot;</span> &lt;&lt; (<span class="hljs-keyword">this</span>-&gt;sex ? <span class="hljs-string">&quot;男&quot;</span>:<span class="hljs-string">&quot;女&quot;</span> ) &lt;&lt; <span class="hljs-built_in">endl</span>;
    &#125;

<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> age;
&#125;;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;

    <span class="hljs-function">Student <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-literal">true</span>)</span></span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; s.name &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//小明</span>

    <span class="hljs-comment">//cout &lt;&lt; s.age &lt;&lt; endl; //错误：不可访问</span>

    s.ShowMessage();<span class="hljs-comment">//小明: age:12,sex:男</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<p>（如上所示的糟糕编码，只是为了展示类内的访问权限的界限是从一个界限开始到下一个界限截至的，例如public到private之间的内容权限都是public，同时一个<strong>访问说明符</strong>可以出现多次。）</p>
<ul>
<li><strong>public</strong>：表示公有，类内类外整个程序内都可以被访问。</li>
<li><strong>private</strong>：表示私有，只有类的成员函数才可以访问，C++ class的默认访问权限是private。</li>
<li><strong>protected</strong>：表示保护，平时与private无区别，仅在继承时有区别。</li>
</ul>
<h2 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>
<span class="hljs-class">&#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 默认构造函数</span>
    Student() &#123;&#125;

    <span class="hljs-comment">//重载带参构造函数</span>
    Student(<span class="hljs-built_in">string</span> name)
    &#123;
        <span class="hljs-keyword">this</span>-&gt;name = name;
    &#125;

    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">dis</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;name;
    &#125;
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">string</span> name;
&#125;;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperStudent</span></span>
<span class="hljs-class">&#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//默认构造函数</span>
    SuperStudent() &#123;&#125;

    <span class="hljs-comment">//带参构造函数</span>
    SuperStudent(<span class="hljs-keyword">int</span> age)
    &#123;
        <span class="hljs-keyword">this</span>-&gt;age = age;
    &#125;

    <span class="hljs-comment">//构造函数初始值列表</span>
    SuperStudent(Student stu,<span class="hljs-keyword">int</span> age) :stu(stu),age(age) &#123;&#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;stu.dis() &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age &lt;&lt; <span class="hljs-built_in">endl</span>;
    &#125;

<span class="hljs-keyword">private</span>:
    Student stu;
    <span class="hljs-keyword">int</span> age;
&#125;;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-function">Student <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;小明&quot;</span>)</span></span>;
    <span class="hljs-function">SuperStudent <span class="hljs-title">s1</span><span class="hljs-params">(s, <span class="hljs-number">12</span>)</span></span>;
    s1.show();<span class="hljs-comment">//小明12</span>

    <span class="hljs-function">SuperStudent <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-number">12</span>)</span></span>;
    s2.show();<span class="hljs-comment">//12</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<p>构造函数是用于<strong>初始化类对象的非static数据成员</strong>，无论何时，只要类的对象被创建，那么就会执行构造函数。</p>
<ul>
<li>在形式上，构造函数无返回类型，函数名与类名相同，一般声明为public，且构造函数有（可能为空）参数列表与（可能为空）函数体。</li>
<li>一个类可包含多个构造函数，和其他重载函数类似，不同构造函数必须在参数数量或参数类型上有所不同。</li>
<li>一个类有自己的<strong>默认构造函数</strong>，默认构造函数无需任何实参。如果存在类内初始值，则默认构造参数使用它来初始化成员，否则将默认初始化成员（赋予对应类型的默认值，eg，string类型的默认值为空串）。</li>
<li>同时如果我们没有显示定义构造函数，编译器就会隐式的定义一个。（<strong>只有当没有声明任何构造函数时，编译器才会自动生成默认构造函数</strong>）</li>
<li><strong>一个类最好定义它的默认构造函数</strong>。（如果我们显示定义了一些其他构造函数，那么建议要加上默认构造函数）P236.</li>
<li>构造函数不能够被声明成const。7.1.2</li>
</ul>
<h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>
<span class="hljs-class">&#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//默认构造函数</span>
    Student() &#123;&#125;

    <span class="hljs-comment">//构造函数初始值列表</span>
    Student(<span class="hljs-keyword">char</span> str[], <span class="hljs-keyword">bool</span> sex, <span class="hljs-keyword">int</span> age) :m_sex(sex),m_age(age)
    &#123;
        <span class="hljs-comment">// m_sex = sex; //错误：表达式必须是可修改的左值</span>
        strcpy_s(m_name, str);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="hljs-string">&quot;: sex: &quot;</span> &lt;&lt; (m_sex ? <span class="hljs-string">&quot;male&quot;</span> : <span class="hljs-string">&quot;female&quot;</span>) &lt;&lt; <span class="hljs-string">&quot;, age:&quot;</span> &lt;&lt; m_age &lt;&lt; <span class="hljs-built_in">endl</span>;
    &#125;

<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">char</span> m_name[<span class="hljs-number">20</span>];
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> m_sex = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">int</span> m_age;
&#125;;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">char</span> str[] = <span class="hljs-string">&quot;Bob&quot;</span>;
    <span class="hljs-function">Student <span class="hljs-title">s</span><span class="hljs-params">(str, <span class="hljs-literal">true</span>, <span class="hljs-number">12</span>)</span></span>;
    s.show();<span class="hljs-comment">//Bob: sex: male, age:12</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<ul>
<li>使用构造函数初始值列表时，<strong>数组应当在构造函数体内进行赋值</strong>，而不能在初始化列表中初始化。</li>
<li><strong>常量成员或者引用类型以及某种未提供默认构造函数的类类型成员必须要在初始化列表中进行</strong>，在函数体内就会报错！</li>
<li><strong>建议使用构造函数初始值的习惯</strong>，因为一部分数据成员只能使用这种方式初始化，同时相对于赋值的方式，构造函数初始值列表的效率更高！</li>
</ul>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
<span class="hljs-class">&#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//默认构造函数</span>
    Foo() &#123;&#125;;

    Foo(<span class="hljs-built_in">string</span> str, <span class="hljs-keyword">int</span> num) :str(str), num(num)
    &#123; &#125;
    <span class="hljs-comment">//拷贝构造函数</span>
    Foo(<span class="hljs-keyword">const</span> Foo&amp; foo) :str(foo.str), num(foo.num)
    &#123;
        times++;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;str &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;num &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; times &lt;&lt; <span class="hljs-built_in">endl</span>;
    &#125;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> times;
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">int</span> num;
&#125;;

<span class="hljs-keyword">int</span> Foo::times = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-function">Foo <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//直接初始化</span>
    f1.show();          <span class="hljs-comment">//hello-10-0</span>

    Foo f2 = f1;        <span class="hljs-comment">//拷贝初始化</span>
    f2.show();          <span class="hljs-comment">//hello-10-1</span>

    <span class="hljs-function">Foo <span class="hljs-title">f3</span><span class="hljs-params">(f1)</span></span>;         <span class="hljs-comment">//拷贝初始化，和上面那种类似</span>
    f3.show();          <span class="hljs-comment">//hello-10-2</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<ul>
<li>一般情况下，拷贝构造函数的作用是，将给定对象中的每个非static成员拷贝到正在创建的对象之中。</li>
<li>拷贝构造函数形式就是<code>Foo(const Foo&amp; foo)</code>，即函数参数为一个const引用类型。</li>
<li>如果我们没有定义一个拷贝构造函数，那么编译器就会自动为我们定义一个。</li>
<li>每个成员的类型决定了它如何被拷贝，类的类型成员将会使用它的拷贝构造函数来拷贝，而内置类型的成员将会直接拷贝。至于数组，将会被逐个元素地拷贝。</li>
<li>但是如何成员中有指针！必须小心的对待！！！</li>
</ul>
<h3 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h3><ol>
<li>拷贝初始化一般发生于用<code>=</code>定义变量时，即<code>Foo f2 = f1</code>这种形式，或者是使用对象初始化的形式，即<code>Foo f3(f1)</code>。</li>
<li>将一个对象作为<strong>实参传递</strong>给一个非引用类型的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>使用花括号列表初始化一个数组中的元素或者聚合类的成员。</li>
</ol>
<p>从上述可以看出拷贝构造函数用于初始化非引用类型参数，这一特性导致它的参数必须是引用类型，否则将会无限循环了。</p>
<h2 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
<span class="hljs-class">&#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//默认构造函数</span>
    Foo() &#123;&#125;;
    
    Foo(<span class="hljs-built_in">string</span> str, <span class="hljs-keyword">int</span> num):str(str),num(num) &#123;&#125;

    <span class="hljs-comment">//拷贝赋值，重载等号</span>
    Foo&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Foo&amp; foo)
    &#123;
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;other)<span class="hljs-comment">//自赋值</span>
        	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
        
        <span class="hljs-keyword">this</span>-&gt;str = foo.str;
        <span class="hljs-keyword">this</span>-&gt;num = foo.num;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        times++;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;str &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;num&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>&lt;&lt;times&lt;&lt;<span class="hljs-built_in">endl</span>;
    &#125;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> times;
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">int</span> num;
&#125;;

<span class="hljs-keyword">int</span> Foo::times = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-function">Foo <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//直接初始化</span>
    f1.show();          <span class="hljs-comment">//hello-10-1</span>

    Foo f2;             <span class="hljs-comment">//默认初始化</span>
    f2 = f1;            <span class="hljs-comment">//使用拷贝赋值运算符</span>
    f2.show();          <span class="hljs-comment">//hello-10-2</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<ul>
<li>一般情况下，拷贝赋值运算符是将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员。</li>
<li>拷贝赋值运算符实际上就是<strong>重载赋值运算符</strong>。</li>
<li>重载赋值运算符必须定义成为成员函数。（参看链接：）</li>
<li>若运算符是成员函数，则运算对象就绑定到了隐式的this参数上，而对于一个二元运算符，右侧运算对象就作为显示的参数传递。</li>
<li>为了与内置类型保持一致，赋值运算符通常返回一个<strong>指向其左侧运算对象的引用</strong>。</li>
</ul>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
<span class="hljs-class">&#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//默认构造函数</span>
    Foo() &#123;&#125;;
    
    Foo(<span class="hljs-built_in">string</span> str, <span class="hljs-keyword">int</span> num):str(str),num(num) &#123;&#125;

    ~Foo() 
    &#123;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;函数析构了&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    &#125;
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">int</span> num;
&#125;;


<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-function">Foo <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//直接初始化</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
<span class="hljs-comment">//执行结果：函数析构了</span></code></pre>
<ul>
<li>作用：析构函数释放掉对象使用的资源，并且销毁对象的非static数据成员。</li>
<li>析构函数形式上是<code>~类名()</code>，波浪线与类名组成的，无返回值，不接受参数，故析构函数不能够重载，——一个类的析构函数唯一。</li>
<li>如果不显示写出析构函数，那么编译器会自动添加一个默认的构造函数。</li>
<li>析构时，成员的销毁完全依赖于成员的类型，对应类型执行对应的析构函数，而内置类型则没有析构函数，故销毁内置类型成员不需要做什么。</li>
<li>而隐式的销毁一个内置指针类型的成员时，不会delete它所指向的对象。</li>
</ul>
<h3 id="什么时候调用析构函数"><a href="#什么时候调用析构函数" class="headerlink" title="什么时候调用析构函数"></a>什么时候调用析构函数</h3><ul>
<li>变量在离开其作用域时被销毁</li>
<li>对象被销毁时，其成员被销毁的时候</li>
<li>容器（标准库容器或者数组）被销毁时，其元素被销毁的时候</li>
<li>对于动态分配的对象，执行它的指针被delete运算符执行时</li>
<li>对于临时对象，创建它的完整表达式结束时被销毁。</li>
</ul>
<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>
<span class="hljs-class">&#123;</span>
<span class="hljs-keyword">public</span>:
    Student();
    ~Student();

<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">char</span>* name;
&#125;;

Student::Student()
&#123;
    <span class="hljs-keyword">this</span>-&gt;name = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>(<span class="hljs-number">20</span>);
    <span class="hljs-keyword">this</span>-&gt;age = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Student()&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
&#125;

Student::~Student()
&#123;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;~Student()&quot;</span> &lt;&lt;(<span class="hljs-keyword">int</span>)name&lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">delete</span> name;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Ok&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    name = <span class="hljs-literal">nullptr</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    &#123;<span class="hljs-comment">// 花括号让s1和s2变成局部对象，方便测试</span>
        Student s1;
        Student s2 = s1;
    &#125;<span class="hljs-comment">//花括号结束，对象析构</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<p>执行结果为引发异常，触发断点。</p>
<pre><code class="hljs less"><span class="hljs-selector-tag">Student</span>()
~<span class="hljs-selector-tag">Student</span>()<span class="hljs-selector-tag">17464200</span>
<span class="hljs-selector-tag">OK</span>
~<span class="hljs-selector-tag">Student</span>()<span class="hljs-selector-tag">17464200</span></code></pre>
<p>当对一个对象进行拷贝的时候，编译器会自动调用<code>拷贝构造函数</code>。而默认的拷贝构造函数就是简单的将原对象的成员一一赋值给新对象。这就是所谓的<strong>浅拷贝</strong>。</p>
<p>对于指针这种类型来说，原拷贝构造函数的动作就像<code>char * a = new char(20)</code>，然后<code>char* b = a</code>，也就是说a与b两个指针指向了同一块内存区域。当对象被析构的时候，同一块内存区域就被<code>delete</code>了两次，因而触发异常。</p>
<p>而这种情况，一般是默认拷贝构造函数无法避免的。</p>
<p>因此对于类的成员含有指针的情况，一定要显示的写出拷贝构造函数，并且特殊针对指针类型进行处理，这就是<strong>深拷贝</strong>。</p>
<pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>
<span class="hljs-class">&#123;</span>
<span class="hljs-keyword">public</span>:
    Student();
    ~Student();
    Student(<span class="hljs-keyword">const</span> Student&amp; other);

<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">char</span>* name;
&#125;;

Student::Student()
&#123;
    <span class="hljs-keyword">this</span>-&gt;name = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>(<span class="hljs-number">20</span>);
    <span class="hljs-keyword">this</span>-&gt;age = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Student()&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
&#125;

Student::Student(<span class="hljs-keyword">const</span> Student&amp; other)
&#123;
    <span class="hljs-keyword">this</span>-&gt;age = other.age;
    <span class="hljs-keyword">this</span>-&gt;name = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>(<span class="hljs-number">20</span>);
    <span class="hljs-built_in">memcpy</span>(<span class="hljs-keyword">this</span>-&gt;name,other.name,<span class="hljs-built_in">strlen</span>(other.name));
&#125;

Student::~Student()
&#123;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;~Student()&quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)name &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">delete</span> name;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Ok&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    name = <span class="hljs-literal">nullptr</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    &#123;<span class="hljs-comment">// 花括号让s1和s2变成局部对象，方便测试</span>
        Student s1;
        Student s2 = s1;
    &#125;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<p>执行结果：</p>
<pre><code class="hljs less"><span class="hljs-selector-tag">Student</span>()
~<span class="hljs-selector-tag">Student</span>()<span class="hljs-selector-tag">17149496</span>
<span class="hljs-selector-tag">Ok</span>
~<span class="hljs-selector-tag">Student</span>()<span class="hljs-selector-tag">17149832</span>
<span class="hljs-selector-tag">Ok</span>
<span class="hljs-selector-tag">hello</span></code></pre>
<blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/caoshangpa/article/details/79226270">C++面试题之浅拷贝和深拷贝的区别</a></p>
<p>总结：<strong>浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针</strong>。<br>再说几句：<br>当对象中存在指针成员时，除了在复制对象时需要考虑自定义拷贝构造函数，还应该考虑以下两种情形：<br>1.当函数的参数为对象时，实参传递给形参的实际上是实参的一个拷贝对象，系统自动通过拷贝构造函数实现；<br>2.当函数的返回值为一个对象时，该对象实际上是函数内对象的一个拷贝，用于返回函数调用处。<br>3.浅拷贝带来问题的本质在于析构函数释放多次堆内存，使用std::shared_ptr，可以完美解决这个问题。</p>
</blockquote>
<blockquote>
<p>知乎大佬Milo Yip的回答：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/36370072/answer/68086634">如何理解 C++ 中的深拷贝和浅拷贝？ - Milo Yip的回答</a></p>
<p>事实上，所谓的浅拷贝和深拷贝各自代表不同的意义，各有所需。关键是要区分值语意(value semantics)和引用语意(reference semantics)。</p>
<p>对于值语意的对象，在x= y完成复制之后，y的状态改变不能影响到x,这特性称为独立性(independence)。使用深拷贝的方式可以完全复制一个独立于原来的对象。C++提供的(模板)大部分都是值语意的，如stad::basic string、 std:.vector 等。</p>
<p>有些对象会引用相同的对象，举个游戏中的例子。通常多个模型可以引用同一个材质，复制模型时并不会深度复制新一份材质。 如果需要改变个别模型的材质里的参数，才会手动把该模型的材质复制，独立于其他模型的材质。</p>
</blockquote>
<h2 id="static修饰的类成员"><a href="#static修饰的类成员" class="headerlink" title="static修饰的类成员"></a>static修饰的类成员</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>
<span class="hljs-class">&#123;</span>
<span class="hljs-keyword">public</span>:
    Student() :age(<span class="hljs-number">0</span>) &#123;&#125;
    Student(<span class="hljs-keyword">int</span> age) :age(age) &#123;&#125;
    ~Student() &#123;&#125;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> conut;

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getConut</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> conut;
    &#125;

<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> nums;
&#125;;

<span class="hljs-keyword">int</span> Student::conut = <span class="hljs-number">12</span>;
<span class="hljs-keyword">int</span> Student::nums = <span class="hljs-number">10</span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    Student s;
    <span class="hljs-built_in">cout</span> &lt;&lt; s.conut &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; Student::getConut() &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-comment">//cout &lt;&lt; s.nums &lt;&lt; endl;//错误，无法访问private成员</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<ol>
<li>static修饰类中成员，表示<strong>类的共享数据</strong>。</li>
<li>static不属于某一个对象。而是此类所有的成员都公有的。</li>
<li>创建一个对象所开辟的空间中不包括静态成员的空间。静态成员的空间是在所有对象之外单独去开辟的。静态成员开辟的空间存放于<strong>静态区</strong>。</li>
<li>静态数据成员是<strong>在开始运行时被分配空间</strong>，到程序结束时才释放空间。</li>
<li>静态成员可以初始化，但是只能够在类外初始化。也不能够用参数列表对其初始化。</li>
<li>静态数据成员既可以通过对象名（a.C）或者类名（A::C）来引用。</li>
<li>static修饰的成员仍然遵循public，private，protected访问准则，即数据以及函数都遵从。</li>
<li>静态成员函数的意义不在于信息共享，而在于管理静态数据成员，完成封装。</li>
<li>静态成员函数<strong>只能访问静态数据成员</strong>，因为静态成员函数属于类所有而非对象所有，没有this指针。</li>
<li>静态数据成员不占据类的大小。</li>
</ol>
<blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuqia/p/8888938.html">C++ static类成员，static类成员函数</a></p>
</blockquote>
<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>this指针是隐含的变量，表示当前对象。实际就是指向了对象的地址。</p>
<p>在类的成员函数，非static函数内，this隐含在其中。</p>
<ul>
<li>在平常情况下，this指针指向的普通成员变量的值可以改变，说明this指针不是<code>const Class *</code>，但是this指针不能做<code>++</code>操作，说明this指针是一个常指针，即<code>Class * const</code>。</li>
<li>而如果在成员函数的末尾加上const，则表示this指针变成了<code>const Class * const</code>这样。</li>
<li>静态成员函数没有this指针</li>
</ul>
<h3 id="成员函数返回对象本身——注意加引用"><a href="#成员函数返回对象本身——注意加引用" class="headerlink" title="成员函数返回对象本身——注意加引用"></a>成员函数返回对象本身——注意加引用</h3><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span></span>
<span class="hljs-class">&#123;</span>
<span class="hljs-keyword">public</span>:
    Example() :a(<span class="hljs-number">10</span>) &#123;&#125;
    ~Example() &#123;&#125;
    
    <span class="hljs-comment">//注意函数返回值为引用。</span>
    <span class="hljs-function">Example&amp; <span class="hljs-title">copy</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Example&amp; other)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">this</span>-&gt;a = other.a;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-comment">//实际上隐含为 cout&lt;&lt;this-&gt;a&lt;&lt;endl;</span>
    &#125;

<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> a;
&#125;;</code></pre>
<h2 id="const修饰的类成员"><a href="#const修饰的类成员" class="headerlink" title="const修饰的类成员"></a>const修饰的类成员</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span></span>
<span class="hljs-class">&#123;</span>
<span class="hljs-keyword">public</span>:
	Example() :i_nom_n(<span class="hljs-number">11</span>) &#123;&#125;
	~Example() &#123;&#125;
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span></span>
<span class="hljs-function">	</span>&#123;
		<span class="hljs-keyword">this</span>-&gt;i_nom_n += <span class="hljs-number">100</span>;

		m_num = <span class="hljs-number">10</span>;

		<span class="hljs-built_in">cout</span> &lt;&lt; i_con_n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i_nom_n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i_sta_n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i_con_sta_n &lt;&lt; <span class="hljs-built_in">endl</span>;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showInfo2</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>	<span class="hljs-comment">//常函数</span></span>
<span class="hljs-function">	</span>&#123;
		<span class="hljs-comment">//this-&gt;i_nom_n++;//错误，表达式必须是可修改的左值</span>

		m_num = <span class="hljs-number">10</span>;			<span class="hljs-comment">//正确，添加了关键字mutable之后仍然可以进行修改</span>

		<span class="hljs-built_in">cout</span> &lt;&lt; i_con_n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i_nom_n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i_sta_n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i_con_sta_n &lt;&lt; <span class="hljs-built_in">endl</span>;
	&#125;

<span class="hljs-keyword">private</span>:
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i_con_n = <span class="hljs-number">10</span>; <span class="hljs-comment">//可在此处赋值或者初始值列表进行初始化</span>
	<span class="hljs-keyword">int</span> i_nom_n;			<span class="hljs-comment">//可在此处赋值，为默认值</span>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i_sta_n;		<span class="hljs-comment">//必须在类外初始化</span>
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i_con_sta_n;<span class="hljs-comment">//可在此处赋值或者类外初始化</span>

	<span class="hljs-keyword">mutable</span> <span class="hljs-keyword">int</span> m_num;		<span class="hljs-comment">//这个变量可以修改</span>
&#125;;

<span class="hljs-keyword">int</span> Example::i_sta_n = <span class="hljs-number">12</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Example::i_con_sta_n = <span class="hljs-number">13</span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
	Example ex;

	ex.showInfo2();

	ex.showInfo();

	<span class="hljs-comment">//常对象</span>
	<span class="hljs-keyword">const</span> Example c_ex;

	<span class="hljs-comment">//c_ex.showInfo(); //错误，常对象只能调用常函数</span>

	c_ex.showInfo2();

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<ul>
<li>const类常量只能在声明时就初始化或者使用构造函数初始值列表进行初始化。</li>
<li>而static const修饰的成员变量则可以在声明时初始化，或者在类外进行初始化。</li>
<li>本质上，const指针修饰的是被隐藏的this指针所指向的内存空间，修饰的是this指针。在成员函数的末尾加上const，则表示this指针变成了<code>const Class * const</code>这样。</li>
<li>类的成员函数后面加 const，即为<strong>常函数</strong>，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。</li>
<li>关键字<code>mutable</code>可以使得在常函数之中，依旧可以进行修改。</li>
<li>而声明对象的时候使用关键字const，可以创建出常对象，常对象不允许修改其任何变量，<code>mutable</code>修饰的例外。并且<strong>常对象只能调用常函数</strong>。因为普通函数难免会改变成员变量，常函数必定不会修改普通的成员变量。</li>
</ul>
<blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cthon/p/9178701.html">C++之const类成员变量，const成员函数</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/buknow/article/details/80275191">C++普通变量、C++静态成员变量、C++成员常量、C++静态成员常量的初始化方法</a></p>
</blockquote>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
<span class="hljs-class">&#123;</span>
<span class="hljs-keyword">public</span>:
    A() :a(<span class="hljs-number">0</span>), b(<span class="hljs-number">0</span>) &#123;&#125;
    A(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) :a(a), b(b) &#123;&#125;
    ~A() &#123;&#125;
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> a;
    <span class="hljs-keyword">int</span> b;

    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span>						<span class="hljs-comment">//类作为友元</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">friendfun</span><span class="hljs-params">(A an, B bn)</span></span>;	<span class="hljs-comment">//全局函数作为友元</span>
    <span class="hljs-comment">//类的某个成员函数也可以作为友元</span>
    <span class="hljs-comment">// friend void B::info(A an);</span>
&#125;;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>
<span class="hljs-class">&#123;</span>
<span class="hljs-keyword">public</span>:
    B() :c(<span class="hljs-number">0</span>) &#123;&#125;
    B(<span class="hljs-keyword">int</span> c) :c(c) &#123;&#125;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">(A an)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-built_in">cout</span> &lt;&lt; an.a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; an.b &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;c&lt;&lt; <span class="hljs-built_in">endl</span>;
    &#125;
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> c;
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">friendfun</span><span class="hljs-params">(A an, B bn)</span></span>;
&#125;;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">friendfun</span><span class="hljs-params">(A an,B bn)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">cout</span> &lt;&lt; an.a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; an.b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; bn.c &lt;&lt; <span class="hljs-built_in">endl</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-function">A <span class="hljs-title">an</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;
    <span class="hljs-function">B <span class="hljs-title">bn</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;
    bn.info(an);

    friendfun(an,bn);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<ul>
<li>当类实现了数据的封装和隐藏的时候，又是需要一些函数频繁访问类的数据成员，但它又不是此类的一部分，此时可以将这些函数定义为友元。</li>
<li>友元将无视权限，同时友元也不受所在private、public或者protected区域的影响，一般将友元放在类的末尾部分。</li>
<li>友元的作用是提高程序运行效率，缺点是破坏了类的封装和隐藏性。</li>
<li>友元不能被继承，友元不具有传递性，友元关系是<strong>单向的</strong>。</li>
</ul>
<h2 id="创建对象实例的方式（new与不new）"><a href="#创建对象实例的方式（new与不new）" class="headerlink" title="创建对象实例的方式（new与不new）"></a>创建对象实例的方式（new与不new）</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
<span class="hljs-class">&#123;</span>
<span class="hljs-keyword">public</span>:
    A() :a(<span class="hljs-number">0</span>), b(<span class="hljs-number">0</span>) &#123;&#125;
    A(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) :a(a), b(b) &#123;&#125;
    ~A()&#123;&#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;
    &#125;
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> a;
    <span class="hljs-keyword">int</span> b;
&#125;;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-function">A <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)</span></span>;
    a1.showInfo();              <span class="hljs-comment">//5 5</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(a1) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">//8</span>

    A* a2 = <span class="hljs-keyword">new</span> A(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);
    a2-&gt;showInfo();             <span class="hljs-comment">//5 5</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(a2) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">//4</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(*a2) &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//8</span>
    <span class="hljs-keyword">delete</span> a2;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<p>C++创建对象实例有两种方式：</p>
<ol>
<li><code>ClassName obj(param);</code></li>
<li><code>ClassName * obj = new ClassName(param);</code></li>
</ol>
<p>这两种方式还是有较大的区别。</p>
<ol>
<li><code>ClassName obj(param);</code>这种方式创建的对象，内存是分配到<strong>栈</strong>中的。由编译器默认调用构造与析构函数。</li>
<li><code>ClassName * obj = new ClassName(param);</code>，这种方式创建的对象位于堆上，new返回的是一个对象指针，这个指针指向一个对象的地址。</li>
<li>new会自动触发构造函数，使用new创建的对象，最后要<strong>手动使用</strong>delete，delete会自动触发析构函数。</li>
<li>new创建的对象需要使用<code>-&gt;</code>来调用对应的成员。</li>
</ol>
<blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_586b6c050100dhjg.html">C++创建对象的两种方法</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/MarkKobs-blog/p/11642431.html">C++用new与不用new创建对象的区别</a></p>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="成员初始化的顺序"><a href="#成员初始化的顺序" class="headerlink" title="成员初始化的顺序"></a>成员初始化的顺序</h3><ul>
<li>成员初始化的顺序与他们在类定义中的出现顺序一致</li>
<li>构造函数初始值列表的顺序不影响被初始化的顺序。</li>
<li>建议是尽可能避免使用类的某些成员去初始化其他成员。</li>
</ul>
<h3 id="类对象做为类成员时的构造顺序？"><a href="#类对象做为类成员时的构造顺序？" class="headerlink" title="类对象做为类成员时的构造顺序？"></a>类对象做为类成员时的构造顺序？</h3><p>当一个<code>类B</code>作为<code>类A</code>的成员时，先调用类B的构造函数，再进行类A的构造函数。</p>
<h3 id="C-类的大小"><a href="#C-类的大小" class="headerlink" title="C++类的大小"></a>C++类的大小</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C1</span></span>
<span class="hljs-class">&#123;</span>
	<span class="hljs-comment">//空类</span>
&#125;;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C2</span></span>
<span class="hljs-class">&#123;</span>
	<span class="hljs-keyword">int</span> a;
&#125;;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C3</span></span>
<span class="hljs-class">&#123;</span>
	<span class="hljs-keyword">int</span> a;
	<span class="hljs-keyword">char</span> b;
&#125;;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C4</span></span>
<span class="hljs-class">&#123;</span>
	<span class="hljs-keyword">int</span> a;
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b;
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;&#125;
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sfunc</span><span class="hljs-params">()</span> </span>&#123;&#125;
&#125;;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
	C1 c1;
	C2 c2;
	C3 c3;
	C4 c4;

	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;C1空类的大小为&quot;</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(c1) &lt;&lt; <span class="hljs-built_in">endl</span>;	<span class="hljs-comment">//1</span>
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;C2类的大小为&quot;</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(c2) &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//4</span>
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;C3类的大小为&quot;</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(c3) &lt;&lt; <span class="hljs-built_in">endl</span>;	<span class="hljs-comment">//8</span>
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;C4类的大小为&quot;</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(c4) &lt;&lt; <span class="hljs-built_in">endl</span>;	<span class="hljs-comment">//4</span>
&#125;</code></pre>
<ol>
<li>当是空类的时候，编译器为了确保空类的对象也有明确的地址，所以空类对象会有<code>1个空间</code>的大小。</li>
<li>不为空时，只有非静态的成员变量才会占据类的大小，成员函数、静态变量以及静态函数都不占据空间，因为静态成员为类所有，此外成员函数通过this指针来区分不同的对象实例。（每个非静态函数只有一份函数实例，即多个同类型的对象公用一块代码）。</li>
<li>由于优化的需要，会有<strong>内存对齐</strong>的情况。参考类C3，按照其内最大的数据类型进行对齐。</li>
</ol>
<h3 id="总结：C-构造函数的调用方式"><a href="#总结：C-构造函数的调用方式" class="headerlink" title="总结：C++构造函数的调用方式"></a>总结：C++构造函数的调用方式</h3><pre><code class="hljs c++">&#123;
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;方式1：括号法&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
	Cat a;			<span class="hljs-comment">//默认构造</span>
	<span class="hljs-function">Cat <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;		<span class="hljs-comment">//有参构造</span>
	<span class="hljs-function">Cat <span class="hljs-title">c</span><span class="hljs-params">(b)</span></span>;		<span class="hljs-comment">//拷贝构造</span>

	<span class="hljs-comment">//Cat d();	//这样不是调用默认构造函数，而是编译器将其视作了一个函数的声明。在CPP中，函数的声明可以写在其他函数中</span>

	<span class="hljs-comment">//int aaa();</span>
&#125;

&#123;
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;方式2：显示法&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
	Cat a = Cat();	<span class="hljs-comment">//默认构造</span>
	Cat b = Cat(<span class="hljs-number">1</span>);	<span class="hljs-comment">//有参构造</span>
	Cat c = Cat(b);	<span class="hljs-comment">//拷贝构造</span>

	Cat(<span class="hljs-number">1</span>);		<span class="hljs-comment">//单独这一句是构造一个匿名函数，当前行执行结束就会被释放。</span>

	<span class="hljs-comment">//Cat(b);	//执行出错，原因是b重定义</span>
				<span class="hljs-comment">//不能使用拷贝构造函数来声明匿名对象，编译器会将其当作括号内的对象的声明。</span>
&#125;


&#123;
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;方式3：隐式法&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
	Cat a = <span class="hljs-number">2</span>;		<span class="hljs-comment">//隐式为Cat a = Cat(2);</span>
	Cat b = a;		<span class="hljs-comment">//隐式为Cat b = Cat(a);</span>
&#125;</code></pre>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/C-C/">C/C++</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C/">C++</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/cpp-opp1-prc1/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C++面向对象练习（一）—— 各种函数执行顺序</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/c-reference&amp;point/">
                        <span class="hidden-mobile">C++引用与指针</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script defer src="https://cdn.staticfile.org/valine/1.4.14/Valine.min.js" ></script>

  <script type="text/javascript">
    var oldLoadVa = window.onload;
    window.onload = function () {
      oldLoadVa && oldLoadVa();

      new Valine({
        el: "#vcomments",
        app_id: "MtnFjgPHU4QgDov26Ttd39aS-gzGzoHsz",
        app_key: "VxW97jqxtcjGJrb9AWmPKqrK",
        placeholder: "说点什么",
        path: window.location.pathname,
        avatar: "wavatar",
        meta: ["nick","mail","link"],
        pageSize: "10",
        lang: "zh-CN",
        highlight: false,
        recordIP: false,
        serverURLs: "",
      });
    };
  </script>
  <noscript>Please enable JavaScript to view the <a target="_blank" href="https://valine.js.org" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      由<a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>强力驱动
    <i class="iconfont icon-love"></i>
    主题：<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

	<span>已经陪伴<a href="https://www.colourso.top" target="_blank" rel="nofollow noopener"><b>Colourso</b></a>：</span><span id="timeDate">25</span>天<span id="times">03 小时 08 分 10 秒</span>
    <br>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


    

	
    
  
  
  <!-- 网站运行时间的设置 -->
  <script src="/js/HidenMath.js"></script>
  <script>
    var now = new Date();
    function createtime() {
      var grt = new Date("10/01/2018 12:30:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime() + 250);
      days = (now - grt) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
      hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
      if (String(hnum).length == 1) { hnum = "0" + hnum; } minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes); if (String(mnum).length == 1) { mnum = "0" + mnum; }
      seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds); if (String(snum).length == 1) { snum = "0" + snum; }
      document.getElementById("timeDate").innerHTML = dnum;
      document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
    setInterval("createtime()", 250);
  </script>
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer>
  (function () {
    // 查询存储的记录
    function getRecord(Counter, target) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({target})))
          .then(response => response.json())
          .then(({results}) => {
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {target, time: 0})
                .then(response => response.json())
                .then((record) => {
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch(error => {
          console.error('LeanCloud Counter Error', error);
          reject(error);
        });
      })
    }

    // 构建自增请求体
    function buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "time": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    }

    // 发起自增请求
    function increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          resolve(res);
        }).catch(error => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    }

    // 校验是否为有效的 UV
    function validUV() {
      var key = 'LeanCloud_UV_Flag';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    }

    function addCount(Counter) {
      var enableIncr = 'true' === 'true'
      var getterArr = [];
      var incrArr = [];

      // 请求 PV 并自增
      var pvCtn = document.querySelector('#leancloud-site-pv-container');
      if (pvCtn || enableIncr) {
        var pvGetter = getRecord(Counter, 'site-pv').then((record) => {
          incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-pv');
          if (ele) {
            ele.innerText = record.time + 1;
            if (pvCtn) {
              pvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#leancloud-site-uv-container');
      if (uvCtn || enableIncr) {
        var uvGetter = getRecord(Counter, 'site-uv').then((record) => {
          var vuv = validUV();
          vuv && incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-uv');
          if (ele) {
            ele.innerText = record.time + (vuv ? 1 : 0);
            if (uvCtn) {
              uvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(uvGetter);
      }

      // 如果是文章，请求文章的浏览数，并自增
      if ('true' === 'true') {
        var viewCtn = document.querySelector('#leancloud-post-views-container');
        if (viewCtn || enableIncr) {
          var target = decodeURI('/cpp-opp1/');
          var viewGetter = getRecord(Counter, target).then((record) => {
            incrArr.push(buildIncrement(record.objectId))
            if (viewCtn) {
              var ele = document.querySelector('#leancloud-post-views');
              if (ele) {
                ele.innerText = (record.time || 0) + 1;
                viewCtn.style.display = 'inline';
              }
            }
          });
          getterArr.push(viewGetter);
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && increment(Counter, incrArr);
        })
      }
    }

    var app_id = 'MtnFjgPHU4QgDov26Ttd39aS-gzGzoHsz'
    var app_key = 'VxW97jqxtcjGJrb9AWmPKqrK'
    var server_url = 'https://mtnfjgph.lc-cn-n1-shared.com'

    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': app_id,
            'X-LC-Key': app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };

      addCount(Counter);
    }

    var api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${ app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({api_server}) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>







  

  

  

  

  

  



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "C++面向对象（一) —— C++类的基础知识&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 80,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>


















</body>
</html>
